<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在开发前端中的一些注意事项]]></title>
    <url>%2F%2Fblog%2FPrecautions.html</url>
    <content type="text"><![CDATA[简述其实很多时候发现很多别人遗留的代码，不是他写不好或者什么，而是没时间，时间不够的时候自己只能用自己比较顺手的写法去写，但是一定要有一个人去管理整个公司的前端技术栈，不然真的是一团乱，]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符优先级]]></title>
    <url>%2F%2Fblog%2FJavaScript-Operator-priority.html</url>
    <content type="text"><![CDATA[简述运算符的优先级决定了表达式中运算执行的先后顺序，优先级高的运算符最先被执行。11 + 2 * 3 // 7 乘法运算符 (“*“)比起加法运算符(“+“)有着更高的优先级，所以它会被最先执行。 结合性结合性决定了拥有相同优先级的运算符的执行顺序。考虑下面这个表达式： 左结合左结合(从左到右计算)相当于把左边的子表达式加上小括号(a OP b) OP c 右关联(从右到左计算)相当于a OP (b OP c)1a = b = 5; 结果 a 和 b 的值都会成为5。这是因为赋值运算符的返回结果就是赋值运算符右边的那个值，具体过程是：b被赋值为5，然后a也被赋值为 b=5 的返回值，也就是5。 汇总表下面的表将所有运算符按照优先级的不同从高到低排列。可以查看 mdn中的 table来分他的等级。参考&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的作用域和作用域链]]></title>
    <url>%2F%2Fblog%2Fjavascript-scope.html</url>
    <content type="text"><![CDATA[全局作用域在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： 最外层的函数、变量拥有全局作用域1234567var sGl = '全局变量';function fGL () &#123; var _sGl = '局部变量'; console.log(_sGl);&#125;console.log(sGl); // 全局变量fGL(); // 局部变量 没有使用var关键字声明的变量也都是全局变量。12345function fun() &#123; name = "全局变量"; alert(name);&#125;console.log(name); // 输出:全局变量 所有window对象的属性拥有全局作用域词法作用域词法作用域：函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行。也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域在通常情况下，变量的查询从最近接的绑定上下文开始，向外部逐渐扩展，直到查询到第一个绑定，一旦完成查找就结束搜索。123456var gl = '全局变量';function fGl () &#123; var gl = '局部变量'; console.log(gl);&#125;fGl(); // 局部变量 动态作用域在编程实践中，最容易低估和过度滥用的概念就是动态作用域，因为很少有语言支持这种方式为绑定解析方案。 动态作用域与词法作用域相对而言的，不同于词法作用域在定义时确定，动态作用域在执行时确定，其生存周期到代码片段执行为止。动态变量存在于动态作用域中，任何给定的绑定的值，在确定调用其函数之前，都是不可知的。 在代码执行时，对应的作用域链常常是保持静态的。然而当遇到with语句、call方法、apply方法和try-catch中的catch时，会改变作用域链的。以with为例，在遇到with语句时，会将传入的对象属性作为局部变量来显示，使其便于访问，也就是说把一个新的对象添加到了作用域链的顶端，这样必然影响对局部标志符的解析。当with语句执行完毕后，会把作用域链恢复到原始状态。实例如下：1234567891011var name = "global";// 使用with之前console.log(name); // 输出:globalwith(&#123;name:"jeri"&#125;)&#123; console.log(name); // 输出:jeri&#125;// 使用with之后，作用域链恢复console.log(name); // 输出:global 在作用域链中有动态作用域时，this引用也会变得更加复杂，不再指向第一次创建时的上下文，而是由调用者确定。比如在使用apply或call方法时，传入它们的第一个参数就是被引用的对象。实例如下：1234567function globalThis() &#123; console.log(this);&#125;globalThis(); // 输出:Window &#123;document: document,external: Object…&#125;globalThis.call(&#123;name:"jeri"&#125;); // 输出:Object &#123;name: "jeri"&#125;globalThis.apply(&#123;name:"jeri"&#125;,[]); // 输出:Object &#123;name: "jeri"&#125; 函数作用域函数作用域，顾名思义就是在定义函数时候产生的作用域，这个作用域也可以称为局部作用域。和全局作用域相反，函数作用域一般只在函数的代码片段内可访问到，外部不能进行变量访问。在函数内部定义的变量存在于函数作用域中，其生命周期随着函数的执行结束而结束。实例如下：123456789101112131415var name = "global";function fun() &#123; var name = "jeri"; console.log(name); // 输出:jeri with (&#123;name:"with"&#125;) &#123; console.log(name); // 输出:with &#125; console.log(name); // 输出:jeri&#125;fun();// 不能访问函数作用域console.log(name); // 输出:global 作用域链在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。它用来保证对执行环境有权访问的变量和函数的有序访问。当一个函数创建后，它的作用域会被创建此函数的作用域中可访问的数据对象填充1234function add(num1,num2) &#123; var sum = num1 + num2; return sum;&#125; 1var total = add(5,10); 执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义函数执行的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。这些值按照它们出现在函数中的顺序被复制到运行期的上下文的作用域中，它们共同组成一个新的对象，叫“活动对象(activation object)”,该对象包含了函数的所有局部变量、命名参数、参数集合以及this,然后此对象会被推入作用域链前端，当运行期上下文被销毁时，活动对象也随之销毁。在全局作用域中创建的函数,其作用域链会自动成为作用域中的一员。而当函数执行时,其活动对象就会成为作用域中的第一个对象。12345678910111213141516var name = 'global';function fun() &#123; console.log(name); // output:global name = "change"; // 函数内部可以修改全局变量 console.log(name); // output:change // 先查询活动对象 var age = "18"; console.log(age); // output:18&#125;fun();// 函数执行完毕，执行环境销毁console.log(age); // output:Uncaught ReferenceError: age is not defined 闭包闭包是JavaScript的一个比较重要的东西，关于这个问题有很多文章进行讲述，然而依然有相当数量的程序员对这个概念理解不透彻，我就是其中一个，闭包报的官方定义为：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也该是表达式的一部分。一句话概括就是：闭包就是一个函数，捕获作用域内的外部绑定。这些绑定是为之后使用而被绑定，即使作用域已经销毁。 自由变量自由变量与闭包的关系是，自由变量闭合于闭包的创建。闭包背后的逻辑是，如果一个函数内部有其他函数，那么这些内部函数可以访问在这个外部函数中声明的变量（这些变量就称之为自由变量）。然而，这些变量可以被内部函数捕获，从高阶函数（返回另一个函数的函数称为高阶函数）中return语句实现“越狱”，以供以后使用。内部函数在没有任何局部声明之前（既不是被传入，也不是局部声明）使用的变量就是被捕获的变量。12345678910function makeAdder(captured) &#123; return function(free) &#123; var ret = free + captured; console.log(ret); &#125;&#125;var add10 = makeAdder(10);add10(2); // 输出:12 从上例可知，外部函数中的变量captured被执行加法的返回函数捕获，内部函数从未声明过captured变量，却可以引用它。如果我们再创建一个加法器将捕获到同名变量captured，但有不同的值，因为这个加法器是在调用makeAdder之后被创建：123var add16 = makeAdder(16);add16(18); // 输出:34add10(10); // 输出:20 每一个新的加法器函数都保留了自己创建时捕获的captured实例。 变量遮蔽 在JavaScript中，当变量在一定作用域内声明，然后在另一个同名变量在一个较低的作用域声明，会发生变量的遮蔽。实例如下：123456789101112var name = "jeri";var name = "tom";function glbShadow() &#123; var name = "fun"; console.log(name); // 输出:fun&#125;glbShadow();console.log(name); // 输出:tom 当在一个变量同一作用域内声明了多次时，最后一次声明会生效，会遮蔽以前的声明。 变量声明的遮蔽很好理解，然而函数参数的遮蔽就略显复杂。例如：12345678910var shadowed = 0;function argShadow(shadowed) &#123; var str = ["Value is",shadowed].join(" "); console.log(str);&#125;argShadow(108); // output:Value is 108argShadow(); // output:Value is 函数argShadow的参数shadowed覆盖了全局作用域内的同名变量。即使没有传递任何参数，仍然绑定的是shadowed，并没有访问到全局变量shadowed = 0。 任何情况下，离得最近的变量绑定优先级最高。实例如下：1234567891011var shadowed = 0;function varShadow(shadowed) &#123; var shadowed = 123; var str = ["Value is",shadowed].join(" "); console.log(str);&#125;varShadow(108); // output:Value is 123varShadow(); // output:Value is 123 varShadow(108)打印出来的并不是108而是123，即使没有参数传入也是打印的123，先访问离得最近的变量绑定。遮蔽变量同样发生在闭包内部，实例如下：123456789101112131415function captureShadow(shadowed) &#123; console.log(shadowed); // output:108 return function(shadowed) &#123; console.log(shadowed); // output:2 var ret = shadowed + 1; console.log(ret); // output:3 &#125;&#125;var closureShadow = captureShadow(108);closureShadow(2); 典型的误区12345678910111213141516var test = function() &#123; var ret = []; for(var i = 0; i &lt; 5; i++) &#123; ret[i] = function() &#123; return i; &#125; &#125; return ret;&#125;;var test0 = test()[0]();console.log(test0); // 输出：5var test1 = test()[1]();console.log(test1); //输出：5 从上面的例子可知，test这个函数执行之后返回一个函数数组，表面上看数组内的每个函数都应该返回自己的索引值，然而并不是如此。当外部函数执行完毕后，外部函数虽然其执行环境已经销毁，但闭包依然保留着对其中变量绑定的引用，仍然驻留在内存之中。当外部函数执行完毕之后，才会执行内部函数，而这时内部函数捕获的变量绑定已经是外部函数执行之后的最终变量值了，所以这些函数都引用的是同一个变量i=5。另一个例子：12345678for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;// 每隔1秒输出一个5 按照我们的推断，上例应该输出1,2,3,4,5。然而，事实上输出的是连续5个5。为什么出现这种诡异的状况呢？其本质上还是由闭包特性造成的，闭包可以捕获外部作用域的变量绑定。上面这个函数片段在执行时，其内部函数和外部函数并不是同步执行的，因为当调用setTimeout时会有一个延时事件排入队列，等所有同步代码执行完毕后，再依次执行队列中的延时事件，而这个时候 i 已经 是5了。 那怎么解决这个问题呢？我们是不是可以在每个循环执行时，给内部函数传进一个变量的拷贝，使其在每次创建闭包时，都捕获一个变量绑定。因为我们每次传参不同，那么每次捕获的变量绑定也是不同的，也就避免了最后输出5个5的状况。实例如下：1234567for (var i = 0; i &lt; 5; i++) &#123; (function (j) &#123; setTimeout(function () &#123; console.log(j); &#125;, 1000) &#125;)(i);&#125; 闭包具有非常强大的功能，函数内部可以引用外部的参数和变量，但其参数和变量不会被垃圾回收机制回，常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。但，闭包也是javascript语言的一大特点，主要应用闭包场合为：设计私有的方法和变量。 模拟私有变量从上文的叙述我们知道，变量的捕获发生在创建闭包的时候，那么我们可以把闭包捕获到的变量做为私有变量。实例如下：123456789101112131415161718192021222324 var closureDemo = (function () &#123; var PRIVATE = 0; return &#123; inc: function (n) &#123; return PRIVATE += n; &#125;, dec: function (n) &#123; return PRIVATE -= n; &#125; &#125; &#125;)(); var testInc = closureDemo.inc(10); console.log(testInc); // 10 var testDec = closureDemo.dec(7); console.log(testDec); // 3 closureDemo.div = function (n) &#123; return PRIVATE/n; &#125; var testDiv = closureDemo.div(3);console.log(testDiv);//输出：Uncaught ReferenceError: PRIVATE is not defined 自执行函数closureDemo执行完毕之后，自执行函数作用和PRIVATE变量随之销毁，但PRIVATE仍滞留在内存中，也就是加入了到了closureDemo.inc和closureDemo.dec的作用域链中，闭包也就完成了变量捕获。但之后新加入的closureDemo.div并不能在作用域中继续寻找到PRIVATE了。因为，函数只有被调用时才会执行函数里面的代码，变量的捕获也只发生在创建闭包时，所以之后新加入的div方法并不能捕获PRIVATE。 创建特权方法通过闭包我们可以创建私有作用域，那么也就可以创建私有变量和私有函数。创建私有函数的方式和声明私有变量方法一致，只要在函数内部声明函数就可以了。当然，既然可以模拟私有变量和私有函数，我们也可以利用闭包这个特性，创建特权方法。实例如下：1234567891011121314(function () &#123; // 私有变量和私有函数 var privateVar = 10; function privateFun () &#123; return false; &#125;; MyObj = function () &#123;&#125; MyObj.prototype.pubulicMethod = function () &#123; privateVar ++; return privateFun(); &#125;&#125;)(); 上面这个实例创建了一个私有作用域，并封装了一个构造函数和对应的方法。需要注意的是在上面的实例中，在声明MyObj这个函数时，使用的是不带var的函数表达式，我们希望产生的是一个全局函数而不是局部的，不然我们依然在外部无法访问。所以，MyObj就成为了一个全局变量，能够在外部进行访问，我们在原型上定义的方法publicMethod也就可以使用，通过这个方法我们也就可以访问私有函数和私有变量了。 本文引用 &gt;http://www.cnblogs.com/syfwhu/p/4839562.html (感觉作者挺可爱的)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在JavaScript中只有固定的值会转为false]]></title>
    <url>%2F%2Fblog%2Fjavascript-IF-False-options.html</url>
    <content type="text"><![CDATA[简介 在JavaScript中使用if的时候，自己如果不注意的话很可能出现判断进错，其实在JavaScript中只有固定的几个值会转为false，其它的统一认为为true。 false null undefined 空字符串’ ‘ 数字零 0 NaN其他的全部都算为true,‘false’、‘0’也是为true,其实这也是一种隐性的类型转换。和 == 又有不同。 逻辑运算符由于逻辑表达式是从左往右计算的，由于运算符优先级的存在，下面的表达式的结果却不相同。如下例所示12false &amp;&amp; true || true // 结果为 truefalse &amp;&amp; (true || true) // 结果为 false 右侧被小括号括起来的操作变成了独立的表达式。 转换规则: 将 AND 转换为 OR 将 OR 转换为 AND 删除嵌套的 AND 删除嵌套的 OR可参考&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators逻辑与(&amp;&amp;)尽管 &amp;&amp; 和 || 运算符能够使用非布尔值的操作数, 但它们依然被看作是布尔操作符，因为它们的返回值总是能够被转换为布尔值。expr1 &amp;&amp; expr2如果expr1能转换为false则返回expr1,否则返回expr2。因此，与布尔值一起使用时，如果两个操作数都为true时&amp;&amp;返回true,否则返回false.1234567a1=true &amp;&amp; true // t &amp;&amp; t 结果为 truea2=true &amp;&amp; false // t &amp;&amp; f 结果为 falsea3=false &amp;&amp; true // f &amp;&amp; t 结果为 falsea4=false &amp;&amp; (3 == 4) // f &amp;&amp; f 结果为 falsea5="Cat" &amp;&amp; "Dog" // t &amp;&amp; t 结果为 Doga6=false &amp;&amp; "Cat" // f &amp;&amp; t 结果为 falsea7="Cat" &amp;&amp; false // t &amp;&amp; f 结果为 false 逻辑与(||)expr1 &amp;&amp; expr2如果expr1能转换为true则返回expr1,否则返回expr2。因此，与布尔值一起使用时，如果任意一个操作数为true时||返回true.1234567o1=true || true // t || t 结果为 trueo2=false || true // f || t 结果为 trueo3=true || false // t || f 结果为 trueo4=false || (3 == 4) // f || f 结果为 falseo5="Cat" || "Dog" // t || t 结果为 Cato6=false || "Cat" // f || t 结果为 Cato7="Cat" || false // t || f 结果为 Cat 逻辑非(!)!expr 如果单个表达式能转换为true的话返回false，否则返回true。123n1=!true // !t 结果为 falsen2=!false // !f 结果为 truen3=!"Cat" // !t 结果为 false]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-GC]]></title>
    <url>%2F%2Fblog%2Fjavascript-GC.html</url>
    <content type="text"><![CDATA[简介 JavaScript创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。 后一个过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理。而不是别人所说的:编写JavaScript程序时，所需内存的分配以及无用内存的回收完全实现自动管理但是他会按照固定的时间间隔（或代码执行中预定的收集时间）周期性地执行这一操作 内存生命周期其实别的语言的内存声明周期基本是那个是一致的：1、 分配你所需要的内存2、使用分配到内存（读、写）3、不需要时将其释放\归还 JavaScript 的内存分配1、JavaScript 在定义变量时就完成了内存分配2、通过函数调用分配内存 内存释放当内存不再需要使用时释放，高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。 两种垃圾回收方式浏览器的内存处理基本分为两种，引用技术垃圾收集、标记清除两种，下面一一介绍。 引用计数这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 但是他有比较大的限制，就是当对象循环引用，引用计数不会回收它 标记清除垃圾收集器会按照固定的时间间隔周期性的执行这一操作。从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。简单来讲就是，当变量进入环境时，就是将变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。收集器在运行时会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。剩下的在被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量。最后，垃圾收集器完成内存清除，销毁那些带有标记的值并收回它们所占用的内存空间。这中算法是没有循环引用限制的]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-build-iconfont]]></title>
    <url>%2F%2Fblog%2Fwebpack-build-iconfont.html</url>
    <content type="text"><![CDATA[简述在使用webpack打包自己在icomoon中的制作的iconfont,即使放到最外层的static文件家中，打包后它的路径也是不对的，这个在vue的github的issue中有人是这么解决的在build文件夹中的utils.js中用vue-style-loader来编译css,修改如下原12345678if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader' &#125;)&#125; else &#123; return ['vue-style-loader'].concat(loaders)&#125; 添加路径后12345678910if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader', // 添加路径 publicPath: '../../' &#125;)&#125; else &#123; return ['vue-style-loader'].concat(loaders)&#125; 这样编译完成以后的iconfont路径是正确的]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack_Environment_build]]></title>
    <url>%2F%2Fblog%2Fwebpack-Environment-build.html</url>
    <content type="text"><![CDATA[简述在公司整体的框架就是要分为测试环境、预发布环境、正式环境，要切换不同的后台api地址，登录地址也是跳转别的子站点登录，所以就要通过编译不同环境的前端代码。用的vue默认的脚手架vue-cli第一种就是通过process.env来传递不同的值，在config文件夹中通过 dev.env.js、pro.env.js区分是什么环境要调用的接口地址和登录地址 思路1可以通过最外层的package.json中的scripts对象中的dev添加 set API_ROOT=localhost&amp;&amp; node build/dev-server.js并且在config文件夹中的dev.env.js加一个判断,分别判断 sit、uat、pro正式环境还有本地loaclhost，打包不同的文件和接口12345678910111213141516171819202122232425262728293031323334 switch (process.env.API_ROOT) &#123; case 'sit': module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"', API_URL: '', LOGIN_URL: '', LOGOUT_URL: '' &#125;) break; case 'uat': module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"', API_URL: '', LOGIN_URL: '', LOGOUT_URL: '' &#125;) break; case 'pro': module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"', API_URL: '', LOGIN_URL: '', LOGOUT_URL: '' &#125;) break; default: module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"', API_URL: '', LOGIN_URL: '', LOGOUT_URL: '' &#125;) break;&#125; 但是有一个不好的地方，就是要写多个dev-sit、dev-uat、dev-pro和build-sit、build-uat、build-pro要运行不同的环境和打包不同的环境同时在api.js中读取process.env.API_URL来调用不同的接口位置 思路2可以在 cmd 运行npm run dev时添加进程的信息，如在window端添加进程信息set API_ROOT=localhost&amp;&amp; npm run dev这样式和上面有同样的结果，这样更简洁一些，这只是个人的一些简单的见解。]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mockData]]></title>
    <url>%2F%2Fblog%2FmockData.html</url>
    <content type="text"><![CDATA[概述 在项目开发中，有很多时候是在后台接口还没开发好，有的是api接口都没写，有的是有api接口但是没有数据，不管是那种，都是在大家都对数据格式，接口的方式都是有统一了的，才能做mock数据，不然的话数据格式变化，接口内容变化，基本上前端mock不mocK数据基本上没什么用，还是等于对接两遍。 我自己的建议，当有接口api的时候，但是没有真实数据的时候，我推荐用mock.js来解决问题，不需要自己再用express，或者别的框架自己发布本地接口，直接在ajax返回数据的时候改变response的data数据 另一种就是完全都没有后台接口的时候，要自己本地跑起来接口或者别的地方要有接口api才可以mock数据，建议使用easy-mock mock.js 首先：可以在自己项目中的package.json中添加mock.js和版本号“mockjs”: “^1.0.1-beta3”可以通过在github中看他的tag号，使用他最稳定的版本，通过npm installorcnpm installoryarn都是可以的，这个完全看自己的网络了。 然后：在自己的api同级创建一个mock文件夹在里面再创建一个叫做，mock.js的文件。我只是简单的做一个demo,具体的mock怎么构思和构建要看自己的业务，可以见一个总开关来控制是否mock数据，和子开关来控制是否mock子接口，如process.env.NODE_ENV 或者别的全局来判断是否开启mock数据 1234567891011121314151617181920212223import Mock from 'mockjs';let Random = Mock.Random; // 这个只是 其中的一种形式 还有其他两种const oMsgData = Mock.mock(&#123; 'list|10': [&#123; name: '@cname', id: '@increment', content: '@csentence', createTime: '@date', isRead: Number(Random.boolean()), isTop: Number(Random.boolean()), state: Number(Random.boolean()), type: '@increment' &#125;]&#125;);// console.log(JSON.stringify(oMsgData, null, 4));// console.log(oMsgData);/** * @param &#123;String&#125; rurl 要替换的接口路径名 * @param &#123;String&#125; rtype 要替换的接口请求方式 * @param &#123;Object&#125; data 要替换的接口的response的data/// 他会自动帮你填写 域名和端口号 rurl rtype response.dataMock.mock('/api/notice/noticeListAdmin', 'post', &#123;oMsgData&#125;); 具体的参数我这个就不讲了，首先引入Mock.js,然后可以通过 ‘@cname’生成随机的名字，也可以通过 Mock.Random.cname()生成随机名字。[参考] http://mockjs.com/ 这个是mock.js的官方文档，里面有mock的具体用法. easy-mock这种是在线方式的，完全可以在他这个里面创建一套符合自己的api接口，具体当可以看下面的连接，这个我感觉没什么好讲的了，因为感觉自己归纳的也没有人家文档好，反正是挺好的。[easy-mock] https://easy-mock.com/docs]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中float精度问题]]></title>
    <url>%2F%2Fblog%2Ffloat-Operation.html</url>
    <content type="text"><![CDATA[概述在用到JavaScript中float类型的值来运算时,会产生精度不准的问题。例如：可以看到：12console.log(0.1+0.2);// 0.30000000000000004 他得到的值是不精准的，简单来说，你的电脑做着正确的二进制浮点运算，但问题是你输入的是十进制的数，电脑以二进制运算，这两者并不是总是转化那么好的想了解更详细的请参考&gt; https://www.zhihu.com/question/20679634 实例12]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie_function]]></title>
    <url>%2F%2Fblog%2Fcookie-function.html</url>
    <content type="text"><![CDATA[概述Cookie在客户端JavaScript中用JavaScript操作Cookie，用原声的接口document.cookie属性是比较难用的，所以封装一个添加、修改、删除的操作方法还是很有必要的。同时要注意的是： Cookie的所有name和value都是要经过URI编码的，必须使用decodeURICompoent()来编码。 实例1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue官方的vue-cli一些优化打包方式的配置和方法，懒加载和dll优化方式]]></title>
    <url>%2F%2Fblog%2Fvue-build-dll.html</url>
    <content type="text"><![CDATA[简述我用了官方脚手架vue-cli，有两个页面ppt_model.vue和 ppt_model1.vue,在两个页面中分别引入了echarts、jquery他默认会把所有的报都打包到 app.js和vendor.js中。运行npm run build –report如下图所示：在cmd中显示打包信息在页面中显示打包信息 懒加载使用vue-router官方推荐的懒加载,基本语法是 component: resolve =&gt; require([‘../view/ppt_model.vue’], resolve)会把每一个页面分开打包成一个js文件，当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。参考 &gt; https://router.vuejs.org/zh-cn/advanced/lazy-loading.html打包如下所示：在cmd中显示打包信息在页面中显示打包信息其中的static/js/0.66e1ff74acbd166fa927.js对应的是ppt_model.vue页面 static/js/1.f09ddc0b737b2466f148.js对应的是ppt_model1.vue页面 webpack官方提供的DllReferencePlugin这个插件是在 webpack 主配置文件中设置的， 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。简单的说，就是把静态的插件库打包到一个静态文件里，同时生成对静态文件引用的json文件，通过webpack的DllReferencePlugin插件实现，打包的优化.首先创建一个名为webpack.dll.config.js文件，内容为：12345678910111213141516171819202122232425var path = require('path');var webpack = require('webpack');module.exports = &#123; entry: &#123; vendor: ['vue-router', 'echarts', 'jquery', 'vue'] &#125;, output: &#123; path: path.join(__dirname, '../static/js'), filename: 'dll.[name].js', library: '[name]' &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, 'dll', '[name]-manifest.json'), name: '[name]', context: path.resolve(__dirname, 'client') &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;; 在你的项目文件夹目录cmd中运行webpack –config ./build/webpack.dll.config.js在build中新建了一个dll中有一个vendor-manifest.json和，在static(最外层的static)中新建一个dll.vendor.js。在build文件中webpack.prod.conf.js添加一段代码在打包前记得在index.html最下方，因为打包生成的js,12345// 记得在plugins中添加new webpack.DllReferencePlugin(&#123; context: path.join(__dirname, "client"), manifest: require("./dll/vendor-manifest.json")&#125;), 再运行npm run build –report运行结果如图所示：在cmd中显示打包信息在页面中显示打包信息 注意在打包前记得在index.html最下方，引入打包生成的js1234567891011121314 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;dq2.0&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;script src="./static/js/dll.vendor.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如果报错，请参考 &gt; https://router.vuejs.org/zh-cn/advanced/lazy-loading.html本地可以预览页面效果，接口是不能调用的，dist中的index.html]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[heatmap.js绘制热力图和擦除热力图]]></title>
    <url>%2F%2Fblog%2Fhetamap-draw.html</url>
    <content type="text"><![CDATA[简述绘制了热力图的时候用到了插件heatmap.js,高德地图的热力图也是用了这个插件来绘制的。heatmap &gt; https://www.patrick-wied.at/static/heatmapjs/可能比较冷门，一般的话相信没人会用这个工具的，但是现在大数据这么火，相信还是有人能用到的。要做的是，上传一张图片，然后在图片上绘制热力图，同是也是可以擦除，这个只是一个小的demo,可以根据自己的实际场景来实际应用 功能默认是绘制图形，点击清除，擦除热力图 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .heatmap &#123; width:1800px; height:600px;border: 1px solid;border-color: grey;cursor: pointer; &#125; .imgUpdate &#123; position: absolute; left: 10px; top: 60px; z-index: -999; &#125; .draw, .clear&#123; display: inline-block; width: 50px; height: 50px; &#125; .circle &#123; width: 15px; height: 15px; position: absolute; border: 2px solid red; border-radius: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="activat"&gt; &lt;span class="draw"&gt;画图&lt;/span&gt; &lt;span class="clear"&gt;清除&lt;/span&gt; &lt;/div&gt; &lt;div class="heatmap"&gt;&lt;/div&gt; &lt;div class="ge_pic_icon_Infor"&gt; &lt;img src="" alt="" class="imgUpdate"&gt; &lt;/div&gt; &lt;div class="Infor_file"&gt; &lt;input type="file" name="uploadPicture" id="file" value="" title="上传照片" onchange="getPhoto(this)"/&gt; &lt;/div&gt; &lt;div class="circle"&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="https://cdn.bootcss.com/heatmap.js/2.0.2/heatmap.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var body = document.body; var hm = document.querySelector('.heatmap'); var clearDom = document.querySelector('.clear'); var drawDom = document.querySelector('.draw'); var circleDom = document.querySelector('.circle'); let State = 0; // var hehedom = document.querySelector('#hehe'); // hehedom.addEventListener('change', function () &#123; // console.log(this.value) // &#125;); var heatmap = h337.create(&#123; container: hm, radius: 30 &#125;); heatmap.setData (&#123; max: 100, min: 0, data: [] &#125;); var lastX, lastY; let key = 0; body.onmousedown = function(ev) &#123; key = 1; return false; &#125; body.onmouseup = function(ev) &#123; key = 0; return false; &#125; let arr = []; let arr1 = []; hm.onmousemove = function(ev) &#123; // console.log(222); if (key !== 1) &#123;return false;&#125; // console.log(ev); lastX = ev.pageX; lastY = ev.pageY - 50; let obj = &#123; x: lastX, y: lastY, value: 10 &#125; heatmap.addData(obj); arr.push(obj); // console.log(obj); &#125; drawDom.addEventListener('click', function(event) &#123; hm.onmousemove = null; hm.onmousemove = function(ev) &#123; if (key !== 1) &#123;return false;&#125; // console.log(ev); lastX = ev.pageX; lastY = ev.pageY - 50; let obj = &#123; x: lastX, y: lastY, value: 10 &#125; heatmap.addData(obj); arr.push(obj); &#125; &#125;) clearDom.addEventListener('click', function(event) &#123; hm.onmousemove = null; hm.onmousemove = function(ev) &#123; circleDom.style.left = ev.pageX + 'px'; circleDom.style.top = ev.pageY + 'px'; if (key !== 1) &#123;return false;&#125; // console.log(ev); let arr2 = []; arr.forEach((item, index) =&gt; &#123; // console.log(typeof ev.pageX); // console.log(ev.pageX + '' + ev.pageY); // for (let i = 0; i &lt;= 15; i++) &#123; let dx = ev.pageX - item.x; let dy = ev.pageY - item.y - 50; // console.log((dx * dx) + (dy * dy)); if ((dx * dx) + (dy * dy) &lt;= 15 * 15)&#123; arr2.push(index); &#125; &#125;) if (arr2.length) &#123; console.log(arr2) &#125; let arr3 = []; // console.log(arr); for(var i = 0; i &lt; arr2.length; i++) &#123; if (arr.length === 1) &#123; arr = []; &#125; else &#123; arr.splice((arr2[i]-i), 1) &#125; &#125; let oObj = &#123; max: 100, min: 0, data: arr &#125; window.heatmap.setData(oObj); &#125; &#125;) var imgurl = ""; function getPhoto(node) &#123; var imgURL = ""; try&#123; var file = null; if(node.files &amp;&amp; node.files[0] )&#123; file = node.files[0]; &#125;else if(node.files &amp;&amp; node.files.item(0)) &#123; file = node.files.item(0); &#125; //Firefox 因安全性问题已无法直接通过input[file].value 获取完整的文件路径 try&#123; imgURL = file.getAsDataURL(); &#125;catch(e)&#123; imgRUL = window.URL.createObjectURL(file); &#125; &#125;catch(e)&#123; if (node.files &amp;&amp; node.files[0]) &#123; var reader = new FileReader(); reader.onload = function (e) &#123; imgURL = e.target.result; &#125;; reader.readAsDataURL(node.files[0]); &#125; &#125; creatImg(imgRUL); return imgURL; &#125; function creatImg(imgRUL)&#123; // var textHtml = "&lt;img src='"+imgRUL+"'width='414px' height='600px'/&gt;"; document.querySelector(".imgUpdate").setAttribute('src', imgRUL); &#125; &lt;/script&gt;&lt;/html&gt; 如图所示：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>heatmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现经典的三列布局]]></title>
    <url>%2F%2Fblog%2FClassic-layout.html</url>
    <content type="text"><![CDATA[概述圣杯布局和双飞翼布局解决的问题是一样的，就是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。 区别和统一圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。 不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。 双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。 简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“，而不是你题目中说的”去掉relative”就是双飞翼布局“。 圣杯布局圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。 实例12345678&lt;section class="container"&gt; &lt;article class="con_continer"&gt; &lt;/article&gt; &lt;article class="con_left"&gt; &lt;/article&gt; &lt;article class="con_right"&gt; &lt;/article&gt;&lt;/section&gt; 先设置container的左右padding值来摆正con_continer的位置1234567891011/*圣杯布局*//*摆正中间栏的位置*/.container &#123;padding: 0 200px;&#125;/*清除浮动*/.container::after&#123;content:""; display: block; clear:both; overflow: hidden; zoom: 1&#125;/*设置三栏高度*/.container .con_continer, .container .con_left, .container .con_right &#123;height: 400px;&#125;/*设置三栏为左浮动 float:left*/.container .con_continer &#123;float:left;width:100%;background:red&#125;.container .con_left &#123;float:left;width:200px;background:yellow;&#125;.container .con_right &#123;float:left;width:200px;background:yellow;&#125; 如下图所示：左右栏通过添加负的margin放到正确的位置了修改如下：12345.container .con_continer &#123;float:left;width:100%;background:red&#125;// 通过margin-left为-100% 左侧栏 覆盖到中间栏上，再通过相对定位的负的left值来让他在左边.container .con_left &#123;float:left;width:200px;margin-left:-100%;background:yellow;position:relative;left:-200px&#125;// 通过margin-left为-200px 右侧栏 覆盖到中间栏上，再通过相对定位的负的right值来让他在右边.container .con_right &#123;float:left;width:200px;margin-left:-200px;background:yellow;position:relative;right:-200px&#125; 双飞翼布局双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。 实例123456789&lt;section class="container"&gt; &lt;article class="con_continer"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/article&gt; &lt;article class="con_left"&gt; &lt;/article&gt; &lt;article class="con_right"&gt; &lt;/article&gt;&lt;/section&gt; 123456789/*双飞翼布局*//*清除浮动*/.container::after&#123;content:""; display: block; clear:both; overflow: hidden; zoom: 1&#125;/*设置三栏高度*/.container .con_continer, .container .con_left, .container .con_right, .container .con_continer .item &#123;height: 400px;&#125;/*设置三栏为左浮动 float:left*/.container .con_continer &#123;float:left;width:100%;background:red&#125;.container .con_left &#123;float:left;width:200px;background:yellow;&#125;.container .con_right &#123;float:left;width:200px;background:yellow;&#125; 如下图所示：左右栏通过添加负的margin放到正确的位置了修改如下：1234567.container .con_continer &#123;float:left;width:100%;background:red&#125;// 通过margin-left为-100% 左侧栏 覆盖到中间栏上，再通过相对定位的负的left值来让他在左边.container .con_left &#123;float:left;width:200px;margin-left:-100%;background:yellow;&#125;// 通过margin-left为-200px 右侧栏 覆盖到中间栏上，再通过相对定位的负的right值来让他在右边.container .con_right &#123;float:left;width:200px;margin-left:-200px;background:yellow;&#125;// 设置 con_continer内部 内容的margin来防止覆盖.container .con_continer .item &#123;margin:0 200px 0 180px;&#125; 修改后的结局为这样]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中Number一些新增的方法和属性]]></title>
    <url>%2F%2Fblog%2Fes6-Number.html</url>
    <content type="text"><![CDATA[概念JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。 描述Number 对象主要用于： 如果参数无法被转为数字，则返回NaN. 早非构造器上下文中（如：没有new操作符），Number能被用来执行类型转换 属性Number.EPSTION两个可表示(representable)数之间的最小间隔。 EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16，或者 2-52。1234x = 0.2;y = 0.3;z = 0.1;equal = (Math.abs(x - y + z) &lt; Number.EPSILON);### Number.MAX_SAFE_INTEGER Number.MIN_SAFE_INTEGERNumber.MAX_SAFE_INTEGER 常量表示在 JavaScript 中最大的安全整数（maxinum safe integer)（253 - 1）。Number.MIN_SAFE_INTEGER 代表在 JavaScript中最小的安全的integer型数字 (-(253 - 1)).MAX_SAFE_INTEGER 常量值为 9007199254740991。MIN_SAFE_INTEGER 的值是-9007199254740991.1234Number.MAX_SAFE_INTEGER // 9007199254740991Math.pow(2, 53) - 1 // 9007199254740991Number.MIN_SAFE_INTEGER // -9007199254740991-(Math.pow(2, 53) - 1) // -9007199254740991### Number.MAX_VALUE Number.MIN_VALUENumber.MAX_VALUE 属性表示在 JavaScript 里所能表示的最大数值Number.MIN_VALUE 属性表示在 JavaScript 中所能表示的最小的正值MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 “Infinity”。MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0。因为 MAX_VALUE 是 Number 对象的一个静态属性，所有应该直接使用，Number.MAX_VALUE ，而不是作为一个创建的 Number 实例的属性。1234567891011if (num1 * num2 &lt;= Number.MAX_VALUE) &#123; func1();&#125; else &#123; func2();&#125;if (num1 / num2 &gt;= Number.MIN_VALUE) &#123; func1();&#125; else &#123; func2();&#125;### Number.NaN Number.prototypeNumber.NaN 表示“非数字”（Not-A-Number）。和 NaN 相同。Number.prototype 属性表示 Number 构造函数的原型。所有 Number 实例都继承自 Number.prototype。修改 Number 构造函数的原型对象会影响到所有 Number 实例。.不必创建一个 Number 实例来访问该属性，使用 Number.NaN 来访问该静态属性。#### 属性constructor返回创建该实例对象的构造函数。默认为 Number 对象。12Properties inherited from Object:__parent__, __proto__## 方法实例本身的方法 Number.isFinite()、Number.isInteger()、Number.isNaN()、Number.isSafeInteger()、Number.parseFloat()、Number.parseInt()prototype原型上的方法 Number.prototype.toExponential()、Number.prototype.toFixed()、Number.prototype.toLocaleString()、Number.prototype.toPrecision()、Number.prototype.toSource()、Number.prototype.toString()、Number.prototype.valueOf()### Number.isFinite() Number.isSafeInteger()Number.isFinite() 方法用来检测传入的参数是否是一个有穷数（finite number）。Number.isSafeInteger() 方法用来判断传入的参数值是否是一个“安全整数”（safe integer）。一个安全整数是一个符合下面条件的整数#### 语法12345678910111213141516171819202122232425262728Number.isFinite(value)// 参数// value// 要被检测有穷性的值Number.isFinite(Infinity); // falseNumber.isFinite(NaN); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(0); // trueNumber.isFinite(2e64); // trueNumber.isFinite('0'); // false, 全局函数 isFinite('0') 会返回 trueNumber.isSafeInteger(testValue)// 参数// testValue// 需要检测的参数。// 返回值// 一个布尔值 表示给定的值是否是一个安全整数（safe integer）。Number.isSafeInteger(3); // trueNumber.isSafeInteger(Math.pow(2, 53)) // falseNumber.isSafeInteger(Math.pow(2, 53) - 1) // trueNumber.isSafeInteger(NaN); // falseNumber.isSafeInteger(Infinity); // falseNumber.isSafeInteger("3"); // falseNumber.isSafeInteger(3.1); // falseNumber.isSafeInteger(3.0); // true#### 注意和全局的 isFinite() 函数相比，这个方法不会强制将一个非数值的参数转换成数值，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。Number.isSafeInteger() 安全整数范围为 -(253 - 1)到 253 - 1 之间的整数，包含 -(253 - 1)和 253 - 1。### Number.isInteger()Number.isInteger() 方法用来判断给定的参数是否为整数。如果被检测的值是整数，则返回 true，否则返回 false。注意 NaN 和正负 Infinity 不是整数。#### 语法123456789101112131415161718Number.isInteger(value)// 参数// value// 要判断此参数是否为整数// 返回值// 判断给定值是否是整数的 Boolean 值。Number.isInteger(0); // trueNumber.isInteger(1); // trueNumber.isInteger(-100000); // trueNumber.isInteger(0.1); // falseNumber.isInteger(Math.PI); // falseNumber.isInteger(Infinity); // falseNumber.isInteger(-Infinity); // falseNumber.isInteger("10"); // falseNumber.isInteger(true); // falseNumber.isInteger(false); // falseNumber.isInteger([1]); // false### Number.isNaN()Number.isNaN() 方法确定传递的值是否为 NaN和其类型是 Number。它是原始的全局isNaN()的更强大的版本。#### 语法123456789101112131415161718192021222324Number.isNaN(value)// 参数// value// 要被检测是否是 NaN 的值。// 返回值// 一个布尔值，表示给定的值是否是 NaN。Number.isNaN(NaN); // trueNumber.isNaN(Number.NaN); // trueNumber.isNaN(0 / 0) // true// 下面这几个如果使用全局的 isNaN() 时，会返回 true。Number.isNaN("NaN"); // false，字符串 "NaN" 不会被隐式转换成数字 NaN。Number.isNaN(undefined); // falseNumber.isNaN(&#123;&#125;); // falseNumber.isNaN("blabla"); // false// 下面的都返回 falseNumber.isNaN(true);Number.isNaN(null);Number.isNaN(37);Number.isNaN("37");Number.isNaN("37.37");Number.isNaN("");Number.isNaN(" ");#### 描述在 JavaScript 中，NaN 最特殊的地方就是，我们不能使用相等运算符（== 和 ===）来判断一个值是否是 NaN ，因为 NaN == NaN 和 NaN === NaN 都会返回 false 。因此，必须要有一个判断值是否是 NaN 的方法。同样：和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。### Number.parseInt() Number.parseFloat()Number.parseFloat() 方法可以把一个字符串解析成浮点数。该方法与全局的 parseFloat() 函数相同，并且处于 ECMAScript 6 规范中（用于全局变量的模块化）。Number.parseInt() 方法可以根据给定的进制数把一个字符串解析成整数。#### 语法12345678910111213141516Number.parseInt(string, radix);// 参数// string// 被解析的值。如果不是一个字符串，则将其转换为字符串。字符串开头的空白符将会被忽略。// radix// 一个整数值，指定转换中采用的基数。总是指定该参数可以保证结果可预测。当忽略该参数时，不同的实现环境可能产生不同的结果。// 返回值// 返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。Number.parseFloat(string)// 参数// string// 被解析的字符串。Number.parseFloat("3.14"); // 3.14Number.parseFloat("314e-2"); // 3.14Number.parseFloat("FF2"); // NaN#### 描述该方法和全局的 parseInt() 函数是同一个函数：该方法和全局的 parseFloat() 函数是同一个函数：123456789验证Number.parseInt、Number.parseFloat与全局的 parseInt、parseFloat是相同的Number.parseInt === parseInt; // trueNumber.parseFloat === parseFloat; // trueparseInt("F", 16); // 15parseInt("17", 8); // 15parseInt("15", 10); // 15parseInt("Hello", 8); // NaNparseInt("546", 2); // NaNparseInt 函数将其第一个参数转换为字符串，解析它，并返回一个整数或NaN。如果不是NaN，返回的值将是作为指定基数（基数）中的数字的第一个参数的整数。例如：radix参数为10 将会把第一个参数看作是一个数的十进制表示,如果不属于radix参数所指定的基数中的字符那么该字符和气候的字符创都将被忽略。在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：- 如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).- 如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。- 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。需要注意的是：如果第一个字符不能被转换成数字，parseInt返回NaN。 Number.prototype.toFixed()、Number.prototype.toPrecision()toFixed() 方法使用定点表示法来格式化一个数。toPrecision() 方法以指定的精度返回该数值对象的字符串表示。 语法1234567891011121314151617181920212223242526272829303132numObj.toFixed(digits)// 参数// digits// 小数点后数字的个数；介于 0 到 20 （包括）之间，实现环境可能支持更大范围。如果忽略该参数，则默认为 0。// 返回值// 一个数值的字符串表现形式，不使用指数记数法，而是在小数点后有 digits 位数字。var numObj = 12345.6789;numObj.toFixed(); // 返回 "12346"：进行四舍五入，不包括小数部分numObj.toFixed(1); // 返回 "12345.7"：进行四舍五入numObj.toFixed(6); // 返回 "12345.678900"：用0填充(1.23e+20).toFixed(2); // 返回 "123000000000000000000.00"(1.23e-10).toFixed(2); // 返回 "0.00"2.34.toFixed(1); // 返回 "2.3"-2.34.toFixed(1); // 返回 -2.3 （由于操作符优先级，负数不会返回字符串）(-2.34).toFixed(1); // 返回 "-2.3" （若用括号提高优先级，则返回字符串）numObj.toPrecision(precision)// 参数// precision// 可选。一个用来指定有效数个数的整数。// 返回值// 以定点表示法或指数表示法表示的一个数值对象的字符串表示，四舍五入到 precision 参数指定的显示数字位数。var numObj = 5.123456;console.log("numObj.toPrecision() is " + numObj.toPrecision()); //输出 5.123456console.log("numObj.toPrecision(5) is " + numObj.toPrecision(5)); //输出 5.1235console.log("numObj.toPrecision(2) is " + numObj.toPrecision(2)); //输出 5.1console.log("numObj.toPrecision(1) is " + numObj.toPrecision(1)); //输出 5// 注意：在某些情况下会以指数表示法返回console.log((1234.5).toPrecision(2)); // "1.2e+3" 该数值在必要时进行四舍五入，另外在必要时会用 0 来填充小数部分，以便小数部分有指定的位数。 Number.prototype.toLocaleString()、Number.prototype.toString()、Number.prototype.valueOf()toString() 方法返回指定 Number 对象的字符串表示形式。valueOf() 方法返回一个被 Number 对象包装的原始值。 语法123456789101112131415161718192021numObj.toString([radix]) // 参数 // radix // 指定要用于数字到字符串的转换的基数(从2到36)。如果未指定 radix 参数，则默认值为 10。 var count = 10; console.log(count.toString()); // 输出 '10' console.log((17).toString()); // 输出 '17' console.log((17.2).toString()); // 输出 '17.2' var x = 6; console.log(x.toString(2)); // 输出 '110' console.log((254).toString(16)); // 输出 'fe' console.log((-10).toString(2)); // 输出 '-1010' numObj.valueOf() var numObj = new Number(10); console.log(typeof numObj); // object var num = numObj.valueOf(); console.log(num); // 10 console.log(typeof num); // number Number 对象覆盖了 Object 对象上的 toString() 方法，它不是继承的 Object.prototype.toString()。对于 Number 对象，toString() 方法以指定的基数返回该对象的字符串表示。valueOf()该方法通常是由 JavaScript 引擎在内部隐式调用的，而不是由用户在代码中显式调用的]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5中的canvas的使用方法，实现自定义绘制图形]]></title>
    <url>%2F%2Fblog%2Fcanvas-2.html</url>
    <content type="text"><![CDATA[绘制路径图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。1、首先，你需要创建路径起始点。2、然后你使用画图命令去画出路径。3、之后你把路径封闭。4、一旦路径生成，你就能通过描边或填充路径区域来渲染图形。 常用方法beginPath()新建一条路径，生成之后，图形绘制命令会被指向到路径上生成路径。 closePath()闭合路径之后图形绘制命令又重新指向到上下文中 stroke()通过线条来绘制图像轮廓 fill()通过填充路径的内容区域生成实心的图形。 moveTo(x, y)将笔触移动到指定的坐标x以及y上。你通常会使用moveTo()函数设置起点，使用moveTo()绘制一些不连续的路径移动中心点123456789101112131415function draw () &#123; var canvas = document.querySelector('.canvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制 ctx.moveTo(110,75); ctx.arc(75,75,35,0,Math.PI,false); // 口(顺时针) ctx.moveTo(65,65); ctx.arc(60,65,5,0,Math.PI*2,true); // 左眼 ctx.moveTo(95,65); ctx.arc(90,65,5,0,Math.PI*2,true); // 右眼 ctx.stroke(); &#125;&#125; lineTo(x, y)绘制直线，需要用到的方法lineTo().绘制一条从当前位置到指定x以及y位置的直线绘制一个填充、描边的三角形1234567891011121314151617181920function draw () &#123; var canvas = document.querySelector('.canvas');] if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // 填充三角形 ctx.beginPath(); ctx.moveTo(25,25); ctx.lineTo(105,25); ctx.lineTo(25,105); ctx.fill(); // 描边三角形 ctx.beginPath(); ctx.moveTo(125,125); ctx.lineTo(125,45); ctx.lineTo(45,125); ctx.closePath(); ctx.stroke(); &#125;&#125; 注意注意：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，第一条路径构造命令通常被视为是moveTo（），无论最后的是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。注意：当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。 实例绘制一个12345678910111213141516171819202122232425262728293031323334 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style lang=""&gt; .canvas &#123; width: 300px; height: 300px; margin: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="canvas"&gt;&lt;/canvas&gt; &lt;script&gt; function draw() &#123; var canvas = document.getElementById('canvas'); if (canvas.getContext)&#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.moveTo(75,50); ctx.lineTo(100,75); ctx.lineTo(100,25); ctx.fill(); &#125; &#125; draw(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5中的canvas基本使用方法]]></title>
    <url>%2F%2Fblog%2Fcanvas-1.html</url>
    <content type="text"><![CDATA[概述canvas元素负责在页面中设定一个区域，然后就可以通过JavaScript动态地在这个区域中绘制图形。与浏览器环境中的其他组件类似，由几组API构成，但非所有浏览器都支持所有这些api,基本绘制能力的2D上下文，还建议了一个名为webGL的3D上下文。 基本用法12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .canvas1 &#123; border: 1px solid #000; margin: auto; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="canvas1" width="300" height="300"&gt;&lt;/canvas&gt; &lt;script&gt; // 使用canvas必须先设置其width和height属性，指定可以绘图的区域大小 var canvas = document.querySelector('.canvas'); var ctx = null; // 判断当前浏览器支不支持 canvas if (canvas.getContext) &#123; ctx = canvas.getContext('2d'); ctx.strokeStyle = 'red'; ctx.fillStyle = '#0000ff'; ctx.fillRect(0, 0, 150, 150); &#125; // fillStyle 填充颜色、strokeStyle 描边颜色 // 字符串（颜色名、十六进制、rgb、rgba、hsl、hsla）、渐变对象、模式对象 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以获取到canvasdom,再通过getContext(‘2d’)获取到2D上下文，通过fillStylefillStyle设置填充颜色，通过strokeStyle设置描边颜色（默认显示 #000），fillRect(0, 0, 150, 150)设置矩形的位置和长宽效果如下所示： 栅格在我们开始画图之前，我们需要了解一下画布栅格（canvas grid）以及坐标空间。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。在课程的最后我们会平移原点到不同的坐标上，旋转网格以及缩放。现在我们还是使用原来的设置。 fillStyle strokeStylefillStyle、strokeStyle这个两个属性的值可以是字符串、渐变对象或者模式对象，而且他们的默认值都是”#000000”。字符串值可以为颜色值、十六进制码、rgb、rgba、hsl或hsla. 绘制矩形不同于SVG，HTML中的元素canvas只支持一种原生的图形绘制：矩形。所有其他的图形的绘制都至少需要生成一条路径。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。 fillRectfillRect(x, y, width, height)参数x矩形起始点的 x 轴坐标。y矩形起始点的 y 轴坐标。width矩形的宽度。height矩形的高度。绘制一个 1&lt;canvas id="canvas"&gt;&lt;/canvas&gt; 12345var canvas = document.getElementById("canvas");var ctx = canvas.getContext("2d");ctx.strokeStyle = "green";ctx.fillRect(10, 10, 100, 100); strokeRect参数x矩形起始点的 x 轴坐标。y矩形起始点的 y 轴坐标。width矩形的宽度。height矩形的高度。 1&lt;canvas id="canvas"&gt;&lt;/canvas&gt; 12345var canvas = document.getElementById("canvas");var ctx = canvas.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(10, 10, 100, 100); clearRect参数x矩形起始点的 x 轴坐标。y矩形起始点的 y 轴坐标。width矩形的宽度。height矩形的高度。这仅是一段简单地使用 clearRect 方法的代码片段。 1&lt;canvas id="canvas"&gt;&lt;/canvas&gt; 1234567891011121314var canvas = document.getElementById("canvas");var ctx = canvas.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath(); // draws last line of the trianglectx.stroke();ctx.clearRect(10, 10, 100, 100);// clear the whole canvas// ctx.clearRect(0, 0, canvas.width, canvas.height);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中Array、Object深度复制、数据类型]]></title>
    <url>%2F%2Fblog%2FArrayObject-deepCopy.html</url>
    <content type="text"><![CDATA[类型在JavaScript中类型分为两类：基本类型(值类型)、引用类型 基本类型Undefind、Null、Boolean、Number、String 实现复制1234567891011var str = '小伙子,25278';var str1 = str;str1 = "大伙子,5967";console.log(str); // 小伙子,25278console.log(str1); // 大伙子,5967var num = 25278;var num1 = num;num1 = 5967;console.log(num); // 25278console.log(num1); // 5967 注意事项javascript里的基本类型（值类型）是不可以改变的，javascript也没有提供任何一个改变字符串的方法和语法.他不是能当成对象来使用的。示例：1234567var str = "myobject";str.name = "myname";console.log(str.name); // undefinedvar num = 123;num.name = "myname";console.log(num.name); // undefined 引用类型如Array、Objectjavascript引用数据类型是保存在堆内存中的对象，与其它语言不同的是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能通过操作对象的在栈内存中的引用地址。所以引用类型的数据，在栈内存中保存的实际上是对象在堆内存中的引用地址。 示例1234var obj1 = new Object();var obj2 = obj1;obj2.name = "我有名字了";console.log(obj1.name); // 我有名字了 示例图：自然，给obj2添加name属性，实际上是给堆内存中的对象添加了name属性，obj2和obj1在栈内存中保存的只是堆内存对象的引用地址，虽然也是拷贝了一份，但指向的对象却是同一个。故而改变obj2引起了obj1的改变。 Array实现复制12345var arr = [1, 2, 3, 4, 5];var arr1 = arr;arr1.push(6);console.log(arr); // [1, 2, 3, 4, 5, 6]console.log(arr1); // [1, 2, 3, 4, 5, 6] 改为：12345678910111213var arr = [1, 2, 3, 4, 5];// Array.prototype.slice() 返回一个新的数组，可以切断他们之间的联系var arr1 = arr.slice(); // 根据数组下标改变数组// Array.prototype.splice() 返回一个新的数组，可以切断他们之间的联系var arr2 = arr.splice(); // 根据数组下标改变数组var arr3 = arr.concat();arr1.push(6);arr2.push(6);arr3.push(6);console.log(arr); // [1, 2, 3, 4, 5]console.log(arr1); // [1, 2, 3, 4, 5, 6]console.log(arr2); // [6]console.log(arr3); // [1, 2, 3, 4, 5, 6] Array.prototype.slice()http://asyncnode.com/blog/es6-Array1.html查看详情 Array.prototype.splice()http://asyncnode.com/blog/es6-Array1.html查看详情 Array.prototype.concat()http://asyncnode.com/blog/es6-Array.html查看详情Object实现复制1234567var obj = &#123; name: '111'&#125;var obj1 = obj;obj1.age = 12;console.log(obj); // Object &#123;name: "111", age: 12&#125;console.log(obj1); // Object &#123;name: "111", age: 12&#125; 改为：、1234567var obj = &#123; name: '111'&#125;var obj1 = JSON.parse(JSON.stringify(obj)); // 先把对象通过浏览器对象转为 JSON字符串，再转为 JSON对象obj1.age = 12;console.log(obj); // Object &#123;name: "111"&#125;console.log(obj1); // Object &#123;name: "111", age: 12&#125; 同时Object也是有合并方法的为assgin(),但是他是不能项Array.prototype.concat()实现深度复制1234567var obj = &#123; name: '111' &#125; var obj1 = Object.assgin(obj, &#123;&#125;); // Object的合并对象方法 obj1.age = 12; console.log(obj); // Object &#123;name: "111", age: 12&#125; console.log(obj1); // Object &#123;name: "111", age: 12&#125; 最后一种也是比较官方的方法1234567891011121314151617function copy(obj) &#123;var copy = Object.create(Object.getPrototypeOf(obj));var propNames = Object.getOwnPropertyNames(obj);propNames.forEach(function(name) &#123; var desc = Object.getOwnPropertyDescriptor(obj, name); Object.defineProperty(copy, name, desc);&#125;);return copy;&#125;var obj1 = &#123; a: 1, b: 2 &#125;;var obj2 = copy(obj1); // obj2 looks like obj1 nowobj2.c = 3;console.log(obj1); // Object &#123;a: 1, b: 2&#125;console.log(obj2); // Object &#123;a: 1, b: 2, c: 3&#125; 下面的代码会创建一个给定对象的副本。 创建对象的副本有不同的方法，以下是只是一种方法，并解释了Array.prototype.forEach() 是如何使用ECMAScript 5 Object.* 元属性（meta property ）函数工作的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中的一个html转pdf、截图、生成图片的库]]></title>
    <url>%2F%2Fblog%2Fnode-phantom.html</url>
    <content type="text"><![CDATA[环境配置下载最新的node安装下载地址 https://nodejs.org/en/创建一个行的文件，文件名为 Test然后在 Test 运行 npm install phantom或者 安装本地依赖 npm install phantom –save ,全局安装 npm install -g phantom目录： 创建一个index.js12345678910111213141516171819202122232425262728293031323334353637// 你的node版本 高于 Node v7.9.0+ 可通过 node -V (产看)const phantom = require('phantom');(async function() &#123; const instance = await phantom.create(); const page = await instance.createPage(); await page.on("onResourceRequested", function(requestData) &#123; console.info('Requesting', requestData.url) &#125;); const status = await page.open('https://stackoverflow.com/'); console.log(status); const content = await page.property('content'); console.log(content); await instance.exit();&#125;());// node版本 高于 6.xvar phantom = require("phantom");var _ph, _page, _outObj;phantom.create().then(ph =&gt; &#123; _ph = ph; return _ph.createPage();&#125;).then(page =&gt; &#123; _page = page; return _page.open('./index_2.html');&#125;).then(status =&gt; &#123; console.log(status); return _page.property('content') // return _page.property('viewportSize', &#123;width: 1024, height: 600&#125;)&#125;).then(content =&gt; &#123; _page.render('index_2.pdf'); // console.log(content); _page.close(); _ph.exit();&#125;).catch(e =&gt; console.log(e)); 根据自己不同的 node版本 选择不同的 js代码新建一个index_2.html文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*重置css*/ body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, code, form, fieldset, lengend, input, button, textarea, select, p, blockquote, th, td &#123; margin:0; padding: 0;&#125; html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123; -webkit-text-size-adjust: none; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125; img &#123; border: 0 none; vertical-align: top; &#125; li &#123; list-style-type: none; &#125; h1, h2, h3, h4, h5, h6 &#123; font-size: 100%;font-weight:400;&#125; body, input, button, textarea, select &#123; font-size: 12px;font-family:"PingFangSC-Light","Microsoft Yahei",sans-serif;&#125; button &#123; cursor: pointer;border:0;&#125; em, cite &#123; font-style: normal; &#125; body &#123;line-height: 1.17; -webkit-text-size-adjust: none;-webkit-touch-callout: none;-webkit-user-select: none;&#125; a &#123; color: #2c2c2c; text-decoration: none!important; &#125; a:link&#123;text-decoration: none; &#125; :focus &#123; outline: none; &#125; .clearfixed:after &#123; content: "."; clear: both; display: block; height: 0; overflow: hidden; &#125; .clearfixed &#123; zoom: 1; display: block; &#125; *&#123;-webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; -o-text-size-adjust: none; text-size-adjust: none;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;&#125; ::-webkit-scrollbar &#123;width:0; height:0;&#125; /*滚动条样式*/ ::-ms-clear &#123;display:none;&#125; ::-ms-reveal &#123;display:none;&#125; input::-webkit-input-placeholder&#123;color:#ccc;&#125; /*body &#123;background-color: #666&#125;*/ /*padding: 0 50px;background-color: #fff*/ /*width: 800px; */ .higColor &#123; color: red;&#125; .themeColor &#123; color: #2a548e&#125; .font14 &#123; font-size: 14px !important;&#125; .header, .content, .footer &#123; margin: 0 50px; &#125; .header &#123;position: relative; padding: 15px 0; border-bottom: 5px solid #2a548e;&#125; .header .images &#123; width: 165px; height: 50px; &#125; .header .title &#123;position: absolute; right: 0; bottom: 15px; color: #2a548e; font-size: 16px; font-weight: bold&#125; .content &#123; padding-top: 30px;&#125; .content .title &#123; font-size: 18px; font-weight:bold;&#125; .content .txt &#123; font-size: 16px; line-height: 19px;&#125; .content .title, .content .txt, .content .des_tit &#123; padding-bottom: 22px;&#125; .content .img &#123; padding: 40px 0 60px 60px;&#125; /*.content .txt, .content .des_tit &#123;&#125;*/ .text_indent &#123; text-indent: 22px;&#125; .content .bold_tit &#123;font-weight: bold;&#125; .table &#123;padding-bottom: 22px;&#125; .table table&#123; width: 100%; font-size: 14px; text-align: center&#125; .table thead th, .table tbody td &#123;padding: 8px 0; font-weight: bold;&#125; .table thead th &#123;background-color: #8d6974; color: #fff;&#125; .footer &#123; border-top: 5px solid #2a548e; font-weight: bold; color: #2a548e;padding: 5px 0&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="header"&gt; &lt;div class="logo"&gt; &lt;img src="http://temp.im/165x50" alt="logo" class="images"&gt; &lt;/div&gt; &lt;div class="title"&gt;啊电话卡是的空间啊十大科技啊十大科技啊十大科技十大科技是打瞌睡的哈宽松觉得很愧疚2&lt;/div&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;div class="title"&gt; 一、综合评定结果： &lt;/div&gt; &lt;p class="txt text_indent"&gt; 中指大数据拿地阿萨德客户卡上快接啊时代快接啊获得卡号是的空间拉黑是的卡号是开店计划阿萨德哈空间是的哈空间啊看见的哈空间是的快接啊获得啊进口货是的快接啊黑色的快接啊黑色的快接啊黄寺大街是打瞌睡的哈空间 啊是的哈宽松的哈空间啊十大科技。&lt;span class="higColor"&gt;1111&lt;/span&gt; &lt;/p&gt; &lt;p class="txt bold_tit text_indent"&gt; 强化科维奇户外空间啊恢复快接啊黑色会计法哈斯空间很大空间是的空间啊十大科技啊是的快接啊黑色的快接啊哈萨克圣诞节 &lt;/p&gt; &lt;p class="txt text_indent"&gt; &lt;span class="bold_tit"&gt; 1、城市潜力： &lt;/span&gt; 啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd&lt;span class="bold_tit"&gt;dasd&lt;/span&gt;打扫的23123asdasdasd&lt;span class="higColor"&gt;打扫的23123asdasdasd&lt;/span&gt; 啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd&lt;span class="bold_tit"&gt;dasd&lt;/span&gt;打扫的23123asdasdasd&lt;span class="higColor"&gt;打扫的23123asdasdasd&lt;/span&gt; &lt;/p&gt; &lt;p class="txt text_indent"&gt; &lt;span class="bold_tit"&gt; 1、城市潜力： &lt;/span&gt; 啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd&lt;span class="bold_tit"&gt;dasd&lt;/span&gt;打扫的23123asdasdasd&lt;span class="higColor"&gt;打扫的23123asdasdasd&lt;/span&gt; 啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd&lt;span class="bold_tit"&gt;dasd&lt;/span&gt;打扫的23123asdasdasd&lt;span class="higColor"&gt;打扫的23123asdasdasd&lt;/span&gt; &lt;/p&gt; &lt;p class="txt text_indent"&gt; &lt;span class="bold_tit"&gt; 1、城市潜力： &lt;/span&gt; 啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd&lt;span class="bold_tit"&gt;dasd&lt;/span&gt;打扫的23123asdasdasd&lt;span class="higColor"&gt;打扫的23123asdasdasd&lt;/span&gt; 啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd&lt;span class="bold_tit"&gt;dasd&lt;/span&gt;打扫的23123asdasdasd&lt;span class="higColor"&gt;打扫的23123asdasdasd&lt;/span&gt; &lt;/p&gt; &lt;p class="txt text_indent"&gt; &lt;span class="bold_tit"&gt; 1、城市潜力： &lt;/span&gt; 啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd&lt;span class="bold_tit"&gt;dasd&lt;/span&gt;打扫的23123asdasdasd&lt;span class="higColor"&gt;打扫的23123asdasdasd&lt;/span&gt; 啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd&lt;span class="bold_tit"&gt;dasd&lt;/span&gt;打扫的23123asdasdasd&lt;span class="higColor"&gt;打扫的23123asdasdasd&lt;/span&gt; &lt;/p&gt; &lt;p class="txt"&gt; 表：标杆企业合理拿地总价（万元） &lt;p&gt; &lt;div class="table"&gt; &lt;table border="1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;企业&lt;/th&gt; &lt;th&gt;合理拿地总价&lt;/th&gt; &lt;th&gt;企业&lt;/th&gt; &lt;th&gt;合理拿地总价&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;toby&gt; &lt;tr&gt; &lt;td&gt;asdasdasd&lt;/td&gt; &lt;td&gt;123123&lt;/td&gt; &lt;td&gt;asdasdasd&lt;/td&gt; &lt;td&gt;123123123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;asdasdasd&lt;/td&gt; &lt;td&gt;123123&lt;/td&gt; &lt;td&gt;asdasdasd&lt;/td&gt; &lt;td&gt;123123123&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;asdasdasd&lt;/td&gt; &lt;td&gt;123123&lt;/td&gt; &lt;td&gt;asdasdasd&lt;/td&gt; &lt;td&gt;123123123&lt;/td&gt; &lt;/tr&gt; &lt;/toby&gt; &lt;/table&gt; &lt;/div&gt; &lt;p class="txt"&gt; &lt;span class="themeColor"&gt; 表：&lt;/span&gt;标杆企业合理拿地总价（万元） &lt;p&gt; &lt;div class="title"&gt; 二、模块分析 &lt;/div&gt; &lt;p class="txt bold_tit text_indent"&gt; 1、城市潜力： &lt;/p&gt; &lt;p class="txt bold_tit text_indent"&gt; 1.1、综合排名 &lt;/p&gt; &lt;p class="txt text_indent"&gt; 啊十大苏打撒打算的啊十大是开店哈继啊空间十大科技上方空间啊恢复及卡号是看见的哈空间十大健康啊就很大空间是的快接啊黑色的快接啊是&lt;span class="higColor"&gt;啊获得卡号是看见的&lt;/span&gt;啊十大苏打撒打算的啊十大是开店哈继啊空间十大科技上方空间啊恢复及卡号是看见的哈空间十大健康啊就很大空间是的快接啊黑色的快接啊是 &lt;p&gt; &lt;p class="txt bold_tit font14"&gt; 啊十大苏打撒打算的啊十大是开店哈继啊空间十大科技上方空间啊恢复 &lt;p&gt; &lt;div class="img"&gt; &lt;img src="http://temp.im/520x230" alt="图片"&gt; &lt;/div&gt; &lt;p class="txt bold_tit text_indent"&gt; 1.1、综合排名 &lt;/p&gt; &lt;p class="txt text_indent"&gt; 啊累积大量宽松基调绿卡时间的绿卡时间的来看了宽松基调徕卡建档立卡集散地立刻啊利空基调徕卡就旅客入境哦i后即可查看垃圾的垃圾了看破起哦贫穷品位磷矿vlklasfkalsjdlkj啊累积大量宽松基调绿卡时间的绿卡时间的来看了宽松基调徕卡建档立卡集散地立刻啊利空基调徕卡就旅客入境哦i后即可查看垃圾的垃圾了看破起哦贫穷品位磷矿vlklasfkalsjdlkj啊累积大量宽松基调绿卡时间的绿卡时间的来看了宽松基调徕卡建档立卡集散地立刻啊利空基调徕卡就旅客入境哦i后即可查看垃圾的垃圾了看破起哦贫穷品位磷矿vlklasfkalsjdlkj &lt;/p&gt; &lt;div class="img"&gt; &lt;img src="http://temp.im/520x230" alt="图片"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt; 啊的卡号是看见的哈宽松基调哈空间是的哈空间十大科技是的哈空间是的哈空间是的哈空间是的哈继是开店 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在 Test中运行 node index.js会生成一个index_2.pdf文件在谷歌中预览为 其实phantom可以做很多的事，比如说截图等等，具体可以看https://github.com/amir20/phantomjs-node]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>phantom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 一些常用array的扩展方法]]></title>
    <url>%2F%2Fblog%2Fes6-Array1.html</url>
    <content type="text"><![CDATA[方法迭代方法every(): 对数组中的每一项运行给函数，如果该函数对每一项都返回true,则返回true.filter(): 对数组中的每一项运行给函数，如果该函数会返回true的项目成的数组。forEach(): 对数组中的每一项运行给函数，这个项目没有返回值.map(): 对数组中的每一项运行给函数，返回每次函数调用的结果组成的数组。some(): 对数组中的每一项运行给函数，如果该函数对任何项都返回true,则返回true. every()/some()12345678910var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];var everyResult = numbers.every((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;)console.log(everyResult); // falsevar everyResult1 = numbers.some((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;)console.log(everyResult1); // true filter() 过滤12345var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];var everyResult = numbers.filter((item, index, array) =&gt; &#123; return (item &gt; 2);&#125;)console.log(everyResult); // [3, 4, 5, 6, 7, 8, 9, 10, 11] forEach()方法对数组的每个元素执行一次提供的函数。123456789101112131415161718 array.forEach(callback(currentValue, index, array)&#123; //do something &#125;, this) array.forEach(callback[, thisArg])// 参数 // callback // 为数组中每个元素执行的函数，该函数接收三个参数： // currentValue(当前值) // 数组中正在处理的当前元素。 // index(索引) // 数组中正在处理的当前元素的索引。 // array // forEach()方法正在操作的数组。 // thisArg可选 // 可选参数。当执行回调 函数时用作this的值(参考对象)。 // 返回值 // undefined. callback 函数会被依次传入三个参数： 数组当前项的值 数组当前项的索引 数组对象本身 注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。如果您正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用 Array.every 或 Array.some。如果可用，新方法 find() 或者findIndex() 也可被用于真值测试的提早终止。 map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。参数与forEach相同123456let numbers = [1, 5, 10, 15];let doubles = numbers.map((x) =&gt; &#123;return x * 2;&#125;);// 返回值// 一个新数组，每个元素都是回调函数的结果。 返回值一个新数组，每个元素都是回调函数的结果。 栈方法/队列方法栈是一种LIFO(Last-In-First-Out,后进先出)的数据结构，也就是最新添加的项被移除。push() 添加到数组末尾pop() 删除到数组末尾shift() 添加到数组头部unshift() 删除到数组头部123456789var arr = [4, 5, 6, 7];arr.push(8);console.log(arr); // [4, 5, 6, 7, 8]arr.pop();console.log(arr); // [4, 5, 6, 7]arr.unshift(1);console.log(arr); // [1, 4, 5, 6, 7]arr.shift();console.log(arr); // [4, 5, 6, 7] 位置方法 indexOf()、lastIndexOf()、find()、findIndex()接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。indexOf()方法从数组开头lastIndexOf()方法则从数组的末尾12345var arr = [1, 2, 3, 4, 5, 6, 4, 8];console.log(arr.indexOf(4)); // 3console.log(arr.lastIndexOf(4)); // 6console.log(arr.lastIndexOf(4)); // 3console.log(arr.lastIndexOf(4)); // 3 find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 ###]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6中的async方法的使用和实现原理]]></title>
    <url>%2F%2Fblog%2Fes6-AsyncFuntion.html</url>
    <content type="text"><![CDATA[基本用法AsyncFunction 构造函数 创建一个新的 async function 对象。在JavaScript中，每个异步函数实际上都是一个 AsyncFunction 对象。 async function 关键字可以用来定义一个异步函数表达式。返回一个 Promise它就是 Generator 函数的语法糖。123456789101112131415161718192021222324252627function resolveAfter2Seconds(x) &#123;return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(x); &#125;, 2000);&#125;);&#125;;var add1 = async function(x) &#123;var a = resolveAfter2Seconds(20);var b = resolveAfter2Seconds(30);return x + await a + await b;&#125;add1(10).then(v =&gt; &#123;console.log(v); // prints 60 after 2 seconds.&#125;);var add2 = async function(x) &#123;var a = await resolveAfter2Seconds(20);var b = await resolveAfter2Seconds(30);return x + a + b;&#125;;add2(10).then(v =&gt; &#123;console.log(v); // prints 60 after 4 seconds.&#125;); 语法1234567891011async function [name]([param1[, param2[, ..., paramN]]]) &#123; statements&#125;// 参数// name // 函数名称。 可以省略，以此来声明一个匿名的函数。也是用于本地调用函数体的一个名称// paramN // 传入函数的参数名// statements // 函数体内的语句声明 返回 Promise 对象async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。12345async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v))// "hello world" 描述async function 表达式非常类似于 async function 声明语句，并且几乎拥有等同的语法。他们之间主要的区别在于函数名称，async function表达式可以省略函数名称来创建一个匿名的函数。另见 functions 章节获取更多信息。 async函数对 Generator 函数的改进，体现在以下四点。内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块,而async函数自带执行器，也就是说，async函数的执行，与普通函数一模一样，只要一行。1234567var asyncReadFile = async function () &#123; var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;var result = asyncReadFile(); 更好的语义async和await，比起*和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 返回值是 Promise。async函数的返回值是 Promise对象，这比 Generator函数的返回值是 Iterator对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise 对象，而await命令就是内部then命令的语法糖。1234567891011function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;)&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello wrold', 50); awaitawait 操作符被用于等待由一个async function返回的一个Promise。如果不是，会被转成一个立即resolve的 Promise 对象。 描述await 表达式会造成异步函数停止执行并且等待 promise 的解决，当值被 resolved，异步函数会恢复执行以及返回 resolved 值。如果该值不是一个 promise，它将会被转换成一个 resolved 后的 promise。12345async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。那么整个async函数都会中断执行。1234567async function f() &#123; // await Promise.reject('出错了'); return await Promise.resolve('hello world'); // 不会执行&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 使用注意点 第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。 12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。因为只有getFoo完成以后，才会执行getBar,完全可以让他们同事触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。 正确的写法是采用for循环。 123456789101112131415async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123; await db.post(doc); &#125;);&#125;async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125;&#125;]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷茫中寻求向前走]]></title>
    <url>%2F%2Fblog%2Fhello-world.html</url>
    <content type="text"><![CDATA[混乱先说一个故事最近一直想换工作，但是一直没找满意的，不知道是自己的表达能力有问题，还是自己的能力有问题，还是自己太不自信了。故事开始，我在这个公司开发人员比较少，也没有技术经理什么的，只有一个不怎么懂业务还很善变的项目经理，一个月换一个大方向，用这个项目经理的一句话说就是：“我们就是对付老板的，老板高兴了什么都好说”，所以为了迎合老板，基本上是一个月换一个想法，什么都没做出来，都是做一个demo就断了，然我感觉现在真的不知道到底要做什么，做的这个东西有价值吗？他的价值是相对于公司内部的业务部门，还是说直接就可以卖给别人，现在真的不知道是那个。还有就是一些技术上的不匹配，我真的不懂，难道前端真的就比后端低一头，还是有的人根本就不能明确自己的职责呢。我是做前端，前端的事情应该是我负责，一般怎么解决我比别人要清楚。 哈哈，真的是什么有什么的不好，试着去改变自己，在改变别人，但是如果改变不了，那只能换一个办法再去改变自己，改变别人，如果别人真的接受不了，那还是算了，只能说大家不怎么合适，不做马后炮，不頂雷，信我的自然会全力以赴，不信的也要全力以赴，至少对得起自己，不后悔就行。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6中实现类(class)和类(class)的继承(extends)]]></title>
    <url>%2F%2Fblog%2Fes6-class-extends.html</url>
    <content type="text"><![CDATA[简介extends关键词被用在类声明或者类表达式上，以创建一个类是另一个类的子类。Class 可以通过extends关键字实现继承。 语法1class ChildClass extends ParentClass &#123; ... &#125; 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546//父类class Polygon &#123; // ..and an (optional) custom class constructor. If one is // not supplied, a default constructor is used instead: // constructor() &#123; &#125; // 只能有一个 constructor 不能多次定义、如果没有声明 默认定义 constructor() &#123; &#125; constructor(height, width) &#123; this.name = 'Polygon'; this.height = height; this.width = width; &#125; // Simple class instance methods using short-hand method // declaration sayName() &#123; ChromeSamples.log('Hi, I am a ', this.name + '.'); &#125; sayHistory() &#123; ChromeSamples.log('"Polygon" is derived from the Greek polus (many) ' + 'and gonia (angle).'); &#125; // We will look at static and subclassed methods shortly&#125;class Square extends Polygon &#123; constructor(length) &#123; // 这里把length传参给父类的构造方法 // 作为父类Polygon的宽和高 super(length, length); // 备注：在衍生类中使用this前必须先调用super()方法 // 忽视这一点将会导致一个引用错误 this.name = 'Square'; &#125; get area() &#123; return this.height * this.width; &#125; set area(value) &#123; this.area = value; &#125; &#125;let s = new Square(5);s.sayName();ChromeSamples.log('The area of this square is ' + s.area); 声明一个父类Polygon，constructor(构造函数中)创建了三个属性 name,height,width, Square通过extends关键字,继承了Polygon类中的所有属性和方法。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。检验Square是否继承自Polygon可以通过Object.getPrototypeOf()1Object.getPrototypeOf(Square) === Polygon; // true super关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。 子类的构造函数必须执行一次super函数，代表调用父类的构造函数，不然会报错。 super内部的this指的是Square,相当于Polygon.prototype.constructor.call(this);作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错12345678910111213class Polygon &#123; constructor () &#123; console.log(new.target.name); &#125;&#125;class Square extends Polygon &#123; //super(); // 报错 constructor () &#123; super(); &#125;&#125;new Polygon(); // Polygonnew Square(); // Square super可以作为对象在普通函数中使用，指向父类的原型对象，在静态方法中，指向父类 类的prototype属性和proto属性在JavaScript中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（es6）一些常用array的扩展方法]]></title>
    <url>%2F%2Fblog%2Fes6-Array.html</url>
    <content type="text"><![CDATA[属性Array.lengthlength 属性表示一个无符号 32-bit 整数，返回一个数组中的元素个数。 方法Array.fromArray.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例。 语法123456Array.from(arrayLike[, mapFn[, thisArg]])// 参数// arrayLike 想要转换成真实数组的类数组对象或可遍历对象。// mapFn(可选) 可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。// thisArg(可选) 可选参数，执行 mapFn 函数时 this 的值。// 返回值 返回一个新的Array类型的实例 描述Array.from() 允许你从下面两者来创建数组： 类数组对象（拥有一个 length 属性和若干索引属性的任意对象） 可遍历对象（你可以从它身上迭代出若干个元素的对象，比如有 Map 和 Set 等）Array.from() 方法有一个可选参数 mapFn，让你可以在最后生成的数组上再执行一次 map 方法后再返回。也就是说 Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg), 除非创建的不是可用的中间数组。 这对一些数组的子类,如 typed arrays 来说很重要, 因为中间数组的值在调用 map() 时需要是适当的类型。示例123456789101112131415161718192021222324252627282930313233// Array from a StringArray.from('foo'); // ["f", "o", "o"]// Array from a Setlet s = new Set(['foo', window]); Array.from(s); // ["foo", window]// Array from a Maplet m = new Map([[1, 2], [2, 4], [4, 8]]);Array.from(m); // [[1, 2], [2, 4], [4, 8]]// Array from an Array-like object (arguments)function f() &#123; return Array.from(arguments);&#125;f(1, 2, 3);// [1, 2, 3]//Using arrow functions and Array.from// Using an arrow function as the map function to// manipulate the elementsArray.from([1, 2, 3], x =&gt; x + x); // [2, 4, 6]// Generate a sequence of numbers// Since the array is initialized with `undefined` on each position,// the value of `v` below will be `undefined`Array.from(&#123;length: 5&#125;, (v, i) =&gt; i);// [0, 1, 2, 3, 4] Array.isArray()Array.isArray() 用于确定传递的值是否是一个 Array。 语法123456Array.isArray(obj)// 参数// obj// 需要检测的值。// 返回值// 如果对象是 Array，则为true; 否则为false。 描述如果对象是 Array ，则返回true，否则为false。有关更多详细信息，请参阅文章以绝对精确度确定JavaScript对象是否为数组。 示例1234567891011121314151617// 下面的函数调用都返回 trueArray.isArray([]);Array.isArray([1]);Array.isArray(new Array());// 鲜为人知的事实：其实 Array.prototype 也是一个数组。Array.isArray(Array.prototype); // 下面的函数调用都返回 falseArray.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(17);Array.isArray('Array');Array.isArray(true);Array.isArray(false);Array.isArray(&#123; __proto__: Array.prototype &#125;); 兼容性代码假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。12345if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125; 扩展运算符（spread）扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 Array.of()Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 语法123456// 参数// elementN// 任意个参数，将按顺序成为返回数组中的元素。// 返回值// 新的 Array 实例。Array.of(element0[, element1[, ...[, elementN]]]) 示例1234Array.of(1); // [1]Array.of(1, 2, 3); // [1, 2, 3]Array.of(undefined); // [undefined]Array.of(); // [] 兼容旧环境12345if (!Array.of) &#123; Array.of = function() &#123; return Array.prototype.slice.call(arguments); &#125;;&#125; Array.prototype.concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 语法123456var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])// 参数// valueN// 需要与原数组合并的数组或非数组值。详见下文。// 返回值// 新的 Array 实例。 描述concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里.示例12345678910111213// 两个数组合并为一个新数组var alpha = ["a", "b", "c"];var numeric = [1, 2, 3];var three = [4, 5, 6];// 组成新数组 ["a", "b", "c", 1, 2, 3]; 原数组 alpha 和 numeric 未被修改var alphaNumeric = alpha.concat(numeric);// 组成新数组["a", "b", "c", 1, 2, 3, 4, 5, 6]; 原数组 num1, num2, num3 未被修改var nums = num1.concat(num2, num3);// 多个数组和多个非数组值合并为一个新数组// 组成新数组 ["a", "b", "c", 1, 2, 3], 原alpha数组未被修改var alphaNumeric1 = alpha.concat(1, [2, 3]); Array.prototype.copyWithin()copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。 语法12345678910111213141516arr.copyWithin(target)arr.copyWithin(target, start)arr.copyWithin(target, start, end)arr.copyWithin(目标索引, [源开始索引], [结束源索引])// 参数// target// 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。// start// 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。 如果 start 被忽略，copyWithin 将会从0开始复制。// end// 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。 如果 end 被忽略，copyWithin 将会复制到 arr.length。// 返回值// 改变了的数组。 描述参数target,start和end 必须为整数。如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。copyWithin方法不要求其this值必须是一个数组对象；除此之外，copyWithin是一个可变方法，它可以改变this对象本身，并且返回它，而不仅仅是它的拷贝。copyWithin 就像 C 和 C++ 的 memcpy 函数一样，且它是用来移动 Array 或者 TypedArray 数据的一个高性能的方法。复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。copyWithin 函数是设计为通用的，其不要求其 this 值必须是一个数组对象。The copyWithin 是一个可变方法，它不会改变 this 的 length，但是会改变 this 本身的内容，且需要时会创建新的属性。 例子123456789101112131415161718192021222324[1, 2, 3, 4, 5].copyWithin(-2);// [1, 2, 3, 1, 2][1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4);// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(-2, -3, -1);// [1, 2, 3, 3, 4][].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3);// &#123;0: 1, 3: 1, length: 5&#125;// ES2015 Typed Arrays are subclasses of Arrayvar i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// On platforms that are not yet ES2015 compliant: [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] Array.prototype.entries()、Array.prototype.keys()、Array.prototype.values() 遍历数组ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。 keys() 方法返回一个新的Array迭代器，它包含数组中每个索引的键。 values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。12345678910111213141516171819202122232425262728293031323334for (let index of ['a', 'b'].keys()) &#123; console.log(index); &#125; // 0 // 1 for (let elem of ['a', 'b'].values()) &#123; console.log(elem); &#125; // 'a' // 'b' for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem); &#125; // 0 "a" // 1 "b" let arr = ['w', 'y', 'k', 'o', 'p']; let eArr = arr.values(); // 您的浏览器必须支持 for..of 循环 // 以及 let —— 将变量作用域限定在 for 循环中 for (let letter of eArr) &#123; console.log(letter); &#125; // 另一种 迭代方式 let arr = ['w', 'y', 'k', 'o', 'p']; let eArr = arr.values(); console.log(eArr.next().value); // w console.log(eArr.next().value); // y console.log(eArr.next().value); // k console.log(eArr.next().value); // o console.log(eArr.next().value); // p 可以通过 for…of来循环数组 转换方法在javascript中所有的对象都具有 toLocaleString()、toString()、valueOf()方法。 语法123456var colors = ['red', 'blue', 'green'];console.log(colors.toString()); // red,blue,greenconsole.log(colors.valueOf()); // [red,blue,green]console.log(colors.toLocaleString()); // red,blue,greenconsole.log(colors.join(',')); // red,blue,green// 在默认情况下都会以逗号分隔的字符串的形式返回数组项 描述如果数组中的某一项的值是null或者undefined,那么该只在join()、toLocaleString()、toString()、valueOf()方法返回的结果中以空字符串表示 重排序方法reverse() 方法会反转数组项的顺序。 sort()方法按升序排列数组项 语法123456789101112131415161718// reverse() 数组反转var values = [1, 3, 4, 5, 6, 7, 8];values.reverse();console.log(values); // [8, 7, 6, 5, 4, 3, 1]//sort() 排序function compare(value1, value2) &#123; if (value1 &gt; value2) &#123; return 1; &#125; else if (value1 &lt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;var values1 = ['2', 4, 1, 3, 5, 2, 4, 65, 2];values1.sort(compare);console.log(values1); // [1, "2", 2, 2, 3, 4, 4, 5, 65]]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios中1px border解决方法]]></title>
    <url>%2F%2Fblog%2Fios-bug-border.html</url>
    <content type="text"><![CDATA[问题描述1、引入flexible方案可通过 手淘的 flexible方案来解决这个问题 flexible的原理讲解和使用 http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html flexible 库地址：https://github.com/amfe/lib-flexible 基本原理在devicePixelRatio = 2 时，输出viewport1&lt;meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"&gt; 在devicePixelRatio = 3 时，输出viewport1&lt;meta name="viewport" content="initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no"&gt; 同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。 2、 transform: scale(0.5)使用css3的transfrom的scale属性123456789101112131415.weui-btn:after &#123; content: " "; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid rgba(0, 0, 0, 0.2); -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0; box-sizing: border-box; border-radius: 10px;&#125; 可参考微信的 web ui中的解决方案参考地址 https://weui.io/#button 可用图片实现代替边框不建议使用]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[retina屏高清屏的具体原理]]></title>
    <url>%2F%2Fblog%2Fios-bug-retina.html</url>
    <content type="text"><![CDATA[概述随着2012年苹果发布第一款Retina Macbook Pro（以下简称RMBP），Retina屏幕开始进入笔记本行业。两年过去了，RMBP的市场占有率越来越高，且获得了一大批设计师朋友的青睐，网站对于Retina屏幕的适配也变成了迫在眉睫的问题。 1、一种具有备超高像素密度的液晶屏 2、同样大小的屏幕上显示的像素点由1个变为多个在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。 物理像素（physical pixel）物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。 设备独立像素(density-independent pixel)设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。 屏幕密度屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。 设备像素比(device pixel ratio)设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到： 设备像素比 ＝ 物理像素 / 设备独立像素在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。而在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。 devicePixelRatio在大多数浏览器是值得信赖的。 在iOS设备，screen.width乘以devicePixelRatio得到的是物理像素值。 在Android以及Windows Phone设备，screen.width除以devicePixelRatio得到的是设备独立像素(dips)值。解决方法通过判断 devicePixelRatio 的值来加载不同尺寸的图片 针对普通显示屏(devicePixelRatio = 1.0、1.3)，加载一张1倍的图片 针对高清显示屏(devicePixelRatio &gt;= 1.5、2.0、3.0)，加载一张2倍大的图片dpr为3的手机比较小，建议用两倍的图片Media Queries判断当前的dpr通过媒体查询结合devicePixelRatio可以区分普通的显示屏和高清显示屏，兼容行比较好12345678910111213.css&#123;/* 普通显示屏(设备像素比例小于等于1.3)使用1倍的图 */ background-image: url(img_1x.png);&#125;@media only screen and (-webkit-min-device-pixel-ratio:1.5)&#123;.css&#123;/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图 */ background-image: url(img_2x.png); &#125;&#125;@media only screen and (-webkit-min-device-pixel-ratio:3)&#123;.css&#123;/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图 */ background-image: url(img_2x.png); &#125;&#125; image-set 设计retina背景图image-set，它是Webkit的私有属性，也是Css4的一个属性。目前支持苹果的 retina 显示屏和部分android 显示屏1234567.css&#123; background: url(../img/bank_ico.png) no-repeat;/* 不支持image-set的显示屏 */ background: -webkit-image-set( url(../img/bank_ico.png) 1x,/* 支持image-set的浏览器的[普通屏幕]下 */ url(../img/bank_ico_retina.png) 2x);/* 支持image-set的浏览器的[Retina屏幕] */ &#125; 本文参考: http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html © w3cplus.com参考：http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/参考：http://www.cnblogs.com/PeunZhang/p/3441110.html]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6中 class（类）的用法]]></title>
    <url>%2F%2Fblog%2Fjavascript-oop.html</url>
    <content type="text"><![CDATA[简介javascript是一种基于对象的语言，你遇到的所有东西几乎都是对象。但是,它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class(类)。es6 中新提出了类（Class）概念，JavaScript中的类只是JavaScript中的类只是JavaScript现有基于原型的继承的一种语法包装（语法糖）,他能让我们用建明的语法实现继承。 基本语法声明一个 Person “类”，它内部有一个constructor方法，这个就是构造方法，而this关键字则代表实例对象。使用new关键子创建，是跟构造函数的用法完全一致。构造函数和普通的JavaScript中的构造函数是一个样的。123456789101112// 声明类class Person&#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; getPerson() &#123; return '名字：' + this.name + '年龄：' + this.age; &#125;&#125;var oObj = new Person('小明', 20);oObj.getPerson();// "名字：小名年龄：20" 实例使用构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546//父类class Polygon &#123;// ..and an (optional) custom class constructor. If one is // not supplied, a default constructor is used instead:// constructor() &#123; &#125;// 只能有一个 constructor 不能多次定义、如果没有声明 默认定义 constructor() &#123; &#125;constructor(height, width) &#123; this.name = 'Polygon'; this.height = height; this.width = width;&#125;// Simple class instance methods using short-hand method// declarationsayName() &#123; ChromeSamples.log('Hi, I am a ', this.name + '.');&#125;sayHistory() &#123; ChromeSamples.log('"Polygon" is derived from the Greek polus (many) ' + 'and gonia (angle).');&#125;// We will look at static and subclassed methods shortly&#125;class Square extends Polygon &#123; constructor(length) &#123; // 这里把length传参给父类的构造方法 // 作为父类Polygon的宽和高 super(length, length); // 备注：在衍生类中使用this前必须先调用super()方法 // 忽视这一点将会导致一个引用错误 this.name = 'Square'; &#125; get area() &#123; return this.height * this.width; &#125; set area(value) &#123; this.area = value; &#125; &#125;let s = new Square(5);s.sayName();ChromeSamples.log('The area of this square is ' + s.area); 构造函数的prototype(原型)属性，类的所有方法都定义在类的prototype属性上面。123class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 子类的使用可以通过 extends关键字来实现继承 constructor 方法一个类必须有constructor方法,默认添加。默认返回this（实例对象），也可指定别的对象。类必须使用new调用，否则会报错。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without 'new' 类的实例对象类的所有实例共享一个原型对象。通过实例的proto属性为“类”添加方法。12345678910var oObj = new Person('小明', 20);var oObj1 = new Person('小明', 20);oObj.__proto__ === oObj1.__proto__; // trueoObj.__proto__.des = function () &#123; return '学习';&#125;oObj.des(); // 学习oObj1.des(); // 学习var oObj2 = new Preson('小红', 18);oObj2.des(); // 学习 extendsextends关键词被用在类声明或者类表达式上，以创建一个类是另一个类的子类。 描述extends关键词用来创建一个普通类或者内建对象的子类。扩展的.prototype必须是一个Object 或者 null。 使用extends12345678910111213141516171819202122232425262728293031323334353637383940414243444546//父类class Polygon &#123;// ..and an (optional) custom class constructor. If one is // not supplied, a default constructor is used instead:// constructor() &#123; &#125;// 只能有一个 constructor 不能多次定义、如果没有声明 默认定义 constructor() &#123; &#125;constructor(height, width) &#123; this.name = 'Polygon'; this.height = height; this.width = width;&#125;// Simple class instance methods using short-hand method// declarationsayName() &#123; ChromeSamples.log('Hi, I am a ', this.name + '.');&#125;sayHistory() &#123; ChromeSamples.log('"Polygon" is derived from the Greek polus (many) ' + 'and gonia (angle).');&#125;// We will look at static and subclassed methods shortly&#125;class Square extends Polygon &#123; constructor(length) &#123; // 这里把length传参给父类的构造方法 // 作为父类Polygon的宽和高 super(length, length); // 备注：在衍生类中使用this前必须先调用super()方法 // 忽视这一点将会导致一个引用错误 this.name = 'Square'; &#125; get area() &#123; return this.height * this.width; &#125; set area(value) &#123; this.area = value; &#125; &#125;let s = new Square(5);s.sayName();ChromeSamples.log('The area of this square is ' + s.area); 使用extends扩展内建对象这个示例继承了Date 对象。 你可以从实战演示看到这个例子。12345678910class myDate extends Date &#123; constructor() &#123; super(); &#125; getFormattedDate() &#123; var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']; return this.getDate() + "-" + months[this.getMonth()] + "-" + this.getFullYear(); &#125;&#125; 扩展 null可以像扩展普通类一样扩展null，但是新对象的原型将不会继承 Object.prototype.12345class nullExtends extends null &#123;constructor() &#123;&#125;&#125;Object.getPrototypeOf(nullExtends); // Function.prototypeObject.getPrototypeOf(nullExtends.prototype) // null 注意事项class表达式1234567891011let person = new class &#123;constructor(name) &#123; this.name = name;&#125;sayName() &#123; console.log(this.name);&#125;&#125;('张三');person.sayName(); // "张三" 不存在变量提升12new Foo(); // ReferenceErrorclass Foo &#123;&#125; class的取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' Class的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a functionclass Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。父类的静态方法，可以被子类继承。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS下的 Fixed + Input BUG现象]]></title>
    <url>%2F%2Fblog%2Fios-bug.html</url>
    <content type="text"><![CDATA[iOS下的 Fixed + Input BUG现象问题复现让我们先举个例子，最直观的说明一个在ios中input + fixed布局，可能使用如下布局转载 http://efe.baidu.com/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt;header, footer, main &#123; display: block;&#125;header &#123; position: fixed; height: 50px; left: 0; right: 0; top: 0;&#125;footer &#123; position: fixed; height: 34px; left: 0; right: 0; bottom: 0;&#125;main &#123; margin-top: 50px; margin-bottom: 34px; height: 2000px&#125;&lt;/style&gt;&lt;body class="layout-fixed"&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header&gt; &lt;/header&gt; &lt;!-- 可以滚动的区域 --&gt; &lt;main&gt; &lt;!-- 内容在这里... --&gt; &lt;/main&gt; &lt;!-- fixed定位的底部 --&gt; &lt;footer&gt; &lt;input type="text" placeholder="Footer..."/&gt; &lt;button class="submit"&gt;提交&lt;/button&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 然后看起来就是下面这个样子。拖动页面时 header 和 footer 已经定位在了对应的位置，目测没问题了。但接下来问题就来了！如果底部输入框软键盘被唤起以后，再次滑动页面，就会看到如下图所示： 软键盘唤起后，页面的 fixed 元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。这就是ios上fixed元素和输入框的bug,其中不仅陷入于type=”text”的输入框，凡是软键盘（比如时间选择器、select选择等等）被唤起，都会遇到同样的问题。 解决思路虽然 isScroll.js 可以很好的解决 fixed 定位滚动的问题，但是不在万不得已的情况下，我们尽量尝试一下不依赖第三方库的布局方案，以简化实现方式。这里抛砖引玉作为参考。 即使在ios下由于软键盘唤出后，页面fixed元素会失效，导致跟随页面一起滚动，那么页面不会过长出现滚动，那么即便fixed元素失效，也无法跟随页面滚动，也不会出现上面的问题了，其实就是内部滚动12345678910111213141516171819&lt;body class="layout-scroll-fixed"&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header&gt; &lt;/header&gt; &lt;!-- 可以滚动的区域 --&gt; &lt;main&gt; &lt;div class="content"&gt; &lt;!-- 内容在这里... --&gt; &lt;/div&gt; &lt;/main&gt; &lt;!-- fixed定位的底部 --&gt; &lt;footer&gt; &lt;input type="text" placeholder="Footer..."/&gt; &lt;button class="submit"&gt;提交&lt;/button&gt; &lt;/footer&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132header, footer, main &#123; display: block;&#125;header &#123; position: fixed; height: 50px; left: 0; right: 0; top: 0;&#125;footer &#123; position: fixed; height: 34px; left: 0; right: 0; bottom: 0;&#125;main &#123; /* main绝对定位，进行内部滚动 */ position: absolute; top: 50px; bottom: 34px; /* 使之可以滚动 */ overflow-y: scroll;&#125;main .content &#123; height: 2000px;&#125; 在原始输入法下， fixed 元素可以定位在页面的正确位置。滚动页面时，由于滚动的是 main 内部的 div，因此 footer 没有跟随页面滚动。 上面貌似解决了问题，但是如果在手机上实际测试一下，会发现 main 元素内的滚动非常不流畅，滑动的手指松开后，滚动立刻停止，失去了原本的流畅滚动特性。百度一下弹性滚动的问题，发现在 webkit 中，下面的属性可以恢复弹性滚动。1-webkit-overflow-scrolling: touch; 在 main 元素上加上该属性，嗯，丝般顺滑的感觉又回来了！12345678910main &#123; /* main绝对定位，进行内部滚动 */ position: absolute; top: 50px; bottom: 34px; /* 使之可以滚动 */ overflow-y: scroll; /* 增加该属性，可以增加弹性 */ -webkit-overflow-scrolling: touch;&#125; 另外，这里的 header 和 footer 使用的是 fixed 定位，如果考虑到更老一些的 iOS 系统不支持 fixed 元素，完全可以把 fixed 替换成 absolute 。测试后效果是一样的。 至此一个不依赖第三方库的 fixed 布局就完成了。 Android 下布局谈到了 iOS ，也来简单说一下 Android 下的布局吧。 在 Android2.3+ 中，因为不支持 overflow-scrolling ，因此部分浏览器内滚动会有不流畅的卡顿。但是目前发现在 body 上的滚动还是很流畅的，因此使用第一种在 iOS 出现问题的 fixed 定位的布局就可以了。 如果需要考虑 Android2.3 以下系统，因为不支持 fixed 元素，所以依然要需要考虑使用 isScroll.js 来实现内部滚动。 其实在 fixed 和输入框的问题上，基本思路就是： &gt; 由于 fixed 在软键盘唤起后会失效，导致在页面可以滚动时，会跟随页面一起滚动。因此如果页面无法滚动，那么 fixed 元素即使失效，也不会滚动，也就不会出现 bug 了。 所以可以在这个方面去考虑解决问题。 其他的一些细节处理在细节处理上，其实还有很多要注意的，挑几个实际遇到比较大的问题来说一下： 有时候输入框 focus 以后，会出现软键盘遮挡输入框的情况，这时候可以尝试 input 元素的 scrollIntoView 进行修复。在 iOS 下使用第三方输入法时，输入法在唤起经常会盖住输入框，只有在输入了一条文字后，输入框才会浮出。目前也不知道有什么好的办法能让唤起输入框时正确显示。这暂时算是 iOS 下的一个坑吧。有些第三方浏览器底部的工具栏是浮在页面之上的，因此底部 fixed 定位会被工具栏遮挡。解决办法也比较简单粗暴——适配不同的浏览器，调整 fixed 元素距离底部的距离。最好将 header 和 footer 元素的 touchmove 事件禁止，以防止滚动在上面触发了部分浏览器全屏模式切换，而导致顶部地址栏和底部工具栏遮挡住 header 和 footer 元素。在页面滚动到上下边缘的时候，如果继续拖拽会将整个 View 一起拖拽走，导致页面的“露底”。为了防止页面露底，可以在页面拖拽到边缘的时候，通过判断拖拽方向以及是否为边缘来阻止 touchmove 事件，防止页面继续拖拽。 以上面内滚动 layout-scroll-fixed 布局为例，给出一段代码作为参考：12345678910111213141516171819202122232425262728293031323334// 防止内容区域滚到底后引起页面整体的滚动var content = document.querySelector('main');var startY;content.addEventListener('touchstart', function (e) &#123; startY = e.touches[0].clientY;&#125;);content.addEventListener('touchmove', function (e) &#123; // 高位表示向上滚动 // 底位表示向下滚动 // 1容许 0禁止 var status = '11'; var ele = this; var currentY = e.touches[0].clientY; if (ele.scrollTop === 0) &#123; // 如果内容小于容器则同时禁止上下滚动 status = ele.offsetHeight &gt;= ele.scrollHeight ? '00' : '01'; &#125; else if (ele.scrollTop + ele.offsetHeight &gt;= ele.scrollHeight) &#123; // 已经滚到底部了只能向上滚动 status = '10'; &#125; if (status != '11') &#123; // 判断当前的滚动方向 var direction = currentY - startY &gt; 0 ? '10' : '01'; // 操作方向和当前允许状态求与运算，运算结果为0，就说明不允许该方向滚动，则禁止默认事件，阻止滚动 if (!(parseInt(status, 2) &amp; parseInt(direction, 2))) &#123; stopEvent(e); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的改变 上下文(this)的方法 bind、call、apply(未完待续)]]></title>
    <url>%2F%2Fblog%2FCall-Apply-Bind.html</url>
    <content type="text"><![CDATA[概述apply()方法吊用一个函数，其具有一种个指定的this值， 以及作为一个数组（或类似数组的对象）提供的参数。call()方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干个参数列表，而apply()方法接受的是一个包含多个参数的数组bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 语法1fun.apply(thisArg, [argsArray]) 参数thisArg在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象 argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 描述在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表（原文：a named set of parameters）。apply 可以使用数组字面量（array literal），如 fun.apply(this, [‘eat’, ‘bananas’])，或数组对象， 如 fun.apply(this, new Array(‘eat’, ‘bananas’))。 你也可以使用 arguments 对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和[0…length) 范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {‘length’: 2, ‘0’: ‘eat’, ‘1’: ‘bananas’} 形式的对象。 需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。 实例使用apply来链接构造器]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的this指向问题]]></title>
    <url>%2F%2Fblog%2Fjs-this.html</url>
    <content type="text"><![CDATA[概述 首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象,那么接下来我会深入的探讨这个问题。 在一般函数方法中使用 this 指代全局对象12345678var ale = '外部';function test() &#123; var ale = '内部'; console.log(this.ale); // 外部 console.log(this); // window&#125;test(); // 因为在全局中执行，所以this指向window// window.a(); 与上面其实是一致的 作为对象方法调用，this纸袋上级对象123456789var ale = '外部'var oObeject = &#123; ale: '内部', fn: function () &#123; console.log(this.ale); // 内部 console.log(this); // oObeject &#125;&#125;oObeject.fn(); 这里的this指向oObeject,因为这个fn是通过oObeject调用的,所以指向oObeject,this在函数创建的时候是决定不了的,在调用的时候才能决定，谁调用this指像谁 作为构造函数调用，this 指代new 出的对象123456789var ale = '外部'function Test () &#123; this.ale = '内部'; console.log(this.ale); // 内部 console.log(this); // Test return this; // 默认 return 当前this&#125;var test1 = new Test();console.log(test1.ale); // 内部 new关键字可以改变this的指向,将这个this指向对象test1,此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象test1，那么this指向的自然是对象test1 当函数中有return时1234567function fn() &#123; this.user = '内部'; return &#123;&#125;; // 因为返回的是空对象像 or return function () &#123;&#125;&#125;var a = new fn; console.log(a.user); //undefinedconsole.log(a); // Object &#123;&#125; 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。1234567function fn() &#123; this.user = '内部'; return 1; // 因为返回的是空对象像 or return undefined&#125;var a = new fn; console.log(a.user); //undefinedconsole.log(a); // Object &#123;user&#125; 需要注意的是 还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 apply、call、bind改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this指代第一个参数1234567891011var x = '外部';function test() &#123; console.log(this.x);&#125;var o = &#123; x: '内部', m: test&#125;o.m.apply(); // 外部//apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为o.m.apply(o); // 内部]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[constructor的作用]]></title>
    <url>%2F%2Fblog%2Fconstructor-1.html</url>
    <content type="text"><![CDATA[概述所有对象都有一个 constructor属性。在不明确使用构造函数（即对象和数组文字）的情况下创建的对象将具有constructor指向该对象的基础对象构造函数类型的属性。12345678910var o = [];o.constructor === Object; // truevar o = new Object;o.constructor === Object; // truevar a = [];a.constructor === Array; // truevar a = new Array;a.constructor === Array // truevar n = new Number(3);n.constructor === Number; // true 例子显示对象的构造函数以下示例创建一个原型，Tree以及该类型的对象theTree。该示例然后显示constructor该对象的属性theTree。12345678function Tree(name)&#123; this.name = name;&#125;var theTree = new Tree('Redwood');console.log('theTree.constructor is' + theTree.constructor);//theTree.constructor is function Tree(name) &#123;// this.name = name;//&#125; 更改对象的构造函数以下示例显示如何修改泛型对象的构造函数值。只有true，1并且”test” 不会受到影响，因为他们有只读的本地构造函数。这个例子表明，依靠constructor对象的属性并不总是安全的。12345678910111213141516171819202122232425262728function Type () &#123;&#125;var types = [ new Array(), [], new Boolean(), true, // remains unchanged new Date(), new Error(), new Function(), function () &#123;&#125;, Math, new Number(), 1, // remains unchanged new Object(), &#123;&#125;, new RegExp(), /(?:)/, new String(), 'test' // remains unchanged];for (var i = 0; i &lt; types.length; i++) &#123; types[i].constructor = Type; types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()];&#125;console.log(types.join('\n')); 此示例显示以下输出：12345678910111213141516171819202122232425function Type() &#123;&#125;,false,function Type() &#123;&#125;,false,function Type() &#123;&#125;,false,falsefunction Boolean() &#123; [native code]&#125;,false,truefunction Type() &#123;&#125;,false,Mon Sep 01 2014 16:03:49 GMT+0600function Type() &#123;&#125;,false,Errorfunction Type() &#123;&#125;,false,function anonymous() &#123;&#125;function Type() &#123;&#125;,false,function () &#123;&#125;function Type() &#123;&#125;,false,[object Math]function Type() &#123;&#125;,false,0function Number() &#123; [native code]&#125;,false,1function Type() &#123;&#125;,false,[object Object]function Type() &#123;&#125;,false,[object Object]function Type() &#123;&#125;,false,/(?:)/function Type() &#123;&#125;,false,/(?:)/function Type() &#123;&#125;,false,function String() &#123; [native code]&#125;,false,test]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js继承实现]]></title>
    <url>%2F%2Fblog%2Fextends-1.html</url>
    <content type="text"><![CDATA[创建js样例： 12345678910111213141516171819/** 约定*/function Fun()&#123; // 私有属性 var val = 1; // 私有基本属性 var arr = [1]; // 私有引用属性 function fun()&#123;&#125; // 私有函数（引用属性） // 实例属性 this.val = 1; // 实例基本属性 this.arr = [1]; // 实例引用属性 this.fun = function()&#123;&#125;; // 实例函数（引用属性）&#125;// 原型属性Fun.prototype.val = 1; // 原型基本属性Fun.prototype.arr = [1]; // 原型引用属性Fun.prototype.fun = function()&#123;&#125;; // 原型函数（引用属性） 这样创建比较合理 原型链继承 这是实现继承最简单的方式，核心就是一句话 实例 1234567891011121314151617function Super () &#123; this.val = 1; this.arr = [1];&#125;function Sub () &#123;&#125;Sub.prototype = new Super(); // 核心var sub1 = new Sub();var sub2 = new Sub();sub1.val = 2;sub1.arr.push(2);console.log(sub1.val); // 2 基本类型 不共享console.log(sub2.val); // 1console.log(sub1.arr); // [1, 2] 引用 array类型 共享console.log(sub2.arr); // [1, 2] 核心 拿父类实例充当子类原型对象 优缺点优点: 简单，易于实现 缺点： 修改sub1.arr后sub2.arr也变了，因为来自原型对象的引用树形是所有实例共享的。 执行顺序：执行sub1.arr.push(2);先对sub1进行属性查找，找遍了实例属性（在本例中没有实例属性），没找到，就开始顺着原型链向上找，拿到了sub1的原型对象，一搜身，发现有arr属性。于是给arr末尾插入了2，所以sub2.arr也变了 创建子类实例时，无法向父类构造函数传参 借用构造函数 简单原型链真够简单，可是存在2个致命缺点简直不能用，于是上个世纪末的jsers就想办法fix这2个缺陷，然后出现了借用构造函数方式 实例 12345678910111213141516171819function Super(val) &#123; this.val = val; this.arr = [1]; this.fun = function () &#123; console.log(this.val); &#125;&#125;function Sub(val) &#123; Super.call(this, val); // 核心&#125;var sub1 = new Sub(1);var sub2 = new Sub(2);sub1.arr.push(2);console.log(sub1.val); // 1console.log(sub2.val); // 2console.log(sub1.arr); // [1, 2]console.log(sub2.arr); // [1]console.log(sub1.fun === sub2.fun) // false 核心 借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型） 优缺点优点 解决了子类实例共享父类引用属性的问题 创建子类实例时，可以向父类构造函数传参 缺点 无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能 组合继承（常用） 目前我们的借用构造函数方式还是有问题（无法实现函数复用），没关系，接着修复，jsers吭哧吭哧又搞出了组合继承 实例 123456789101112131415161718function Super()&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype = new Super(); // 核心 var sub1 = new Sub(1);var sub2 = new Sub(2);console.log(sub1.fun === sub2.fun); // true 核心 &lt;font color=”red&gt;把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Sub.prototype = new Super();继承父类函数，实现函数复用 优缺点优点 不存在引用属性共享问题 可传参 函数可复用 缺点 子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的 寄生组合继承（最佳方式） 从名字就能看出又是对组合继承的优化 实例 1234567891011121314151617181920212223242526272829303132333435363738function beget(obj)&#123; // 生孩子函数 beget：龙beget龙，凤beget凤。 var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;var proto = beget(Super.prototype); // 核心console.log(proto); // F &#123;&#125;console.log(proto.constructor); // function Super()&#123; // 只在此处声明基本属性和引用属性 // this.val = 1; // this.arr = [1];// &#125;proto.constructor = Sub; // 核心console.log(proto.constructor);// function Sub()&#123; // Super.call(this); // 核心 // ...// &#125;Sub.prototype = proto; // 核心console.log(Sub.prototype);// Super &#123;constructor: function&#125;var sub = new Sub();console.log(sub.val);console.log(sub.arr); construcotr可参考： 核心 用beget(Super.prototype);&lt;font color=”red&gt;切掉了原型对象上多余的那份父类实例属性 寄生组合式继承，这名字不是很贴切，和寄生式继承关系并不是特别大 原型式 其实介绍完上面的完美方案就可以结束了，但从组合继承到完美方案好像有一段不小的思维跳跃，有必要把故事说清楚 实例 12345678910111213141516171819202122function beget(obj)&#123; // return 一个新的 function 原型复制为参数原型 var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; this.val = 1; this.arr = [1];&#125; // 拿到父类对象var sup = new Super();// 生孩子var sub = beget(sup); // 核心// 增强sub.attr1 = 1;sub.attr2 = 2;//sub.attr3... console.log(sub.val); // 1console.log(sub.arr); // 1console.log(sub.attr1); // 1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值（es6）(未完待续)]]></title>
    <url>%2F%2Fblog%2Fes6-2.html</url>
    <content type="text"><![CDATA[解构赋值 语法是一个Javascript表达式，这使得可以将值从数组或属性从对象提取到不同的变量中。 语法1234567891011121314151617181920let a, b, rest;/* array 解构赋值 */[a, b] = [1, 2]console.log(a); // 1console.log(b); // 2[a, b, ...rest] = [1, 2, 3, 4, 5];console.log(a); // 1console.log(b); // 2console.log(rest); // 3, 4, 5/* object 解构赋值 */(&#123;a, b&#125; = &#123;a:1, b:2&#125;);console.log(a); // 1console.log(b); // 2// ES7 - 试验性 (尚未标准化)// Uncaught SyntaxError: Unexpected token ...(&#123;a, b, ...rest&#125; = &#123;a:1, b:2, c:3, d:4&#125;); 剩余元素必须是解构赋值表达式中的最后一个元素 简述 对象字面量和数组字面量提供了一种简单的定义一个特定的数据组的方法。 1var x = [1, 2, 3, 4, 5]; 结构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。 1234var x = [1, 2, 3, 4, 5];var [y, z] = x;console.log(y) // 1console.log(z) // 2 解构赋值的作用类似于perl和Python语言中的相似特性。 解构数组基本变量赋值 12345var foo = ["one", "two", "three"];var [one, two, three] = foo;console.log(one); // "one"console.log(two); // "two"console.log(three); // "three" 声明赋值分离 通过解构分离变量的声明，可以为一个变量赋值 1234var a, b;[a, b] = [1, 2];console.log(a); // 1console.log(b); // 2 默认值 为了防止从数组中去一个值为undefined的对象，可以为这个对象设置默认值 1234var a, b;[a=5, b=7] = [1];console.log(a); // 1console.log(b); // 7 交换变量 在一个解构表达式中可以交换两个变量的值。 没有解构值情况下，交换两个变量需要一个临时变量 12345var a = 1;var b = 3;[a, b] = [b, a];console.log(a); // 3console.log(b); // 1 解析一个从函数返回的数组 从一个函数返回一个数组是十分常见的情况.。解构使得处理返回值为数组时更加方便。 在下面例子中，[1, 2] 作为函数的 f() 的输出值，可以使用解构用一句话完成解析。 1234567function f() &#123; return [1, 2];&#125;var a, b;[a, b] = f();console.log(a); // 1console.log(b); // 2 感谢解构赋值，函数现在可以返回多个值了。尽管函数一直都可以返回一个数组，但现在这样做有更多的灵活性。 忽略某些返回值 你也可以忽略你不感兴趣的返回值： 123456function f() &#123; return [1, 2, 3];&#125;var [a, , b] = f();console.log(a); // 1console.log(b); // 3 你也可以忽略全部返回值。例如： 1[,,] = f(); 将剩余数组赋值给一个变量 当解构一个数组时，可以使用剩余模式，将数组剩余部分赋值给一个变量。 123var [a, ...b] = [1, 2, 3];console.log(a); // 1console.log(b); // [2, 3] 注意：如果剩余元素右侧有一个逗号，会抛出语法错误的异常，因为剩余元素必须是数组的最后一个元素。 12var [a, ...b,] = [1, 2, 3];// SyntaxError: rest element may not have a trailing comma 解构对象简单示例 12345678var o = &#123;p: 42, q: true&#125;;var &#123;p, q&#125; = o;console.log(p); // 42console.log(q); // true // 用新变量名赋值var &#123;p: foo, q: bar&#125; = o;console.log(foo); // 42console.log(bar); // true]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架选型]]></title>
    <url>%2F%2Fblog%2FFrame-selection.html</url>
    <content type="text"><![CDATA[框架和库 库(lib)具有一下三个特点： 1、是针对特定问题的解答，具有专业性 2、你控制应用的流程 3、被动的被调用 框架(framework)具有以下三个特点： 1、具有控制反转(inverse of control)的功能 2、决定应用程序的声明周期 3、一般来说,集成了大量的库 如下图所示，框架会在特定的时间要求程序执行某段代码。框架决定了什么时候调用库，决定了什么时候要求代码去执行特定功能 而实际上，一个库有事也可以称之为框架，而库里面继承的方法称之为库 框架和库的区别不是由实际大小决定，而是有思考角度来决定。框架和库世界上可以统称为解决方案 解决方案 前端开发中的解决方案主要用于解决以下7各方面的问题： 1、DOM 2、Communication(通信) 3、Utililty(工具库) 4、Templating(模版集成) 5、Component(组件) 6、Routing(router路由) 7、architecture(架构) 为什么使用外部的解决方案 1、提高开发效率 2、可靠性高(浏览器兼容性，测试覆盖) 3、配备优良，如文档、demo及工具等 4、代码设计合理、更优雅 5、专业性高 如果问题过于简单，或者备选框架的质量和可靠性无法保证，再或者无法满足业务需求，则不应该选择外部的框架。如果团队中已经有相关的累积，就更不需要使用了 一般地，解决方案要实际开发中有以下3种使用方式： 1、开放式：基于外部模块系统，并自由组合 2、半开放式：基于一个定制的模块系统，内部外部解决方案共存 3、封闭式：深度定制的模块系统，很少需要引入外部模块 DOM 接下来，将针对解决方案中提到的7个问题进行分别介绍，首先是DOM 关于DOM，主要包括Selector(选择器)、Manipulation(DOM操作)、Event(事件)、Animation(动画)这四个部分 DOM相关的解决方案主要用于提供以下操作 1、提供便利的 DOM 查询、操作、移动等操作 2、提供事件绑定及事件代理支持 3、提供浏览器特性检测及 UserAgent 侦测 4、提供节点属性、样式、类名的操作 5、保证目标平台的跨浏览器支持 【常用方案】常用的DOM解决方案有 jQuery、zepto.JS、MOOTOO.JS等 jQuery是曾经风靡一时的最流行的前端解决方案，jQuery特有的链式调用的方式简化了javascript的复杂操作，而且使人们不再需要关心兼容性，并提供了大量的实用方法 zepto是jQuery的精简版，针对移动端去除了大量jQuery的兼容代码，提供了简单的手势，部分API的实现方式不同 mootools源码清晰易懂，严格遵循Command-Query(命令-查询)的接口规范，没有诸如jQuery的两义性接口。还有一个不得不提的特点是，使用选择器获取的是DOM原生对象，而不是被包装过的对象。而它支持的诸多方法则是通过直接扩展DOM原生对象实现的，这也是它的争议所在 相比较而言，最稳妥的DOM解决方案是jQuery 【专业领域】 上面的解决方案用于解决DOM一般的通用问题。随着技术的发展，DOM的专业领域出现一些小而精致的解决方案 1、手势 Hammer.JS包括了常见手势封装（Tab、Hold、Transform、Swifp）并支持自定义扩展 2、局部滚动 iscroll.JS是移动端position:fix + overflow:scroll的救星 3、高级动画 Velocity.JS可以复杂动画序列实现，不仅局限于 DOM 4、视频播放 Video.JS类似原生 video 标签的使用方式，对低级浏览器使用 flash 播放器 通信 关于通信，主要包括XMLHttpRequest、Form、JSONP、Socket等 通信相关的解决方案主要用于提供以下操作 1、处理与服务器的请求与相应 2、预处理请求数据与响应数据 Error/Success 的判断封装 3、多类型请求，统一接口（XMLHttpRequest1/2、JSONP、iFrame） 4、处理浏览器兼容性 【常用方案】除了jQuery等，其他常用的通信解决方案有Reqwest、qwest等 Reqwest支持JSONP，稳定性高，IE6+支持，CORS 跨域，Promise/A 支持 qwest代码少、支持XMLHttpRequest2、CORS 跨域、支持高级数据类型（ArrayBuffer、Blob、FormData） 【专业领域】 对于实时性要求较高的需求可以使用socket.io，它实时性高，支持二进制数据流，智能自动回退支持，且支持多种后端语言 工具包 工具包(Utililty)的主要职责包括以下： 1、提供 JavaScript 原生不提供的功能 2、包装原生方法，使其便于使用 3、异步队列及流程控制 【常用方案】 常用的工具包解决方案有es5-shim、es6-shim、underscore、Lodash等 上面提到的shim，也是经常听到的一个词，翻译过来是垫片的意思。对于es5、es6等标准包括的一些新方法，由于浏览器兼容性不高，所以无法直接使用它们。这时，就需要在保证实现与规范一致的基础上，来扩展原型方法，这种做法就叫做shim。好处在于，实际上就是在使用javascript的语法，但不用去考虑低版本浏览器的兼容性问题 es5-shim 提供 ES3 环境下的 ES5 支持 es6-shim 提供 ES5 环境下的 ES6支持 underscore 提供兼容 IE6+ 的扩展功能函数 Lodash是underscore 的高性能版本，方法多为 runtime 编译出来的 模板 模板主要包括三类：基于字符串的模板(String-based)、基于DOM的模板(DOM-based)、活动模板(Living Template) 1、基于字符串的模板(String-based)，解决方案包括(dustjs、hogan.js、dot.js) 原理如下：输入一段模板字符串，通过编译之后 ，生成一段Function，通过Function的render或类render函数渲染输入的数据data，输出模板字符串，字符串通过innerHTML或类似的方式渲染成最后的DOM结构。这类模板的问题在于通过字符串生成DOM之后就不再变化，如果在改变输入的数据data，需要重新render，重新生成一个全新的DOM结构，性能较差。但该模板可以在服务器端运行 2、基于DOM的模板(DOM-based)，解决方案包括(angularjs、vuejs、knockout) 原理如下：将输入的字符串模板通过innerHTML转换为一个无状态DOM树，然后遍历该节点树，去抓取关键属性或语句，来进行相关的绑定，进而变成了有状态的DOM树，最终导致DOM树会与数据模型model进行绑定。这类模板的特点是修改数据时，会使有状态的DOM树实时更新，运行时性能更好，也会保留 DOM 中的已有事件 3、活动模板(Living Template)，解决方案包括(RegularJS、RactiveJS、htmlbar) 原理如下：活动模板融合了字符串模板和DOM模板的技术，模板字符串string通过自定义的解析器DSL-based Parse解析成AST(抽象语法树)，通过遍历AST，使用createElement()、setAttribute()等原生DOM方法，生成DOM树，最终导致DOM树会与数据模型model进行绑定。由于其内部完全不使用innerHTML，所以安全性较高 组件 组件(Component)的主要职责包括以下： 1、提供基础的 CSS 支持 2、提供常见的组件，如slider、Modal等 3、提供声明式的调用方式（类似 Bootstrap） 【常用方案】 常用的组件解决方案有Bootstrap、Foundation等，两者具有移动端first的流式栅格系统，由sass组织，可定制UI Bootstrap封装了常用的组件，是目前最火的组件解决方案 Foundation在国内知名度不高 路由 路由在单页系统中非常重要，主要职责如下 1、监听 URL 变化，并通知注册的模块 2、通过 JavaScript 进行主动跳转 3、历史管理 4、对目标浏览器的兼容性支持 无论什么框架，在完成配置之后，内部都有如下图所示的类似的路由表。 【常用方案】常用的路由解决方案有page.JS、Director.JS、Stateman、crossroad.JS等 page.JS类似 Express.Router 的路由规则的前端路由库 Director.JS可以前后端使用同一套规则定义路由 Stateman处理深层复杂路由的独立路优库 crossroad.JS老牌路由库，API 功能较为繁琐 架构所有的架构(architecture)都是一个目的，就是解耦。解耦有很多方式，可以通过事件、分层等市面上，有很多架构模式，包括MVC、MVVM、MV*等 架构的职责主要包括以下： 1、提供一种范式帮助（强制）开发者进行模块解耦 2、视图与模型分离 3、容易进行单元测试 4、容易实现应用扩展 以MVVM为例，如下图所示。它包括Model(数据层或模型层)、View(视图层)、ViewModel(控制层) Model(数据层或模型层)表示数据实体，它们用于记录应用程序的数据 View(视图层)用于展示界面，界面是数据定制的反映，它包含样式结构定义以及VM享有的声明式数据以及数数据绑定ViewModel(控制层)是View与Model的粘合，它通过绑定事件与View交互并可以调用Service处理数据持久化，也可以通过数据绑定将Model的变动反映到View中 【SPA】要特点注意的是，MV* !== SPA(单页系统) SPA应用程序的逻辑比较复杂，需要一种模式来进行解耦，但并不一定是MV*模式 ####最后推荐一个框架选型网站https://www.javascripting.com，该网站根据不同的需求的选择，给出当下流行的框架选型]]></content>
      <categories>
        <category>框架选型</category>
      </categories>
      <tags>
        <tag>框架选型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli构建项目 npm run build后应该怎么运行在本地查看效果 (未完待续)]]></title>
    <url>%2F%2Fblog%2Fvue-run-build.html</url>
    <content type="text"><![CDATA[运行npm run build 本地查看页面效果本文以vue官方脚手架vue-cli构建的项目为例 这时如果直接运行npn run build是可以运行并打包你的代码的，不会报任何异常或错误，但是你会看到你的命令行打包完成有这样一句提示： 123Build complete.Tip: built files are meant to be served over an HTTP server.Opening index.html over file:// won\'t work 运行完npm run build,打开项目中的dist目录下的index.html文件！ 看到index.html的 控制台会出现一片404 如下图： 解决方案 因为 config 目录下的 index.js 中的 build 配置的 assetsPublicPath 为 / 绝对路径,所以找不到打包以后的资源 我们只要报 build 中的 assetsPublicPath 改为 ./ 就可以了，在运行一次npm run build,再打开index.html就可以在本地看了]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3transfrom3D]]></title>
    <url>%2F%2Fblog%2Fcss3transfrom3D.html</url>
    <content type="text"><![CDATA[css3 3d transfrom 参考 &gt; http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/ 3D变化示意图 认识 rotate rotateX() 以x轴为中心旋转 rotateY() 以Y轴为中心旋转 rotateZ() 以Z轴为中心旋转 perspective属性perspective的意思是：透视,远景CSS3 3D transform的透视点是在浏览器的前方！显示器中3D效果元素的透视点在显示器的上方（不是后面），近似就是我们眼睛所在方位！ translateZ帮你寻找透视位置如果说rotateX/rotateY/rotateZ可以帮助理解三维坐标，则translateZ则可以帮你理解透视位置。我们都知道近大远小的道理，对于没有rotateX以及rotateY的元素，translateZ的功能就是让元素在自己的眼前或近或远。比方说，我们设置元素perspective为201像素，如下： 1perspective: 201px; 则其子元素，设置的translateZ值越小，则子元素大小越小（因为元素远去，我们眼睛看到的就会变小）;可参考 &gt; http://www.zhangxinxu.com/study/201209/transform-perspective-translateZ.html 反转效果css代码 1234567.flip-container&#123;perspective:1000&#125;.flip-container:hover .flipper,.flip-container.hover .flipper&#123;transform:rotateY(180deg)&#125;.flip-container,.front,.back&#123;width:320px;height:480px&#125;.flipper&#123;transition:0.6s;transform-style:preserve-3d;position:relative&#125;.front,.back&#123;backface-visibility:hidden;position:absolute;top:0;left:0&#125;.front&#123;z-index:2;background:red&#125;.back&#123;background:blue;transform:rotateY(180deg)&#125; 1234567.flip-container&#123;-webkit-perspective:1000;-moz-perspective:1000;-ms-perspective:1000;perspective:1000;-ms-transform:perspective(1000px);-moz-transform:perspective(1000px);-moz-transform-style:preserve-3d;-ms-transform-style:preserve-3d&#125;.flip-container:hover .back.flip&#123;-webkit-transform:rotateY(0deg);-moz-transform:rotateY(0deg);-o-transform:rotateY(0deg);-ms-transform:rotateY(0deg);transform:rotateY(0deg)&#125;.flip-container:hover .front.flip&#123;-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg);-o-transform:rotateY(180deg);transform:rotateY(180deg)&#125;.flipper&#123;-webkit-transition:0.6s;-webkit-transform-style:preserve-3d;-ms-transition:0.6s;-moz-transition:0.6s;-moz-transform:perspective(1000px);-moz-transform-style:preserve-3d;-ms-transform-style:preserve-3d;transition:0.6s;transform-style:preserve-3d;position:relative;height:100%&#125;.front,.back&#123;-webkit-backface-visibility:hidden;-moz-backface-visibility:hidden;-ms-backface-visibility:hidden;backface-visibility:hidden;-webkit-transition:0.6s;-webkit-transform-style:preserve-3d;-webkit-transform:rotateY(0deg);-moz-transition:0.6s;-moz-transform-style:preserve-3d;-moz-transform:rotateY(0deg);-o-transition:0.6s;-o-transform-style:preserve-3d;-o-transform:rotateY(0deg);-ms-transition:0.6s;-ms-transform-style:preserve-3d;-ms-transform:rotateY(0deg);transition:0.6s;transform-style:preserve-3d;transform:rotateY(0deg);position:absolute;top:0;left:0&#125;.front&#123;-webkit-transform:rotateY(0deg);-ms-transform:rotateY(0deg);z-index:2;width:100%;height:100%&#125;.back&#123;-webkit-transform:rotateY(-180deg);-moz-transform:rotateY(-180deg);-o-transform:rotateY(-180deg);-ms-transform:rotateY(-180deg);transform:rotateY(-180deg);height:100%&#125; html代码 12345678910&lt;div class="flip-container" ontouchstart="this.classList.toggle('hover');"&gt; &lt;div class="flipper"&gt; &lt;div class="front"&gt; &lt;!-- 前面内容 --&gt; &lt;/div&gt; &lt;div class="back"&gt; &lt;!-- 背面内容 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6中let、const和var之间的关联、区别]]></title>
    <url>%2F%2Fblog%2Fes6-1.html</url>
    <content type="text"><![CDATA[let、const、var的区别（let、const 为es5新添加的） let 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。 var 声明的变量只能是全局或者整个函数块的。 const 伪常量 本身的值不能改变 d 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 let const 暂时性死区 （temporal dead zone，简称 TDZ）只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 必须在声明以后才能使用 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 参考 &gt; https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let 兼容性查询 let 不允许被重复声明 12345//Uncaught SyntaxError: Identifier 'q' has already been declaredfunction b() &#123; var a = 10; let a = 10;&#125; 三点注意允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。 1234567891011// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端注意事项 (未完待续)]]></title>
    <url>%2F%2Fblog%2Fmobile-all.html</url>
    <content type="text"><![CDATA[一些问题阐述 (未完待续) 设备更新换代快 + 浏览器厂商不统一———— 兼容问题多 网络更复杂——弱网络，低端机性能差————页面打开慢 未知问题——坑多 meta基础知识 H5页面窗口自动调整到设备宽度，并禁止用户缩放页面&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; 忽略将页面中的数字识别为电话号码&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 忽略Android平台中对邮箱地址的识别&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt; 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt; viewport模板 ———— 通用12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt;&lt;/html&gt; 常见问题移动端如何定义字体font-family 中文字体使用系统默认即可，英文用Helvetica /* 移动端定义字体的代码 */ body{font-family:Helvetica;} 移动端字体单位font-size选择px还是rem 对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 / 长宽占位 rem算法, 根据root的rem来计算各元素相对rem, 默认html 750/10 = 75px / 可以参考 &gt; http://www.cnblogs.com/well-nice/p/5509589.html 12345678 updataHtml(); function updataHtml() &#123; var w = document.documentElement.offsetWidth; document.documentElement.style.fontSize = w / 10 + "px"; &#125; window.onresize = function () &#123; updataHtml();&#125; 移动端click屏幕产生200-300 ms的延迟响应 在IOS safari下，大概为300毫秒，IOS 自带的双击页面放大，点击完成第一次时，会等待第二次点击，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理 fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序ontouchstartontouchmoveontouchendonclick解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应 什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 12//例如图片宽高为：200px*200px，那么写法如下.css&#123;width:100px;height:100px;background-size:100px 100px;&#125; 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px 1.css&#123;font-size:20px&#125; ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩 1a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)&#125; 部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果 1234a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only; &#125; 兼容性不是很好 winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉、1&lt;meta name="msapplication-tap-highlight" content="no"&gt; webkit表单元素的默认外观怎么重置1.css&#123;-webkit-apperarance:none&#125; 把各个浏览器表单的默认样式重置 伪元素改变number类型input框的默认样式123456789input[type=number]::-webkit-textfield-decoration-container &#123; background-color: transparent; &#125;input[type=number]::-webkit-inner-spin-button &#123; -webkit-appearance: none;&#125;input[type=number]::-webkit-outer-spin-button &#123; -webkit-appearance: none;&#125;]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大家好]]></title>
    <url>%2F%2Fblog%2FHello.html</url>
    <content type="text"><![CDATA[每周两篇bolg,最后整理合并，分类，总结]]></content>
  </entry>
</search>
