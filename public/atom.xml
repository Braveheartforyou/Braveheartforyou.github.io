<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asyncnode</title>
  
  <subtitle>asyncnode</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://asyncnode.com/"/>
  <updated>2019-03-23T15:56:36.347Z</updated>
  <id>http://asyncnode.com/</id>
  
  <author>
    <name>Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http中get请求和post请求的区别</title>
    <link href="http://asyncnode.com//blog/http-get-post.html"/>
    <id>http://asyncnode.com//blog/http-get-post.html</id>
    <published>2019-03-22T14:59:35.000Z</published>
    <updated>2019-03-23T15:56:36.347Z</updated>
    
    <content type="html"><![CDATA[<p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p><ul><li>GET - 从指定的资源请求数据。</li><li>POST - 向指定的资源提交要被处理的数据<br>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。<br>区别</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">GET</th><th style="text-align:center">POST</th></tr></thead><tbody><tr><td style="text-align:center">后退按钮/刷新</td><td style="text-align:center">无害</td><td style="text-align:center">数据会被重新提交（浏览器应该告知用户数据会被重新提交）</td></tr><tr><td style="text-align:center">书签</td><td style="text-align:center">可收藏为书签</td><td style="text-align:center">不可收藏为书签</td></tr><tr><td style="text-align:center">缓存</td><td style="text-align:center">能被缓存</td><td style="text-align:center">不能缓存</td></tr><tr><td style="text-align:center">编码类型</td><td style="text-align:center">application/x-www-form-urlencoded</td><td style="text-align:center">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码</td></tr><tr><td style="text-align:center">历史</td><td style="text-align:center">参数保留在浏览器历史中</td><td style="text-align:center">参数不会保存在浏览器历史中</td></tr><tr><td style="text-align:center">对数据长度的限制</td><td style="text-align:center">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">对数据类型的限制</td><td style="text-align:center">只允许 ASCII 字符</td><td style="text-align:center">没有限制。也允许二进制数据</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分 在发送密码或其他敏感信息时绝不要使用 GET ！</td><td style="text-align:center">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中</td></tr><tr><td style="text-align:center">可见性</td><td style="text-align:center">数据在 URL 中对所有人都是可见的</td><td style="text-align:center">数据不会显示在 URL 中</td></tr></tbody></table><p>其实GET和POST都是http协议中的两种发送请求的方法。</p><ol><li>http协议并未规定get和post的长度限制</li><li>get的最大长度限制是因为浏览器和web服务器限制了URL的长度</li><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</li></ol><p>其实很多人说get请求比post请求快，主要是底下两条</p><ol><li>get请求比post请求少一步</li><li>get请求可以缓存</li></ol><p>get请求过程：</p><ol><li>浏览器请求tcp连接（第一次握手） </li><li>服务器答应进行tcp连接（第二次握手） </li><li>浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） </li><li>服务器返回200 OK响应</li></ol><p>post请求过程：</p><ol><li>浏览器请求tcp连接（第一次握手） </li><li>服务器答应进行tcp连接（第二次握手） </li><li>浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） </li><li>服务器返回100 Continue响应 </li><li>浏览器发送数据 </li><li>服务器返回200 OK响应</li></ol>]]></content>
    
    <summary type="html">
    
      在http协议中get请求和post请求的区别
    
    </summary>
    
    
      <category term="Http" scheme="http://asyncnode.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的变量提升</title>
    <link href="http://asyncnode.com//blog/hoisting.html"/>
    <id>http://asyncnode.com//blog/hoisting.html</id>
    <published>2019-03-21T03:32:13.000Z</published>
    <updated>2019-03-23T15:57:59.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生变量提升的原因"><a href="#产生变量提升的原因" class="headerlink" title="产生变量提升的原因"></a>产生变量提升的原因</h2><p>在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。<br>在JavaScript代码运行之前其实是有一个编译阶段的。编译之后才是从上到下，一行一行解释执行。变量提升就发生在编译阶段，它把变量和函数的声明提升至作用域的顶端。（编译阶段的工作之一就是将变量与其作用域进行关联）。<br>我先分开介绍变量提升和函数提升到后面再放到一起比较。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>我们直接从代码从最基础的开始<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>相信这个大家知道，上面代码其实就是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>他会提前声明a,但是不会给a赋值。<br>但是如下代码会怎么执行呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined </span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>如果没有通过var声明值类型的就不会存在变量提升，而是会报错。</p><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>和变量提升一样存在函数提升，但是他们还有点不同。如下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure></p><p>他会提前声明并且赋值，还有一种函数声明方式，代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法就和变量提升相同了。<br>还有一种我感觉要说一下，其实不仔细思考也很容易犯错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a()); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="comment">// 会输出如下：</span></span><br><span class="line"><span class="comment">// 1 这个 a function 输出的</span></span><br><span class="line"><span class="comment">// undefined 因为 a function没有 return出来任何值，默认return  undefined。</span></span><br></pre></td></tr></table></figure></p><p>为什么会输出 一个 <font color="blue">1</font> 和一个<font color="blue">undefined</font>,我来解释一下,首先console.log(a())，他会<font color="blue">先执行a()</font>方法，<font color="blue">输出 1</font>,但是a方法没有返回值，默认返回<font color="blue">undefined</font>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a()); <span class="comment">// Uncaught TypeError: a is not a function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure></p><p>这个看一下就行。</p><h3 id="结合变量提升和函数提升"><a href="#结合变量提升和函数提升" class="headerlink" title="结合变量提升和函数提升"></a>结合变量提升和函数提升</h3><p>如果变量提升遇到函数提升，那个优先级更高呢，看下面的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>看上面的代码知道<font color="blue">函数提升</font><font color="blue">是<font color="blue">高于变量提升</font>的，因为在javascript中函数是一等公民，<font color="blue">并且不会被变量声明覆盖</font>，但是会被<font color="blue">变量赋值覆盖</font>。其实代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></font></p><p>我们再来一个稍微复杂一点的，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(2);&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure></p><p>在多次函数提升的会后一个覆盖前一个，然后才是变量提升，其实代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(2);&#125;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure></p><p>基本上这个上面基本上包含了javascript的变量提升和函数提升。其实还有一个作用域的我在这边就不介绍了，我会开篇再好好说一下作用域。</p>]]></content>
    
    <summary type="html">
    
      JavaScript中的变量提升，一般人都能说出来一点，我这里总结一下自己比较常见的，值的声明提升，还有函数的声明提升
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>(http)tcp三次握手和四次挥手</title>
    <link href="http://asyncnode.com//blog/http-tcp.html"/>
    <id>http://asyncnode.com//blog/http-tcp.html</id>
    <published>2019-03-13T08:21:03.000Z</published>
    <updated>2019-03-21T13:20:24.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP概念"><a href="#TCP概念" class="headerlink" title="TCP概念"></a>TCP概念</h2><p>TCP(Transmission Control Protocol 传输控制协议)是一种<font color="blue">面向连接(连接导向)</font>的、<font color="blue">可靠</font>的、 <font color="blue">基于IP的传输层</font>协议。<br>首先来看看OSI的七层模型<br><img src="../images/http/1.jpg" alt="OSI"></p>]]></content>
    
    <summary type="html">
    
      tcp三次握手和四次挥手,为什么是三次握手挥手是四次。
    
    </summary>
    
    
      <category term="Http" scheme="http://asyncnode.com/tags/Http/"/>
    
      <category term="Tcp" scheme="http://asyncnode.com/tags/Tcp/"/>
    
  </entry>
  
  <entry>
    <title>函数节流（throttle）与函数去抖（debounce）</title>
    <link href="http://asyncnode.com//blog/javascript-debounce-throttle.html"/>
    <id>http://asyncnode.com//blog/javascript-debounce-throttle.html</id>
    <published>2019-03-04T06:03:51.000Z</published>
    <updated>2019-03-04T13:31:04.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。</p><ol><li><p>window对象的resize、scroll事件</p></li><li><p>拖拽时的mousemove事件</p></li><li><p>射击游戏中的mousedown、keydown事件</p></li><li><p>文字输入、自动完成的keyup事件</p></li></ol><p>实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。</p><h2 id="与函数去抖（debounce）"><a href="#与函数去抖（debounce）" class="headerlink" title="与函数去抖（debounce）"></a>与函数去抖（debounce）</h2><p>当<font color="blue">调用动作n毫秒</font>后，才会执行该动作，若在这<font color="blue">n毫秒</font>内又调用此动作则将<font color="blue">重新</font>计算执行时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* timer为第二次要调用间隔的时间，只有大于间隔时间的调用会立即执func，不然要等到timer之后再执行</span></span><br><span class="line"><span class="comment">* @param timer &#123;Number&#125; 间隔时间，单位毫秒</span></span><br><span class="line"><span class="comment">* @param func &#123;Function&#125; 要执行的函数</span></span><br><span class="line"><span class="comment">* @param * &#123;Function&#125; 返回匿名函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">timer, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextAction;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(nextAction);</span><br><span class="line">    nextAction = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(content, args);</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>调用onresize函数，我们不需要触发频率这么快，要让函数执行延迟500毫秒再执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.onresize = debounce(<span class="number">500</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="参考-v1-9-1的Underscore-js-debounce"><a href="#参考-v1-9-1的Underscore-js-debounce" class="headerlink" title="参考 v1.9.1的Underscore.js debounce"></a>参考 v1.9.1的Underscore.js debounce</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class="line"><span class="comment">// be triggered. The function will be called after it stops being called for</span></span><br><span class="line"><span class="comment">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class="line"><span class="comment">// leading edge, instead of the trailing.</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//immediate 不传为 undefind, 默认不立即执行，传true 立即执行一次</span></span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (args) result = func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// restArguments Underscore.js 的restArguments方法 https://underscorejs.org/#restArguments</span></span><br><span class="line">  <span class="comment">// 格式化 参数为数组</span></span><br><span class="line">  <span class="keyword">var</span> debounced = restArguments(<span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// _.delay Underscore.js _.delay https://underscorejs.org/#delay</span></span><br><span class="line">      timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><p>预先设定一个<font color="blue">执行周期</font>，当再次调用动作的<font color="blue">时刻</font>大于等于<font color="blue">执行周期</font>则执行该动作，然后进入下一个新周期。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* timer为第二次要调用间隔的时间，只有大于间隔时间的调用会立即执func，不然要等到timer之后再执行</span></span><br><span class="line"><span class="comment">* @param delay &#123;Number&#125; 间隔时间，单位毫秒</span></span><br><span class="line"><span class="comment">* @param func &#123;Function&#125; 要执行的函数</span></span><br><span class="line"><span class="comment">* @param * &#123;Function&#125; 返回匿名函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">delay, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextAction = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (currTime - nextAction &gt; delay) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      nextAction = currTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>和防抖一样调用onresize函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="number">500</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="参考-v1-9-1的Underscore-js-throttle"><a href="#参考-v1-9-1的Underscore-js-throttle" class="headerlink" title="参考 v1.9.1的Underscore.js throttle"></a>参考 v1.9.1的Underscore.js throttle</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class="line"> <span class="comment">// during a given window of time. Normally, the throttled function will run</span></span><br><span class="line"> <span class="comment">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class="line"> <span class="comment">// but if you'd like to disable the execution on the leading edge, pass</span></span><br><span class="line"> <span class="comment">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class="line"> _.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">   <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">     timeout = <span class="literal">null</span>;</span><br><span class="line">     result = func.apply(context, args);</span><br><span class="line">     <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> now = _.now();</span><br><span class="line">     <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">     <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">     context = <span class="keyword">this</span>;</span><br><span class="line">     args = <span class="built_in">arguments</span>;</span><br><span class="line">     <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">       <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">         clearTimeout(timeout);</span><br><span class="line">         timeout = <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       previous = now;</span><br><span class="line">       result = func.apply(context, args);</span><br><span class="line">       <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">       timeout = setTimeout(later, remaining);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     clearTimeout(timeout);</span><br><span class="line">     previous = <span class="number">0</span>;</span><br><span class="line">     timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> throttled;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      防止频繁操作dom带来重绘、回流（重排）带来的性能损耗
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>require和import的区别</title>
    <link href="http://asyncnode.com//blog/javascript-module.html"/>
    <id>http://asyncnode.com//blog/javascript-module.html</id>
    <published>2019-02-27T13:44:57.000Z</published>
    <updated>2019-03-23T16:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单比较"><a href="#简单比较" class="headerlink" title="简单比较"></a>简单比较</h2><p>对比表格如下</p><table><thead><tr><th style="text-align:center">对比类型</th><th style="text-align:center">import</th><th style="text-align:center">require</th></tr></thead><tbody><tr><td style="text-align:center">何时加载</td><td style="text-align:center">编译时加载</td><td style="text-align:center">运行时加载</td></tr><tr><td style="text-align:center">静态化</td><td style="text-align:center">ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</td><td style="text-align:center">只有运行时才能得到这个对象，不能在编译时做到静态化</td></tr><tr><td style="text-align:center">调用时间</td><td style="text-align:center">import是编译时调用，所以严格模式必须放在文件开头</td><td style="text-align:center">require是运行时调用，所以require理论上可以运用在代码的任何地方</td></tr><tr><td style="text-align:center">模块输出</td><td style="text-align:center">模块输出的是值的引用，不会缓存，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块</td><td style="text-align:center">模块输出的是一个值的拷贝，并且在第一次加载是缓存，后面加载都会读取缓存</td></tr><tr><td style="text-align:center">模块加载</td><td style="text-align:center">按引入加载</td><td style="text-align:center">整体加载</td></tr><tr><td style="text-align:center">循环加载</td><td style="text-align:center">ES6 模块是动态引用，如果使用import从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值</td><td style="text-align:center">CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出</td></tr></tbody></table><p>下面我们一项一项具体解释：</p><h3 id="何时加载-静态化"><a href="#何时加载-静态化" class="headerlink" title="何时加载/静态化"></a>何时加载/静态化</h3><p>require / exports ：<br>遵循 <font color="blue">CommonJS/AMD</font>，只能在<font color="blue">运行时</font>确定模块的依赖关系及输入/输出的变量，<font color="blue">无法</font>进行<font color="blue">静态优化</font>。</p><p>import / export：<br>遵循 <font color="blue">ES6</font> 规范，支持<font color="blue">编译时静态分析</font>，便于JS引入宏和类型检验。<font color="blue">动态绑定</font>。</p><h3 id="调用时间"><a href="#调用时间" class="headerlink" title="调用时间"></a>调用时间</h3><p>import / export：<br>import命令具有<font color="blue">提升效果</font>，会<font color="blue">提升</font>到整个模块的头部，<font color="blue">首先执行</font>。（是在编译阶段执行的）<br>因为import是静态执行的，不能使用表达式和变量，即在运行时才能拿到结果的语法结构.</p><p>require / exports ：<br>require是<font color="blue">运行时</font>调用，所以require理论上可以运用在代码的<font color="blue">任何地方</font></p><h3 id="模块输出-模块加载"><a href="#模块输出-模块加载" class="headerlink" title="模块输出/模块加载"></a>模块输出/模块加载</h3><p>require / exports ：<br>CommonJS 模块输出的是<font color="blue">值的拷贝</font>，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值，并且会在第一次加载是<font color="blue">缓存</font>这个值的拷贝，他是<font color="blue">完全</font>输出这个值的拷贝。</p><p>import / export：<br>模块输出的是值的<font color="blue">引用</font>，<font color="blue">不会</font>缓存，而是<font color="blue">动态</font>地去被加载的模块取值，并且变量总是绑定其所在的模块，并且只会<font color="blue">加载</font>引入的值，不去全部加载。</p>]]></content>
    
    <summary type="html">
    
      CommonJS/Require和ES6/import的区别
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>es-promise</title>
    <link href="http://asyncnode.com//blog/es-promise.html"/>
    <id>http://asyncnode.com//blog/es-promise.html</id>
    <published>2019-02-27T13:44:35.000Z</published>
    <updated>2019-02-27T14:43:38.171Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么![] == []为true, [] == false为true,  ![] == false为true, !![] == false 为false</title>
    <link href="http://asyncnode.com//blog/javascript-false-true.html"/>
    <id>http://asyncnode.com//blog/javascript-false-true.html</id>
    <published>2019-02-26T09:00:31.000Z</published>
    <updated>2019-02-27T14:43:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。<br>比较的特点:</p><ul><li>对于两个拥有相同字符顺序，相同长度，并且每个字符的位置都匹配的字符串，应该使用严格比较运算符。</li><li>对于两个数值相同的数字应该使用严格比较运算符，NaN和任何值不相等，包括其自身，正数零等于负数零。</li><li>对于两个同为true或同为false的布尔操作数，应使用严格比较运算符。</li><li>不要使用严格比较运算符或比较运算符来比较两个不相等的对象。</li><li>当比较一个表达式和一个对象时，仅当两个操作数引用相同的对象（指针指向相同对象）。</li><li>对于Null 和 Undefined 类型而言，应使用严格比较运算符比较其自身，使用比较运算符进行互相比较。</li></ul><p>参考 &gt;<font color="blue"><a href="https://www.h5jun.com/post/why-false-why-true.html" target="_blank" rel="noopener">https://www.h5jun.com/post/why-false-why-true.html</a></font></p><h3 id="一致-严格相等"><a href="#一致-严格相等" class="headerlink" title="一致/严格相等 (===)"></a>一致/严格相等 (===)</h3><p>一致运算符不会进行类型转换，仅当操作数严格相等时返回true</p><h3 id="相等"><a href="#相等" class="headerlink" title="相等(==)"></a>相等(==)</h3><p>比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。</p><p>非严格比较操作符 == 是会做强制类型转换的，那么根据 ECMA 262 它的规则是：<br><strong> 图1-1 </strong><br><img src="../images/false-true/1.png" alt="! =="><br><strong> <font color="blue">ToPrimitive：</font> </strong><br><strong> 图1-2 </strong><br><img src="../images/false-true/2.png" alt="! =="><br><strong> 图1-3 </strong><br><img src="../images/false-true/3.png" alt="! =="><br><strong> 图1-4 </strong><br><img src="../images/false-true/4.png" alt="! =="></p><p><strong> <font color="blue">ToBoolean: </font> </strong><br><strong> 图1-5 </strong><br><img src="../images/false-true/5.png" alt="! =="><br><strong> 图1-6 </strong><br><img src="../images/false-true/6.png" alt="! =="></p><p>来源： &gt;<font color="blue"><a href="http://www.ecma-international.org" target="_blank" rel="noopener">http://www.ecma-international.org</a></font></p><h2 id="false-or-or-false-为true"><a href="#false-or-or-false-为true" class="headerlink" title="[] == false or ![] == [] or ![] == false 为true"></a>[] == false or ![] == [] or ![] == false 为true</h2><p>mdn运算符优先级参考表<br><img src="../images/false-true/false-true-1.png" alt="! =="><br><img src="../images/false-true/false-true-2.png" alt="! =="></p><p><font color="red">==</font>的优先级16</p><p><font color="red">!</font>的优先级10</p><h3 id="false-结果为-true"><a href="#false-结果为-true" class="headerlink" title="[] == false 结果为 true"></a>[] == false 结果为 true</h3><p>根据图1-1可知</p><ul><li>第 7 条：If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).</li><li>第 9 条：If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.</li></ul><p>所以 [] == false 的比较是对 x 执行 ToPrimitive(x)，然后和 ToNumber(false) （为 0）进行比较。</p><p><strong> 看一下 ToPrimitive：</strong><br>根据上图1-2、1-3、1-4的规则对于ToPrimitive([])，先执行<code>[].valueOf()</code>，返回result的是’[]’，因为Type(result)是Object，所以继续执行<code>[].toString()</code>，返回””。<br>因此实际上最终是比较”” == 0，结果为true。</p><h3 id="结果为-true"><a href="#结果为-true" class="headerlink" title="![] == [] 结果为 true"></a>![] == [] 结果为 true</h3><p>按照优先级，先执行 ![]，根据规范，实际上是 !(ToBoolean([]))：<br>根据上图1-5、1-6可看出，实际上 ToBoolean([]) 会return出true, ![] 就是 false.<br>[] 上文已经讲过了 是 “” 。<br>所以对比就是 false == “”，结果为true。</p><h3 id="false-结果为-true-1"><a href="#false-结果为-true-1" class="headerlink" title="![] == false 结果为 true"></a>![] == false 结果为 true</h3><p>按照优先级，先执行 ![]，根据规范，实际上是 !(ToBoolean([]))：<br>根据上图可看出，实际上 ToBoolean([]) 会return出true, ![] 就是 false.<br>false == false ，结果为true。</p><h3 id="false-结果为-false"><a href="#false-结果为-false" class="headerlink" title="!![] == false 结果为 false"></a>!![] == false 结果为 false</h3><p>按照优先级，先执行 !![]，根据规范，实际上是 !!(ToBoolean([]))：<br>根据上图可看出，实际上 ToBoolean([]) 会return出true, !![] 就是 true.<br>true == false ，结果为 false。</p>]]></content>
    
    <summary type="html">
    
      在JavaScript中==和===的区别,为什么![] == []为true, [] == false为true, ![] == false为true, !![] == false为false.
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>git中git rebase的使用</title>
    <link href="http://asyncnode.com//blog/git-rebase.html"/>
    <id>http://asyncnode.com//blog/git-rebase.html</id>
    <published>2019-01-24T08:59:06.000Z</published>
    <updated>2019-03-02T23:44:54.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase（译注：rebase 的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。<br>同时，比如要要合并多个commit,就可以用git rebase -i head~2。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git merge // 合并分支</span><br><span class="line">git cherry-pick // copy单个commit</span><br><span class="line">git rebase // 衍合</span><br><span class="line">git rebase [startpoint]   [endpoint]  --onto  [branchName] // copy多个commit</span><br><span class="line">git rebase -i  [startpoint]  [endpoint] // 合并多个commit</span><br><span class="line">//  pick：保留该commit（缩写:p）</span><br><span class="line">//  reword：保留该commit，但我需要修改该commit的注释（缩写:r）</span><br><span class="line">//  edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</span><br><span class="line">//  squash：将该commit和前一个commit合并（缩写:s）</span><br><span class="line">//  fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</span><br><span class="line">//  exec：执行shell命令（缩写:x）</span><br><span class="line">//  drop：我要丢弃该commit（缩写:d）</span><br></pre></td></tr></table></figure></p><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>使用 git merge 合并master1和dev1分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master1</span><br><span class="line">git merge dev1</span><br></pre></td></tr></table></figure></p><p><img src="../images/git/1-1.png" alt="git merge"><br>如上图所示：<br>最新的快照c2和c3，还有它们共同的祖先c1进行三方合并，合并的结果会产生以下新的c5，同时太还会对你的master1分支上的合并线条产生不好的结果。<br><img src="../images/git/1-2.jpg" alt="git merge"></p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>我们现在使用 git rebase 来合并master1和dev1分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev1</span><br><span class="line">git rebase master1</span><br><span class="line">git checkout master1</span><br><span class="line">git merge dev1</span><br></pre></td></tr></table></figure></p><p><img src="../images/git/1-3.png" alt="git merge"><br>如上图所示：<br>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 dev1）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master1）最后一个提交对象（C2）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 dev1 的提交历史，使它成为 master1 分支的直接下游.<br>把 C3 里产生的改变到 C2 上重演一遍。<br>现在回到 master1 分支，进行一次快进合并.<br><img src="../images/git/1-4.png" alt="git merge"></p><h2 id="git-rebase-startpoint-endpoint-–onto-branchName"><a href="#git-rebase-startpoint-endpoint-–onto-branchName" class="headerlink" title="git rebase [startpoint]   [endpoint]  –onto  [branchName]"></a>git rebase [startpoint]   [endpoint]  –onto  [branchName]</h2><p>当我们想从master1分支上复制b、c、d节点复制到dev1分支上，如下图所示：<br><img src="../images/git/1-5.png" alt="git rebase [startpoint]   [endpoint]  --onto  [branchName]"><br>master1分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">commit 302d0381120b55518924d0fa5d91aeb651e7d4fd (HEAD -&gt; master1)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:38:25 2019 +0800</span><br><span class="line"></span><br><span class="line">    d</span><br><span class="line"></span><br><span class="line">commit 9ef980cce33baa48a96f2d989d17330047cdf36b</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:38:04 2019 +0800</span><br><span class="line"></span><br><span class="line">    c</span><br><span class="line"></span><br><span class="line">commit 0d00c05dc3cb28447e35d5d4be23ca76cc32741c</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:37:27 2019 +0800</span><br><span class="line"></span><br><span class="line">    b</span><br><span class="line"></span><br><span class="line">commit 57840ed32293ca5218a9734402b51d6bcad9698d</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:34:50 2019 +0800</span><br><span class="line"></span><br><span class="line">    a</span><br><span class="line"></span><br><span class="line">commit 24b0963b54f65fc58ca2642e81e7cdc7dae1e8ac (origin/develop, master, develop)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Feb 22 13:28:15 2019 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit from Create React App</span><br></pre></td></tr></table></figure></p><p>dev1分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">commit 1225ea20d48bd16fbcfe1465e84f06292c52fe42 (HEAD -&gt; dev1)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:36:58 2019 +0800</span><br><span class="line"></span><br><span class="line">    e</span><br><span class="line"></span><br><span class="line">commit 57840ed32293ca5218a9734402b51d6bcad9698d</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:34:50 2019 +0800</span><br><span class="line"></span><br><span class="line">    a</span><br><span class="line"></span><br><span class="line">commit 24b0963b54f65fc58ca2642e81e7cdc7dae1e8ac (origin/develop, master, develop)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Feb 22 13:28:15 2019 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit from Create React App</span><br></pre></td></tr></table></figure></p><p>我们使用命令的形式为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase   [startpoint]   [endpoint]  --onto  [branchName]</span><br></pre></td></tr></table></figure></p><p>其中，[startpoint]  [endpoint]仍然和上一个命令一样指定了一个编辑区间(前开后闭)，–onto的意思是要将该指定的提交复制到哪个分支上。<br>所以，在找到b(7343021a9f5a65c6042bf62589ca02bd7bb95e7f)和c(d422a0cb01609f9007b5acf8771428d04ef5d963)的提交hash后，我们运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase 0d00c05dc^ 302d0381 --onto dev1</span><br></pre></td></tr></table></figure></p><p>如果有冲突解决冲突就解决冲突,如果没有就跳过这一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure></p><p><img src="../images/git/1-6.png" alt="git rebase [startpoint]   [endpoint]  --onto  [branchName]"><br>当前HEAD处于<font color="blue">游离状态</font>，实际上，此时所有分支的状态应该是这样:<br>![git rebase [startpoint]   [endpoint]  –onto  [branchName]](../images/git/1-7.png<br>所以，虽然此时<font color="blue">HEAD</font>所指向的内容正是我们所需要的，但是<font color="blue">dev1</font>分支是没有任何变化的，git只是将<font color="blue">b-c-d</font>部分的提交内容复制一份粘贴到了<font color="blue">dev1</font>所指向的提交后面，我们需要做的就是将<font color="blue">dev1</font>所指向的提交id设置为当前HEAD所指向的提交id就可以了，即:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev1</span><br><span class="line">git reset --hard 316ad6d</span><br></pre></td></tr></table></figure></p><p>这时候就完成了。</p><font color="blue">git rebase [startpoint]   [endpoint]  –onto  [branchName] </font>还有一种用法。<br>参考 &gt;<font color="blue"><a href="https://blog.csdn.net/endlu/article/details/51605861" target="_blank" rel="noopener">https://blog.csdn.net/endlu/article/details/51605861</a></font><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>如果只是复制某一两个提交到其他分支，建议使用更简单的命令:git cherry-pick<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout &apos;你的分支&apos;</span><br><span class="line">git cherry-pick &apos;你要copy的id&apos;</span><br><span class="line">git log //查看</span><br></pre></td></tr></table></figure></p><h2 id="git-rebase-i-startpoint-endpoint-合并多个commit"><a href="#git-rebase-i-startpoint-endpoint-合并多个commit" class="headerlink" title="git rebase -i  [startpoint]  [endpoint] // 合并多个commit"></a>git rebase -i  [startpoint]  [endpoint] // 合并多个commit</h2><p>其中-i的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint]  [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。<br>在查看到了log日志后，我们运行以下命令：<br>未完待续。</p>]]></content>
    
    <summary type="html">
    
      在git中有两种合并方式 git merge、git rebase 还有 git cherry-pcik(单个copy commit)、git rebase --onto (多个commit copy 合并)，合并多个 commit 也要用到 git rebase
    
    </summary>
    
      <category term="Git" scheme="http://asyncnode.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://asyncnode.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git中删除git本地远程分支、本地分支、远程分支</title>
    <link href="http://asyncnode.com//blog/git-delete.html"/>
    <id>http://asyncnode.com//blog/git-delete.html</id>
    <published>2019-01-23T14:10:09.000Z</published>
    <updated>2019-02-27T14:43:38.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在项目中使用git管理代码后，有些时候会创建很多不同名称的分支，以此区分各个分支代码功能。 而随着代码的合并，以前的分支就可能不再需要保存了，所以就要对没有用的分支进行删除，包括紧急回滚时从中抽取某一个版本记录所创建的临时分支。 这时候就可以使用下面的命令：</p><h3 id="删除本地git分支"><a href="#删除本地git分支" class="headerlink" title="删除本地git分支"></a>删除本地git分支</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -D branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure><h3 id="删除本地git远程分支"><a href="#删除本地git远程分支" class="headerlink" title="删除本地git远程分支"></a>删除本地git远程分支</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -D origin/branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure><h3 id="删除远程git分支"><a href="#删除远程git分支" class="headerlink" title="删除远程git分支"></a>删除远程git分支</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin -D origin/branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      删除本地git的远程分支和删除远程git分支
    
    </summary>
    
      <category term="Git" scheme="http://asyncnode.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://asyncnode.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>mixins在vue中的使用 vue_mixins实战</title>
    <link href="http://asyncnode.com//blog/vue-mixins.html"/>
    <id>http://asyncnode.com//blog/vue-mixins.html</id>
    <published>2019-01-16T02:25:47.000Z</published>
    <updated>2019-02-27T14:43:38.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文: <a href="https://www.w3cplus.com/vue/practical-use-of-components-and-mixins-in-vue-js.html" target="_blank" rel="noopener">https://www.w3cplus.com/vue/practical-use-of-components-and-mixins-in-vue-js.html</a> © w3cplus.com</p></blockquote>]]></content>
    
    <summary type="html">
    
      因为高级函数在vue中实现难度比较大,官方推荐使用mixins来实现组件的高复用性，Vue组件中Mixins的使用
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>利用ETag和If-None-Match字段验证缓存的响应</title>
    <link href="http://asyncnode.com//blog/etag-cache.html"/>
    <id>http://asyncnode.com//blog/etag-cache.html</id>
    <published>2019-01-15T14:29:16.000Z</published>
    <updated>2019-02-27T14:43:38.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>首部字段ETag能告知客户实体标识，它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值。</p><h2 id="强ETag值和弱ETag值"><a href="#强ETag值和弱ETag值" class="headerlink" title="强ETag值和弱ETag值"></a>强ETag值和弱ETag值</h2><p>Etag中有强ETag值和弱ETag值之分。</p><h3 id="强ETag值"><a href="#强ETag值" class="headerlink" title="强ETag值"></a>强ETag值</h3><p>强ETag值，不论实体发生多么细微的变化都会改变其值。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: "usagi-1234"</span><br></pre></td></tr></table></figure></p><h3 id="弱ETag值"><a href="#弱ETag值" class="headerlink" title="弱ETag值"></a>弱ETag值</h3><p>弱ETag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时，会在字段值最开始处附加 W/<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: "W/usagi-1234"</span><br></pre></td></tr></table></figure></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li><p><font color="red">服务器端</font>会给每份资源分配对应的<font color="red">ETag值</font>。在<font color="red">response</font>中的头部返回给<font color="red">客户端</font>.</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">etag</span>: "123456"</span><br></pre></td></tr></table></figure></li><li><p><font color="red">第二次客户端</font>请求的时候在<font color="red">request首部字段</font><font color="red">If-None-Match</font>中传递刚才服务端发送到客户端的<font color="red">ETag值</font>。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if-none-match</span>: "123456"</span><br></pre></td></tr></table></figure></li><li><p>服务器端会拿客户端if-none-match传递的值和ETag的值比对，如果相同，就会把if-none-match的值修改为false,服务器将返回“304 Not Modified”响应。</p></li></ol>]]></content>
    
    <summary type="html">
    
      利用http协议的 首部字段 Etag 和 If-None-Match字段来做接口缓存
    
    </summary>
    
      <category term="Http" scheme="http://asyncnode.com/categories/Http/"/>
    
    
      <category term="Http" scheme="http://asyncnode.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>理解 react的 setState 在不同情况下同步异步之间切换（未完待续）</title>
    <link href="http://asyncnode.com//blog/react-setState.html"/>
    <id>http://asyncnode.com//blog/react-setState.html</id>
    <published>2019-01-15T08:27:09.000Z</published>
    <updated>2019-02-27T14:43:38.179Z</updated>
    
    <content type="html"><![CDATA[<p>作者：虹晨<br>链接：<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="noopener">https://juejin.im/post/5b45c57c51882519790c7441</a><br>来源：掘金</p><h2 id="总结setState在不同环境中同步、异步不同"><a href="#总结setState在不同环境中同步、异步不同" class="headerlink" title="总结setState在不同环境中同步、异步不同"></a>总结setState在不同环境中同步、异步不同</h2><ol><li><font color="red">setState</font> 只在<font color="red">合成事件</font>和<font color="red">钩子函数</font>中是”异步”的,在<font color="red">原生事件</font>和<font color="red">setTimeout</font>中都是<font color="red">同步</font>的。</li><li><font color="red">setState</font>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的<font color="red">callback</font>拿到更新后的结果。</li><li><font color="red">setState</font> 的批量更新优化也是建立在<font color="red">“异步”（合成事件、钩子函数）</font>之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行<font color="red">多次 setState </font>， setState 的批量更新策略会对其进行<font color="red">覆盖</font>，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行<font color="red">合并批量更新</font>。</li></ol>]]></content>
    
    <summary type="html">
    
      react的setState是异步的，但是他有没有可能在一定情况下是同步的呢,很多人都是一口断定是异步但是确实是不对的，其实react在一定的条件下是同步的
    
    </summary>
    
      <category term="React" scheme="http://asyncnode.com/categories/React/"/>
    
    
      <category term="React" scheme="http://asyncnode.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>自己手动实现call、apply、bind</title>
    <link href="http://asyncnode.com//blog/call-apply-bind-polyfill.html"/>
    <id>http://asyncnode.com//blog/call-apply-bind-polyfill.html</id>
    <published>2019-01-15T07:31:37.000Z</published>
    <updated>2019-02-27T14:43:38.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li><font color="red">将函数设为对象的属性</font></li><li><font color="red">执行该函数</font></li><li><font color="red">删除该函数</font><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line">foo.fn = bar</span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">foo.fn()</span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="keyword">delete</span> foo.fn</span><br></pre></td></tr></table></figure></li></ol><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol><li><font color="red">传入的参数并不确定</font></li><li><font color="red">this 参数可以传 null，当为 null 的时候，视为指向 window</font></li><li><font color="red">函数是可以有返回值的！</font><h2 id="call-实现代码"><a href="#call-实现代码" class="headerlink" title="call 实现代码"></a>call 实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="comment">// arguments是类数组对象，遍历之前需要保存长度，过滤出第一个传参</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 避免object之类传入</span></span><br><span class="line">    args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> aArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> oObj = &#123;</span><br><span class="line">  firstName: <span class="string">'joy'</span>,</span><br><span class="line">  lastName: <span class="string">'tony'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callArr</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">callArr.call(aArr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calloObj</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'firstName：'</span> + <span class="keyword">this</span>.firstName + <span class="string">'/ lastName：'</span> + <span class="keyword">this</span>.lastName + <span class="string">'/ age：'</span> + age;</span><br><span class="line">&#125;</span><br><span class="line">calloObj.call(oObj, <span class="number">25</span>); <span class="comment">// "firstName：joy/ lastName：tony/ age：25"</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="apply-实现代码"><a href="#apply-实现代码" class="headerlink" title="apply 实现代码"></a>apply 实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">      result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> args = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">          args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyArr</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">applyArr.apply(aArr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyoObj</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'firstName：'</span> + <span class="keyword">this</span>.firstName + <span class="string">'/ lastName：'</span> + <span class="keyword">this</span>.lastName + <span class="string">'/ age：'</span> + age;</span><br><span class="line">&#125;</span><br><span class="line">calloObj.call(oObj, [<span class="number">25</span>]); <span class="comment">// "firstName：joy/ lastName：tony/ age：25"</span></span><br></pre></td></tr></table></figure><h2 id="bind-实现polyfill"><a href="#bind-实现polyfill" class="headerlink" title="bind 实现polyfill"></a>bind 实现polyfill</h2><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="keyword">this</span>,</span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound</span><br><span class="line">                 ? <span class="keyword">this</span></span><br><span class="line">                 : oThis,</span><br><span class="line">                 <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">                 aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      <span class="comment">// Function.prototype doesn't have a prototype property</span></span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">    <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      自己手动实现一个 call、apply 并且实现 bind的polyfill
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>nginx 配置前端 字段 gzip</title>
    <link href="http://asyncnode.com//blog/nginx-gzip.html"/>
    <id>http://asyncnode.com//blog/nginx-gzip.html</id>
    <published>2018-11-14T09:21:14.000Z</published>
    <updated>2019-02-27T14:43:38.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>windows 直接从<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">nginx官网</a>下载即可</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行nginx 在nginx安装目录运行nginx.exe</span></span><br><span class="line"><span class="comment"># 打开cmd</span></span><br><span class="line">nginx.exe start</span><br><span class="line"><span class="comment"># 打开conf/nginx.conf添加下面几行</span></span><br><span class="line"><span class="comment"># gzip  on;</span></span><br><span class="line"><span class="comment"># gzip_comp_level 1;</span></span><br><span class="line"><span class="comment"># gzip_min_length 256;</span></span><br><span class="line"><span class="comment"># gzip_types text/plain text/css application/json application/javascript text/javascript;</span></span><br><span class="line">nginx.exe -s reload</span><br></pre></td></tr></table></figure><p>就可以在 localhost:8080中打开network 查看 js、css已经压缩</p>]]></content>
    
    <summary type="html">
    
      nginx 配置gzip 压缩读取 javascript、css、json等
    
    </summary>
    
      <category term="nginx" scheme="http://asyncnode.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://asyncnode.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli结合jekins配置 实现自动部署，持续化集成</title>
    <link href="http://asyncnode.com//blog/vue-cli-jenkins.html"/>
    <id>http://asyncnode.com//blog/vue-cli-jenkins.html</id>
    <published>2018-11-14T07:46:23.000Z</published>
    <updated>2019-02-27T14:43:38.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-cli-配置"><a href="#vue-cli-配置" class="headerlink" title="vue-cli 配置"></a>vue-cli 配置</h1><p><a href="https://github.com/Braveheartforyou/vue-cli-jenkins" target="_blank" rel="noopener">项目源码</a><br><a href="">nginx配置gzip传输</a></p><h2 id="source-map、devtool、gzip"><a href="#source-map、devtool、gzip" class="headerlink" title="source-map、devtool、gzip"></a>source-map、devtool、gzip</h2><p>vue-cli 已经配置了一部分优化的，如关闭 <font color="red">source-map</font>、<font color="red">devtool</font>,<font color="red">开启gzip</font> 打包压缩，虽然打包时间变长但是，在配置好服务器的话，用户访问时间会很快 <font color="red">config/index.js</font> 如下<br><img src="../images/vue_build/jenkins_vue_cli6.png" alt="vue-cli config"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  build: &#123;</span><br><span class="line">  <span class="comment">// Template for index.html</span></span><br><span class="line">  index: path.resolve(__dirname, <span class="string">'../dist/index.html'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Paths</span></span><br><span class="line">  assetsRoot: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">  assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">  assetsPublicPath: <span class="string">'./'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Source Maps</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// https://webpack.js.org/configuration/devtool/#production</span></span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gzip off by default as many popular static hosts such as</span></span><br><span class="line">  <span class="comment">// Surge or Netlify already gzip all static assets for you.</span></span><br><span class="line">  <span class="comment">// Before setting to `true`, make sure to:</span></span><br><span class="line">  <span class="comment">// npm install --save-dev compression-webpack-plugin</span></span><br><span class="line">  productionGzip: <span class="literal">true</span>,</span><br><span class="line">  productionGzipExtensions: [<span class="string">'js'</span>, <span class="string">'css'</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the build command with an extra argument to</span></span><br><span class="line">  <span class="comment">// View the bundle analyzer report after build finishes:</span></span><br><span class="line">  <span class="comment">// `npm run build --report`</span></span><br><span class="line">  <span class="comment">// Set to `true` or `false` to always turn it on or off</span></span><br><span class="line">  bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽取公用包"><a href="#抽取公用包" class="headerlink" title="抽取公用包"></a><a href="http://asyncnode.com/blog/vue-build-dll.html">抽取公用包</a></h2><h2 id="懒加载-按模块打包"><a href="#懒加载-按模块打包" class="headerlink" title="懒加载 按模块打包"></a><a href="http://asyncnode.com/blog/vue-build-dll.html">懒加载 按模块打包</a></h2><h2 id="service-worker-这个必须要在https下才支持"><a href="#service-worker-这个必须要在https下才支持" class="headerlink" title="service-worker (这个必须要在https下才支持)"></a>service-worker (这个必须要在https下才支持)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 sw-precache-webpack-plugin</span></span><br><span class="line">yarn add sw-precache-webpack-plugin --save</span><br></pre></td></tr></table></figure><p>在<font color="red">webpack.prod.conf.js</font><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SWPrecacheWebpackPlugin = <span class="built_in">require</span>(<span class="string">'sw-precache-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//在 plugins 数组中写入</span></span><br><span class="line"><span class="comment">// Generate a service worker script that will precache, and keep up to date,</span></span><br><span class="line"><span class="comment">// the HTML &amp; assets that are part of the Webpack build.</span></span><br><span class="line"><span class="keyword">new</span> SWPrecacheWebpackPlugin(&#123;</span><br><span class="line">    <span class="comment">// By default, a cache-busting query parameter is appended to requests</span></span><br><span class="line">    <span class="comment">// used to populate the caches, to ensure the responses are fresh.</span></span><br><span class="line">    <span class="comment">// If a URL is already hashed by Webpack, then there is no concern</span></span><br><span class="line">    <span class="comment">// about it being stale, and the cache-busting can be skipped.</span></span><br><span class="line">    dontCacheBustUrlsMatching: <span class="regexp">/\.\w&#123;8&#125;\./</span>,</span><br><span class="line">    filename: <span class="string">'service-worker.js'</span>,</span><br><span class="line">    logger(message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message.indexOf(<span class="string">'Total precache size is'</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This message occurs for every build and is a bit too noisy.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (message.indexOf(<span class="string">'Skipping static resource'</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This message obscures real errors so we ignore it.</span></span><br><span class="line">        <span class="comment">// https://github.com/facebookincubator/create-react-app/issues/2612</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;,</span><br><span class="line">    minify: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// For unknown URLs, fallback to the index page</span></span><br><span class="line">    navigateFallback: <span class="string">'./'</span> + <span class="string">'/index.html'</span>,</span><br><span class="line">    <span class="comment">// Ignores URLs starting from /__ (useful for Firebase):</span></span><br><span class="line">    <span class="comment">// https://github.com/facebookincubator/create-react-app/issues/2237#issuecomment-302693219</span></span><br><span class="line">    navigateFallbackWhitelist: [<span class="regexp">/^(?!\/__).*/</span>],</span><br><span class="line">    <span class="comment">// Don't precache sourcemaps (they're large) and build asset manifest:</span></span><br><span class="line">    staticFileGlobsIgnorePatterns: [<span class="regexp">/\.map$/</span>, /asset-manifest\.json$/],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在<font color="red">src文件夹</font>中新建一个文件叫做<font color="red">registerServiceWorker.js</font>的文件写入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In production, we register a service worker to serve assets from local cache.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This lets the app load faster on subsequent visits in production, and gives</span></span><br><span class="line"><span class="comment">// it offline capabilities. However, it also means that developers (and users)</span></span><br><span class="line"><span class="comment">// will only see deployed updates on the "N+1" visit to a page, since previously</span></span><br><span class="line"><span class="comment">// cached resources are updated in the background.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.</span></span><br><span class="line"><span class="comment">// This link also includes instructions on opting out of this behavior.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isLocalhost = <span class="built_in">Boolean</span>(</span><br><span class="line">  <span class="built_in">window</span>.location.hostname === <span class="string">'localhost'</span> ||</span><br><span class="line">    <span class="comment">// [::1] is the IPv6 localhost address.</span></span><br><span class="line">    <span class="built_in">window</span>.location.hostname === <span class="string">'[::1]'</span> ||</span><br><span class="line">    <span class="comment">// 127.0.0.1/8 is considered localhost for IPv4.</span></span><br><span class="line">    <span class="built_in">window</span>.location.hostname.match(</span><br><span class="line">      /^<span class="number">127</span>(?:\.(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?))&#123;<span class="number">3</span>&#125;$/</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span> &amp;&amp; <span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="comment">// The URL constructor is available in all browsers that support SW.</span></span><br><span class="line">    <span class="keyword">const</span> publicUrl = <span class="keyword">new</span> URL(<span class="string">'./'</span>, <span class="built_in">window</span>.location);</span><br><span class="line">    <span class="keyword">if</span> (publicUrl.origin !== <span class="built_in">window</span>.location.origin) &#123;</span><br><span class="line">      <span class="comment">// Our service worker won't work if PUBLIC_URL is on a different origin</span></span><br><span class="line">      <span class="comment">// from what our page is served on. This might happen if a CDN is used to</span></span><br><span class="line">      <span class="comment">// serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> swUrl = <span class="string">`<span class="subst">$&#123;<span class="string">'./'</span>&#125;</span>service-worker.js`</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isLocalhost) &#123;</span><br><span class="line">        <span class="comment">// This is running on localhost. Lets check if a service worker still exists or not.</span></span><br><span class="line">        checkValidServiceWorker(swUrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add some additional logging to localhost, pointing developers to the</span></span><br><span class="line">        <span class="comment">// service worker/PWA documentation.</span></span><br><span class="line">        navigator.serviceWorker.ready.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">'This web app is being served cache-first by a service '</span> +</span><br><span class="line">              <span class="string">'worker. To learn more, visit https://goo.gl/SC7cgQ'</span></span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Is not local host. Just register service worker</span></span><br><span class="line">        registerValidSW(swUrl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerValidSW</span>(<span class="params">swUrl</span>) </span>&#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(swUrl)</span><br><span class="line">    .then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">      registration.onupdatefound = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> installingWorker = registration.installing;</span><br><span class="line">        installingWorker.onstatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (installingWorker.state === <span class="string">'installed'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (navigator.serviceWorker.controller) &#123;</span><br><span class="line">              <span class="comment">// At this point, the old content will have been purged and</span></span><br><span class="line">              <span class="comment">// the fresh content will have been added to the cache.</span></span><br><span class="line">              <span class="comment">// It's the perfect time to display a "New content is</span></span><br><span class="line">              <span class="comment">// available; please refresh." message in your web app.</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'New content is available; please refresh.'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// At this point, everything has been precached.</span></span><br><span class="line">              <span class="comment">// It's the perfect time to display a</span></span><br><span class="line">              <span class="comment">// "Content is cached for offline use." message.</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'Content is cached for offline use.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Error during service worker registration:'</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkValidServiceWorker</span>(<span class="params">swUrl</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check if the service worker can be found. If it can't reload the page.</span></span><br><span class="line">  fetch(swUrl)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Ensure service worker exists, and that we really are getting a JS file.</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        response.status === <span class="number">404</span> ||</span><br><span class="line">        response.headers.get(<span class="string">'content-type'</span>).indexOf(<span class="string">'javascript'</span>) === <span class="number">-1</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// No service worker found. Probably a different app. Reload the page.</span></span><br><span class="line">        navigator.serviceWorker.ready.then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">          registration.unregister().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Service worker found. Proceed as normal.</span></span><br><span class="line">        registerValidSW(swUrl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">'No internet connection found. App is running in offline mode.'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.ready.then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">      registration.unregister();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这个是基于vue-cli的一些优化，当然create-react-app也是可以把这些打包优化做进去，他只是一个基础的框架，就是打包优化参考
    
    </summary>
    
      <category term="WebPack" scheme="http://asyncnode.com/categories/WebPack/"/>
    
    
      <category term="vue-cli" scheme="http://asyncnode.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>jenkins配置前端不同环境打包不同的文件</title>
    <link href="http://asyncnode.com//blog/jenkins-fornt.html"/>
    <id>http://asyncnode.com//blog/jenkins-fornt.html</id>
    <published>2018-11-13T10:09:31.000Z</published>
    <updated>2019-02-27T14:43:38.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-cli-配置"><a href="#vue-cli-配置" class="headerlink" title="vue-cli 配置"></a>vue-cli 配置</h1><p>vue-cli <font color="red">2.x</font>版本，因为自己不太习惯3.x的这种配置，很多配置不容易写进去，同时 3.x 也在不断的修bug,所以没有升级.<br>最新代码在<a href="https://github.com/Braveheartforyou/vue-cli-jenkins.git" target="_blank" rel="noopener">github</a>，这个项目基本上是一些打包优化，缓存，等等并不是后台模版，你可以在这个项目上再搭建自己的东西，直接只是提供了一个项目比较基础的一些东西。</p><h2 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h2><p>在<font color="red">package.json</font>文件中的<font color="blue">scripts</font>添加三个字段:</p><ul><li>“build:sit”: “cross-env API_ROOT=sit node build/build.js”,</li><li>“build:uat”: “cross-env API_ROOT=uat node build/build.js”,</li><li>“build:prod”: “cross-env API_ROOT=prod node build/build.js”</li></ul><p>其中<font color="red">cross-env</font>包是为了兼容liunx和window不同系统都可以把 <font color="green">API_ROOT</font>参数传进进程中.<br><img src="../images/vue_build/jenkins_vue_cli.png" alt="jenkins_vue_cli"><br>然后配置<font color="red">config</font>文件夹下的<font color="green">dev.env.js、prod.env.js</font></p><h3 id="dev-env-js"><a href="#dev-env-js" class="headerlink" title="dev.env.js"></a>dev.env.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> prodEnv = <span class="built_in">require</span>(<span class="string">'./prod.env'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断环境 运行不同的api</span></span><br><span class="line"><span class="comment"> * 登录地址切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (process.env.API_ROOT) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'sit'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = merge(prodEnv, &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"development"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://localhost:3800/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://localhost:3800/public_api"'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prod-env-js"><a href="#prod-env-js" class="headerlink" title="prod.env.js"></a>prod.env.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前环境 打包不同的 api地址  login地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (process.env.API_ROOT) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'sit'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://localhost:3800/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-sit.com/api"'</span>,</span><br><span class="line">      version: <span class="string">'v1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'uat'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://youapi-uat.com/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-uat.com/api"'</span>,</span><br><span class="line">      version: <span class="string">'v1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'prod'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://youapi-prod.com/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-prod.com/api"'</span>,</span><br><span class="line">      version: <span class="string">'v1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后也是最重要的也就是我们要有一个统一的调用地址，如果不是统一的一个，那就多声明几个模块如<font color="red">PAYMENT、PRODUCT</font>等来区分不同环境的不同后台接口<br><img src="../images/vue_build/jenkins_vue_cli2.png" alt="jenkins_vue_cli2"></p><h1 id="jenkins-配置"><a href="#jenkins-配置" class="headerlink" title="jenkins 配置"></a>jenkins 配置</h1><ul><li>新建一个 构建一个自由风格的软件项目</li><li>配置》源码管理》Git(git地址和ssh帐号密码、拉去代码的分支)<br>  <img src="../images/vue_build/jenkins_vue_cli3.png" alt="jenkins_vue_cli3"></li><li>锁定编译环境node 版本为 8.9.3或者别的<br>  <img src="../images/vue_build/jenkins_vue_cli4.png" alt="jenkins_vue_cli4"></li><li>jenkins前端的构建脚本<br>  <img src="../images/vue_build/jenkins_vue_cli5.png" alt="jenkins_vue_cli5"><br>  这个只是最简单的打包发送到对应的服务器，其实你在这个时候还可以做很多其他的事，如运行单元测试、sonar平台质量检测、备份等等</li></ul>]]></content>
    
    <summary type="html">
    
      使用webpack打包 前端应用，并且配置jenkins脚本打包不同环境路径，配置文件如vue-cli、create-react-app都可以配置，后续文章记录常用的webpack优化，从文件大小，传输类型，缓存优化
    
    </summary>
    
      <category term="WebPack" scheme="http://asyncnode.com/categories/WebPack/"/>
    
    
      <category term="jenkins" scheme="http://asyncnode.com/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>在开发前端中的一些注意事项</title>
    <link href="http://asyncnode.com//blog/Precautions.html"/>
    <id>http://asyncnode.com//blog/Precautions.html</id>
    <published>2017-12-28T07:00:19.000Z</published>
    <updated>2019-02-27T14:43:38.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>其实很多时候发现很多别人遗留的代码，不是他写不好或者什么，而是没时间，时间不够的时候自己只能用自己比较顺手的写法去写，但是一定要有一个人去管理整个公司的前端技术栈，不然真的是一团乱，</p>]]></content>
    
    <summary type="html">
    
      在开发中有很多技术上的坑是可以百度，google或者stackoverflow能过解决，但是很多时候整个前端项目的管理，都是和个人风格有很大的关系，甚至和整个公司的技术架构有很大的关系，有很多的事情我们没有权利去解决，但是至少能管理好自己的代码。
    
    </summary>
    
      <category term="杂谈" scheme="http://asyncnode.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://asyncnode.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>运算符优先级</title>
    <link href="http://asyncnode.com//blog/JavaScript-Operator-priority.html"/>
    <id>http://asyncnode.com//blog/JavaScript-Operator-priority.html</id>
    <published>2017-11-28T07:56:23.000Z</published>
    <updated>2019-02-27T14:43:38.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>运算符的优先级决定了表达式中运算执行的先后顺序，优先级高的运算符最先被执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span> <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p><p><font color="red"></font><br>乘法运算符 (“<font color="red">*</font>“)比起加法运算符(“<font color="red">+</font>“)有着更高的优先级，所以它会被最先执行。</p><h3 id="结合性"><a href="#结合性" class="headerlink" title="结合性"></a>结合性</h3><p>结合性决定了拥有相同优先级的运算符的执行顺序。考虑下面这个表达式：</p><ul><li>左结合<br>左结合(从左到右计算)相当于把左边的子表达式加上小括号(a OP b) OP c</li><li>右关联<br>(从右到左计算)相当于a OP (b OP c)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ul><p>结果 a 和 b 的值都会成为5。这是因为赋值运算符的返回结果就是赋值运算符右边的那个值，具体过程是：b被赋值为5，然后a也被赋值为 b=5 的返回值，也就是5。</p><h3 id="汇总表"><a href="#汇总表" class="headerlink" title="汇总表"></a>汇总表</h3><p>下面的表将所有运算符按照优先级的不同从高到低排列。<br>可以查看 mdn中的 table来分他的等级。</p><p>mdn运算符优先级参考表 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table</a></p>]]></content>
    
    <summary type="html">
    
      在JavaScript中运算符是有明确的有限级的，如*运算符比+运算符的优先级高，如果想让+运算符的优先级超过*运算符，可以在+外层嵌套一个()符号，他的优先级就是高于*运算符的
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的作用域和作用域链</title>
    <link href="http://asyncnode.com//blog/javascript-scope.html"/>
    <id>http://asyncnode.com//blog/javascript-scope.html</id>
    <published>2017-11-07T02:28:32.000Z</published>
    <updated>2019-02-27T14:43:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p><font color="red"></font><br>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p><h3 id="最外层的函数、变量拥有全局作用域"><a href="#最外层的函数、变量拥有全局作用域" class="headerlink" title="最外层的函数、变量拥有全局作用域"></a>最外层的函数、变量拥有全局作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sGl = <span class="string">'全局变量'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fGL</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _sGl = <span class="string">'局部变量'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(_sGl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sGl); <span class="comment">// 全局变量</span></span><br><span class="line">fGL(); <span class="comment">// 局部变量</span></span><br></pre></td></tr></table></figure><h3 id="没有使用var关键字声明的变量也都是全局变量。"><a href="#没有使用var关键字声明的变量也都是全局变量。" class="headerlink" title="没有使用var关键字声明的变量也都是全局变量。"></a>没有使用var关键字声明的变量也都是全局变量。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    name = <span class="string">"全局变量"</span>;</span><br><span class="line">    alert(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:全局变量</span></span><br></pre></td></tr></table></figure><h3 id="所有window对象的属性拥有全局作用域"><a href="#所有window对象的属性拥有全局作用域" class="headerlink" title="所有window对象的属性拥有全局作用域"></a>所有window对象的属性拥有全局作用域</h3><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域：<font color="red">函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行。</font>也就是说词法作用域取决于源码，通过静态分析就能确定，因此<font color="red">词法作用域也叫做静态作用域</font><br>在通常情况下，变量的查询从最近接的绑定上下文开始，向外部逐渐扩展，直到查询到第一个绑定，一旦完成查找就结束搜索。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gl = <span class="string">'全局变量'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fGl</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gl = <span class="string">'局部变量'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(gl);</span><br><span class="line">&#125;</span><br><span class="line">fGl(); <span class="comment">// 局部变量</span></span><br></pre></td></tr></table></figure></p><h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>在编程实践中，最容易低估和过度滥用的概念就是动态作用域，因为很少有语言支持这种方式为绑定解析方案。</p><p>动态作用域与词法作用域相对而言的，不同于词法作用域在定义时确定，<font color="red">动态作用域在执行时确定，其生存周期到代码片段执行为止</font>。动态变量存在于动态作用域中，<font color="red">任何给定的绑定的值，在确定调用其函数之前，都是不可知的</font>。</p><p>在代码执行时，对应的作用域链常常是保持静态的。然而当遇到with语句、call方法、apply方法和try-catch中的catch时，会改变作用域链的。以with为例，在遇到with语句时，会将传入的对象属性作为局部变量来显示，使其便于访问，也就是说把一个新的对象添加到了作用域链的顶端，这样必然影响对局部标志符的解析。<font color="red">当with语句执行完毕后，会把作用域链恢复到原始状态</font>。实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with之前</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(&#123;<span class="attr">name</span>:<span class="string">"jeri"</span>&#125;)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with之后，作用域链恢复</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure></p><p>在作用域链中有动态作用域时，this引用也会变得更加复杂，不再指向第一次创建时的上下文，而是由调用者确定。比如在使用apply或call方法时，传入它们的第一个参数就是被引用的对象。实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalThis(); <span class="comment">// 输出:Window &#123;document: document,external: Object…&#125;</span></span><br><span class="line">globalThis.call(&#123;<span class="attr">name</span>:<span class="string">"jeri"</span>&#125;); <span class="comment">// 输出:Object &#123;name: "jeri"&#125;</span></span><br><span class="line">globalThis.apply(&#123;<span class="attr">name</span>:<span class="string">"jeri"</span>&#125;,[]); <span class="comment">// 输出:Object &#123;name: "jeri"&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域，顾名思义就是在定义函数时候产生的作用域，这个作用域也可以称为<font color="red">局部作用域</font>。和全局作用域相反，函数作用域一般只在函数的代码片段内可访问到，外部不能进行变量访问。在函数内部定义的变量存在于函数作用域中，其生命周期随着函数的执行结束而结束。实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"jeri"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> (&#123;<span class="attr">name</span>:<span class="string">"with"</span>&#125;) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name); <span class="comment">// 输出:with</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能访问函数作用域</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure></p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在JavaScript中，<font color="red">函数也是对象</font>，实际上，JavaScript里<font color="red">一切</font>都是<font color="red">对象</font>。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是<font color="red">[[Scope]]</font>，由ECMA-262标准第三版定义，该内部属性包含了<font color="red">函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链</font>，<font color="red">它决定了哪些数据能被函数访问</font>。<font color="red">它用来保证对执行环境有权访问的变量和函数的有序访问</font>。<br>当一个函数创建后，它的作用域会被创建此函数的作用域中可访问的数据对象填充<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="../images/scope/scope1.jpg" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义函数执行的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。<br>这些值按照它们出现在函数中的顺序被复制到运行期的上下文的作用域中，它们共同组成一个新的对象，叫“活动对象(activation object)”,该对象包含了函数的所有局部变量、命名参数、参数集合以及this,然后此对象会被推入作用域链前端，当运行期上下文被销毁时，活动对象也随之销毁。<br><img src="../images/scope/scope2.jpg" alt=""><br>在全局作用域中创建的函数,其作用域链会自动成为作用域中的一员。而当函数执行时,其活动对象就会成为作用域中的第一个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// output:global</span></span><br><span class="line">    name = <span class="string">"change"</span>;</span><br><span class="line">    <span class="comment">// 函数内部可以修改全局变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// output:change</span></span><br><span class="line">    <span class="comment">// 先查询活动对象</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="string">"18"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(age); <span class="comment">// output:18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行完毕，执行环境销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// output:Uncaught ReferenceError: age is not defined</span></span><br></pre></td></tr></table></figure></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是JavaScript的一个比较重要的东西，关于这个问题有很多文章进行讲述，然而依然有相当数量的程序员对这个概念理解不透彻，我就是其中一个，闭包报的官方定义为：<font style="font-weight: bold;">一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也该是表达式的一部分</font>。<br>一句话概括就是：<font style="font-weight: bold; color: red">闭包就是一个函数，捕获作用域内的外部绑定</font>。这些绑定是为之后使用而被绑定，即使作用域已经销毁。</p><h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><p><font style="font-weight: bold;">自由变量与闭包的关系是，自由变量闭合于闭包的创建</font>。闭包背后的逻辑是，如果一个函数内部有其他函数，那么这些内部函数可以访问在这个外部函数中声明的变量（这些变量就称之为自由变量）。然而，这些变量可以被内部函数捕获，从高阶函数（返回另一个函数的函数称为高阶函数）中return语句实现“越狱”，以供以后使用。内部函数在没有任何局部声明之前（既不是被传入，也不是局部声明）使用的变量就是被捕获的变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">captured</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">free</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = free + captured;</span><br><span class="line">        <span class="built_in">console</span>.log(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">add10(<span class="number">2</span>); <span class="comment">// 输出:12</span></span><br></pre></td></tr></table></figure></p><p>从上例可知，外部函数中的变量captured被执行加法的返回函数捕获，内部函数从未声明过captured变量，却可以引用它。<br>如果我们再创建一个加法器将捕获到同名变量captured，但有不同的值，因为这个加法器是在调用makeAdder之后被创建：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add16 = makeAdder(<span class="number">16</span>);</span><br><span class="line">add16(<span class="number">18</span>); <span class="comment">// 输出:34</span></span><br><span class="line">add10(<span class="number">10</span>); <span class="comment">// 输出:20</span></span><br></pre></td></tr></table></figure></p><p>每一个新的加法器函数都保留了自己创建时捕获的captured实例。</p><h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h3><p><font style="font-weight: bold"> </font><br>在JavaScript中，当变量在一定作用域内声明，然后在另一个同名变量在一个较低的作用域声明，会发生<font style="font-weight: bold">变量的遮蔽</font>。实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"jeri"</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"tom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">glbShadow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"fun"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 输出:fun</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glbShadow();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:tom</span></span><br></pre></td></tr></table></figure></p><p>当在一个变量同一作用域内声明了多次时，最后一次声明会生效，会遮蔽以前的声明。</p><p>变量声明的遮蔽很好理解，然而<font style="font-weight: bold">函数参数的遮蔽就略显复杂</font>。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = [<span class="string">"Value is"</span>,shadowed].join(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">argShadow(<span class="number">108</span>); <span class="comment">// output:Value is 108</span></span><br><span class="line"></span><br><span class="line">argShadow(); <span class="comment">// output:Value is</span></span><br></pre></td></tr></table></figure></p><p>函数argShadow的参数shadowed覆盖了全局作用域内的同名变量。即使没有传递任何参数，仍然绑定的是shadowed，并没有访问到全局变量shadowed = 0。</p><p><font style="font-weight: bold">任何情况下，离得最近的变量绑定优先级最高</font>。实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> shadowed = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">var</span> str = [<span class="string">"Value is"</span>,shadowed].join(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">varShadow(<span class="number">108</span>); <span class="comment">// output:Value is 123</span></span><br><span class="line"></span><br><span class="line">varShadow(); <span class="comment">// output:Value is 123</span></span><br></pre></td></tr></table></figure></p><p>varShadow(108)打印出来的并不是108而是123，即使没有参数传入也是打印的123，先访问离得最近的变量绑定。<br>遮蔽变量同样发生在闭包内部，实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(shadowed); <span class="comment">// output:108</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(shadowed); <span class="comment">// output:2</span></span><br><span class="line">        <span class="keyword">var</span> ret = shadowed + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(ret); <span class="comment">// output:3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closureShadow = captureShadow(<span class="number">108</span>);</span><br><span class="line"></span><br><span class="line">closureShadow(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>典型的误区<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ret[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> test0 = test()[<span class="number">0</span>]();</span><br><span class="line"><span class="built_in">console</span>.log(test0); <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test1 = test()[<span class="number">1</span>]();</span><br><span class="line"><span class="built_in">console</span>.log(test1); <span class="comment">//输出：5</span></span><br></pre></td></tr></table></figure></p><p>从上面的例子可知，test这个函数执行之后返回一个函数数组，表面上看数组内的每个函数都应该返回自己的索引值，然而并不是如此。当外部函数执行完毕后，外部函数虽然其执行环境已经销毁，但闭包依然保留着对其中变量绑定的引用，仍然驻留在内存之中。当外部函数执行完毕之后，才会执行内部函数，而这时内部函数捕获的变量绑定已经是外部函数执行之后的最终变量值了，所以这些函数都引用的是同一个变量i=5。<br>另一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);  </span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔1秒输出一个5</span></span><br></pre></td></tr></table></figure></p><p>按照我们的推断，上例应该输出1,2,3,4,5。然而，事实上输出的是连续5个5。为什么出现这种诡异的状况呢？其本质上还是由闭包特性造成的，闭包可以捕获外部作用域的变量绑定。<br>上面这个函数片段在执行时，其内部函数和外部函数并不是同步执行的，因为当调用setTimeout时会有一个延时事件排入队列，等所有同步代码执行完毕后，再依次执行队列中的延时事件，而这个时候 i 已经 是5了。</p><p>那怎么解决这个问题呢？我们是不是可以在每个循环执行时，给内部函数传进一个变量的拷贝，使其在每次创建闭包时，都捕获一个变量绑定。因为我们每次传参不同，那么每次捕获的变量绑定也是不同的，也就避免了最后输出5个5的状况。实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>闭包具有非常强大的功能，函数内部可以引用外部的参数和变量，但其参数和变量不会被垃圾回收机制回，常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。但，闭包也是javascript语言的一大特点，主要应用闭包场合为：<font style="font-weight: bold">设计私有的方法和变量</font>。 </p><h3 id="模拟私有变量"><a href="#模拟私有变量" class="headerlink" title="模拟私有变量"></a>模拟私有变量</h3><p>从上文的叙述我们知道，变量的捕获发生在创建闭包的时候，那么我们可以把闭包捕获到的变量做为私有变量。实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> closureDemo = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> PRIVATE = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            inc: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> PRIVATE += n;</span><br><span class="line">            &#125;,</span><br><span class="line">            dec: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> PRIVATE -= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">var</span> testInc = closureDemo.inc(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(testInc); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> testDec = closureDemo.dec(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(testDec); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    closureDemo.div = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRIVATE/n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> testDiv = closureDemo.div(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testDiv);</span><br><span class="line"><span class="comment">//输出：Uncaught ReferenceError: PRIVATE is not defined</span></span><br></pre></td></tr></table></figure></p><p>自执行函数closureDemo执行完毕之后，自执行函数作用和PRIVATE变量随之销毁，但PRIVATE仍滞留在内存中，也就是加入了到了closureDemo.inc和closureDemo.dec的作用域链中，闭包也就完成了变量捕获。但之后新加入的closureDemo.div并不能在作用域中继续寻找到PRIVATE了。因为，函数只有被调用时才会执行函数里面的代码，变量的捕获也只发生在创建闭包时，所以之后新加入的div方法并不能捕获PRIVATE。</p><h3 id="创建特权方法"><a href="#创建特权方法" class="headerlink" title="创建特权方法"></a>创建特权方法</h3><p>通过闭包我们可以创建私有作用域，那么也就可以创建私有变量和私有函数。创建私有函数的方式和声明私有变量方法一致，只要在函数内部声明函数就可以了。当然，既然可以模拟私有变量和私有函数，我们也可以利用闭包这个特性，创建特权方法。实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVar = <span class="number">10</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFun</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    MyObj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    MyObj.prototype.pubulicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVar ++;</span><br><span class="line">        <span class="keyword">return</span> privateFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>上面这个实例创建了一个私有作用域，并封装了一个构造函数和对应的方法。需要注意的是在上面的实例中，在声明MyObj这个函数时，使用的是不带var的函数表达式，我们希望产生的是一个全局函数而不是局部的，不然我们依然在外部无法访问。所以，MyObj就成为了一个全局变量，能够在外部进行访问，我们在原型上定义的方法publicMethod也就可以使用，通过这个方法我们也就可以访问私有函数和私有变量了。</p><p>本文引用 &gt;<a href="http://www.cnblogs.com/syfwhu/p/4839562.html" target="_blank" rel="noopener">http://www.cnblogs.com/syfwhu/p/4839562.html</a> (感觉作者挺可爱的)</p>]]></content>
    
    <summary type="html">
    
      JavaScript没有块级作用域,我们比较熟知的就是函数级作用域
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>在JavaScript中只有固定的值会转为false</title>
    <link href="http://asyncnode.com//blog/javascript-IF-False-options.html"/>
    <id>http://asyncnode.com//blog/javascript-IF-False-options.html</id>
    <published>2017-11-03T05:13:39.000Z</published>
    <updated>2019-02-27T14:43:38.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><!-- <font color="red"></font> --><p>在JavaScript中使用if的时候，自己如果不注意的话很可能出现判断进错，其实在JavaScript中只有<font color="red">固定的几个值会转为false，其它的统一认为为true。</font></p><ul><li><font color="red">false</font></li><li><font color="red">null</font></li><li><font color="red">undefined</font></li><li><font color="red">空字符串’ ‘</font></li><li><font color="red">数字零 0</font></li><li><font color="red">NaN</font><br>其他的全部都算为true,<font color="red">‘false’</font>、<font color="red">‘0’</font>也是为true,其实这也是一种隐性的类型转换。和 == 又有不同。</li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>由于逻辑表达式是<font color="red">从左往右</font>计算的，由于运算符优先级的存在，下面的表达式的结果却不相同。如下例所示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>  || <span class="literal">true</span>      <span class="comment">// 结果为 true</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; (<span class="literal">true</span> || <span class="literal">true</span>)     <span class="comment">// 结果为 false</span></span><br></pre></td></tr></table></figure></p><p>右侧被小括号括起来的操作变成了独立的表达式。</p><p><font color="red">转换规则</font>:</p><ul><li>将 AND  转换为 OR</li><li>将 OR 转换为 AND</li><li>删除嵌套的 AND</li><li>删除嵌套的 OR<br>可参考&gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators</a><h3 id="逻辑与-amp-amp"><a href="#逻辑与-amp-amp" class="headerlink" title="逻辑与(&amp;&amp;)"></a>逻辑与(&amp;&amp;)</h3><font color="red"></font><br>尽管 &amp;&amp; 和 || 运算符能够使用<font color="red">非布尔值</font>的操作数, 但它们依然被看作是<font color="red">布尔操</font>作符，因为它们的返回值总是能够被转换为<font color="red">布尔值</font>。<br>expr1 &amp;&amp; expr2<br>如果<font color="red">expr1</font>能转换为<font color="red">false</font>则返回<font color="red">expr1</font>,否则返回<font color="red">expr2</font>。因此，与布尔值一起使用时，如果<font color="red">两个</font>操作数都为<font color="red">true</font>时<font color="red">&amp;&amp;</font>返回<font color="red">true</font>,否则返回<font color="red">false</font>.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a1=<span class="literal">true</span> &amp;&amp; <span class="literal">true</span>       <span class="comment">// t &amp;&amp; t 结果为 true</span></span><br><span class="line">a2=<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>      <span class="comment">// t &amp;&amp; f 结果为 false</span></span><br><span class="line">a3=<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>      <span class="comment">// f &amp;&amp; t 结果为 false</span></span><br><span class="line">a4=<span class="literal">false</span> &amp;&amp; (<span class="number">3</span> == <span class="number">4</span>)  <span class="comment">// f &amp;&amp; f 结果为 false</span></span><br><span class="line">a5=<span class="string">"Cat"</span> &amp;&amp; <span class="string">"Dog"</span>     <span class="comment">// t &amp;&amp; t 结果为 Dog</span></span><br><span class="line">a6=<span class="literal">false</span> &amp;&amp; <span class="string">"Cat"</span>     <span class="comment">// f &amp;&amp; t 结果为 false</span></span><br><span class="line">a7=<span class="string">"Cat"</span> &amp;&amp; <span class="literal">false</span>     <span class="comment">// t &amp;&amp; f 结果为 false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与(||)"></a>逻辑与(||)</h3><p>expr1 &amp;&amp; expr2<br>如果<font color="red">expr1</font>能转换为<font color="red">true</font>则返回<font color="red">expr1</font>,否则返回<font color="red">expr2</font>。因此，与布尔值一起使用时，如果<font color="red">任意一个</font>操作数为<font color="red">true</font>时<font color="red">||</font>返回<font color="red">true</font>.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">o1=<span class="literal">true</span> || <span class="literal">true</span>       <span class="comment">// t || t 结果为 true</span></span><br><span class="line">o2=<span class="literal">false</span> || <span class="literal">true</span>      <span class="comment">// f || t 结果为 true</span></span><br><span class="line">o3=<span class="literal">true</span> || <span class="literal">false</span>      <span class="comment">// t || f 结果为 true</span></span><br><span class="line">o4=<span class="literal">false</span> || (<span class="number">3</span> == <span class="number">4</span>)  <span class="comment">// f || f 结果为 false</span></span><br><span class="line">o5=<span class="string">"Cat"</span> || <span class="string">"Dog"</span>     <span class="comment">// t || t 结果为 Cat</span></span><br><span class="line">o6=<span class="literal">false</span> || <span class="string">"Cat"</span>     <span class="comment">// f || t 结果为 Cat</span></span><br><span class="line">o7=<span class="string">"Cat"</span> || <span class="literal">false</span>     <span class="comment">// t || f 结果为 Cat</span></span><br></pre></td></tr></table></figure></p><h3 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非(!)"></a>逻辑非(!)</h3><p>!expr    如果单个表达式能转换为<font color="red">true</font>的话返回<font color="red">false</font>，否则返回<font color="red">true</font>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n1=!<span class="literal">true</span>              <span class="comment">// !t 结果为 false</span></span><br><span class="line">n2=!<span class="literal">false</span>             <span class="comment">// !f 结果为 true</span></span><br><span class="line">n3=!<span class="string">"Cat"</span>             <span class="comment">// !t 结果为 false</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      在用javaScript的if的时候他会把固定的值转换为false，其他的统一认为为true
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
