<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asyncnode</title>
  
  <subtitle>asyncnode</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://asyncnode.com/"/>
  <updated>2019-06-10T09:24:36.273Z</updated>
  <id>http://asyncnode.com/</id>
  
  <author>
    <name>asyncnode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue中的next-tick原理和源码解析</title>
    <link href="http://asyncnode.com//blog/vue-next-tick.html"/>
    <id>http://asyncnode.com//blog/vue-next-tick.html</id>
    <published>2019-06-10T09:22:51.000Z</published>
    <updated>2019-06-10T09:24:36.273Z</updated>
    
    <summary type="html">
    
      Vue的next-tick其实也是在eventloop的原理实现的
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中的依赖收集</title>
    <link href="http://asyncnode.com//blog/vue-dep.html"/>
    <id>http://asyncnode.com//blog/vue-dep.html</id>
    <published>2019-06-08T09:19:46.000Z</published>
    <updated>2019-06-10T09:23:17.632Z</updated>
    
    <summary type="html">
    
      Vue首先会会通过Obsever,创建响应式数据,并且在getter中做依赖收集setter中派发。
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中有三种wathcer</title>
    <link href="http://asyncnode.com//blog/vue-three-wathcer.html"/>
    <id>http://asyncnode.com//blog/vue-three-wathcer.html</id>
    <published>2019-06-05T09:16:30.000Z</published>
    <updated>2019-06-10T09:19:28.585Z</updated>
    
    <summary type="html">
    
      Vue中有三种wathcer,渲染wathcer、computed-wathcer、自定义wathcer
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-render</title>
    <link href="http://asyncnode.com//blog/vue-update-render-createelement-patch.html"/>
    <id>http://asyncnode.com//blog/vue-update-render-createelement-patch.html</id>
    <published>2019-06-01T07:47:01.000Z</published>
    <updated>2019-06-03T02:47:53.440Z</updated>
    
    <summary type="html">
    
      vue的render
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-new-vue</title>
    <link href="http://asyncnode.com//blog/vue-new-vue.html"/>
    <id>http://asyncnode.com//blog/vue-new-vue.html</id>
    <published>2019-05-28T01:45:22.000Z</published>
    <updated>2019-06-03T02:46:25.580Z</updated>
    
    <summary type="html">
    
      new vue 都做了什么
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack实现热加载的两种方式 和 实现原理</title>
    <link href="http://asyncnode.com//blog/webpack-hot-twofuntions.html"/>
    <id>http://asyncnode.com//blog/webpack-hot-twofuntions.html</id>
    <published>2019-05-25T04:42:23.000Z</published>
    <updated>2019-06-03T02:43:38.217Z</updated>
    
    <summary type="html">
    
      webpack实现热加载的两种方式 和 实现原理
    
    </summary>
    
      <category term="WebPack" scheme="http://asyncnode.com/categories/WebPack/"/>
    
    
      <category term="WebPack" scheme="http://asyncnode.com/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>创建一个自己的webpack插件</title>
    <link href="http://asyncnode.com//blog/webpack-self-plugins.html"/>
    <id>http://asyncnode.com//blog/webpack-self-plugins.html</id>
    <published>2019-05-22T03:38:39.000Z</published>
    <updated>2019-06-03T02:40:33.718Z</updated>
    
    <summary type="html">
    
      创建一个自己的webpack插件
    
    </summary>
    
      <category term="WebPack" scheme="http://asyncnode.com/categories/WebPack/"/>
    
    
      <category term="WebPack" scheme="http://asyncnode.com/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>webpack编译流程</title>
    <link href="http://asyncnode.com//blog/webpack-process.html"/>
    <id>http://asyncnode.com//blog/webpack-process.html</id>
    <published>2019-05-19T06:35:28.000Z</published>
    <updated>2019-06-03T02:40:02.869Z</updated>
    
    <summary type="html">
    
      webpack编译流程
    
    </summary>
    
      <category term="WebPack" scheme="http://asyncnode.com/categories/WebPack/"/>
    
    
      <category term="WebPack" scheme="http://asyncnode.com/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>webpack的依赖分析、依赖加载</title>
    <link href="http://asyncnode.com//blog/webpack-rely-load.html"/>
    <id>http://asyncnode.com//blog/webpack-rely-load.html</id>
    <published>2019-05-16T02:32:43.000Z</published>
    <updated>2019-06-03T02:36:32.704Z</updated>
    
    <summary type="html">
    
      webpack的依赖分析、依赖加载
    
    </summary>
    
      <category term="WebPack" scheme="http://asyncnode.com/categories/WebPack/"/>
    
    
      <category term="WebPack" scheme="http://asyncnode.com/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="http://asyncnode.com//blog/vue-router.html"/>
    <id>http://asyncnode.com//blog/vue-router.html</id>
    <published>2019-05-14T15:27:07.000Z</published>
    <updated>2019-05-15T01:37:16.894Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue中@click和@click.native的区别和实现、vue中eventBus的原理</title>
    <link href="http://asyncnode.com//blog/vue-click-eventbus.html"/>
    <id>http://asyncnode.com//blog/vue-click-eventbus.html</id>
    <published>2019-05-13T06:55:55.000Z</published>
    <updated>2019-05-13T07:05:07.512Z</updated>
    
    <summary type="html">
    
      这篇博客讲解vue中@click和@click.native的区别，和vue中eventBus的使用、原理分析。
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScirpt数据类型判断和数据结构判断</title>
    <link href="http://asyncnode.com//blog/jsistype.html"/>
    <id>http://asyncnode.com//blog/jsistype.html</id>
    <published>2019-05-11T14:24:23.000Z</published>
    <updated>2019-05-14T07:49:40.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型简介"><a href="#类型简介" class="headerlink" title="类型简介"></a>类型简介</h2><ul><li><p>在ECMAScript规范中，共定义了7种数据类型，分为基本数据类型和引用类型两大类，如下所示：</p><blockquote><p>基本类型： Null、Undefined、Symbol（ES6）、Number、Boolean、String<br>引用类型：Obeject、Array、Date</p></blockquote></li></ul><ul><li><p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在<font color="blue">栈</font>中，即按值访问。</p></li><li><p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在<font color="blue">堆(heap)</font>中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。</p></li></ul><h3 id="原始值-primitive-values"><a href="#原始值-primitive-values" class="headerlink" title="原始值( primitive values )"></a>原始值( primitive values )</h3><p>  除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。</p><p>  注: <strong>想看Java​Script 数据类型和数据结构 可以在： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">mdn</a>中查看</strong></p><p>  有四种方法可以判断Java​Script中的类型如：<br>  1、typeof运算符<br>  2、instanceof运算符<br>  3、constructor(原型对象的构造函数)<br>  4、toString(内置[[Class]]属性)、Array.isArray()<br>  下面就分别来讲一下他们能判断什么类型，判断不了什么类型，因为什么还有一些注意事项。</p><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><ul><li><h3 id="typeof语法"><a href="#typeof语法" class="headerlink" title="typeof语法"></a>typeof语法</h3><p>typeof运算符后跟操作数：</p><blockquote><p>typeof operand<br>or<br>typeof (operand)</p></blockquote></li><li><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>operand 是一个表达式，表示对象或<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive" target="_blank" rel="noopener">原始值</a>，其类型将被返回。</p><p>下面表格总结了typeof可能返回的值。</p><p>| 类型 | 结果 |<br>|:——–:|:——-:|<br>| Undefined | “undefined” |<br>| Null | “object” |<br>| Boolean | “boolean” |<br>| Number | “number” |<br>| String | “string” |<br>| Symbol （ECMAScript 6 新增） | “symbol” |<br>| 宿主对象（由JS环境提供） | Implementation-dependent |<br>| 函数对象（[[Call]] 在ECMA-262条款中实现了） | “function” |<br>| 任何其他对象 | “object” |</p></li><li><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'foo'</span>); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>; <span class="comment">// object </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;; <span class="comment">// object </span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>在这其中要注意的是：</p></li></ul><ul><li>其中null返回了object是因为JavaScript语言设计遗留的问题。</li><li>对于引用类型，除 function 以外，一律返回 object 类型</li><li>对于 function 返回 function</li></ul><ul><li><h3 id="typeof-null"><a href="#typeof-null" class="headerlink" title="typeof null"></a>typeof null</h3><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。由于 null 代表的是机器代码的空指针，一个对象类型的引用，值是零（大多数平台下值为 0x00）。自然前三位也是0，所以执行typeof时会返回”object”.</p><p>这个bug是第一版Javascript留下来的。在这个版本，数值是以32字节存储的，由标志位（1~3个字节）和数值组成。标志位存储的是低位的数据。这里有五种标志位：</p><ul><li>000：对象，数据是对象的应用。</li><li>1：整型，数据是31位带符号整数。</li><li>010：双精度类型，数据是双精度数字。</li><li>100：字符串，数据是字符串。</li><li>110：布尔类型，数据是布尔值。<br>最低位有一位，那么标志位只有一个1字节长度；或者是零位，标志位有3个字节长度，多出两个了字节，一共多出四种类型。</li></ul><p>注：<strong>原文地址<a href="http://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">英文</a></strong></p><pre><code>**翻译地址[中文](http://www.cnblogs.com/xiaoheimiaoer/p/4572558.html)**</code></pre><p>  <strong>判断null类型也很简单，就用null === null来判断</strong><br>  <strong>看typeof所有的类型细节请看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">mdn-typeof</a></strong></p></li></ul><h2 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h2><p>  instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置.<br>  原始值使用instanceof都会返回false，如果使用new 声明 是可以检测出来。对于是使用new声明的类型，它还可以检测出多层继承关系。</p><ul><li><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><ul><li>object instanceof constructor</li></ul></blockquote></li><li><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>object 要检测的对象<br>constructor 某个构造函数</p></li><li><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'123'</span>;</span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C(); </span><br><span class="line">c1 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(c1) === C.prototype</span></span><br><span class="line"></span><br><span class="line">C.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">c1 <span class="keyword">instanceof</span> C; <span class="comment">// false, C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c2 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(c2) === C.prototype</span></span><br><span class="line"></span><br><span class="line">c2.__proto__ = &#123;&#125;; <span class="comment">// 借助于非标准的__proto__伪属性</span></span><br><span class="line"></span><br><span class="line">c2 <span class="keyword">instanceof</span> C; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注：<strong>需要注意的是，如果表达式 obj instanceof Foo 返回true，则并不意味着该表达式会永远返回true，因为Foo.prototype属性的值有可能会改变，改变之后的值很有可能不存在于obj的原型链上，这时原表达式的值就会成为false。另外一种情况下，原表达式的值也会改变，就是改变对象obj的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的<strong>proto</strong>伪属性，是可以实现的。比如执行obj.<strong>proto</strong> = {}之后，obj instanceof Foo就会返回false了。</strong></p><ul><li><h3 id="、Array、Object-三者之间的关系："><a href="#、Array、Object-三者之间的关系：" class="headerlink" title="[]、Array、Object 三者之间的关系："></a>[]、Array、Object 三者之间的关系：</h3>从 instanceof 能够判断出 [ ].<strong>proto</strong>  指向 Array.prototype，而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，最终 Object.prototype.<strong>proto</strong> 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：<br><img src="../images/javascript/javascript1.png" alt="[]-Array-Object" width="60%" style="margin: 0 auto;"><br>从原型链可以看出，[] 的 <strong>proto</strong>  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。<strong>因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></li></ul></li><li><h3 id="instanceof和多全局对象-多个frame或多个window之间的交互"><a href="#instanceof和多全局对象-多个frame或多个window之间的交互" class="headerlink" title="instanceof和多全局对象(多个frame或多个window之间的交互)"></a>instanceof和多全局对象(多个frame或多个window之间的交互)</h3><p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回false，因为 Array.prototype !== window.frames[0].Array.prototype，并且数组从前者继承。</p><p>实际上你可以通过使用 Array.isArray(myObj) 或者Object.prototype.toString.call(myObj) === “[object Array]”来安全的检测传过来的对象是否是一个数组。</p></li><li><h3 id="实现一个简单的instanceof"><a href="#实现一个简单的instanceof" class="headerlink" title="实现一个简单的instanceof"></a>实现一个简单的instanceof</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L instanceof R</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123; <span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line">  <span class="keyword">var</span> O = R.prototype; <span class="comment">// 取的R的显式原型</span></span><br><span class="line">  L = L.__proto__; <span class="comment">// 取的L的隐式原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L === <span class="literal">null</span>) &#123; <span class="comment">// 已找到顶层</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (O === L) &#123; <span class="comment">// 当 O严格等于L时，返回true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L = L.__proto__; <span class="comment">// 继续向上一层原型链查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">instance_of([], <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line">instance_of([], <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="constructor-原型对象的构造函数"><a href="#constructor-原型对象的构造函数" class="headerlink" title="constructor(原型对象的构造函数)"></a>constructor(原型对象的构造函数)</h2><p>  当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示：<br>  <img src="../images/javascript/javascript2.png" alt="constructor" style="margin: 0 auto;"><br>  当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor === F.</p><p>  可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p><p>  实例<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.constructor === <span class="built_in">String</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="keyword">new</span> Data().constructor === <span class="built_in">Date</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><blockquote><ul><li>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断</li><li>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</li></ul></blockquote><p>  总结： <strong>手动设置或更新构造函数可能会导致不同且有时令人困惑的后果。为了防止它，只需在每个特定情况下定义构造函数的角色。在大多数情况下，不使用构造函数，并且不需要重新分配构造函数。</strong></p><h2 id="toString-内置-Class-属性"><a href="#toString-内置-Class-属性" class="headerlink" title="toString(内置[[Class]]属性)"></a>toString(内置[[Class]]属性)</h2><p>  原型上的toString() 方法返回一个表示该对象的字符串。<br>  调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。<br>  对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure></p><p>  注：<strong>但是它不能检测非原生构造函数的构造函数名。</strong><br>    jquery中的$.type原理就是通过Object.prototype.toString.call();<br>  Array.isArray其实也是通过[[Class]]来判定当前是否维数组.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  <strong>以上就是已知的4中检测类型的方法，那个方法都不识最完美的，就看你要检测的是那个对应的类型，就用对应的检测方法。</strong></p><p>  我们可以通过四种方式获取数据类型：</p><ul><li><font color="blue">typeof运算符，用来区分对象和原始值</font></li><li><font color="blue">instanceof运算符，用来分类对象</font></li><li><font color="blue">constructor，用来创建实例对象的 Object 构造函数的引用</font></li><li><font color="blue">[[Class]]是一个内部属性字符串，用来给对象分类</font><blockquote><p>参考：<a href="https://www.cnblogs.com/onepixel/p/5126046.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/5126046.html</a><br>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor</a><br>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString</a><br>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</a><br>参考：<a href="https://segmentfault.com/a/1190000015264821" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015264821</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      javascript中的类型判断又分为基础类型判断和引用类型多种判断方法
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue渲染父子组件中生命周期执行顺序</title>
    <link href="http://asyncnode.com//blog/vue-list-two.html"/>
    <id>http://asyncnode.com//blog/vue-list-two.html</id>
    <published>2019-05-07T05:40:21.000Z</published>
    <updated>2019-05-09T01:39:28.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>在另一片博客中我已经有详细讲过<a href="http://asyncnode.com/blog/vue-list-one.html">vue生命周期</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p @click=<span class="string">"setParentMessage"</span>&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;child :msg="parentMsgOne"&gt;&lt;/</span>child&gt;</span><br><span class="line">        &lt;child :msg=<span class="string">"parentMsgTwo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="https:/</span><span class="regexp">/cdn.bootcss.com/</span>vue/<span class="number">2.6</span><span class="number">.10</span>/vue.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        var mixins = &#123;</span></span><br><span class="line"><span class="string">            props: ['msg'],</span></span><br><span class="line"><span class="string">            template: '&lt;div&gt;from child: &#123;&#123;childMsg&#125;&#125; &lt;/div&gt;',</span></span><br><span class="line"><span class="string">            data: function () &#123;</span></span><br><span class="line"><span class="string">                return &#123;</span></span><br><span class="line"><span class="string">                    childMsg: this.msg</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeCreate() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---beforeCreate');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            created() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---created');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeMount() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---beforeMount');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            mounted() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---mounted');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeUpdate() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---beforeUpdate');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            updated() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---updated');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeDestroy() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---beforeDestroy');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            destroyed() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---destroyed');</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">        Vue.component('child', &#123;</span></span><br><span class="line"><span class="string">            mixins: [mixins]</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">        var vm = new Vue(&#123;</span></span><br><span class="line"><span class="string">            el: '#app',</span></span><br><span class="line"><span class="string">            data: function () &#123;</span></span><br><span class="line"><span class="string">                return &#123;</span></span><br><span class="line"><span class="string">                    parentMsgOne: 'childrenOne',</span></span><br><span class="line"><span class="string">                    parentMsgTwo: 'childrenTwo',</span></span><br><span class="line"><span class="string">                    message: 'parent'</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            methods: &#123;</span></span><br><span class="line"><span class="string">                setParentMessage: function () &#123;</span></span><br><span class="line"><span class="string">                    this.message = 'parent--message--更新';</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeCreate() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---beforeCreate');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            created() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---created');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeMount() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---beforeMount');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            mounted() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---mounted');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeUpdate() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---beforeUpdate');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            updated() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---updated');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeDestroy() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---beforeDestroy');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            destroyed() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---destroyed');</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>代码执行结果如下：<br><img src="../images/vue/vue-hook4.png" alt="vue-hook" width="100%" style="margin: 0 auto;"></p><h3 id="beforeCreate-到-mounted"><a href="#beforeCreate-到-mounted" class="headerlink" title=" beforeCreate 到 mounted  "></a><strong> beforeCreate 到 mounted  </strong></h3><p>1、先创建父组件<br>beforeCreate<br>created<br>beforeMount<br>2、按顺序创建子组件<br>beforeCreate<br>created<br>beforeMount<br>3、先挂载子组件<br>mounted<br>4、在挂载父组件<br>mounted</p><p>总结：<font color="blue">从创建到挂载，是从外到内，再由内到外</font></p><h3 id="beforeUpdate-到-updated"><a href="#beforeUpdate-到-updated" class="headerlink" title=" beforeUpdate 到 updated "></a><strong> beforeUpdate 到 updated </strong></h3><p>注： <font color="blue">只有在标签上绑定了data时，data发生改变，才会触发updated钩子函数。如果只是在控制台改变data，而没有反馈到视图上，则无法触发。</font><br>1、父组件点击事件更新data中的数据<br><img src="../images/vue/vue-hook5.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>他不会重新渲染子组件<br>注：<font color="blue">react中如果父组件状态更新，子组件也会跟着更新。稍后的文章会讲怎么解决这种问题。</font><br>2、子组件点击事件更新data中的数据<br><img src="../images/vue/vue-hook6.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>这个他也不会重新选然父组件</p><p>注： <font color="blue">如果是mixins的话当data中的数据改变时，不会触发子组件中的updated函数。触发的顺序仍然是mixins先于组件</font><br>总结：<font color="blue">父子组件update互相不影响</font></p><h3 id="beforeDestroy-到-destroy"><a href="#beforeDestroy-到-destroy" class="headerlink" title=" beforeDestroy 到 destroy "></a><strong> beforeDestroy 到 destroy </strong></h3><p>在浏览器中执行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$destroy();</span><br></pre></td></tr></table></figure></p><p><img src="../images/vue/vue-hook7.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>1、父组件先beforeDestroy<br>2、子组件beforeDestroy<br>3、子组件destroyed<br>4、父组件destroyed<br>总结：<font color="blue">从外到内，再从内到外</font></p><font color="blue"><strong>总结：生命周期遵从“从外到内，再从内到外，mixins先于组件”的原则。</strong></font>]]></content>
    
    <summary type="html">
    
      如果是嵌套组件那么父组件和子组件的各个生命周期的执行顺序。
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期详解。</title>
    <link href="http://asyncnode.com//blog/vue-list-one.html"/>
    <id>http://asyncnode.com//blog/vue-list-one.html</id>
    <published>2019-05-04T05:37:58.000Z</published>
    <updated>2019-05-08T10:04:09.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p><a href="http://asyncnode.com/blog/vue-list-two.html">vue父子组件渲染生命周期执行循序</a></p><h3 id="Vue声明周期表格"><a href="#Vue声明周期表格" class="headerlink" title="Vue声明周期表格"></a>Vue声明周期表格</h3><p>一说到Vue的生命周期，大家都能说上来一点.我自己会随着自己对Vue的深入了解，不断的完善自己对Vue的整体认识。<br>本文Vue的版本 <font color="blue">Vue 2.x</font> 官方生命周期图解：<br><!-- ![vue-hook]( 200x800) --><br><img src="../images/vue/vue-hook.png" alt="vue-hook" width="60%" style="margin: 0 auto;"></p><table><thead><tr><th style="text-align:center">生命周期钩子</th><th style="text-align:center">详细</th></tr></thead><tbody><tr><td style="text-align:center">beforeCreate</td><td style="text-align:center">在实例初始化之后，数据观测(data observer) 和 event/watcher事件配置之前被调用。</td></tr><tr><td style="text-align:center">created</td><td style="text-align:center">在实例创建完成后被立即调用。在这一步,实例已经完成以下配置：数据观测（data observer），属性和方法的运算，watch/event事件回调。然而，挂载阶段还没有开始，<font color="blue">$el</font>属性目前不可见。</td></tr><tr><td style="text-align:center">beforeMount</td><td style="text-align:center">在挂载开始之前被调用：相关的 <font color="blue">render</font> 函数首次被调用。<strong>该钩子在服务器端渲染期间不被调用。</strong></td></tr><tr><td style="text-align:center">mounted</td><td style="text-align:center"><font color="blue">el</font>被新创建的<font color="blue">vm.$el</font>替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 <br> 注意 mounted <strong>不会</strong> 承诺所有的子组件也一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td></tr><tr><td style="text-align:center">beforeUpdate</td><td style="text-align:center">数据更新时调用，发生在虚拟DOM打补丁之前。这里适合在更新之前访问现在的DOM，比如手动移除已添加的事件监听器。<strong>该钩子在服务器渲染期间不被调用，因为只有初次渲染会在服务器端运行</strong></td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">由于数据更改导致的虚拟dom重新渲染和打补丁，在这之后会调用该钩子。<br> 当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然后在大多数情况下，你应该避免在此期间更改状态。如果要相应的状态改变，通常最好使用 <a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener"><font color="blue">计算属性</font></a>或<a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener"><font color="blue">watcher</font></a>取而代之。 <br> 注意 <font color="blue">updated</font> 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 <font color="blue">updated</font>。</td></tr><tr><td style="text-align:center">beforeDestory</td><td style="text-align:center">实例销毁之前调用。在这一步，实例仍然完全可用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td></tr><tr><td style="text-align:center">destoryed</td><td style="text-align:center">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p @click=<span class="string">"setMessage"</span>&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">'Vue的生命周期'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        setMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.message = <span class="string">'updateMessage'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------beforeCreate创建前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// undefined</span></span><br><span class="line">      &#125;,</span><br><span class="line">      created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------created创建完毕状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data); <span class="comment">// Object ** 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message); <span class="comment">// Vue的生命周期 ** 已经初始化</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 当不存在el的时候只会执行到前面两个生命周期</span></span><br><span class="line">      beforeMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------beforeMount挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// 已经初始化</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mounted() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------mounted挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// 已经初始化</span></span><br><span class="line">      &#125;,</span><br><span class="line">      beforeUpdate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------beforeUpdate挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span><br><span class="line">      &#125;,</span><br><span class="line">      updated() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------updated挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeDestroy() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------beforeDestroy挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span><br><span class="line">      &#125;,</span><br><span class="line">      destroyed() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------destroyed挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong> 1、beforeMount生命周期之前 </strong><br><img src="../images/vue/vue-hook1.png" alt="vue-hook" width="60%" style="margin: 0 auto;"><br>在这个调用<font color="blue">beforeMount</font>判断vm.$options是否存在<font color="blue">el</font>，如果没有的话则会<font color="blue">停止编译</font>，也就意味着<font color="blue">停止了生命周期</font>，直到在改vue实例上调用<font color="blue">vm.$mount(el)</font>。<br>vue的实现代码：如果存在el时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原型上的$mount实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm,</span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  vm.$el = el;</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们注释掉上面el属性的代码,并且不再后续调用vm.$mount(el)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// el: '#app'</span></span><br></pre></td></tr></table></figure></p><p>如果没有el他只会执行前两个生命周期<font color="blue">beforeCreate、created</font>，如果我们在后续调用了<font color="blue">vm.$mount(el)</font>，可以发现代码继续向下执行了<br>在浏览器上调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure></p><p>他就会接着执行下去</p><p><strong> 2、template属性、outer html、render函数三个优先级 </strong><br>（1）如果直接调用render函数，那么他的优先级最高。<br>（2）如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。<br>（3）如果没有template选项，则将外部HTML作为模板编译。<br>（4）可以看到template中的模板优先级要高于outer HTML的优先级。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    <span class="comment">// 如果render、template都不存在 会显示这个</span></span><br><span class="line">    &lt;p&gt;&#123;&#123;message + <span class="string">'这是在outer HTML中的'</span>&#125;&#125;&lt;<span class="regexp">/p&gt; </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 如果三个都存在 最终会显示 &lt;h1&gt;this is createElement&lt;/</span>h1&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script src="https:/</span><span class="regexp">/cdn.bootcss.com/</span>vue/<span class="number">2.6</span><span class="number">.10</span>/vue.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="string">      el: '#app',</span></span><br><span class="line"><span class="string">      template: "</span>&lt;h1&gt;&#123;&#123;message +<span class="string">'这是在template中的'</span>&#125;&#125;&lt;<span class="regexp">/h1&gt;", /</span><span class="regexp">/ 如果render不存在 只有 template 会显示这个</span></span><br><span class="line"><span class="regexp">      data: &#123;</span></span><br><span class="line"><span class="regexp">        message: 'Vue的生命周期'</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      render: function (createElement) &#123;</span></span><br><span class="line"><span class="regexp">        return createElement('h1', 'this is createElement')</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></p><p><strong>3、mounted</strong><br>可以看到此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到beforeMount之前el上还是undefined</p><p><strong>4、mounted</strong><br>在mounted之前h1中还是通过进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化。</p><p><strong>5、beforeUpdate和updated</strong><br>当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。我们点击当前的p标签就会触发data中的message更新</p><p><strong>6、beforeDestroy和destroyed</strong><br>beforeDestroy 钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。<br>destroyed 钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><p>参考：<a href="https://segmentfault.com/a/1190000011381906?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011381906?utm_source=tag-newest</a><br>      <a href="https://juejin.im/post/5c6d48e36fb9a049eb3c84ff" target="_blank" rel="noopener">https://juejin.im/post/5c6d48e36fb9a049eb3c84ff</a></p>]]></content>
    
    <summary type="html">
    
      总结一下Vue生命周期，还有Vue是怎么渲染父子组件的，那些生命周期父组件先执行，那些生命周期在子组件先执行。
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>css-flex</title>
    <link href="http://asyncnode.com//blog/css-flex.html"/>
    <id>http://asyncnode.com//blog/css-flex.html</id>
    <published>2019-05-02T06:51:36.000Z</published>
    <updated>2019-05-07T06:54:37.451Z</updated>
    
    <summary type="html">
    
      css3中的flex布局详解
    
    </summary>
    
      <category term="css" scheme="http://asyncnode.com/categories/css/"/>
    
    
      <category term="css" scheme="http://asyncnode.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>react-hot</title>
    <link href="http://asyncnode.com//blog/react-hot.html"/>
    <id>http://asyncnode.com//blog/react-hot.html</id>
    <published>2019-04-30T02:36:56.000Z</published>
    <updated>2019-04-30T02:36:56.739Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-parse</title>
    <link href="http://asyncnode.com//blog/vue-parse.html"/>
    <id>http://asyncnode.com//blog/vue-parse.html</id>
    <published>2019-04-26T08:14:45.000Z</published>
    <updated>2019-04-26T08:14:45.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-complier</title>
    <link href="http://asyncnode.com//blog/vue-complier.html"/>
    <id>http://asyncnode.com//blog/vue-complier.html</id>
    <published>2019-04-23T13:50:49.000Z</published>
    <updated>2019-04-26T08:13:43.555Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>simple-vue-mvvm</title>
    <link href="http://asyncnode.com//blog/simple-vue-mvvm.html"/>
    <id>http://asyncnode.com//blog/simple-vue-mvvm.html</id>
    <published>2019-04-18T08:16:55.000Z</published>
    <updated>2019-04-26T08:19:41.002Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>evenloop</title>
    <link href="http://asyncnode.com//blog/evenloop.html"/>
    <id>http://asyncnode.com//blog/evenloop.html</id>
    <published>2019-04-15T08:42:11.000Z</published>
    <updated>2019-04-26T08:13:43.555Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
