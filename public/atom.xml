<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asyncnode</title>
  
  <subtitle>asyncnode</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://asyncnode.com/"/>
  <updated>2019-05-13T07:05:07.512Z</updated>
  <id>http://asyncnode.com/</id>
  
  <author>
    <name>Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue中@click和@click.native的区别和实现、vue中eventBus的原理</title>
    <link href="http://asyncnode.com//blog/vue-click-eventbus.html"/>
    <id>http://asyncnode.com//blog/vue-click-eventbus.html</id>
    <published>2019-05-13T06:55:55.000Z</published>
    <updated>2019-05-13T07:05:07.512Z</updated>
    
    <summary type="html">
    
      这篇博客讲解vue中@click和@click.native的区别，和vue中eventBus的使用、原理分析。
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScirpt数据类型判断和数据结构判断</title>
    <link href="http://asyncnode.com//blog/jsistype.html"/>
    <id>http://asyncnode.com//blog/jsistype.html</id>
    <published>2019-05-11T14:24:23.000Z</published>
    <updated>2019-05-13T06:59:19.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型简介"><a href="#类型简介" class="headerlink" title="类型简介"></a>类型简介</h2><p>在ECMAScript规范中，共定义了7种数据类型，分为基本数据类型和引用类型两大类，如下所示：</p><blockquote><p>基本类型： Null、Undefined、Symbol（ES6）、Number、Boolean、String<br>引用类型：Obeject、Array、Date</p></blockquote><ul><li><p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在<font color="blue">栈</font>中，即按值访问。</p></li><li><p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在<font color="blue">堆(heap)</font>中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。</p></li></ul><h3 id="原始值-primitive-values"><a href="#原始值-primitive-values" class="headerlink" title="原始值( primitive values )"></a>原始值( primitive values )</h3><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。</p><p>注: 想看Java​Script 数据类型和数据结构 可以在： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">mdn</a>中查看</p><p>有四种方法可以判断Java​Script中的类型如：<br>1、typeof运算符<br>2、instanceof运算符<br>3、constructor(原型对象的构造函数)<br>4、toString(内置[[Class]]属性)、Array.isArray()<br>下面就分别来讲一下他们能判断什么类型，判断不了什么类型，因为什么还有一些注意事项。</p><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p><strong>typeof语法</strong></p><p>typeof运算符后跟操作数：</p><blockquote><p>typeof operand<br>or<br>typeof (operand)</p></blockquote><p><strong>参数</strong><br>operand 是一个表达式，表示对象或<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive" target="_blank" rel="noopener">原始值</a>，其类型将被返回。</p><p>下面表格总结了typeof可能返回的值。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">Undefined</td><td style="text-align:center">“undefined”</td></tr><tr><td style="text-align:center">Null</td><td style="text-align:center">“object”</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">“boolean”</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:center">“number”</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">“string”</td></tr><tr><td style="text-align:center">Symbol （ECMAScript 6 新增）</td><td style="text-align:center">“symbol”</td></tr><tr><td style="text-align:center">宿主对象（由JS环境提供）</td><td style="text-align:center">Implementation-dependent</td></tr><tr><td style="text-align:center">函数对象（[[Call]] 在ECMA-262条款中实现了）</td><td style="text-align:center">“function”</td></tr><tr><td style="text-align:center">任何其他对象</td><td style="text-align:center">“object”</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'foo'</span>); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>; <span class="comment">// object </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;; <span class="comment">// object </span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>在这其中要注意的是：</p><ul><li>其中null返回了object是因为JavaScript语言设计遗留的问题。</li><li>对于引用类型，除 function 以外，一律返回 object 类型</li><li>对于 function 返回 function</li></ul><p><strong>typeof null</strong></p><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。由于 null 代表的是机器代码的空指针，一个对象类型的引用，值是零（大多数平台下值为 0x00）。自然前三位也是0，所以执行typeof时会返回”object”.</p><p>这个bug是第一版Javascript留下来的。在这个版本，数值是以32字节存储的，由标志位（1~3个字节）和数值组成。标志位存储的是低位的数据。这里有五种标志位：</p><ul><li>000：对象，数据是对象的应用。</li><li>1：整型，数据是31位带符号整数。</li><li>010：双精度类型，数据是双精度数字。</li><li>100：字符串，数据是字符串。</li><li>110：布尔类型，数据是布尔值。<br>最低位有一位，那么标志位只有一个1字节长度；或者是零位，标志位有3个字节长度，多出两个了字节，一共多出四种类型。</li></ul><p>注：原文地址<a href="http://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">英文</a><br>    翻译地址<a href="http://www.cnblogs.com/xiaoheimiaoer/p/4572558.html" target="_blank" rel="noopener">中文</a></p><p>判断null类型也很简单，就用null === null来判断<br>看typeof所有的类型细节请看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">mdn-typeof</a></p><h2 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h2><p>instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置.<br>原始值使用instanceof都会返回false，如果使用new 声明 是可以检测出来。对于是使用new声明的类型，它还可以检测出多层继承关系。</p><p><strong>语法</strong></p><blockquote><ul><li>object instanceof constructor</li></ul></blockquote><p><strong>参数</strong><br>object 要检测的对象<br>constructor 某个构造函数</p><p><strong>实例</strong><br>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'123'</span>;</span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C(); </span><br><span class="line">c1 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(c1) === C.prototype</span></span><br><span class="line"></span><br><span class="line">C.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">c1 <span class="keyword">instanceof</span> C; <span class="comment">// false, C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c2 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(c2) === C.prototype</span></span><br><span class="line"></span><br><span class="line">c2.__proto__ = &#123;&#125;; <span class="comment">// 借助于非标准的__proto__伪属性</span></span><br><span class="line"></span><br><span class="line">c2 <span class="keyword">instanceof</span> C; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注：需要注意的是，如果表达式 obj instanceof Foo 返回true，则并不意味着该表达式会永远返回true，因为Foo.prototype属性的值有可能会改变，改变之后的值很有可能不存在于obj的原型链上，这时原表达式的值就会成为false。另外一种情况下，原表达式的值也会改变，就是改变对象obj的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的<strong>proto</strong>伪属性，是可以实现的。比如执行obj.<strong>proto</strong> = {}之后，obj instanceof Foo就会返回false了。</p><p><strong> []、Array、Object 三者之间的关系：</strong><br>从 instanceof 能够判断出 [ ].<strong>proto</strong>  指向 Array.prototype，而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，最终 Object.prototype.<strong>proto</strong> 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：<br><img src="../images/javascript/javascript1.png" alt="[]-Array-Object" width="60%" style="margin: 0 auto;"><br>从原型链可以看出，[] 的 <strong>proto</strong>  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。<strong>因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p><p><strong>instanceof和多全局对象(多个frame或多个window之间的交互)</strong><br>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回false，因为 Array.prototype !== window.frames[0].Array.prototype，并且数组从前者继承。</p><p>实际上你可以通过使用 Array.isArray(myObj) 或者Object.prototype.toString.call(myObj) === “[object Array]”来安全的检测传过来的对象是否是一个数组。</p><h2 id="constructor-原型对象的构造函数"><a href="#constructor-原型对象的构造函数" class="headerlink" title="constructor(原型对象的构造函数)"></a>constructor(原型对象的构造函数)</h2><p>当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示：<br><img src="../images/javascript/javascript2.png" alt="constructor" style="margin: 0 auto;"><br>当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor === F.</p><p>可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p><p>实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.constructor === <span class="built_in">String</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="keyword">new</span> Data().constructor === <span class="built_in">Date</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><blockquote><ul><li>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断</li><li>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</li></ul></blockquote><p><strong>总结：</strong> 手动设置或更新构造函数可能会导致不同且有时令人困惑的后果。为了防止它，只需在每个特定情况下定义构造函数的角色。在大多数情况下，不使用构造函数，并且不需要重新分配构造函数。</p><h2 id="toString-内置-Class-属性"><a href="#toString-内置-Class-属性" class="headerlink" title="toString(内置[[Class]]属性)"></a>toString(内置[[Class]]属性)</h2><p>原型上的toString() 方法返回一个表示该对象的字符串。<br>调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。<br>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure></p><p>注：但是它不能检测非原生构造函数的构造函数名。<br>  jquery中的$.type原理就是通过Object.prototype.toString.call();<br>Array.isArray其实也是通过[[Class]]来判定当前是否维数组.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是已知的4中检测类型的方法，那个方法都不识最完美的，就看你要检测的是那个对应的类型，就用对应的检测方法。</p><p>我们可以通过四种方式获取数据类型：</p><ul><li>typeof运算符，用来区分对象和原始值</li><li>instanceof运算符，用来分类对象</li><li>constructor，用来创建实例对象的 Object 构造函数的引用</li><li>[[Class]]是一个内部属性字符串，用来给对象分类</li></ul><blockquote><p>参考：<a href="https://www.cnblogs.com/onepixel/p/5126046.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/5126046.html</a><br>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor</a><br>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString</a><br>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</a><br>参考：<a href="https://segmentfault.com/a/1190000015264821" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015264821</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      javascript中的类型判断又分为基础类型判断和引用类型多种判断方法
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue渲染父子组件中生命周期执行顺序</title>
    <link href="http://asyncnode.com//blog/vue-list-two.html"/>
    <id>http://asyncnode.com//blog/vue-list-two.html</id>
    <published>2019-05-07T05:40:21.000Z</published>
    <updated>2019-05-09T01:39:28.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>在另一片博客中我已经有详细讲过<a href="http://asyncnode.com/blog/vue-list-one.html">vue生命周期</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p @click=<span class="string">"setParentMessage"</span>&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;child :msg="parentMsgOne"&gt;&lt;/</span>child&gt;</span><br><span class="line">        &lt;child :msg=<span class="string">"parentMsgTwo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="https:/</span><span class="regexp">/cdn.bootcss.com/</span>vue/<span class="number">2.6</span><span class="number">.10</span>/vue.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        var mixins = &#123;</span></span><br><span class="line"><span class="string">            props: ['msg'],</span></span><br><span class="line"><span class="string">            template: '&lt;div&gt;from child: &#123;&#123;childMsg&#125;&#125; &lt;/div&gt;',</span></span><br><span class="line"><span class="string">            data: function () &#123;</span></span><br><span class="line"><span class="string">                return &#123;</span></span><br><span class="line"><span class="string">                    childMsg: this.msg</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeCreate() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---beforeCreate');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            created() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---created');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeMount() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---beforeMount');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            mounted() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---mounted');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeUpdate() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---beforeUpdate');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            updated() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---updated');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeDestroy() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---beforeDestroy');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            destroyed() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", this.childMsg + '---destroyed');</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">        Vue.component('child', &#123;</span></span><br><span class="line"><span class="string">            mixins: [mixins]</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">        var vm = new Vue(&#123;</span></span><br><span class="line"><span class="string">            el: '#app',</span></span><br><span class="line"><span class="string">            data: function () &#123;</span></span><br><span class="line"><span class="string">                return &#123;</span></span><br><span class="line"><span class="string">                    parentMsgOne: 'childrenOne',</span></span><br><span class="line"><span class="string">                    parentMsgTwo: 'childrenTwo',</span></span><br><span class="line"><span class="string">                    message: 'parent'</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            methods: &#123;</span></span><br><span class="line"><span class="string">                setParentMessage: function () &#123;</span></span><br><span class="line"><span class="string">                    this.message = 'parent--message--更新';</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeCreate() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---beforeCreate');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            created() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---created');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeMount() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---beforeMount');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            mounted() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---mounted');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeUpdate() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---beforeUpdate');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            updated() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---updated');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            beforeDestroy() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---beforeDestroy');</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            destroyed() &#123;</span></span><br><span class="line"><span class="string">                console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">", 'parent---destroyed');</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>代码执行结果如下：<br><img src="../images/vue/vue-hook4.png" alt="vue-hook" width="100%" style="margin: 0 auto;"></p><h3 id="beforeCreate-到-mounted"><a href="#beforeCreate-到-mounted" class="headerlink" title=" beforeCreate 到 mounted  "></a><strong> beforeCreate 到 mounted  </strong></h3><p>1、先创建父组件<br>beforeCreate<br>created<br>beforeMount<br>2、按顺序创建子组件<br>beforeCreate<br>created<br>beforeMount<br>3、先挂载子组件<br>mounted<br>4、在挂载父组件<br>mounted</p><p>总结：<font color="blue">从创建到挂载，是从外到内，再由内到外</font></p><h3 id="beforeUpdate-到-updated"><a href="#beforeUpdate-到-updated" class="headerlink" title=" beforeUpdate 到 updated "></a><strong> beforeUpdate 到 updated </strong></h3><p>注： <font color="blue">只有在标签上绑定了data时，data发生改变，才会触发updated钩子函数。如果只是在控制台改变data，而没有反馈到视图上，则无法触发。</font><br>1、父组件点击事件更新data中的数据<br><img src="../images/vue/vue-hook5.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>他不会重新渲染子组件<br>注：<font color="blue">react中如果父组件状态更新，子组件也会跟着更新。稍后的文章会讲怎么解决这种问题。</font><br>2、子组件点击事件更新data中的数据<br><img src="../images/vue/vue-hook6.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>这个他也不会重新选然父组件</p><p>注： <font color="blue">如果是mixins的话当data中的数据改变时，不会触发子组件中的updated函数。触发的顺序仍然是mixins先于组件</font><br>总结：<font color="blue">父子组件update互相不影响</font></p><h3 id="beforeDestroy-到-destroy"><a href="#beforeDestroy-到-destroy" class="headerlink" title=" beforeDestroy 到 destroy "></a><strong> beforeDestroy 到 destroy </strong></h3><p>在浏览器中执行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$destroy();</span><br></pre></td></tr></table></figure></p><p><img src="../images/vue/vue-hook7.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>1、父组件先beforeDestroy<br>2、子组件beforeDestroy<br>3、子组件destroyed<br>4、父组件destroyed<br>总结：<font color="blue">从外到内，再从内到外</font></p><font color="blue"><strong>总结：生命周期遵从“从外到内，再从内到外，mixins先于组件”的原则。</strong></font>]]></content>
    
    <summary type="html">
    
      如果是嵌套组件那么父组件和子组件的各个生命周期的执行顺序。
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期详解。</title>
    <link href="http://asyncnode.com//blog/vue-list-one.html"/>
    <id>http://asyncnode.com//blog/vue-list-one.html</id>
    <published>2019-05-04T05:37:58.000Z</published>
    <updated>2019-05-08T10:04:09.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p><a href="http://asyncnode.com/blog/vue-list-two.html">vue父子组件渲染生命周期执行循序</a></p><h3 id="Vue声明周期表格"><a href="#Vue声明周期表格" class="headerlink" title="Vue声明周期表格"></a>Vue声明周期表格</h3><p>一说到Vue的生命周期，大家都能说上来一点.我自己会随着自己对Vue的深入了解，不断的完善自己对Vue的整体认识。<br>本文Vue的版本 <font color="blue">Vue 2.x</font> 官方生命周期图解：<br><!-- ![vue-hook]( 200x800) --><br><img src="../images/vue/vue-hook.png" alt="vue-hook" width="60%" style="margin: 0 auto;"></p><table><thead><tr><th style="text-align:center">生命周期钩子</th><th style="text-align:center">详细</th></tr></thead><tbody><tr><td style="text-align:center">beforeCreate</td><td style="text-align:center">在实例初始化之后，数据观测(data observer) 和 event/watcher事件配置之前被调用。</td></tr><tr><td style="text-align:center">created</td><td style="text-align:center">在实例创建完成后被立即调用。在这一步,实例已经完成以下配置：数据观测（data observer），属性和方法的运算，watch/event事件回调。然而，挂载阶段还没有开始，<font color="blue">$el</font>属性目前不可见。</td></tr><tr><td style="text-align:center">beforeMount</td><td style="text-align:center">在挂载开始之前被调用：相关的 <font color="blue">render</font> 函数首次被调用。<strong>该钩子在服务器端渲染期间不被调用。</strong></td></tr><tr><td style="text-align:center">mounted</td><td style="text-align:center"><font color="blue">el</font>被新创建的<font color="blue">vm.$el</font>替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 <br> 注意 mounted <strong>不会</strong> 承诺所有的子组件也一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td></tr><tr><td style="text-align:center">beforeUpdate</td><td style="text-align:center">数据更新时调用，发生在虚拟DOM打补丁之前。这里适合在更新之前访问现在的DOM，比如手动移除已添加的事件监听器。<strong>该钩子在服务器渲染期间不被调用，因为只有初次渲染会在服务器端运行</strong></td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">由于数据更改导致的虚拟dom重新渲染和打补丁，在这之后会调用该钩子。<br> 当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然后在大多数情况下，你应该避免在此期间更改状态。如果要相应的状态改变，通常最好使用 <a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener"><font color="blue">计算属性</font></a>或<a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener"><font color="blue">watcher</font></a>取而代之。 <br> 注意 <font color="blue">updated</font> 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 <font color="blue">updated</font>。</td></tr><tr><td style="text-align:center">beforeDestory</td><td style="text-align:center">实例销毁之前调用。在这一步，实例仍然完全可用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td></tr><tr><td style="text-align:center">destoryed</td><td style="text-align:center">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p @click=<span class="string">"setMessage"</span>&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">'Vue的生命周期'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        setMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.message = <span class="string">'updateMessage'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------beforeCreate创建前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// undefined</span></span><br><span class="line">      &#125;,</span><br><span class="line">      created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------created创建完毕状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data); <span class="comment">// Object ** 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message); <span class="comment">// Vue的生命周期 ** 已经初始化</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 当不存在el的时候只会执行到前面两个生命周期</span></span><br><span class="line">      beforeMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------beforeMount挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// 已经初始化</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mounted() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------mounted挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// 已经初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// 已经初始化</span></span><br><span class="line">      &#125;,</span><br><span class="line">      beforeUpdate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------beforeUpdate挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span><br><span class="line">      &#125;,</span><br><span class="line">      updated() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------updated挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeDestroy() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------beforeDestroy挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span><br><span class="line">      &#125;,</span><br><span class="line">      destroyed() &#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'------destroyed挂载前状态------'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong> 1、beforeMount生命周期之前 </strong><br><img src="../images/vue/vue-hook1.png" alt="vue-hook" width="60%" style="margin: 0 auto;"><br>在这个调用<font color="blue">beforeMount</font>判断vm.$options是否存在<font color="blue">el</font>，如果没有的话则会<font color="blue">停止编译</font>，也就意味着<font color="blue">停止了生命周期</font>，直到在改vue实例上调用<font color="blue">vm.$mount(el)</font>。<br>vue的实现代码：如果存在el时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原型上的$mount实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm,</span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  vm.$el = el;</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们注释掉上面el属性的代码,并且不再后续调用vm.$mount(el)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// el: '#app'</span></span><br></pre></td></tr></table></figure></p><p>如果没有el他只会执行前两个生命周期<font color="blue">beforeCreate、created</font>，如果我们在后续调用了<font color="blue">vm.$mount(el)</font>，可以发现代码继续向下执行了<br>在浏览器上调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure></p><p>他就会接着执行下去</p><p><strong> 2、template属性、outer html、render函数三个优先级 </strong><br>（1）如果直接调用render函数，那么他的优先级最高。<br>（2）如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。<br>（3）如果没有template选项，则将外部HTML作为模板编译。<br>（4）可以看到template中的模板优先级要高于outer HTML的优先级。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    <span class="comment">// 如果render、template都不存在 会显示这个</span></span><br><span class="line">    &lt;p&gt;&#123;&#123;message + <span class="string">'这是在outer HTML中的'</span>&#125;&#125;&lt;<span class="regexp">/p&gt; </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 如果三个都存在 最终会显示 &lt;h1&gt;this is createElement&lt;/</span>h1&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script src="https:/</span><span class="regexp">/cdn.bootcss.com/</span>vue/<span class="number">2.6</span><span class="number">.10</span>/vue.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="string">      el: '#app',</span></span><br><span class="line"><span class="string">      template: "</span>&lt;h1&gt;&#123;&#123;message +<span class="string">'这是在template中的'</span>&#125;&#125;&lt;<span class="regexp">/h1&gt;", /</span><span class="regexp">/ 如果render不存在 只有 template 会显示这个</span></span><br><span class="line"><span class="regexp">      data: &#123;</span></span><br><span class="line"><span class="regexp">        message: 'Vue的生命周期'</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      render: function (createElement) &#123;</span></span><br><span class="line"><span class="regexp">        return createElement('h1', 'this is createElement')</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></p><p><strong>3、mounted</strong><br>可以看到此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到beforeMount之前el上还是undefined</p><p><strong>4、mounted</strong><br>在mounted之前h1中还是通过进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化。</p><p><strong>5、beforeUpdate和updated</strong><br>当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。我们点击当前的p标签就会触发data中的message更新</p><p><strong>6、beforeDestroy和destroyed</strong><br>beforeDestroy 钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。<br>destroyed 钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><p>参考：<a href="https://segmentfault.com/a/1190000011381906?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011381906?utm_source=tag-newest</a><br>      <a href="https://juejin.im/post/5c6d48e36fb9a049eb3c84ff" target="_blank" rel="noopener">https://juejin.im/post/5c6d48e36fb9a049eb3c84ff</a></p>]]></content>
    
    <summary type="html">
    
      总结一下Vue生命周期，还有Vue是怎么渲染父子组件的，那些生命周期父组件先执行，那些生命周期在子组件先执行。
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>css-flex</title>
    <link href="http://asyncnode.com//blog/css-flex.html"/>
    <id>http://asyncnode.com//blog/css-flex.html</id>
    <published>2019-05-02T06:51:36.000Z</published>
    <updated>2019-05-07T06:54:37.451Z</updated>
    
    <summary type="html">
    
      css3中的flex布局详解
    
    </summary>
    
      <category term="css" scheme="http://asyncnode.com/categories/css/"/>
    
    
      <category term="css" scheme="http://asyncnode.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>react-hot</title>
    <link href="http://asyncnode.com//blog/react-hot.html"/>
    <id>http://asyncnode.com//blog/react-hot.html</id>
    <published>2019-04-30T02:36:56.000Z</published>
    <updated>2019-04-30T02:36:56.739Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-parse</title>
    <link href="http://asyncnode.com//blog/vue-parse.html"/>
    <id>http://asyncnode.com//blog/vue-parse.html</id>
    <published>2019-04-26T08:14:45.000Z</published>
    <updated>2019-04-26T08:14:45.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-complier</title>
    <link href="http://asyncnode.com//blog/vue-complier.html"/>
    <id>http://asyncnode.com//blog/vue-complier.html</id>
    <published>2019-04-23T13:50:49.000Z</published>
    <updated>2019-04-26T08:13:43.555Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>simple-vue-mvvm</title>
    <link href="http://asyncnode.com//blog/simple-vue-mvvm.html"/>
    <id>http://asyncnode.com//blog/simple-vue-mvvm.html</id>
    <published>2019-04-18T08:16:55.000Z</published>
    <updated>2019-04-26T08:19:41.002Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>evenloop</title>
    <link href="http://asyncnode.com//blog/evenloop.html"/>
    <id>http://asyncnode.com//blog/evenloop.html</id>
    <published>2019-04-15T08:42:11.000Z</published>
    <updated>2019-04-26T08:13:43.555Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>arrow-functions（箭头函数）和普通的函数的区别</title>
    <link href="http://asyncnode.com//blog/arrow-functions.html"/>
    <id>http://asyncnode.com//blog/arrow-functions.html</id>
    <published>2019-04-10T08:53:14.000Z</published>
    <updated>2019-04-26T08:13:43.554Z</updated>
    
    <content type="html"><![CDATA[<p>在用vue框架、或者react框架中我们会用到很多es6中的新特性，比较多的就是<font color="blue">箭头函数</font>.都会知道一点普通函数和箭头函数的区别,这里总结一下箭头函数和普通函数的区别：</p><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">普通函数</th><th style="text-align:center">箭头函数</th></tr></thead><tbody><tr><td style="text-align:center">this指向规则</td><td style="text-align:center">this总是指向调用它的那个对象</td><td style="text-align:center">1.所有箭头函数本身没有this <br>2.箭头函数的this在定义的时候捕获自外层第一个普通函数的this <br> 3.如果箭头函数外层没有普通函数,严格模式和非严格模式下它的this都会指向window(全局对象)</td></tr><tr><td style="text-align:center">有无prototype</td><td style="text-align:center">有</td><td style="text-align:center">箭头函数没有<font color="blue">prototype</font>(原型)</td></tr><tr><td style="text-align:center">可否new</td><td style="text-align:center">可以</td><td style="text-align:center">箭头函数作为匿名函数,是不能作为构造函数的(因为箭头函数没有constructor),不能使用new,不然会报错</td></tr><tr><td style="text-align:center">有无argumens</td><td style="text-align:center">有</td><td style="text-align:center">1.箭头函数的this指向全局,使用argunens会报未声明的错误 <br> 2.箭头函数的this指向普通函数时,它的<font color="blue">argumens</font>继承于改普通函数</td></tr><tr><td style="text-align:center">可否new</td><td style="text-align:center">可以</td><td style="text-align:center">箭头函数作为匿名函数,是不能作为构造函数的(因为箭头函数没有constructor),不能使用new,不然会报错</td></tr><tr><td style="text-align:center">可否改变this指向</td><td style="text-align:center">可以通过call、apply、bind改变this的指向</td><td style="text-align:center">箭头函数本身的this指向不能改变,但是可以修改它要捕获的对象的this</td></tr></tbody></table><h2 id="箭头函数this指向的规则"><a href="#箭头函数this指向的规则" class="headerlink" title="箭头函数this指向的规则"></a>箭头函数this指向的规则</h2><h3 id="1-箭头函数的this在定义的时候捕获自外层第一个普通函数的this"><a href="#1-箭头函数的this在定义的时候捕获自外层第一个普通函数的this" class="headerlink" title="1.箭头函数的this在定义的时候捕获自外层第一个普通函数的this"></a>1.箭头函数的this在定义的时候捕获自外层第一个普通函数的this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">aa(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><h3 id="2-不能直接修改箭头函数的this指向-但是可以通过修改外层函数的this"><a href="#2-不能直接修改箭头函数的this指向-但是可以通过修改外层函数的this" class="headerlink" title="2.不能直接修改箭头函数的this指向,但是可以通过修改外层函数的this"></a>2.不能直接修改箭头函数的this指向,但是可以通过修改外层函数的this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = &#123;</span><br><span class="line">    name: <span class="string">'1111'</span>;</span><br><span class="line">    bb: = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">aa.bb(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ECMAScript6中的箭头我们基本都是非常的常用，总结一下他与普通函数的区别和优点、确定。
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>vue-hoc</title>
    <link href="http://asyncnode.com//blog/vue-hoc.html"/>
    <id>http://asyncnode.com//blog/vue-hoc.html</id>
    <published>2019-04-06T01:53:31.000Z</published>
    <updated>2019-04-10T10:01:33.831Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>理解Vue中双向绑定的原理（mvvm）</title>
    <link href="http://asyncnode.com//blog/vue-mvvm.html"/>
    <id>http://asyncnode.com//blog/vue-mvvm.html</id>
    <published>2019-04-01T03:22:42.000Z</published>
    <updated>2019-04-10T10:01:33.831Z</updated>
    
    <summary type="html">
    
      首先我们先理解Vue中实现
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>http中get请求和post请求的区别</title>
    <link href="http://asyncnode.com//blog/http-get-post.html"/>
    <id>http://asyncnode.com//blog/http-get-post.html</id>
    <published>2019-03-22T14:59:35.000Z</published>
    <updated>2019-03-24T02:17:29.606Z</updated>
    
    <content type="html"><![CDATA[<p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p><ul><li>GET - 从指定的资源请求数据。</li><li>POST - 向指定的资源提交要被处理的数据<br>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。<br>区别</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">GET</th><th style="text-align:center">POST</th></tr></thead><tbody><tr><td style="text-align:center">后退按钮/刷新</td><td style="text-align:center">无害</td><td style="text-align:center">数据会被重新提交（浏览器应该告知用户数据会被重新提交）</td></tr><tr><td style="text-align:center">书签</td><td style="text-align:center">可收藏为书签</td><td style="text-align:center">不可收藏为书签</td></tr><tr><td style="text-align:center">缓存</td><td style="text-align:center">能被缓存</td><td style="text-align:center">不能缓存</td></tr><tr><td style="text-align:center">编码类型</td><td style="text-align:center">application/x-www-form-urlencoded</td><td style="text-align:center">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码</td></tr><tr><td style="text-align:center">历史</td><td style="text-align:center">参数保留在浏览器历史中</td><td style="text-align:center">参数不会保存在浏览器历史中</td></tr><tr><td style="text-align:center">对数据长度的限制</td><td style="text-align:center">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）</td><td style="text-align:center">无限制</td></tr><tr><td style="text-align:center">对数据类型的限制</td><td style="text-align:center">只允许 ASCII 字符</td><td style="text-align:center">没有限制。也允许二进制数据</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分 在发送密码或其他敏感信息时绝不要使用 GET ！</td><td style="text-align:center">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中</td></tr><tr><td style="text-align:center">可见性</td><td style="text-align:center">数据在 URL 中对所有人都是可见的</td><td style="text-align:center">数据不会显示在 URL 中</td></tr></tbody></table><p>其实GET和POST都是http协议中的两种发送请求的方法。</p><ol><li>http协议并未规定get和post的长度限制</li><li>get的最大长度限制是因为浏览器和web服务器限制了URL的长度</li><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</li></ol><p>其实很多人说get请求比post请求快，主要是底下两条</p><ol><li>get请求比post请求少一步</li><li>get请求可以缓存</li></ol><p>get请求过程：</p><ol><li>浏览器请求tcp连接（第一次握手） </li><li>服务器答应进行tcp连接（第二次握手） </li><li>浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） </li><li>服务器返回200 OK响应</li></ol><p>post请求过程：</p><ol><li>浏览器请求tcp连接（第一次握手） </li><li>服务器答应进行tcp连接（第二次握手） </li><li>浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） </li><li>服务器返回100 Continue响应 </li><li>浏览器发送数据 </li><li>服务器返回200 OK响应</li></ol>]]></content>
    
    <summary type="html">
    
      在http协议中get请求和post请求的区别
    
    </summary>
    
    
      <category term="Http" scheme="http://asyncnode.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的变量提升</title>
    <link href="http://asyncnode.com//blog/hoisting.html"/>
    <id>http://asyncnode.com//blog/hoisting.html</id>
    <published>2019-03-21T03:32:13.000Z</published>
    <updated>2019-03-24T02:17:29.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生变量提升的原因"><a href="#产生变量提升的原因" class="headerlink" title="产生变量提升的原因"></a>产生变量提升的原因</h2><p>在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。<br>在JavaScript代码运行之前其实是有一个编译阶段的。编译之后才是从上到下，一行一行解释执行。变量提升就发生在编译阶段，它把变量和函数的声明提升至作用域的顶端。（编译阶段的工作之一就是将变量与其作用域进行关联）。<br>我先分开介绍变量提升和函数提升到后面再放到一起比较。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>我们直接从代码从最基础的开始<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>相信这个大家知道，上面代码其实就是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>他会提前声明a,但是不会给a赋值。<br>但是如下代码会怎么执行呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined </span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>如果没有通过var声明值类型的就不会存在变量提升，而是会报错。</p><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>和变量提升一样存在函数提升，但是他们还有点不同。如下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure></p><p>他会提前声明并且赋值，还有一种函数声明方式，代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法就和变量提升相同了。<br>还有一种我感觉要说一下，其实不仔细思考也很容易犯错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a()); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="comment">// 会输出如下：</span></span><br><span class="line"><span class="comment">// 1 这个 a function 输出的</span></span><br><span class="line"><span class="comment">// undefined 因为 a function没有 return出来任何值，默认return  undefined。</span></span><br></pre></td></tr></table></figure></p><p>为什么会输出 一个 <font color="blue">1</font> 和一个<font color="blue">undefined</font>,我来解释一下,首先console.log(a())，他会<font color="blue">先执行a()</font>方法，<font color="blue">输出 1</font>,但是a方法没有返回值，默认返回<font color="blue">undefined</font>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a()); <span class="comment">// Uncaught TypeError: a is not a function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure></p><p>这个看一下就行。</p><h3 id="结合变量提升和函数提升"><a href="#结合变量提升和函数提升" class="headerlink" title="结合变量提升和函数提升"></a>结合变量提升和函数提升</h3><p>如果变量提升遇到函数提升，那个优先级更高呢，看下面的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>看上面的代码知道<font color="blue">函数提升</font><font color="blue">是<font color="blue">高于变量提升</font>的，因为在javascript中函数是一等公民，<font color="blue">并且不会被变量声明覆盖</font>，但是会被<font color="blue">变量赋值覆盖</font>。其实代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></font></p><p>我们再来一个稍微复杂一点的，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(2);&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure></p><p>在多次函数提升的会后一个覆盖前一个，然后才是变量提升，其实代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(2);&#125;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure></p><p>基本上这个上面基本上包含了javascript的变量提升和函数提升。其实还有一个作用域的我在这边就不介绍了，我会开篇再好好说一下作用域。</p>]]></content>
    
    <summary type="html">
    
      JavaScript中的变量提升，一般人都能说出来一点，我这里总结一下自己比较常见的，值的声明提升，还有函数的声明提升
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>(http)tcp三次握手和四次挥手</title>
    <link href="http://asyncnode.com//blog/http-tcp.html"/>
    <id>http://asyncnode.com//blog/http-tcp.html</id>
    <published>2019-03-13T08:21:03.000Z</published>
    <updated>2019-03-13T10:15:33.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP概念"><a href="#TCP概念" class="headerlink" title="TCP概念"></a>TCP概念</h2><p>TCP(Transmission Control Protocol 传输控制协议)是一种<font color="blue">面向连接(连接导向)</font>的、<font color="blue">可靠</font>的、 <font color="blue">基于IP的传输层</font>协议。<br>首先来看看OSI的七层模型<br><img src="../images/http/1.jpg" alt="OSI"></p>]]></content>
    
    <summary type="html">
    
      tcp三次握手和四次挥手,为什么是三次握手挥手是四次。
    
    </summary>
    
    
      <category term="Http" scheme="http://asyncnode.com/tags/Http/"/>
    
      <category term="Tcp" scheme="http://asyncnode.com/tags/Tcp/"/>
    
  </entry>
  
  <entry>
    <title>函数节流（throttle）与函数去抖（debounce）</title>
    <link href="http://asyncnode.com//blog/javascript-debounce-throttle.html"/>
    <id>http://asyncnode.com//blog/javascript-debounce-throttle.html</id>
    <published>2019-03-04T06:03:51.000Z</published>
    <updated>2019-03-04T08:42:06.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。</p><ol><li><p>window对象的resize、scroll事件</p></li><li><p>拖拽时的mousemove事件</p></li><li><p>射击游戏中的mousedown、keydown事件</p></li><li><p>文字输入、自动完成的keyup事件</p></li></ol><p>实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。</p><h2 id="与函数去抖（debounce）"><a href="#与函数去抖（debounce）" class="headerlink" title="与函数去抖（debounce）"></a>与函数去抖（debounce）</h2><p>当<font color="blue">调用动作n毫秒</font>后，才会执行该动作，若在这<font color="blue">n毫秒</font>内又调用此动作则将<font color="blue">重新</font>计算执行时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* timer为第二次要调用间隔的时间，只有大于间隔时间的调用会立即执func，不然要等到timer之后再执行</span></span><br><span class="line"><span class="comment">* @param timer &#123;Number&#125; 间隔时间，单位毫秒</span></span><br><span class="line"><span class="comment">* @param func &#123;Function&#125; 要执行的函数</span></span><br><span class="line"><span class="comment">* @param * &#123;Function&#125; 返回匿名函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">timer, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextAction;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(nextAction);</span><br><span class="line">    nextAction = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(content, args);</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>调用onresize函数，我们不需要触发频率这么快，要让函数执行延迟500毫秒再执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.onresize = debounce(<span class="number">500</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="参考-v1-9-1的Underscore-js-debounce"><a href="#参考-v1-9-1的Underscore-js-debounce" class="headerlink" title="参考 v1.9.1的Underscore.js debounce"></a>参考 v1.9.1的Underscore.js debounce</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class="line"><span class="comment">// be triggered. The function will be called after it stops being called for</span></span><br><span class="line"><span class="comment">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class="line"><span class="comment">// leading edge, instead of the trailing.</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//immediate 不传为 undefind, 默认不立即执行，传true 立即执行一次</span></span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (args) result = func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// restArguments Underscore.js 的restArguments方法 https://underscorejs.org/#restArguments</span></span><br><span class="line">  <span class="comment">// 格式化 参数为数组</span></span><br><span class="line">  <span class="keyword">var</span> debounced = restArguments(<span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// _.delay Underscore.js _.delay https://underscorejs.org/#delay</span></span><br><span class="line">      timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><p>预先设定一个<font color="blue">执行周期</font>，当再次调用动作的<font color="blue">时刻</font>大于等于<font color="blue">执行周期</font>则执行该动作，然后进入下一个新周期。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* timer为第二次要调用间隔的时间，只有大于间隔时间的调用会立即执func，不然要等到timer之后再执行</span></span><br><span class="line"><span class="comment">* @param delay &#123;Number&#125; 间隔时间，单位毫秒</span></span><br><span class="line"><span class="comment">* @param func &#123;Function&#125; 要执行的函数</span></span><br><span class="line"><span class="comment">* @param * &#123;Function&#125; 返回匿名函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">delay, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextAction = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (currTime - nextAction &gt; delay) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      nextAction = currTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>和防抖一样调用onresize函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="number">500</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="参考-v1-9-1的Underscore-js-throttle"><a href="#参考-v1-9-1的Underscore-js-throttle" class="headerlink" title="参考 v1.9.1的Underscore.js throttle"></a>参考 v1.9.1的Underscore.js throttle</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class="line"> <span class="comment">// during a given window of time. Normally, the throttled function will run</span></span><br><span class="line"> <span class="comment">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class="line"> <span class="comment">// but if you'd like to disable the execution on the leading edge, pass</span></span><br><span class="line"> <span class="comment">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class="line"> _.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">   <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">     timeout = <span class="literal">null</span>;</span><br><span class="line">     result = func.apply(context, args);</span><br><span class="line">     <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> now = _.now();</span><br><span class="line">     <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">     <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">     context = <span class="keyword">this</span>;</span><br><span class="line">     args = <span class="built_in">arguments</span>;</span><br><span class="line">     <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">       <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">         clearTimeout(timeout);</span><br><span class="line">         timeout = <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       previous = now;</span><br><span class="line">       result = func.apply(context, args);</span><br><span class="line">       <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">       timeout = setTimeout(later, remaining);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     clearTimeout(timeout);</span><br><span class="line">     previous = <span class="number">0</span>;</span><br><span class="line">     timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> throttled;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      防止频繁操作dom带来重绘、回流（重排）带来的性能损耗
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>require和import的区别</title>
    <link href="http://asyncnode.com//blog/javascript-module.html"/>
    <id>http://asyncnode.com//blog/javascript-module.html</id>
    <published>2019-02-27T13:44:57.000Z</published>
    <updated>2019-03-24T02:17:29.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单比较"><a href="#简单比较" class="headerlink" title="简单比较"></a>简单比较</h2><p>对比表格如下</p><table><thead><tr><th style="text-align:center">对比类型</th><th style="text-align:center">import</th><th style="text-align:center">require</th></tr></thead><tbody><tr><td style="text-align:center">何时加载</td><td style="text-align:center">编译时加载</td><td style="text-align:center">运行时加载</td></tr><tr><td style="text-align:center">静态化</td><td style="text-align:center">ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</td><td style="text-align:center">只有运行时才能得到这个对象，不能在编译时做到静态化</td></tr><tr><td style="text-align:center">调用时间</td><td style="text-align:center">import是编译时调用，所以严格模式必须放在文件开头</td><td style="text-align:center">require是运行时调用，所以require理论上可以运用在代码的任何地方</td></tr><tr><td style="text-align:center">模块输出</td><td style="text-align:center">模块输出的是值的引用，不会缓存，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块</td><td style="text-align:center">模块输出的是一个值的拷贝，并且在第一次加载是缓存，后面加载都会读取缓存</td></tr><tr><td style="text-align:center">模块加载</td><td style="text-align:center">按引入加载</td><td style="text-align:center">整体加载</td></tr><tr><td style="text-align:center">循环加载</td><td style="text-align:center">ES6 模块是动态引用，如果使用import从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值</td><td style="text-align:center">CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出</td></tr></tbody></table><p>下面我们一项一项具体解释：</p><h3 id="何时加载-静态化"><a href="#何时加载-静态化" class="headerlink" title="何时加载/静态化"></a>何时加载/静态化</h3><p>require / exports ：<br>遵循 <font color="blue">CommonJS/AMD</font>，只能在<font color="blue">运行时</font>确定模块的依赖关系及输入/输出的变量，<font color="blue">无法</font>进行<font color="blue">静态优化</font>。</p><p>import / export：<br>遵循 <font color="blue">ES6</font> 规范，支持<font color="blue">编译时静态分析</font>，便于JS引入宏和类型检验。<font color="blue">动态绑定</font>。</p><h3 id="调用时间"><a href="#调用时间" class="headerlink" title="调用时间"></a>调用时间</h3><p>import / export：<br>import命令具有<font color="blue">提升效果</font>，会<font color="blue">提升</font>到整个模块的头部，<font color="blue">首先执行</font>。（是在编译阶段执行的）<br>因为import是静态执行的，不能使用表达式和变量，即在运行时才能拿到结果的语法结构.</p><p>require / exports ：<br>require是<font color="blue">运行时</font>调用，所以require理论上可以运用在代码的<font color="blue">任何地方</font></p><h3 id="模块输出-模块加载"><a href="#模块输出-模块加载" class="headerlink" title="模块输出/模块加载"></a>模块输出/模块加载</h3><p>require / exports ：<br>CommonJS 模块输出的是<font color="blue">值的拷贝</font>，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值，并且会在第一次加载是<font color="blue">缓存</font>这个值的拷贝，他是<font color="blue">完全</font>输出这个值的拷贝。</p><p>import / export：<br>模块输出的是值的<font color="blue">引用</font>，<font color="blue">不会</font>缓存，而是<font color="blue">动态</font>地去被加载的模块取值，并且变量总是绑定其所在的模块，并且只会<font color="blue">加载</font>引入的值，不去全部加载。</p>]]></content>
    
    <summary type="html">
    
      CommonJS/Require和ES6/import的区别
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>实现一个自己的Promise</title>
    <link href="http://asyncnode.com//blog/es-promise.html"/>
    <id>http://asyncnode.com//blog/es-promise.html</id>
    <published>2019-02-27T13:44:35.000Z</published>
    <updated>2019-05-13T01:31:16.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个 Promise 就是一个对象，它代表了一个异步操作的最终完成或者失败。大多数人仅仅是使用已创建的Promise实例对象，因此本教程将首先说明怎样使用 Promise，之后说明如何创建Promise。<br>本质上，Promise 是一个绑定了回调的对象，而不是将回调传进函数内部。<br>原生提供了Promise对象。本篇不注重讲解promise的用法，关于用法，可以看阮一峰老师的ECMAScript 6系列里面的Promise部分：<br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ECMAScript 6 : Promise对象</a><br>我们在最后实现一个es2015版本的PromiseA.<br>注：在本代码中有很多不完善的地方，最后会给出一个es2015的版本，那个版本是比较完善的。<br>本篇博客逐步实现，最终使其符合Promises/A+规范</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>逐步实现：<br>1、基础版本<br>2、支持同步任务<br>3、支持状态<br>4、支持链式操作<br>5、支持串行异步任务<br>6、达到PromiseA+规范<br>7、实现Promise方法all、resolve、reject、race等方法<br>8、实现promiseify方法<br>注意事项：这边建议不要使用 setTimeout 作为 Promise 的实现。因为 setTimeout 属于 宏任务， 而 Promise 属于 微任务。<br>不理知道宏任务和微任务请看量一篇博客：<a href="http://asyncnode.com/blog/evenloop.html">evenloop</a></p><h3 id="基础版本-异步回调"><a href="#基础版本-异步回调" class="headerlink" title="基础版本(异步回调)"></a>基础版本(异步回调)</h3><p>目标</p><ul><li>可以通过new 关键字创建一个 Promise实例。</li><li>Promise实例传入的异步方法执行成功就执行注册的成功回调函数，失败就执行注册的失败回调函数。</li></ul><p>首先实现两个判断函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">    executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executeAsync = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;setTimeout(fn, <span class="number">0</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 封装我们要调用的callAsync函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callAsync</span> (<span class="params">fn, arg, callback, onError</span>) </span>&#123;</span><br><span class="line">    executeAsync(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback ? callback(fn(arg)) : fn(arg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            onError(e);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注：判断传入参数是否为function, 根据当前环境降级实现微任务或宏任务</p><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span> (<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle))&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Promise resolver handle is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">null</span>; <span class="comment">// 成功时的值</span></span><br><span class="line">  self.error = <span class="literal">null</span>; <span class="comment">// 失败时的原因</span></span><br><span class="line">  self.onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; (value) &#125;; <span class="comment">// 成功的回调函数</span></span><br><span class="line">  self.onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; (value) &#125;;; <span class="comment">// 失败的回调函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      self.value = value;</span><br><span class="line">      self.onFulfilled(self.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      self.error = error;</span><br><span class="line">      self.onRejected(self.error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//捕获callback是否报错</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    handle(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里给promise实例注册成功和失败回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.onFulfilled);</span><br><span class="line">    <span class="built_in">console</span>.log(onFulfilled);</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">    <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">111</span>);</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br><span class="line"><span class="keyword">new</span> PromiseA([]);</span><br></pre></td></tr></table></figure><p>判断实例传入的参数是否为function，在then中注册了这个promise实例的成功回调和失败回调，当promise resolve时，当promise resolve时，就把异步执行结果赋值给promise实例的value，并把这个值传入成功回调中执行，失败就把异步执行失败原因赋值给promise实例的error，并把这个值传入失败回调并执行。</p><h3 id="支持同步代码"><a href="#支持同步代码" class="headerlink" title="支持同步代码"></a>支持同步代码</h3><p>我们执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在如果我们同步执行resolve(111)的话，我们的then函数还没有被执行，所以后续的then中得回调函数也不会被执行，简单来说就是then函数在resolve(111)的函数之后执行，所以then中得回调也不会被执行。<br><strong>目标</strong></p><ul><li>使promise支持同步方法</li></ul><p><strong>代码</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">    executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executeAsync = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;setTimeout(fn, <span class="number">0</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span> (<span class="params">handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(handle))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Promise resolver handle is not a function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.value = <span class="literal">null</span>; <span class="comment">// 成功时的值</span></span><br><span class="line">    self.error = <span class="literal">null</span>; <span class="comment">// 失败时的原因</span></span><br><span class="line">    self.onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; (value) &#125;; <span class="comment">// 成功的回调函数</span></span><br><span class="line">    self.onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; (value) &#125;;; <span class="comment">// 失败的回调函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            <span class="built_in">console</span>.log(self.onFulfilled(self.value));</span><br><span class="line">            self.onFulfilled(self.value);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            self.error = error;</span><br><span class="line">            self.onRejected(self.error);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handle(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里给promise实例注册成功和失败回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.onFulfilled);</span><br><span class="line">    <span class="built_in">console</span>.log(onFulfilled);</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">    <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br></pre></td></tr></table></figure></p><p>就是在resolve和reject里面用setTimeout进行包裹，使其到then方法执行之后再去执行，这样我们就让promise支持传入同步方法。</p><p>注：setTimeout其实是最后一种方法，要看环境，<br>    要是支持的话，优先使用MutationObserver(微任务)<br>    再是MessageChannel（优先级比定时器高的宏任务）<br>    再是setImmediate（这个兼容性太差，不建议用）<br>    再不行就退化到setTimeout了</p><h3 id="支持三种状态"><a href="#支持三种状态" class="headerlink" title="支持三种状态"></a>支持三种状态</h3><p>我们知道在使用promise时，promise有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失效)。<br>1、只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p><p><strong>目标</strong></p><ul><li>实现promise的三种状态</li><li>实现promise对象的状态改变，改变只有两种可能：从pending变为fulfilled和从pending变为rejected。</li><li>实现一旦promise状态改变，再对promise对象添加回调函数，也会立即得到这个结果。</li></ul><p><strong>代码实现</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">    executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executeAsync = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;setTimeout(fn, <span class="number">0</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span> (<span class="params">handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.value = <span class="literal">undefined</span>;</span><br><span class="line">    self.error = <span class="literal">undefined</span>;</span><br><span class="line">    self.status = PENDING;</span><br><span class="line">    self.onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; (value) &#125;;</span><br><span class="line">    self.onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; (value) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                self.status = FULFILLED;</span><br><span class="line">                self.value = value;</span><br><span class="line">                self.onFulfilled(self.value);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                self.status = REJECTED;</span><br><span class="line">                self.error = value;</span><br><span class="line">                self.onRejected(self.error);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle(resolve, reject);</span><br><span class="line">    <span class="comment">//捕获callback是否报错</span></span><br><span class="line">    <span class="comment">// try &#123;</span></span><br><span class="line">    <span class="comment">// &#125; catch (error) &#123;</span></span><br><span class="line">    <span class="comment">//     reject(error);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">        <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data, error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br></pre></td></tr></table></figure></p><p>为了实现上面的目标我们建立了三种状态：pending、fulfilled、rejected，如果是peding状态，我们才会改变promise的状态，并且执行相关状态的操作，并且现在的promise的状态是不可改变的。在the那种我们判断promise的状态已经从pending转换为’fulfilled’或者’rejected‘就会立刻执行他的状态的回调，并且把结果传入。</p><h3 id="支持链式调用（同步）"><a href="#支持链式调用（同步）" class="headerlink" title="支持链式调用（同步）"></a>支持链式调用（同步）</h3><p>大家都知道jquery的链式调用，promise也是支持链式调用。<br>我们首先在这一步实现同步的链式调用。</p><p><strong>目标</strong></p><ul><li>使promise支持链式调用</li></ul><p>注：我们把then中的回调存入数组中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.onFulfilledCallbacks = [];</span><br><span class="line">self.onRejectedCallbacks = [];</span><br></pre></td></tr></table></figure></p><p>当我们执行回调时，也要改成遍历回调数组执行回调函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.onFulfilledCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value));</span><br><span class="line">self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value));</span><br></pre></td></tr></table></figure></p><p>最后，then方法也要改一下,只需要在最后一行加一个return this即可，这其实和jQuery链式操作的原理一致，每次调用完方法都返回自身实例，后面的方法也是实例的方法，所以可以继续执行。<br><strong>代码实现</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">    executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executeAsync = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;setTimeout(fn, <span class="number">0</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span> (<span class="params">handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.value = <span class="literal">undefined</span>;</span><br><span class="line">    self.error = <span class="literal">undefined</span>;</span><br><span class="line">    self.onFulfilledCallbacks = [];</span><br><span class="line">    self.onRejectedCallbacks = [];</span><br><span class="line">    self.status = PENDING;</span><br><span class="line">    <span class="comment">// self.onFulfilled = function (value) &#123; (value) &#125;;</span></span><br><span class="line">    <span class="comment">// self.onRejected = function (value) &#123; (value) &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                self.status = FULFILLED;</span><br><span class="line">                self.value = value;</span><br><span class="line">                <span class="comment">// self.onFulfilled(self.value);</span></span><br><span class="line">                self.onFulfilledCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                self.status = REJECTED;</span><br><span class="line">                self.value = error;</span><br><span class="line">                <span class="comment">// self.onRejected(self.value);</span></span><br><span class="line">                self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.error));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle(resolve, reject);</span><br><span class="line">    <span class="comment">//捕获callback是否报错</span></span><br><span class="line">    <span class="comment">// try &#123;</span></span><br><span class="line">    <span class="comment">// &#125; catch (error) &#123;</span></span><br><span class="line">    <span class="comment">//     reject(error);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// this.onFulfilled = onFulfilled;</span></span><br><span class="line">        <span class="comment">// this.onRejected = onRejected;</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reslove(<span class="number">111</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第一'</span> + data);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二'</span> + data);</span><br><span class="line">&#125;); <span class="comment">// 第一 第二</span></span><br></pre></td></tr></table></figure></p><p>总结： 这个就是最简单的同步then的回调用一个内部数组来储存，最后循环调用。</p><h3 id="支持串行异步任务"><a href="#支持串行异步任务" class="headerlink" title="支持串行异步任务"></a>支持串行异步任务</h3><p>我们一般都是用promise.then来写异步任务，在下面完善一下代码</p><p><strong>目标</strong></p><ul><li>使promise支持串行异步操作</li><li>支持传入promise</li></ul>]]></content>
    
    <summary type="html">
    
      Promise是我们用来解决地狱回调，我在这篇博客中实现自己的一个Promise.
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>为什么![] == []为true, [] == false为true,  ![] == false为true, !![] == false 为false</title>
    <link href="http://asyncnode.com//blog/javascript-false-true.html"/>
    <id>http://asyncnode.com//blog/javascript-false-true.html</id>
    <published>2019-02-26T09:00:31.000Z</published>
    <updated>2019-03-01T01:49:45.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。<br>比较的特点:</p><ul><li>对于两个拥有相同字符顺序，相同长度，并且每个字符的位置都匹配的字符串，应该使用严格比较运算符。</li><li>对于两个数值相同的数字应该使用严格比较运算符，NaN和任何值不相等，包括其自身，正数零等于负数零。</li><li>对于两个同为true或同为false的布尔操作数，应使用严格比较运算符。</li><li>不要使用严格比较运算符或比较运算符来比较两个不相等的对象。</li><li>当比较一个表达式和一个对象时，仅当两个操作数引用相同的对象（指针指向相同对象）。</li><li>对于Null 和 Undefined 类型而言，应使用严格比较运算符比较其自身，使用比较运算符进行互相比较。</li></ul><p>参考 &gt;<font color="blue"><a href="https://www.h5jun.com/post/why-false-why-true.html" target="_blank" rel="noopener">https://www.h5jun.com/post/why-false-why-true.html</a></font></p><h3 id="一致-严格相等"><a href="#一致-严格相等" class="headerlink" title="一致/严格相等 (===)"></a>一致/严格相等 (===)</h3><p>一致运算符不会进行类型转换，仅当操作数严格相等时返回true</p><h3 id="相等"><a href="#相等" class="headerlink" title="相等(==)"></a>相等(==)</h3><p>比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。</p><p>非严格比较操作符 == 是会做强制类型转换的，那么根据 ECMA 262 它的规则是：<br><strong> 图1-1 </strong><br><img src="../images/false-true/1.png" alt="! =="><br><strong> <font color="blue">ToPrimitive：</font> </strong><br><strong> 图1-2 </strong><br><img src="../images/false-true/2.png" alt="! =="><br><strong> 图1-3 </strong><br><img src="../images/false-true/3.png" alt="! =="><br><strong> 图1-4 </strong><br><img src="../images/false-true/4.png" alt="! =="></p><p><strong> <font color="blue">ToBoolean: </font> </strong><br><strong> 图1-5 </strong><br><img src="../images/false-true/5.png" alt="! =="><br><strong> 图1-6 </strong><br><img src="../images/false-true/6.png" alt="! =="></p><p>来源： &gt;<font color="blue"><a href="http://www.ecma-international.org" target="_blank" rel="noopener">http://www.ecma-international.org</a></font></p><h2 id="false-or-or-false-为true"><a href="#false-or-or-false-为true" class="headerlink" title="[] == false or ![] == [] or ![] == false 为true"></a>[] == false or ![] == [] or ![] == false 为true</h2><p>mdn运算符优先级参考表<br><img src="../images/false-true/false-true-1.png" alt="! =="><br><img src="../images/false-true/false-true-2.png" alt="! =="></p><p><font color="red">==</font>的优先级16</p><p><font color="red">!</font>的优先级10</p><h3 id="false-结果为-true"><a href="#false-结果为-true" class="headerlink" title="[] == false 结果为 true"></a>[] == false 结果为 true</h3><p>根据图1-1可知</p><ul><li>第 7 条：If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).</li><li>第 9 条：If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.</li></ul><p>所以 [] == false 的比较是对 x 执行 ToPrimitive(x)，然后和 ToNumber(false) （为 0）进行比较。</p><p><strong> 看一下 ToPrimitive：</strong><br>根据上图1-2、1-3、1-4的规则对于ToPrimitive([])，先执行<code>[].valueOf()</code>，返回result的是’[]’，因为Type(result)是Object，所以继续执行<code>[].toString()</code>，返回””。<br>因此实际上最终是比较”” == 0，结果为true。</p><h3 id="结果为-true"><a href="#结果为-true" class="headerlink" title="![] == [] 结果为 true"></a>![] == [] 结果为 true</h3><p>按照优先级，先执行 ![]，根据规范，实际上是 !(ToBoolean([]))：<br>根据上图1-5、1-6可看出，实际上 ToBoolean([]) 会return出true, ![] 就是 false.<br>[] 上文已经讲过了 是 “” 。<br>所以对比就是 false == “”，结果为true。</p><h3 id="false-结果为-true-1"><a href="#false-结果为-true-1" class="headerlink" title="![] == false 结果为 true"></a>![] == false 结果为 true</h3><p>按照优先级，先执行 ![]，根据规范，实际上是 !(ToBoolean([]))：<br>根据上图可看出，实际上 ToBoolean([]) 会return出true, ![] 就是 false.<br>false == false ，结果为true。</p><h3 id="false-结果为-false"><a href="#false-结果为-false" class="headerlink" title="!![] == false 结果为 false"></a>!![] == false 结果为 false</h3><p>按照优先级，先执行 !![]，根据规范，实际上是 !!(ToBoolean([]))：<br>根据上图可看出，实际上 ToBoolean([]) 会return出true, !![] 就是 true.<br>true == false ，结果为 false。</p>]]></content>
    
    <summary type="html">
    
      在JavaScript中==和===的区别,为什么![] == []为true, [] == false为true, ![] == false为true, !![] == false为false.
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
