---
title: Http中的缓存（一） 强缓存、协商缓存 缓存
date: 2018-09-07 10:29:23
tags: [Http]
categories: [Http]
description: http中的缓存、强缓存、协商缓存
---
> [Http中的缓存（一） 多级缓存结构](/blog/http/http-cache.html)
> [Http中的缓存（二） HTTP中的缓存](/blog/http/http-etag-cache.html)
> [Http中的缓存（三） PWA中的ServiceWorker](/blog/http/http-cache-serviceworker.html)

## 简介

**缓存**相信现在这个词大家都不陌生，因为在当前的应用中被广泛的应用。因为**缓存**会带来更高的**性能**、**用户体验**，同时也会**节省流量**、**离线体验**等等好处。

关于缓存的文章分为三篇：**多级缓存结构**、**HTTP缓存详解**、**离线缓存**

### 缓存的分层

**缓存**大致分为如下：

- **客户端/浏览器缓存**
- **http/服务器缓存**
- **cdn缓存**
- **代理服务器缓存**
- **后端进程缓存redis、lru等等**
- **分布式缓存**
- **数据库**

可以在下面几层做缓存大致如下：

<img src="../../images/http/http-cache-1-1.png" height="300" alt="http-cache"/>

### 多层缓存流程

整个的缓存判断流程是：

1. **用户刷新页面发出请求**
2. 客户端/浏览器是否命中`serviceWorker`、**强缓存（缓存策略）**、**协商缓存**
3. **cdn缓存**
4. **代理服务器缓存**
5. **进程缓存**
6. **分布式缓存**
7. **数据库**

这里主要记述**客户端/浏览器缓存**、**http/服务器缓存**的一些使用和细节。

## HTTP缓存

`HTTP`缓存基本上可以分为两类： **一类强缓存（有效期策略）**、**另一类 协商缓存（资源唯一标识符）**。它们缓存在不同的位置，按照分类为：**本地硬盘缓存**、**本地内存缓存**。当时对于一些不同的文件类型要用不同的缓存来做，同时让它们缓存在不同的位置。
跟随**移动端**应用的发展，为了提高用户离线的体验，延伸出了不同**离线缓存方案**大致有两种实现方式：**AppCache**、**ServiceWorker**两种方式。

在这里一些详细的实现方式和细节不多做解释，在下片文章[Http中的缓存（二） HTTP中的缓存](/blog/http/http-etag-cache.html)来详细的记录，比如**有限期是怎么验证的**、**详细的配置**、**不同的本地缓存储存在那**、**它们之间的对比和适用缓存文件**等等。

### 强缓存

**强缓存**可以用三种实行方式： `cache-control`、`Expires`、`Pragma`它们都是通过**有效期**来决定是否命中缓存的。

大致的优先级如下： 在本地 `Cache-Control > Expires，Pragma 在不支持 Cache-Control` 时生效。

### 协商缓存

**协商缓存**可以用两种种实行方式： `Last-Modified/If-Modified-Since`、`Etag/If-None-Match`它们的实现方式是不同的。

**Last-Modified/If-Modified-Since**是通过**有限期**来检验是否使用缓存，而**Etag/If-None-Match**它是通过**唯一资源标识符**来判断是否使用缓存。
同时它们的整体流程也是不同，比如说**Last-Modified/If-Modified-Since**返回的**HTTP状态**为**200状态码**，而**Etag/If-None-Match**它返回的是**304状态码**。

### 储存位置

从缓存位置上来看，分为**4种**，**从上往下依次检查**是否命中，如果但都没有命中则重新发起请求。

- `Service Worker` 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 `Service Worker`的话，传输协议必须为 `HTTPS`。
- `Memory Cache` 也就是**内存**中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。
- `Disk Cache` 也就是存储在硬盘中的缓存。
- `Push Cache`（推送缓存）是 `HTTP/2` 中的内容，当以上三种缓存都没有命中时，它才会被使用。

它们之间是有优缺点的，比如说静态资源适用于`Memory Cache`。

### 用户操作对缓存的影响

当用户的操作比如**地址栏回车**、**前进回退**、**F5刷新**、**Ctrl+F5强制刷新**等等对缓存的影响。大致如下图所示：

![http-cache](../../images/http/http-cache-1-2.png)

在这里就不细究了不然这篇文章太长了。

## CDN缓存

**CND**的全称是**Content Delivery NetWork**内容分发网络。**HTTP**缓存主要是对一些**客户端/浏览器**中的静态资源和**不长更新的数据**资源。
**CDN**是在**客户端**和**服务器**端加设的一层，可以让**CDN**为应用服务器提供缓存，如果在 **CDN** 上缓存，就不用再请求应用服务器了。并且 **HTTP** 缓存提到的两种策略同样可以在 **CDN**服务器执行。

### CDN流程

**CDN**缓存流程大致如下：
![http-cache](../../images/http/http-cache-1-3.png)

- 客户端发送 `URL` 给 `DNS` 服务器。
- `DNS` 通过域名解析，把请求指向 `CDN` 网络中的 `DNS` 负载均衡器。
- `DNS` 负载均衡器将最近 `CDN` 节点的 `IP` 告诉 `DNS`，`DNS` 告之客户端最新 `CDN` 节点的 `IP`。
- 客户端请求最近的 `CDN` 节点。
- `CDN` 节点从应用服务器获取资源返回给客户端，同时将静态信息缓存。

> 注意：客户端下次互动的对象就是 `CDN` 缓存了，`CDN` 可以和应用服务器同步缓存信息。

`CDN` 接受客户端的请求，它就是离客户端最近的服务器，它后面会链接多台服务器，起到了缓存和负载均衡的作用。

## 负载均衡缓存

说完客户端（`HTTP`）缓存和 `CDN` 缓存，我们离应用服务越来越近了，在到达应用服务之前，请求还要经过**负载均衡器**。

虽说它的主要工作是对**应用服务器进行负载均衡**，但是它也可以作**缓存**。可以把一些修改频率不高的数据缓存在这里，例如：用户信息，配置信息。通过服务定期刷新这个缓存就行了。

![http-cache](../../images/http/http-cache-1-4.png)

以 `Nginx` 为例，我们看看它是如何工作的：

- 用户请求在达到应用服务器之前，会**先访问 Nginx 负载均衡器**，如果发现**有缓存信息**，直接**返回**给用户。
- 如果**没有发现**缓存信息，**Nginx 回源**到应用服务器获取信息。
- 另外，有一个**缓存更新服务**，定期把应用服务器中**相对稳定**的信息更新到 **Nginx 本地缓存**中。

## 进程内缓存

通过了**客户端**，**CDN**，**负载均衡器**，我们终于来到了应用服务器。应用服务器上部署着一个个应用，这些应用以进程的方式运行着，那么在进程中的缓存是怎样的呢？

**进程内缓存又叫托管堆缓存**，以 Java 为例，这部分缓存放在**JVM的托管堆**上面，同时会受到**托管堆回收算法**的影响。

由于其运行在内存中，对**数据的响应速度很快**，通常我们会把热点数据放在这里。

在**进程内缓存没有命中**的时候，我们会去**搜索进程外的缓存或者分布式缓存**。这种缓存的好处是**没有序列化和反序列化**，是**最快的缓存**。**缺点是缓存的空间不能太大**，**对垃圾回收器的性能有影响**。

目前比较流行的实现有 **Ehcache**、**GuavaCache**、**Caffeine**。这些架构可以很方便的把一些热点数据放到**进程内的缓存**中。

这里我们需要关注几个缓存的回收策略，具体的实现架构的回收策略会有所不同，但大致的思路都是一致的：

FIFO（First In First Out）：先进先出算法，最先放入缓存的数据最先被移除。


LRU（Least Recently Used）：最近最少使用算法，把最久没有使用过的数据移除缓存。


LFU（Least Frequently Used）：最不常用算法，在一段时间内使用频率最小的数据被移除缓存。
