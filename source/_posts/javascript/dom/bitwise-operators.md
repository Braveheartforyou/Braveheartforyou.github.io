---
title: JavaScript了解JS中的位运算符
date: 2020-01-15 10:43:12
tags: [JavaScript]
categories: [JavaScript]
description: 通过本篇博客让我们了解JavaScript中的位运算符，并且在什么情况下我们可以用到位运算符。
---

## JavaScript中的按位操作符

JavaScript提供了几种运算符，可以对一些简单的值进行基本操作，比如`算术运算符`、`赋值运算符`、`逻辑运算符`、`按位操作符`等。其他的操作运算符都是经常用到的，比如算数运算符的`+、-、*、/`；赋值运算符的`=、+=、-=`；逻辑运算符的`||、&&、!`等等。但是`按位操作符`操作符是比较来说不常用的，很多人也不知道都有什么`按位操作符`?

本章内容大致分为：

- 有哪些`按位操作符`?简单的应用
- 在日常开发是`按位操作符`可以做哪些事情？

会一步一步从了解`按位操作符`到能把它运用到项目中来，以使自己的编码更简洁、更方便。

## 简单了解按位操作符

首先来了解一下`按位操作符`的定义是什么： **`按位操作符（Bitwise operators） 将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值`**。其实[mdn 中 按位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)讲的有点晦涩，不太好理解通过对下面的介绍可能会好理解一点。

JavaScript内部`Number`是以`64位浮点数`的形式储存，但是做位运算的时候，是以`32位带符号的整数`进行运算的，并且返回值也是一个`32位带符号的整数`。

JavaScript中有七中按位操作符，如下表格所示：

|运算符|用法|描述|
|:------:|:-------:|:--------------:|
|按位与（ AND）|a & b|对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。|
|按位或（OR）|a 丨 b|对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。|
|按位异或（XOR）|a ^ b|对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。|
|按位非（NOT）|~ a|反转操作数的比特位，即0变成1，1变成0。|
|左移（Left shift）|	a << b|	将 a 的二进制形式向左移 b (< 32) 比特位，右边用0填充。|
|有符号右移	|a >> b|	将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。|
|无符号右移|	a >>> b|	将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。|

### 按位与（ AND）`&`

`&`以特定的方式组合操作`二进制`数中对应的位，如果对应的位都为`1`，那么结果就是`1`， 如果任意一个位是`0` 则结果就是`0`。请看下面示例：

```js
  // 1的二进制表示为: 00000000 00000000 00000000 00000001
  // 2的二进制表示为: 00000000 00000000 00000000 00000010
  // 3的二进制表示为: 00000000 00000000 00000000 00000011
  console.log(1&2) // 0
  console.log(1&3) // 1
```

**1&2对比过程**: 因为`1`和`2`它们的比特位没有相同的位置都为`1`，所以会返回一个`00000000 00000000 00000000 00000000`的`32位二进制`，转换位10进制就是`0`
**1&3对比过程**: 因为`1`和`3`它们的第一个位比特位都为`1`，所以会返回一个`00000000 00000000 00000000 00000001`的`32位二进制`，转换位10进制就是`1`

### 按位或(OR)`|`

`|` 运算符跟 `&` 的区别在于如果对应的位中`任一个`比特位为`1` 那么结果就是`1`。请看下面示例：

```js
  // 1的二进制表示为: 00000000 00000000 00000000 00000001
  // 2的二进制表示为: 00000000 00000000 00000000 00000010
  // 3的二进制表示为: 00000000 00000000 00000000 00000011
  console.log(1|2) // 3
  console.log(1|3) // 3
```

**1|2对比过程**: 因为`1`和`2`它们的比特位为`1`的并集就是`00000000 00000000 00000000 00000011`的`32位二进制`，转换位10进制就是`3`
**1|3对比过程**: 因为`1`和`3`它们的比特位为`1`的并集就是`00000000 00000000 00000000 00000011`的`32位二进制`，转换位10进制就是`3`

### 按位异或(XOR)`^`

`^`如果对应两个操作位有且仅有一个`1`时结果为`1`，其他都是`0`。请看下面示例：

```js
  // 1的二进制表示为: 00000000 00000000 00000000 00000001
  // 2的二进制表示为: 00000000 00000000 00000000 00000010
  // 3的二进制表示为: 00000000 00000000 00000000 00000011
  console.log(1^2) // 3
  console.log(1^3) // 2
```

**1^2对比过程**: 因为`1`和`2`它们的比特位中只有其中一个为`1`的组合出来是`00000000 00000000 00000000 00000011`的`32位二进制`，转换位10进制就是`3`
**1^3对比过程**: 因为`1`和`3`它们的比特位中只有其中一个为`1`的组合出来`00000000 00000000 00000000 00000010`的`32位二进制`，转换位10进制就是`2`

### 按位非(NOT)`~`

`~`运算符是对位求反，`1`变`0`, `0`变`1`，也就是求二进制的反码。请看下面示例：

```js
  // 9的二进制表示为: 00000000 00000000 00000000 00001001
  console.log(~9) // -10
```

`9`的二进制反码表示为`11111111 11111111 11111111 11110110`
