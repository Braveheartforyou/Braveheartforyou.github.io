---
title: 数据结构/算法 知识引导篇
date: 2020-06-01 11:12:43
tags: [JavaScript, Algorithm]
categories: [Algorithm, 未完成]
description: 数据结构中的数组
---

## 概览

什么是数据结构？数据结构的作用是啥？
什么是算法？算法有什么作用？

本篇文章只是简单了解一些专业术语、基本概念，作为后期文章的引导篇。对数据结构和算法有一个基本的概念和了解，以便于后面的 leetcode 刷题、数据结构深入了解做铺垫。

### 基本概念和术语

#### 数据(data)

- 是事实或观察的结果，是对客观事物的`逻辑归纳`，是用于表示客观事物的未经加工的原始素材。
- 在计算机科学中指的是所有能输入到计算机中并被计算机程序`处理的符号的总称`。

#### 数据项(data item)

- 数据项是指数据元素可由若干个`数据项（data item）组成`，数据项是数据的`不可分割`的`最小单位`。
- 数据项是数据记录中`最基本的`、`不可分的`有名`数据单位`，是具有独立含义的`最小标识单位`。

#### 数据元素(data element)

- 它是`数据`的`基本单位`，数据元素也叫做`结点`或`记录`。
- 一个`数据元素`可由`若干`个`数据项`组成.

#### 数据对象(data Object)

- 数据对象指`性质相同`的数据元素的集合，是数据的`子集`；
- `数据对象`简称数据

> 性质相同指数据元素具有相同数量和类型的数据项；

#### 数据结构(data structure)

- 由互相之间存在着`一种`或`多种`关系的数据元素组成的`集合`；这些数据元素之间的关系称为`结构`。

### 数据结构

> 在计算机科学中，`数据结构(英语：data structure)`是计算机中`存储`、`组织数据`的方式。

简单来说数据结构: 是指互相之间存在一种或多种特定关系的数据元素的组合。`数据结构 = 数据元素 + 元素之间的关系`.

数据结构一般分为两个维度：`逻辑结构`和`存储结构`，`逻辑结构`又大致可以分为`线性结构`和`非线性结构`两种。下面会对`逻辑机构`、`存储结构`展开来讲。

常见数据结构：

- `堆栈`（Stack）
- `队列`（Queue）
- `数组`（Array）
- `链表`（Linked List）
- `树` （Tree）
- `图` （Graph）
- `堆积` (Heap)
- `散列表` （Hash table）

#### 基本逻辑结构

**集合结构**： `数组元素的有限集合`。数据元素之间除了”属于同一个集合“的关系之外`没有其他关系`。
![集合结构](./algorithm-structure/1.webp)

**线性结构**： `数据元素的有序集合`。数据元素之间形成`一对一`的关系。
![线性结构](./algorithm-structure/2.webp)

**树形结构**： 树是层次数据结构，树中数据元素之间存在`一对多`的关系。
![树形结构](./algorithm-structure/3.webp)

**图状结构**：  图中数据元素之间的关系是`多对多`。
![图状结构](./algorithm-structure/4.webp)

### 算法

> `算法（algorithm）`，在数学（算学）和计算机科学之中，为任何一系列良定义的具体计算步骤，常用于`计算`、`数据处理`和`自动推理`。作为一个有效方法，算法被用于计算函数，它包含了一系列定义清晰的指令，并可于有限的时间及空间内清楚的表述出来。

#### 算法的基本特征

算法的基本特征： 是一组严谨地定义运算顺序的规则，每一个规则都是`有效的`，是`明确的`，此顺序将在有限的次数下终止。
特征包括：

1. 输入：一个算法必须有零个或以上输入量。
2. 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。
3. 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地符合要求或期望，通常要求实际运行结果是确定的。
4. 有限性：依据图灵的定义，一个算法是能够被任何图灵完全系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。
5. 有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。

#### 常用设计模式

`完全遍历法和不完全遍历法`： 在问题的解是有限离散解空间，且可以验证正确性和最优性时，最简单的算法就是把解空间的所有元素完全遍历一遍，逐个检测元素是否是我们要的解。这是最直接的算法，实现往往最简单。但是当解空间特别庞大时，这种算法很可能导致工程上无法承受的计算量。这时候可以利用不完全遍历方法——例如各种搜索法和规划法——来减少计算量。
`分治法`： 把一个问题`分割`成`相互独立`的`多个部分`分别求解的思路。这种求解思路带来的好处之一便是进行并行计算。
`动态规划`： 当问题的整体最优解就是由`局部最优解组成`的时候，经常采用的一种方法。
`贪心算法`：常见的近似求解思路。当问题的整体`最优解不是（或无法证明是）由局部最优解组成`，且对接的最优性没有要求的时候，可以采用的一种方法。
`线性规划法`： `线性规划（Linear Programming，简称LP）`特指目标函数和约束条件皆为线性的最优化问题。线性规划是最优化问题中的一个重要领域。
`简并法`： 把一个问题通过逻辑或者数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法。

#### 常用实现方法

[递归方法](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92): 递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中`使用函数自身的方法`。递归一词还较常用于描述以`自相似方法重复事物`的过程。
[迭代方法](https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3): 迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的`重复被称为一次“迭代”`，而每一次迭代得到的结果会被用来作为`下一次迭代的初始值`。

`顺序计算`: 顺序计算就是把形式化算法用编程语言进行单线程序列化后执行。
`并行计算`: 并行计算（英语：parallel computing）一般是指许多指令得以同时进行的计算模式。在同时进行的前提下，可以将计算的过程分解成小部分，之后以并发方式来加以解决

常用的算法：`递归`、`排序`、`二分查找`、`搜索`、`哈希算法`、`贪心算法`、`分治算法`、`回溯算法`、`动态规划`、`字符串匹配算法`等等。

## 数据结构

数据结构一般分为两个维度： `逻辑结构`和`存储结构`。下面再根据这两个维度来大致了解一下一些常用的知识点。

### 逻辑结构

> 逻辑结构即数据之间的关系，逻辑结构可以分为两种：`线性结构`和`非线性结构`。

`非线性结构`又大致可以分为`图形结构`、`树形结构`、`集合结构`对应上面的分类。

**线性结构**

线性结构：是一个`有序数据元素的集合`，其中数据元素之间的关系是`一对一`的关系，即除了第一个和最后一个元素之外，其他数据元素都是一个`首尾接应`的。
常用的线性结构有：`栈`、`队列`、`链表`、`线性表`等。

**非线性结构**

非线性结构：各个数据元素不再保持在`一个线性序列中`，每个数据元素可能与`零个或者多个`其他数据元素发生联系。
常见的非线性结构：`二叉树`、`图`、`树`、`集合`等等。

### 存储结构

逻辑结构指的是数据元素之间的关系，而存储结构是逻辑结构用计算机语言的实现。常见的存储结构有： `顺序存储`、`链式存储`、`索引存储`、`散列存储`。

比较常见的就是`顺序存储`和`链式存储`

**顺序存储结构**

顺序存储结构：把数据元素存放在地址`连续的的存储单元里`，其数据间的`逻辑关系和物理关系一致`；比如数组等等，它存储结构大致如下图所示：
![顺序存储结构](./algorithm-structure/5.webp)

**链式存储结构**

链式存储结构: 把数据元素存放在任意的存储单元里，这组存储单元可以是`连续`的也可以是`不连续`的。数据元素的存储关系`不反映其逻辑关系`，用`指针存放数据元素的地址，我们通过地址可以找到相关联数据元素的位置`。

![链式存储结构](./algorithm-structure/6.webp)

下面会把比较常用的数据结构再稍微详细的介绍一下。

## 算法

在学习算法和后面的算法实战中首先要非常清楚两个衡量算法的指标，`时间复杂度`和`空间复杂度`。

### 大O复杂度表示法

通过一个代码样例来了解一下什么是`大O`？代码如下：

```js
  function sum (n) {
    let sum = 0;
    for (let i = 0; i < n; i++) {
      sum += i;
    }
    return sum
  }
```

这是一个最简单的js代码，不需要关注代码的功能。假设每行代码的执行的时间都是相同为`unit_time`，从代码执行的角度来分析代码的执行时间。第`2行`代码它们只需要一个`unit_time`，但是下面`for循环（第3行、第4行）`它执行代码的时间为`2n*unit_time`，再加上`第6行`的代码执行时间为`unit_time`，到此我们知道总执行时间为`(2n+2)*unit_time`的时间。我们可以从这个样例里面知道，`所有代码执行时间T(n)与每行代码执行次数n成正比`。

来看一下`大O`，公式为`T(n) = O(f(n))`，下面来解释一下`大O`中一些关键性的东西。

- `T(n)`: 它表示代码执行的总时间。
- `n`: 表示数据规模的大小，通俗的讲就是代码执行的次数。
- `f(n)`: 表示每次代码执行的次数总和。因为这是一个公式，所以用`f(n)`来表示。
- `O`: 表示代码的执行时间`T(n)`与`f(n)`表达式成正比。

上面例子通过`大O`表示的话就是`T(n) = O(2n + 2)`，这就是`大O时间复杂度表示法`。

> 大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码`执行时间随数据规模增长变化趋势`，所以，也叫作`渐进时间复杂度`