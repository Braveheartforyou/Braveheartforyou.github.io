<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asyncnode</title>
  
  <subtitle>asyncnode</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://asyncnode.com/"/>
  <updated>2019-12-30T08:02:29.860Z</updated>
  <id>http://asyncnode.com/</id>
  
  <author>
    <name>asyncnode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019年年度终结</title>
    <link href="http://asyncnode.com/blog/annualReport/2019.html"/>
    <id>http://asyncnode.com/blog/annualReport/2019.html</id>
    <published>2019-12-30T07:23:21.000Z</published>
    <updated>2019-12-30T08:02:29.860Z</updated>
    
    <summary type="html">
    
      又过去了一年，总结自己整装出发
    
    </summary>
    
      <category term="Other" scheme="http://asyncnode.com/categories/Other/"/>
    
    
      <category term="annual" scheme="http://asyncnode.com/tags/annual/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout实现原理和EventLoop的关系</title>
    <link href="http://asyncnode.com/blog/mode/mode_setTimeout.html"/>
    <id>http://asyncnode.com/blog/mode/mode_setTimeout.html</id>
    <published>2019-11-14T11:32:12.000Z</published>
    <updated>2019-11-18T09:45:39.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/GI6entTJl2EtP5rRzmQFTw" target="_blank" rel="noopener">setTimeout 的实现原理和使用注意</a></p>]]></content>
    
    <summary type="html">
    
      setTimeout实现原理和EventLoop的关系
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="设计模式" scheme="http://asyncnode.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列 ———— 单例模式和设计模式的作用</title>
    <link href="http://asyncnode.com/blog/mode/mode_simple_des.html"/>
    <id>http://asyncnode.com/blog/mode/mode_simple_des.html</id>
    <published>2019-11-09T14:12:54.000Z</published>
    <updated>2019-11-18T09:41:40.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/7QDxcAVFmLVGbKGdtE7dRg" target="_blank" rel="noopener">深入理解JavaScript的设计模式</a></p>]]></content>
    
    <summary type="html">
    
      介绍设计模式的作用和比较简单的单例模式
    
    </summary>
    
      <category term="设计模式" scheme="http://asyncnode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://asyncnode.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代码评审</title>
    <link href="http://asyncnode.com/blog/other/code_review.html"/>
    <id>http://asyncnode.com/blog/other/code_review.html</id>
    <published>2019-11-05T13:12:32.000Z</published>
    <updated>2019-11-18T09:29:24.433Z</updated>
    
    <summary type="html">
    
      代码评审
    
    </summary>
    
      <category term="Other" scheme="http://asyncnode.com/categories/Other/"/>
    
    
      <category term="编码相关" scheme="http://asyncnode.com/tags/%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>lighthouse的使用</title>
    <link href="http://asyncnode.com/blog/performance/performance-lighthouse.html"/>
    <id>http://asyncnode.com/blog/performance/performance-lighthouse.html</id>
    <published>2019-11-03T02:20:42.000Z</published>
    <updated>2019-11-18T08:55:46.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/EuFDLOCg53IxvieaQDeYug" target="_blank" rel="noopener">网易云音乐前端性能监控实践</a></p>]]></content>
    
    <summary type="html">
    
      lighthouse的使用
    
    </summary>
    
      <category term="Browser" scheme="http://asyncnode.com/categories/Browser/"/>
    
    
      <category term="Browser" scheme="http://asyncnode.com/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>typeScript中的interface （未完成）</title>
    <link href="http://asyncnode.com/blog/typeScript/typeScript_decorator.html"/>
    <id>http://asyncnode.com/blog/typeScript/typeScript_decorator.html</id>
    <published>2019-10-30T04:52:54.000Z</published>
    <updated>2019-11-18T08:21:23.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/06iBhb4ye6-1cAxgLX7ybA" target="_blank" rel="noopener">TypeScript真香系列——接口篇</a></p>]]></content>
    
    <summary type="html">
    
      学习TypeScript
    
    </summary>
    
      <category term="TypeScript" scheme="http://asyncnode.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://asyncnode.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>react中使用useState （未完成）</title>
    <link href="http://asyncnode.com/blog/react/react-useState.html"/>
    <id>http://asyncnode.com/blog/react/react-useState.html</id>
    <published>2019-10-24T02:23:53.000Z</published>
    <updated>2019-11-18T08:21:44.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/ydApE7akeJ0VO3R1r365mQ" target="_blank" rel="noopener">简单易懂的 React useState() Hook 指南（长文建议收藏）</a></p>]]></content>
    
    <summary type="html">
    
      react中使用useState
    
    </summary>
    
      <category term="React" scheme="http://asyncnode.com/categories/React/"/>
    
    
      <category term="React" scheme="http://asyncnode.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>node中的线程和进程，父子进程的关联 （未完成）</title>
    <link href="http://asyncnode.com/blog/node/node_process.html"/>
    <id>http://asyncnode.com/blog/node/node_process.html</id>
    <published>2019-10-20T12:13:24.000Z</published>
    <updated>2019-11-18T08:21:18.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/VzXnnfn4gCBMd5wea3LRIg" target="_blank" rel="noopener">深入理解 Node.js 进程与线程</a></p>]]></content>
    
    <summary type="html">
    
      node中的垃圾回收机制简单的讲解
    
    </summary>
    
      <category term="Node" scheme="http://asyncnode.com/categories/Node/"/>
    
    
      <category term="Node" scheme="http://asyncnode.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>typeScript中的interface （未完成）</title>
    <link href="http://asyncnode.com/blog/typeScript/typeScript_interface.html"/>
    <id>http://asyncnode.com/blog/typeScript/typeScript_interface.html</id>
    <published>2019-10-17T11:24:21.000Z</published>
    <updated>2019-11-18T08:21:28.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/06iBhb4ye6-1cAxgLX7ybA" target="_blank" rel="noopener">TypeScript真香系列——接口篇</a></p>]]></content>
    
    <summary type="html">
    
      学习TypeScript
    
    </summary>
    
      <category term="TypeScript" scheme="http://asyncnode.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://asyncnode.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列 ———— mvc和mvvm到底是什么</title>
    <link href="http://asyncnode.com/blog/mode/mode-mvc-mvvm.html"/>
    <id>http://asyncnode.com/blog/mode/mode-mvc-mvvm.html</id>
    <published>2019-10-13T06:32:21.000Z</published>
    <updated>2019-10-24T05:12:36.958Z</updated>
    
    <summary type="html">
    
      在现在常用框架中比如说Vue是mvvm模式，react是mvc模式，其实设计模式最早是在建筑工程学中产生的，后面被引申到程序设计中。一开始基本上都是在服务器web语言中听到这种模式的，这篇文章记录清楚mvvm和mvc到底是什么？他们一样？
    
    </summary>
    
      <category term="设计模式" scheme="http://asyncnode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://asyncnode.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝系列 ———— 分析lodash中的deepcopy</title>
    <link href="http://asyncnode.com/blog/javascript/javascript-loadsh-deepcopy.html"/>
    <id>http://asyncnode.com/blog/javascript/javascript-loadsh-deepcopy.html</id>
    <published>2019-10-07T12:12:58.000Z</published>
    <updated>2019-10-24T05:12:36.952Z</updated>
    
    <summary type="html">
    
      本篇文章学习loadsh中的deepcopy，并且优化自己的在上篇文章中写的deepcopy。
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
      <category term="深拷贝" scheme="http://asyncnode.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝系列 ———— 自己通过递归实现一个深拷贝</title>
    <link href="http://asyncnode.com/blog/javascript/javascript-deepcopy.html"/>
    <id>http://asyncnode.com/blog/javascript/javascript-deepcopy.html</id>
    <published>2019-10-02T15:12:32.000Z</published>
    <updated>2019-11-13T09:44:08.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/blog/es6/es6-assign.html">深拷贝系列 ———— 什么是深拷贝、浅拷贝、Object.assign</a><br><a href="/blog/javascript/javascript-paser-stringify.html">深拷贝系列 ———— 自己实现一个 JSON.stringify 和 JSON.parse</a><br><a href="/blog/javascript/javascript-deepcopy.html">深拷贝系列 ———— 自己通过递归实现一个深拷贝</a><br><a href="/blog/javascript/javascript-loadsh-deepcopy.html">深拷贝系列 ———— 分析 lodash 中的 deepcopy</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上篇文章中我们深入了解了<code>JSON.parse/JSON.stringify</code>，并且自己实现了一个<code>JSON.parse/JSON.stringify</code>，在这篇文章中我们要自己实现一个<strong>深拷贝</strong>，并且解决<code>JSON.parse/JSON.stringify</code>中出现的问题。</p><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p><strong>实现目标</strong></p><ul><li>我们通过递归实现一个简单的深拷贝</li><li>判断<code>Object</code>和<code>Array</code></li></ul><p><strong>实现步骤</strong></p><ul><li>提前声明一个判断类型函数<code>getType</code></li><li>声明函数<code>cloneDeep</code>，首先判断<code>原对象</code>是否为<code>object</code>类型，如果不是直接返回原值</li><li>声明一个新的目标对象<code>newTarget</code>，它的类型根据入参决定<code>（Array、Object）</code></li><li>通过<code>for...in</code>循环<code>原对象</code>，并且通过<code>hasOwnProperty</code>判断属性是否为本身属性</li><li>如果是本身属性递归调用<code>cloneDeep</code></li><li>最后返回新对象<code>newTarget</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">    <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否传入类型为Object</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明新对象</span></span><br><span class="line">    <span class="keyword">let</span> newTarget = getType(target) === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="comment">// 循环对象 递归复制给新对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">        <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            newTarget[key] = cloneDeep(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新对象</span></span><br><span class="line">    <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    val1: <span class="number">1</span>,</span><br><span class="line">    val2: <span class="literal">undefined</span>,</span><br><span class="line">    val4: <span class="string">'target'</span>,</span><br><span class="line">    val5: &#123;</span><br><span class="line">        name: <span class="string">'target'</span>,</span><br><span class="line">        age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> targetArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="attr">name</span>: <span class="string">'123'</span>, <span class="attr">age</span>: <span class="number">789</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(cloneDeep(target));</span><br><span class="line"><span class="built_in">console</span>.log(cloneDeep(targetArray));</span><br></pre></td></tr></table></figure><p>测试效果图如下：</p><p><img src="../../images/javascript/javascript-clone-deep-1-1.png" width="80%" height="60%"></p><p>在上面的代码中，已经解决了<code>JSON.stringify/JSON.parse</code>中的忽略<code>undefined/function</code>的问题，下面会逐渐解决问题，并且优化到类似与<code>lodash</code>库中的问题。</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p><strong>实现目标</strong></p><ul><li>解决循环引用对象问题</li><li>解决引用丢失问题</li></ul><p><strong>实现步骤</strong></p><ul><li>首先了解<code>Map</code>、<code>WeakMap</code>是什么</li><li>通过<code>Map</code>、<code>WeakMap</code>、<code>Array</code>储存属性对象</li><li>如果再次使用，直接从<code>Map</code>、<code>WeakMap</code>中取出(这样既解决了循环引用，又解决了引用丢失)</li></ul><p>测试循环引用代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    val1: <span class="number">1</span>,</span><br><span class="line">    val2: <span class="literal">undefined</span>,</span><br><span class="line">    val4: <span class="string">"target"</span>,</span><br><span class="line">    val5: &#123;</span><br><span class="line">        name: <span class="string">"target"</span>,</span><br><span class="line">        age: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        sym: <span class="built_in">Symbol</span>(<span class="string">"setter"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;</span><br><span class="line"><span class="built_in">console</span>.log(cloneDeep(target));</span><br></pre></td></tr></table></figure><p>执行效果如下图所示：<br><img src="../../images/javascript/javascript-clone-deep-1-2.png" alt="深拷贝/浅拷贝"></p><h3 id="Map-weakMap"><a href="#Map-weakMap" class="headerlink" title="Map/weakMap"></a>Map/weakMap</h3><p><code>Map</code>和<code>WeakMap</code>都是ES6中的新出的数据类型。如果有兴趣可以去<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">WeakMap mdn</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">Map mdn</a>，或者<a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">Set 和 Map 数据结构</a>去了解它们的<code>api</code>和<code>使用场景</code>等。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code>对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><p><strong>语法</strong></p><p><code>new Map([iterable])</code></p><ul><li><code>iterable</code>: <code>Iterable</code> 可以是一个<code>数组</code>或者其他 <code>iterable 对象</code>，其元素为键值对(两个元素的数组，例如: <code>[[ 1, &#39;one&#39; ],[ 2, &#39;two&#39; ]]</code>)。 每个键值对都会添加到新的<code>Map</code>。<code>null</code> 会被当做 <code>undefined</code>。</li></ul><p><strong>常用方法</strong></p><ul><li><code>Map.prototype.get(key)</code>: 返回键对应的值，如果不存在，则返回<code>undefined</code>。</li><li><code>Map.prototype.set(key, value)</code>: 设置<code>Map</code>对象中键的值。返回该<code>Map对象</code>。</li><li><code>Map.prototype.has(key)</code>: 返回一个<code>布尔值</code>，表示<code>Map实例</code>是否包含键对应的值。</li><li><code>Map.prototype.delete(key)</code>: 如果 <code>Map对象</code>中存在该元素，则移除它并返回 <code>true</code>；否则如果该元素不存在则返回 <code>false</code>。</li></ul><p>这里只介绍了常用的<code>操作方法</code>，<code>Map</code>还有<code>循环方法</code>、<code>其他方法</code>等等。</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oneMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;</span><br><span class="line">    name: <span class="string">'keyObj'</span></span><br><span class="line">&#125;;</span><br><span class="line">oneMap.set(<span class="string">'name'</span>, <span class="string">'test'</span>); <span class="comment">// &#123;"name" =&gt; "test"&#125;</span></span><br><span class="line">oneMap.set(keyObj, <span class="string">'keyObj'</span>); <span class="comment">// &#123;"name" =&gt; "test", keyObj =&gt; "keyObj"&#125; 这里的keyObj是上面声明的对象</span></span><br><span class="line"></span><br><span class="line">oneMap.get(<span class="string">'name'</span>); <span class="comment">// "test"</span></span><br><span class="line">oneMap.get(keyObj); <span class="comment">// "keyObj"</span></span><br><span class="line"></span><br><span class="line">oneMap.has(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">oneMap.has(keyObj); <span class="comment">// true</span></span><br><span class="line">oneMap.has(<span class="string">'age'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">oneMap.delete(<span class="string">'name'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p><code>WeakMap</code> 对象是一组<code>键/值对</code>的集合，其中的键是<code>弱引用</code>的。其键<code>必须是对象</code>，而值可以是<code>任意</code>的。</p><p>它的语法、参数与<code>Map</code>是一至的，只有两点区别：</p><ul><li><code>WeakMap</code>只接受<code>对象</code>作为<code>键</code>名（<code>null除外</code>），<code>不接受其他类型的值作为键名</code>。</li><li><code>WeakMap</code> <code>弱引用</code>的<code>只是键名</code>，而<code>不是键值</code>。<code>键值</code>依然是<code>正常引用</code>。</li></ul><p>同时<code>WeakMap</code>只有上面<code>get/set/has/delete</code>四种方法，其它的方法它都是没有的。</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><p>这里就不测试它的操作方法了，它的操作方法与<code>Map</code>一至。</p><h3 id="通过Map解决"><a href="#通过Map解决" class="headerlink" title="通过Map解决"></a>通过Map解决</h3><p>在这里我们通过<code>Map</code>来解决循环引用，修改代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span> (<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否传入类型为Object</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明新对象</span></span><br><span class="line">    <span class="keyword">let</span> newTarget = getType(target) === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;!------新增代码开始------!&gt;</span></span><br><span class="line">    <span class="comment">// 查询map中是否有存在原对象（target），如果存在直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果map中不存在原对象（target），则储存进map中</span></span><br><span class="line">    map.set(target, newTarget);</span><br><span class="line">    <span class="comment">// &lt;!------新增代码结束------!&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环对象 递归复制给新对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">        <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            newTarget[key] = cloneDeep(target[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新对象</span></span><br><span class="line">    <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试代码如下：<br><img src="../../images/javascript/javascript-clone-deep-1-3.png" width="80%" height="60%"></p><p>我们可以看到<code>target</code>变为一个<code>Circular</code>类型的对象，这个是在<code>node环境</code>中运行的，如果在<code>浏览器</code>对还是会<code>报错（爆栈）</code>。<br>到这里我们只做到了让他没有报错，但是也并没有完美的解决循环引用的问题，下面就要到<code>WeakMap</code>登场了。</p><h3 id="WeakMap解决"><a href="#WeakMap解决" class="headerlink" title="WeakMap解决"></a>WeakMap解决</h3><p>上面我们已经讲解过<code>Map</code>和<code>WeakMap</code>的不同点和相同点，为什么说<code>WeakMap</code>在解决循环引用会比<code>Map</code>好很多呢，就是因为<code>WeakMap</code>它的<code>键值</code>是弱引用的。<br>什么是弱引用，即<code>垃圾回收机制</code>不考虑 <code>WeakMap</code> 对该对象的引用，也就是说，如果其他对象都<code>不再引用</code>该对象，那么<code>垃圾回收机制</code>会<code>自动回收</code>该对象所占用的<code>内存</code>，不考虑该对象还存在于 <code>WeakMap</code> 之中。<br>要深入理解<code>弱引用</code>这个又会涉及到<code>Node</code>和<code>JavaScript</code>底层垃圾回收机制，因为它们的垃圾回收机制都是使用的<code>标记法</code>，又分为<code>新生代</code>和<code>老生代</code>，所以这里就不多做赘述了。后面会有一系列文章来讲述<code>Node</code>和<code>JavaScript</code>中的相同和异同点。</p><p>修改代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只是把Map修改为WeakMap</span></span><br><span class="line">map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br></pre></td></tr></table></figure><p>这样无论是在<code>浏览器端</code>还是<code>node</code>中都可以正常的运行。</p><h2 id="类型问题"><a href="#类型问题" class="headerlink" title="类型问题"></a>类型问题</h2><p>我们在上面只考虑了<code>Array/Object</code>其实就是<code>Object</code>类型的数据处理，其他的数据都是走的直接返回。</p><ul><li>改写<code>Object</code>的判断，并且分别处理<code>Array/Object</code>方法</li><li>处理<code>Function</code></li><li>处理<code>Symbol</code></li><li>处理<code>不可循环类型（Number/String/Date/Boolean）</code></li><li>处理<code>RegExp/Map/Set</code></li></ul><p>我们就按上面的步骤一步一步分拆不同类型走不同的处理，已解决在<code>JSON.stringify</code>遇到的问题。</p><h3 id="Object类型判断"><a href="#Object类型判断" class="headerlink" title="Object类型判断"></a>Object类型判断</h3><p>在上面的代码中我们只是简单的判断了<code>Object</code>，如果不是<code>Object</code>直接返回，其实是没有考虑到<code>null</code>这个特殊情况的。我们现在就要加上<code>null</code>的怕判断并且后面也要独立处理<code>Function</code>类型的<code>copy</code>。</p><p><strong>实现目标</strong>：</p><ul><li><code>null</code>的判断</li><li><code>function</code>的判断</li><li><code>Array/Object</code>的分别处理</li></ul><p><strong>代码实现</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增判断属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 储存传入值的类型</span></span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="comment">// 过滤null</span></span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span> (<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否传入类型为Object</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 。。。省略代码</span></span><br><span class="line">    <span class="comment">// 其实还可以通过Array.isArray()来检测是否为数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><strong>function</strong>处理：</p><p>其实即使<code>function</code>指向同一个内存地址，他也是没有任何问题的，所以可以直接可以返回<code>return value</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span>;</span><br><span class="line"><span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>数据类型 <code>“symbol”</code> 是一种原始数据类型，该类型的性质在于这个类型的值可以用来<code>创建匿名的对象属性</code>。<br>我们可以拷贝<code>symbol</code>类型的属性名？</p><p>首先我们可以通过<code>typeof、Object.prototype.toString.call()</code>来检测<code>symbol</code>的类型，但是我们怎么获取到<code>symbol</code>.</p><p><strong>示例</strong>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">Symbol</span>(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">typeof</span> test; <span class="comment">// symbol</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(test); <span class="comment">// [object Symbol]</span></span><br></pre></td></tr></table></figure><p>我们可以通过两种方法获取的到<code>symbol</code>.</p><ul><li><code>Object.getOwnPropertySymbols(...)</code>: <code>Object.getOwnPropertySymbols(...)</code>可以查找一个给定对象的符号属性时返回一个 <code>symbol</code> 类型的数组。</li><li><code>Reflect.ownKeys(...)</code>: 返回一个由目标对象自身的<code>属性键</code>组成的数组。</li></ul><blockquote><p>注意： 每个初始化的对象都是没有自己的 symbol 属性的，因此这个数组可能为空，除非你已经在对象上设置了 symbol 属性。<br><code>Reflect.ownKeys(...)</code>的返回值等同于<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>。</p></blockquote><p><strong>示例</strong>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sName = <span class="built_in">Symbol</span>(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">var</span> age = <span class="built_in">Symbol</span>(<span class="string">'age'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testObj = &#123;</span><br><span class="line">    firstSex: <span class="string">'man'</span></span><br><span class="line">&#125;;</span><br><span class="line">testObj[sName] = <span class="string">'name'</span>;</span><br><span class="line">testObj[age] = <span class="number">19</span>;</span><br><span class="line">testObj.lastSex = <span class="string">'girl'</span></span><br><span class="line"></span><br><span class="line">objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(testObj);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols)         <span class="comment">// [Symbol('name'), Symbol('age')]</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols[<span class="number">0</span>])      <span class="comment">// Symbol('name')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(testObj); <span class="comment">// ["firstSex", "lastSex", Symbol(name), Symbol(age)]</span></span><br><span class="line"><span class="comment">// 注意顺序</span></span><br></pre></td></tr></table></figure><p>这个只能获取到当前的值，但是我们怎么拷贝这个属性呢？</p><p>我们可以通过<code>valueOf</code>来获取<code>symbol</code>的原始值，然后再复制当前的属性和值。<br><code>valueOf()</code>方法返回当前 <code>symbol</code> 对象所包含的 <code>symbol</code> 原始值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span> (<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保存方法</span></span><br><span class="line">    <span class="keyword">const</span> symbolValueOf = <span class="built_in">Symbol</span>.prototype.valueOf;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(symbolValueOf.call(symbol))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不可循环类型"><a href="#不可循环类型" class="headerlink" title="不可循环类型"></a>不可循环类型</h3><p>我们常用的不可循环的类型，比如<code>Number/String/Date/Boolean</code>，如果是一些字面量<strong>直接赋值</strong>给新的对象也是没有问题，但是我们通过创建一个新的对象自然更好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneStatic</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取构造函数</span></span><br><span class="line">    <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">    <span class="comment">// 实例化一个同类型的属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RegExp-Map-Set"><a href="#RegExp-Map-Set" class="headerlink" title="RegExp/Map/Set"></a>RegExp/Map/Set</h3><p>首先处理<code>RegExp</code>正则，我们这里直接使用<code>lodash</code>中的，其实和静态的方法类似，都是生成一个新的<code>RegExp</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">regexp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> regexp.constructor(regexp.source, reFlags.exec(regexp));</span><br><span class="line">    result.lastIndex = regexp.lastIndex;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map/Set"></a>Map/Set</h4><p>我们要考虑<code>Map/Set</code>类型的处理，因为它们也是可以循环的，并且他们可以的<code>key-value</code>也可以为可循环的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneMap</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个新的Map</span></span><br><span class="line">    <span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 循环复制到新Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 因为值有可能是一个对象、数组，所以要递归调用</span></span><br><span class="line">        newMap.set(key, cloneDeep);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newMap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSet</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个新的Set</span></span><br><span class="line">    <span class="keyword">let</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 循环复制到新Set</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 因为值有可能是一个对象、数组，所以要递归调用</span></span><br><span class="line">        newSet.add(key, cloneDeep);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们考虑了大部分类型的实现，下面是完整的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// &lt;!------------工具函数开始----------------------------!&gt;</span></span><br><span class="line"><span class="comment">// 创建数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createData</span>(<span class="params">deep, breadth</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> temp = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deep; i++) &#123;</span><br><span class="line">    temp = temp[<span class="string">"data"</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; breadth; j++) &#123;</span><br><span class="line">      temp[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">  <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否为引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 储存传入值的类型</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="comment">// 过滤null</span></span><br><span class="line">  <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">"object"</span> || type === <span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 克隆function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunc</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">"function"</span>;</span><br><span class="line">  <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆symbol</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存方法</span></span><br><span class="line">  <span class="keyword">const</span> symbolValueOf = <span class="built_in">Symbol</span>.prototype.valueOf;</span><br><span class="line">  <span class="comment">// 返回key</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(symbolValueOf.call(symbol));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆RegExp</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">regexp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> regexp.constructor(regexp.source, reFlags.exec(regexp));</span><br><span class="line">  result.lastIndex = regexp.lastIndex;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可循环的类型 Number/String/Date/Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneStatic</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取构造函数</span></span><br><span class="line">  <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">  <span class="comment">// 实例化一个同类型的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;!------------工具函数结束----------------------------!&gt;</span></span><br><span class="line"><span class="comment">// &lt;!------------克隆逻辑开始----------------------------!&gt;</span></span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="comment">// console.log(isObject(target));</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(111);</span></span><br><span class="line">  <span class="keyword">let</span> newTarget = &#123;&#125;;</span><br><span class="line">  <span class="keyword">switch</span> (getType(target)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Number"</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"String"</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Boolean"</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Date"</span>:</span><br><span class="line">      <span class="keyword">return</span> cloneStatic(target);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"RegExp"</span>:</span><br><span class="line">      <span class="keyword">return</span> cloneRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Function"</span>:</span><br><span class="line">      <span class="keyword">return</span> cloneFunc(target);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Array"</span>:</span><br><span class="line">      newTarget = [];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Map"</span>:</span><br><span class="line">      newTarget = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Set"</span>:</span><br><span class="line">      newTarget = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询map中是否有存在原对象（target），如果存在直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (map.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果map中不存在原对象（target），则储存进map中</span></span><br><span class="line">  map.set(target, newTarget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝Map</span></span><br><span class="line">  <span class="keyword">if</span> (getType(target) === <span class="string">"Map"</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环复制到新Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 因为值有可能是一个对象、数组，所以要递归调用</span></span><br><span class="line">      newTarget.set(key, cloneDeep(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newTarget;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拷贝Set</span></span><br><span class="line">  <span class="keyword">if</span> (getType(target) === <span class="string">"Set"</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环复制到新Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 因为值有可能是一个对象、数组，所以要递归调用</span></span><br><span class="line">      newTarget.add(key, cloneDeep(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环对象 递归复制给新对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">      newTarget[key] = cloneDeep(target[key], map); <span class="comment">// &lt;!------新增代码 参数map------!&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新对象</span></span><br><span class="line">  <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;!------------克隆逻辑结束----------------------------!&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化symbol</span></span><br><span class="line"><span class="keyword">let</span> oneSymbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 实例化Map</span></span><br><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">newMap.set(<span class="string">"name"</span>, &#123; <span class="attr">name</span>: <span class="string">"everybody"</span> &#125;);</span><br><span class="line"><span class="comment">// 实例化Set</span></span><br><span class="line"><span class="keyword">let</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">newSet.add(<span class="string">"age"</span>, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  val1: <span class="number">1</span>,</span><br><span class="line">  val2: <span class="literal">undefined</span>,</span><br><span class="line">  val4: <span class="string">"target"</span>,</span><br><span class="line">  val5: &#123;</span><br><span class="line">    name: <span class="string">"target"</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"永远18岁"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    sym: <span class="built_in">Symbol</span>(<span class="string">"setter"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  val32: <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>),</span><br><span class="line">  val23: <span class="keyword">new</span> <span class="built_in">String</span>(<span class="literal">true</span>),</span><br><span class="line">  val443: <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="literal">true</span>),</span><br><span class="line">  date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  reg: <span class="regexp">/\d+/</span>,</span><br><span class="line">  empty: <span class="literal">null</span>,</span><br><span class="line">  newMap,</span><br><span class="line">  newSet,</span><br><span class="line">  arrowFunc: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test111"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  deepObj: createData(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">&#125;;</span><br><span class="line">target[oneSymbol] = <span class="string">"name"</span>;</span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> ss = cloneDeep(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ss);</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="../../images/javascript/javascript-clone-deep-1-4.png" width="80%" height="60%"></p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>在上面我们使用的循环是<code>for...in</code>，但是他的性能并不是最高的，我们现在来对比一下<code>for...in</code>、<code>for</code>、<code>while</code>、<code>forEach</code>三个循环谁的速度更快。<br>我们可以通过每个循环<code>100000</code>次，在浏览器端通过<code>console.time()</code>、<code>console.timeend()</code>统计当前执行的循环效率。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成数据</span></span><br><span class="line"><span class="keyword">let</span> initData = [];</span><br><span class="line"><span class="keyword">var</span> len = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = &#123;</span><br><span class="line">        name: <span class="string">'name'</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        sex: <span class="string">'man'</span>,</span><br><span class="line">        class: 'first'</span><br><span class="line">    &#125;;</span><br><span class="line">    initData.push(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录for循环时间</span></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    sum += initData[i].age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录for...in循环时间</span></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> initData) &#123;</span><br><span class="line">    sum += initData[item];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录while循环时间</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">    sum += initData[i].age;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"><span class="comment">// 记录forEach循环时间</span></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line">initData.forEach(<span class="function">(<span class="params">item, index, soruce</span>) =&gt;</span> &#123;</span><br><span class="line">    sum += item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br></pre></td></tr></table></figure><p>多次执行效果相差不多，执行效果如下：<br><img src="../../images/javascript/javascript-clone-deep-1-5.png" width="80%" height="60%"></p><p>图上的四个时间分别对应的顺序是：</p><ul><li><code>for</code>: 2.8ms</li><li><code>for...in</code>: 17.7ms</li><li><code>while</code>: 4.4ms</li><li><code>forEach</code>: 45.2ms</li></ul><p>这个测试环境是在<code>mac pro i7 16G</code>、<code>Chrome 78.0.3904.87</code>这个进行的只是简单测试，大致结果<code>for &gt; while &gt; for...in &gt; forEach</code>。</p><p>但是我看到<code>lodash</code>中是用的<code>while</code>，并且别人测试的是和我测试相反的。这里就不再多做追究了，免的喧宾夺主后面会独立一篇文章好好探讨一下谁的速度更快。<br>我们也通过<code>while</code>改写代码吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">        <span class="comment">// 执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (iteratee(array[index], index, array) === <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改循环逻辑的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原代码如下</span></span><br><span class="line"><span class="comment">// 循环对象 递归复制给新对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        newTarget[key] = cloneDeep(target[key], map); <span class="comment">// &lt;!------新增代码 参数map------!&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = getType(target) === <span class="string">"Array"</span> ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">arrayEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">        key = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">        newTarget[key] = cloneDeep(target[key], map); <span class="comment">// &lt;!------新增代码 参数map------!&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化symbol</span></span><br><span class="line"><span class="keyword">let</span> oneSymbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 实例化Map</span></span><br><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">newMap.set(<span class="string">"name"</span>, &#123; <span class="attr">name</span>: <span class="string">"everybody"</span> &#125;);</span><br><span class="line"><span class="comment">// 实例化Set</span></span><br><span class="line"><span class="keyword">let</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">newSet.add(<span class="string">"age"</span>, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    val1: <span class="number">1</span>,</span><br><span class="line">    val2: <span class="literal">undefined</span>,</span><br><span class="line">    val4: <span class="string">"target"</span>,</span><br><span class="line">    val5: &#123;</span><br><span class="line">        name: <span class="string">"target"</span>,</span><br><span class="line">        age: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"永远18岁"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        sym: <span class="built_in">Symbol</span>(<span class="string">"setter"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    val32: <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>),</span><br><span class="line">    val23: <span class="keyword">new</span> <span class="built_in">String</span>(<span class="literal">true</span>),</span><br><span class="line">    val443: <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="literal">true</span>),</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    reg: <span class="regexp">/\d+/</span>,</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    newMap,</span><br><span class="line">    newSet,</span><br><span class="line">    arrowFunc: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"test111"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    deepObj: createData(<span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;;</span><br><span class="line">target[oneSymbol] = <span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log('');</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> ss1 = cloneDeepTwo(target)</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> ss = clone(target)</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br></pre></td></tr></table></figure><p>分开测试执行时间相差是<code>1ms-2ms</code>，其实并不相差太大，不能一起测试，因为一起测试的话，第一次执行的一些变量会被储存在内存中，第二次执行的速度自然会很快，所以一起测试的时间并不准确。</p><h3 id="递归爆栈"><a href="#递归爆栈" class="headerlink" title="递归爆栈"></a>递归爆栈</h3><p>我们测试使用的数据深度为<code>100</code>，广度为<code>1000</code>，这样还是不会造成递归爆栈，但是当我们把深度广度都提升到<code>10000</code>次就会造成递归爆栈。<br>解决递归爆栈的方法有三种：</p><ul><li>加大阈值</li><li>循环改写</li><li>尾递归优化</li></ul><p>因为<code>JavaScript</code>是会运行在浏览器端的，我们不能加大它的内存占用。</p><p>以前在<code>V8</code>中是已经是实现了<code>尾递归</code>的，但是它会影响<code>JavaScript</code>的栈的调用顺序，所以最后又删除掉了。<br>如果有兴趣可以去看我另一篇文章<a href="/blog/algorithm/algorithm-tailCall.html">尾递归</a></p><p>我们这里只用循环实现防止递归爆栈。</p><p>当我们的对象层级特别深事，我们通过递归循环时，会造成递归爆栈，因为一些临时变量会储存在堆栈中，通多深层递归调用，它们的不会被回收，当调用的层级越深自然储存的就越多，最后会导致栈储存不下，也就会造成递归爆栈。</p><p>我们可通过自己<code>创建一个栈</code>，<code>栈</code>中储存当前要拷贝的节点，一层一层往下拷贝，所以是一个深度优先的优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneLoop</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: <span class="literal">undefined</span>,</span><br><span class="line">            data: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        <span class="comment">// 深度优先</span></span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,</span><br><span class="line">                        key: k,</span><br><span class="line">                        data: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细内容见<a href="https://mp.weixin.qq.com/s/iDbDyWeSDgShqR_nQ1po_g" target="_blank" rel="noopener">深拷贝的终极探索</a></p><p>到此就一个<code>深拷贝</code>就结束了</p><h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>我们是在原来的基础上一步一步优化我们自己的<code>深拷贝</code>实现，但是最后的<code>递归爆栈</code>如果在当前文章书写的话，会让当前文章很乱，所以会独立出来一篇文章来记录什么是<code>斐波拉契数列</code>相关的。</p><p>我们的大致实现步骤是：</p><ul><li>用递归实现一个简单的深拷贝</li><li>考虑循环引用问题，通过<code>WeakMap</code>解决</li><li>考虑类型问题，处理<code>Function、Map、Set</code>等等</li><li>考虑性能问题，递归爆栈问题</li></ul><p>到此基本上就实现一个可以使用的<strong>深拷贝</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://github.com/lodash/lodash/blob/master/cloneDeep.js" target="_blank" rel="noopener">lodash cloneDeep</a><br><a href="https://muyiy.cn/blog/4/4.1.html#%E4%B8%80%E3%80%81%E8%B5%8B%E5%80%BC%EF%BC%88copy%EF%BC%89" target="_blank" rel="noopener">深浅拷贝原理</a><br><a href="https://mp.weixin.qq.com/s/gQhfwoaxqHh4hRG1BQqKow" target="_blank" rel="noopener">如何写出一个惊艳面试官的深拷贝</a><br><a href="https://mp.weixin.qq.com/s/iDbDyWeSDgShqR_nQ1po_g" target="_blank" rel="noopener">深拷贝的终极探索</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      本篇文章会介绍通过递归实现一个深拷贝，并且解决JSON.parse和JSON.stringify存在的问题。
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
      <category term="深拷贝" scheme="http://asyncnode.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝系列 ———— 自己实现一个JSON.stringify和JSON.parse</title>
    <link href="http://asyncnode.com/blog/javascript/javascript-paser-stringify.html"/>
    <id>http://asyncnode.com/blog/javascript/javascript-paser-stringify.html</id>
    <published>2019-09-27T10:23:56.000Z</published>
    <updated>2019-11-11T02:00:45.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/blog/es6/es6-assign.html">深拷贝系列 ———— 什么是深拷贝、浅拷贝、Object.assign</a><br><a href="/blog/javascript/javascript-paser-stringify.html">深拷贝系列 ———— 自己实现一个 JSON.stringify 和 JSON.parse</a><br><a href="/blog/javascript/javascript-deepcopy.html">深拷贝系列 ———— 自己通过递归实现一个深拷贝</a><br><a href="/blog/javascript/javascript-loadsh-deepcopy.html">深拷贝系列 ———— 分析 lodash 中的 deepcopy</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上篇文章我们已经了解什么是<strong>深拷贝</strong>和<strong>浅拷贝</strong>，也着重介绍了<strong>浅拷贝</strong>相关的一下实现方法，或者自己实现一个浅拷贝等等。本篇文章主要介绍深拷贝的一种简单实现方式<code>JSON.parse/JSON.stringify</code>。在平常开发时我们可以经常的看到别人使用，或者在不那么了解深拷贝时自己也有使用。</p><p><strong>JSON.parse/JSON.stringify</strong>其实是用来序列化 JSON 格式的数据的方法。那它为什么能实现一个简单的深拷贝呢？<br>在执行<code>JSON.stringify</code>会把我们的一个对象序列化为字符串，而字符串是基本类型。<br>再通过<code>JSON.parse</code>时，把字符串类型反序列化为对象，这个时候因为在反序列化之前它是基本类型所以他会指向一个新的地址，在反序列化之后它是一个对象会再分配内存空间。<br>所以<strong>JSON.parse/JSON.stringify</strong>可以实现一个简单的<strong>深拷贝</strong>。</p><p>本篇文章首先实现一个<code>JSON.stringify/JSON.parse</code>，下一篇文章实现一个比较完整的<strong>深拷贝</strong>。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>直接上代码验证一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明原始对象</span></span><br><span class="line"><span class="keyword">var</span> old = &#123;</span><br><span class="line">  name: <span class="string">"old"</span>,</span><br><span class="line">  attr: &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">"man"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  title: [<span class="string">"M1"</span>, <span class="string">"P6"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个新对象，通过SON.parse/JSON.stringify 实现对原始对象深拷贝，并且赋值给新对象</span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(old));</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始对象的name，新对象不受影响</span></span><br><span class="line">old.name = <span class="string">"new"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(old); <span class="comment">// &#123;name: "new", attr: &#123;age: 18, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始对象的引用类型，新对象也不受影响</span></span><br><span class="line">old.attr.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(old); <span class="comment">// &#123;name: "new", attr: &#123;age: 20, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br></pre></td></tr></table></figure><p>其实是不是以为用这个就可以了，并没有什么问题啊，下面我们就来一点点揭开它的面纱。</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>其实<code>JSON.parse/JSON.stringify</code>还是有很多局限性，大致如下：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>Symbol</code></li><li>无法序列化<code>function</code>，也会忽略</li><li>无法解决循环引用，会报错</li><li>深层对象转换爆栈</li></ul><p>直接上代码验证</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个包含undefined、null、symbol、function的对象</span></span><br><span class="line"><span class="keyword">var</span> oldObj = &#123;</span><br><span class="line">  name: <span class="string">"old"</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  sex: <span class="built_in">Symbol</span>(<span class="string">"setter"</span>),</span><br><span class="line">  title: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  lastName: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br><span class="line"><span class="comment">// 可以看到会忽略undefined、symbol、function的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">// &#123;name: "old", lastName: null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstObj = &#123;</span><br><span class="line">  name: <span class="string">"firstObj"</span></span><br><span class="line">&#125;;</span><br><span class="line">firstObj.newKey = firstObj;</span><br><span class="line"><span class="comment">// Converting circular structure to JSON</span></span><br><span class="line"><span class="keyword">var</span> newFirstObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(firstObj));</span><br></pre></td></tr></table></figure><p>如果循环引用报错如下图所示：<br><img src="../../images/es/es-assign-1-4.png" alt="JSON.parse/JSON.stringify"></p><p>一个生成<strong>任意深度、广度</strong>对象方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createData</span>(<span class="params">deep, breadth</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> temp = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deep; i++) &#123;</span><br><span class="line">    temp = temp[<span class="string">"data"</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; breadth; j++) &#123;</span><br><span class="line">      temp[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证<code>JSON.stringify</code>递归爆栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(createData(<span class="number">10000</span>));</span><br><span class="line"><span class="comment">// VM97994:1 Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><h2 id="自己实现-JSON-stringify"><a href="#自己实现-JSON-stringify" class="headerlink" title="自己实现 JSON.stringify"></a>自己实现 JSON.stringify</h2><ul><li><strong>首先一个简单的递归</strong></li><li>区分<code>String</code>与<code>Boolean</code>、<code>Number</code>、<code>null</code></li><li>过滤<code>undefined</code>、<code>symbol</code>、<code>function</code><!-- - 递归爆栈提示 --></li><li>循环引用警告</li></ul><h3 id="一个简单的递归"><a href="#一个简单的递归" class="headerlink" title="一个简单的递归"></a>一个简单的递归</h3><p><strong>实现目标</strong></p><ul><li>递归调用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">  <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是非object类型 or null的类型直接返回 原值的String</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span> || getType(obj) === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明一个数组</span></span><br><span class="line">  <span class="keyword">let</span> json = [];</span><br><span class="line">  <span class="comment">// 判断当前传入参数是对象还是数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = obj ? getType(obj) === <span class="string">"Array"</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 循环对象属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 获取属性并且判断属性值类型</span></span><br><span class="line">      <span class="keyword">let</span> item = obj[key];</span><br><span class="line">      <span class="comment">// 如果为object类型递归调用</span></span><br><span class="line">      <span class="keyword">if</span> (getType(obj) === <span class="string">"Object"</span>) &#123;</span><br><span class="line">        <span class="comment">// consoarrle.log(item)</span></span><br><span class="line">        item = StringIfy(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 拼接数组字段</span></span><br><span class="line">      json.push((arr ? <span class="string">'"'</span> : <span class="string">'"'</span> + key + <span class="string">'": "'</span>) + <span class="built_in">String</span>(item) + <span class="string">'"'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="built_in">String</span>(json));</span><br><span class="line">  <span class="comment">// 转换数组字段为字符串</span></span><br><span class="line">  <span class="keyword">return</span> (arr ? <span class="string">"["</span> : <span class="string">"&#123;"</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">"]"</span> : <span class="string">"&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">StringIfy(&#123; <span class="attr">name</span>: &#123; <span class="attr">name</span>: <span class="string">"abc"</span> &#125; &#125;); <span class="comment">// "&#123;"name": "&#123;"name": "abc"&#125;"&#125;"</span></span><br><span class="line">StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]); <span class="comment">// "["1","2","4"]"</span></span><br></pre></td></tr></table></figure><p>在上面代码中我们基本的<code>JSON序列化</code>，可以序列化<strong>引用类型</strong>和<strong>基本类型</strong>。</p><h3 id="区分数据类型"><a href="#区分数据类型" class="headerlink" title="区分数据类型"></a>区分数据类型</h3><p>我说的区分的类型，是<code>JSON.stringify</code>再序列化时，像<code>Number</code>、<code>Boolean</code>、<code>null</code>它是不会加上<code>双引号</code>的，只有在<code>String</code>类型或者<code>Object中的key</code>才会带<code>双引号</code>。</p><ul><li>增加一个判断当前属性类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 。。。省略代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 。。。省略代码</span></span><br><span class="line">  <span class="keyword">let</span> IsQueto =</span><br><span class="line">    getType(item) === <span class="string">"Number"</span> ||</span><br><span class="line">    getType(item) === <span class="string">"Boolean"</span> ||</span><br><span class="line">    getType(item) === <span class="string">"Null"</span></span><br><span class="line">      ? <span class="string">""</span></span><br><span class="line">      : <span class="string">'"'</span>;</span><br><span class="line">  <span class="comment">// 拼接数组字段</span></span><br><span class="line">  json.push((arr ? IsQueto : <span class="string">'"'</span> + key + <span class="string">'": "'</span>) + <span class="built_in">String</span>(item) + IsQueto);</span><br><span class="line">  <span class="comment">// 。。。省略代</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">StringIfy(&#123; <span class="attr">name</span>: &#123; <span class="attr">name</span>: <span class="string">"abc"</span> &#125; &#125;); <span class="comment">// "&#123;"name": "&#123;"name": "abc"&#125;"&#125;"</span></span><br><span class="line">StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]); <span class="comment">// "[1,2,4]"</span></span><br></pre></td></tr></table></figure><h3 id="不处理部分值"><a href="#不处理部分值" class="headerlink" title="不处理部分值"></a>不处理部分值</h3><ul><li>通过正则判断过滤<code>Symbol|Function|Undefined</code></li><li>跳过当前循环</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/Symbol|Function|Undefined/</span>.test(getType(item))) &#123;</span><br><span class="line">    <span class="keyword">delete</span> obj[key];</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">    name: <span class="string">'name'</span>,</span><br><span class="line">    age: <span class="literal">undefined</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test);</span><br><span class="line"><span class="built_in">console</span>.log(newTest); <span class="comment">// &#123;"name": "name"&#125;</span></span><br></pre></td></tr></table></figure><h3 id="循环引用警告"><a href="#循环引用警告" class="headerlink" title="循环引用警告"></a>循环引用警告</h3><ul><li>处理循环引用，警告并且退出循环</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (item === obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Converting circular structure to JSON"</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON-stingify-其他参数"><a href="#JSON-stingify-其他参数" class="headerlink" title="JSON.stingify 其他参数"></a>JSON.stingify 其他参数</h3><p><code>JSON.stringify</code>它可以传入三个参数。</p><p><strong>语法</strong>： <code>JSON.stringify(value[, replacer [, space]])</code></p><p><strong>参数</strong></p><ul><li><code>value</code>：将要序列化成 一个 JSON 字符串的值。</li><li><code>replacer(可选)</code>：如果该参数是一个<code>函数</code>，则在序列化过程中，被序列化的值的<code>每个属性都会</code>经过该函数的<code>转换和处理</code>；如果该参数是一个<code>数组</code>，则<code>只有包含</code>在这个数组中的<code>属性名</code>才会被序列化到最终的 <code>JSON</code> 字符串中；</li><li><code>space</code>：指定缩进用的<code>空白字符串</code>，用于<code>美化输出（pretty-print）</code>；</li></ul><p>这里主要记录<code>replacer</code>的实现，首先我们要知道<code>replacer</code>参数的使用才能自己实现。</p><p><strong>replacer</strong>实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oJson = &#123;</span><br><span class="line">  name: <span class="string">"oJson"</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  sex: <span class="string">"man"</span>,</span><br><span class="line">  calss: <span class="string">"one"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(oJson, [<span class="string">"sex"</span>, <span class="string">"name"</span>]); <span class="comment">// "&#123;"sex":"man","name":"oJson"&#125;"</span></span><br><span class="line"><span class="comment">// 两个参数 key/value的形式</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(oJson, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;); <span class="comment">// "&#123;"age":20&#125;"</span></span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj, replacer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是非object类型 or null的类型直接返回 原值的String</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span> || getType(obj) === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明一个数组</span></span><br><span class="line">  <span class="keyword">let</span> json = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断当前传入参数是对象还是数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = obj ? getType(obj) === <span class="string">"Array"</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 循环对象属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否可枚举</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// console.log(key, item);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取属性并且判断属性值类型</span></span><br><span class="line">      <span class="keyword">let</span> item = obj[key];</span><br><span class="line">      <span class="comment">// &lt;!-------修改开始-------!&gt;</span></span><br><span class="line">      <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 处理第二个参数</span></span><br><span class="line">      <span class="keyword">if</span> (replacer) &#123;</span><br><span class="line">        <span class="comment">// 判断第二个参数类型</span></span><br><span class="line">        <span class="keyword">switch</span> (getType(replacer)) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">"Function"</span>:</span><br><span class="line">            <span class="comment">// 如果为函数执行</span></span><br><span class="line">            flag = replacer(key, item);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">"Array"</span>:</span><br><span class="line">            <span class="comment">// 如果为数组</span></span><br><span class="line">            flag = replacer.indexOf(key) !== <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断返回结果</span></span><br><span class="line">      <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// &lt;!-------修改结束-------!&gt;</span></span><br><span class="line">      <span class="keyword">if</span> (item === obj) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Converting circular structure to JSON"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/Symbol|Function|Undefined/</span>.test(getType(item))) &#123;</span><br><span class="line">        <span class="keyword">delete</span> obj[key];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果为object类型递归调用</span></span><br><span class="line">      <span class="keyword">if</span> (getType(item) === <span class="string">"Object"</span>) &#123;</span><br><span class="line">        <span class="comment">// consoarrle.log(item)</span></span><br><span class="line">        item = StringIfy(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> IsQueto =</span><br><span class="line">        getType(item) === <span class="string">"Number"</span> ||</span><br><span class="line">        getType(item) === <span class="string">"Boolean"</span> ||</span><br><span class="line">        getType(item) === <span class="string">"Null"</span></span><br><span class="line">          ? <span class="string">""</span></span><br><span class="line">          : <span class="string">'"'</span>;</span><br><span class="line">      <span class="comment">// 拼接数组字段</span></span><br><span class="line">      json.push((arr ? IsQueto : <span class="string">'"'</span> + key + <span class="string">'": "'</span>) + <span class="built_in">String</span>(item) + IsQueto);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="built_in">String</span>(json));</span><br><span class="line">  <span class="comment">// 转换数组字段为字符串</span></span><br><span class="line">  <span class="keyword">return</span> (arr ? <span class="string">"["</span> : <span class="string">"&#123;"</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">"]"</span> : <span class="string">"&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新增第二个参数的处理，第三个参数暂时就忽滤了，主要用于设置<code>space</code>的，下面直接测试上面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">"name"</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">"setter"</span>),</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(StringIfy(test, [<span class="string">'name'</span>, <span class="string">'sex'</span>])); <span class="comment">// &#123;"name": "name","sex": "man"&#125;</span></span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newTest); <span class="comment">// &#123;"age": "30&#125;</span></span><br></pre></td></tr></table></figure><p>到此<code>StringIfy</code>的实现到此结束。</p><h3 id="Stringify-总结"><a href="#Stringify-总结" class="headerlink" title="Stringify 总结"></a>Stringify 总结</h3><p>到此自己实现<code>JSON.stringify</code>到此结束了，完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">  <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是非object类型 or null的类型直接返回 原值的String</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span> || getType(obj) === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明一个数组</span></span><br><span class="line">  <span class="keyword">let</span> json = [];</span><br><span class="line">  <span class="comment">// 判断当前传入参数是对象还是数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = obj ? getType(obj) === <span class="string">"Array"</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 循环对象属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// console.log(key, item);</span></span><br><span class="line">      <span class="comment">// 获取属性并且判断属性值类型</span></span><br><span class="line">      <span class="keyword">let</span> item = obj[key];</span><br><span class="line">      <span class="keyword">if</span> (item === obj) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Converting circular structure to JSON"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/Symbol|Function|Undefined/</span>.test(getType(item))) &#123;</span><br><span class="line">        <span class="keyword">delete</span> obj[key];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果为object类型递归调用</span></span><br><span class="line">      <span class="keyword">if</span> (getType(item) === <span class="string">"Object"</span>) &#123;</span><br><span class="line">        <span class="comment">// consoarrle.log(item)</span></span><br><span class="line">        item = StringIfy(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> IsQueto =</span><br><span class="line">        getType(item) === <span class="string">"Number"</span> ||</span><br><span class="line">        getType(item) === <span class="string">"Boolean"</span> ||</span><br><span class="line">        getType(item) === <span class="string">"Null"</span></span><br><span class="line">          ? <span class="string">""</span></span><br><span class="line">          : <span class="string">'"'</span>;</span><br><span class="line">      <span class="comment">// 拼接数组字段</span></span><br><span class="line">      json.push((arr ? IsQueto : <span class="string">'"'</span> + key + <span class="string">'": "'</span>) + <span class="built_in">String</span>(item) + IsQueto);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="built_in">String</span>(json));</span><br><span class="line">  <span class="comment">// 转换数组字段为字符串</span></span><br><span class="line">  <span class="keyword">return</span> (arr ? <span class="string">"["</span> : <span class="string">"&#123;"</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">"]"</span> : <span class="string">"&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aa = StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">"name"</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">"setter"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test);</span><br><span class="line"><span class="built_in">console</span>.log(aa, newTest);</span><br><span class="line"><span class="keyword">var</span> firstObj = &#123;</span><br><span class="line">  name: <span class="string">"firstObj"</span></span><br><span class="line">&#125;;</span><br><span class="line">firstObj.newKey = firstObj;</span><br><span class="line">StringIfy(firstObj);</span><br></pre></td></tr></table></figure><h2 id="JSON-parse-实现"><a href="#JSON-parse-实现" class="headerlink" title="JSON.parse 实现"></a>JSON.parse 实现</h2><p>有两种方法实现<code>parse</code>效果，第一种是<code>eval</code>实现，另一种是<code>Function</code>实现，下面直接开始。</p><h3 id="eval-实现"><a href="#eval-实现" class="headerlink" title="eval 实现"></a>eval 实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParseJson</span>(<span class="params">opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"("</span> + opt + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aa = StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">ParseJson(aa); <span class="comment">// [1, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">"name"</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">"setter"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test);</span><br><span class="line"><span class="built_in">console</span>.log(ParseJson(newTest)); <span class="comment">// &#123;name: "name"&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到上面的代码可以实现基本的反序列化。</p><blockquote><p>避免在不必要的情况下使用 eval，eval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用 eval()运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。</p></blockquote><h3 id="Function-实现"><a href="#Function-实现" class="headerlink" title="Function 实现"></a>Function 实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParseJsonTwo</span>(<span class="params">opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"return "</span> + opt)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aa = StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">ParseJson(aa); <span class="comment">// [1, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">"name"</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">"setter"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test);</span><br><span class="line"><span class="built_in">console</span>.log(ParseJson(newTest)); <span class="comment">// &#123;name: "name"&#125;</span></span><br></pre></td></tr></table></figure><p><code>eval</code> 与 <code>Function</code> 都有着<code>动态编译js代码</code>的作用，但是在实际的编程中并不推荐使用。</p><h3 id="处理-XSS"><a href="#处理-XSS" class="headerlink" title="处理 XSS"></a>处理 XSS</h3><p><strong>它会执行 JS 代码，有 XSS 漏洞。</strong></p><p><strong>如果你只想记这个方法，就得对参数 json 做校验。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">rx_one.test(</span><br><span class="line">json.replace(rx_two, <span class="string">"@"</span>).replace(rx_three, <span class="string">"]"</span>).replace(rx_four, <span class="string">""</span>)</span><br><span class="line">);</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">var</span> obj = ParseJson(json); <span class="comment">// ParseJson(json) or ParseJsonTwo(json)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Parse-总结"><a href="#Parse-总结" class="headerlink" title="Parse 总结"></a>Parse 总结</h3><p>其实无论在什么时候都不太推荐<code>eval</code>和<code>function</code>，因为它很容造成入侵。<br>如果有兴趣可以去看一下<a href="https://juejin.im/entry/5a98f1ef518825558001a859" target="_blank" rel="noopener">JSON.parse 三种实现方式</a>，它有涉及到递归实现，状态机实现，讲的也不错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要讲解了<code>JSON.parse/JSON.stringify</code>是怎么实现的<strong>深拷贝</strong>，并且深入了解一下<code>JSON.parse/JSON.stringify</code>在<strong>深拷贝</strong>上的实现，其实还有怎么加速<code>JSON</code>序列化的速度，会在另一篇文章中讲解。最后自己也简单实现了一个<code>ParseJson/StringIfy</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDEyMzA2NQ==&amp;mid=2247484039&amp;idx=1&amp;sn=a2adb13a072b889eec096523ef14ea98&amp;chksm=c0252fd1f752a6c7b56b1fa268c34194a76d72e2be09bb4aa92b630bd7ffac120d82c50011e9&amp;mpshare=1&amp;scene=1&amp;srcid=0817FYhsdmgAzbulSCdGAfOd&amp;sharer_sharetime=1566046217540&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b#rd" target="_blank" rel="noopener">无敌秘籍之 — JavaScript 手写代码</a><br><a href="https://juejin.im/entry/5a98f1ef518825558001a859" target="_blank" rel="noopener">JSON.parse 三种实现方式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      本篇文章会介绍JSON.stringify和JSON.parse用来深拷贝时存在什么问题，并且自己手动实现一个。
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
      <category term="深拷贝" scheme="http://asyncnode.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝系列 ———— 什么是深拷贝、浅拷贝、Object.assign</title>
    <link href="http://asyncnode.com/blog/es6/es6-assign.html"/>
    <id>http://asyncnode.com/blog/es6/es6-assign.html</id>
    <published>2019-09-23T01:45:21.000Z</published>
    <updated>2020-03-20T08:43:33.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/blog/es6/es6-assign.html">深拷贝系列 ———— 什么是深拷贝、浅拷贝、Object.assign</a><br><a href="/blog/javascript/javascript-paser-stringify.html">深拷贝系列 ———— 自己实现一个JSON.stringify和JSON.parse</a><br><a href="/blog/javascript/javascript-deepcopy.html">深拷贝系列 ———— 自己通过递归实现一个深拷贝</a><br><a href="/blog/javascript/javascript-loadsh-deepcopy.html">深拷贝系列 ———— 分析lodash中的deepcopy</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先我们要了解什么是<code>深拷贝</code>、<code>浅拷贝</code>，要了解<code>深拷贝/浅拷贝</code>首先要了解浅拷贝<code>JavaScript</code>中的数据类型。</p><p><code>JavaScript</code>中的数据类型分为两类：</p><ul><li><code>值类型/原始类型/基本类型：String、Number、Boolean、null、undefined、Symbol</code></li><li><code>引用类型/“指针”类型：Object、Array、Window等等</code></li></ul><p><code>基本类型</code>是储存在栈(stack)中的数据。<br><code>引用类型</code>真实数据是储存在堆中的，而它的引用地址储存在栈中。</p><p><img src="../../images/es/es-assign-1-1.png" alt="深拷贝/浅拷贝"></p><p>如果有兴趣了解<code>JavaScript</code>中的类型的话，可以看一下我往期的文章<a href="/blog/javascript/javascript-Type-conversion.html">JavaScript数据类型（一） 常见数据类型</a>，这个只是其中的一篇，有关<code>JavaScript</code>类型的常见的概念基本上都有提及。</p><p><code>基本类型</code>是不存在<code>深拷贝</code>和<code>浅拷贝</code>的，因为<code>基本类型</code>是不可变的，无论是<code>修改</code>、<code>重新赋值</code>、<code>赋值给别的变量</code>都是一个新的值，和原来的值再无关联。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>,</span><br><span class="line">    b = a;</span><br><span class="line">b = <span class="string">'abcd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// abc, abcd</span></span><br></pre></td></tr></table></figure><p><code>引用类型</code>因为是地址引用，所以会存在<code>深拷贝</code>和<code>浅拷贝</code>，下面就开始介绍。</p><ul><li><code>浅拷贝简介</code>: 创建一个新对象，这个对象有着<code>原始对象属性值</code>的一份精确拷贝。如果属性是基本类型，拷贝的就是<code>基本类型的值</code>，如果属性是引用类型，拷贝的就是<code>内存地址</code> ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li></ul><p><img src="../../images/es/es-assign-1-2.png" alt="深拷贝/浅拷贝"></p><ul><li><code>深拷贝</code>: 创建一个新的对象把原始对象的<code>所有属性</code>的拷贝一份，并且<code>引用类型的引用地址和内存空间都会被拷贝一份，重新分配内存空间</code>。<code>修改新对象不会影响原始对象</code>。</li></ul><p><img src="../../images/es/es-assign-1-3.png" alt="深拷贝/浅拷贝"></p><p>本章主要记录<code>深拷贝/浅拷贝</code>，主要讲解浅拷贝相关的如<code>assign、解构、扩展运算符、slice</code>等等，后面的文章会<code>由浅到深的</code>的介绍<code>深拷贝</code>相关的。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>虽然看着<code>浅拷贝</code>比较简单，其实它就是比较简单，但是它相关的东西也不少，下面就开始吧。</p><ul><li>Object.assign() &amp; 自己实现一个Object.assign()</li><li>Array.prototype.slice()</li><li>Array.prototype.concat()</li><li>解构</li><li>…扩展运算符</li><li>jquery.extend()</li><li>自己实现一个浅拷贝</li></ul><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>语法</code>: <code>Object.assign(target, ...sources)</code>;<br><code>返回值</code>: <code>target对象</code></p><p>ES6中拷贝对象的方法，接受的第一个参数是拷贝的<code>目标target</code>，剩下的参数是拷贝的<code>源对象sources</code>（<code>可以是多个</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">firstname</span>: <span class="string">'target'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">lastname</span>: <span class="string">'source'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> newtarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="comment">// target与newtarget指向同一个内存地址</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget === target); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改newtarget的age属性，target属性也跟着变化，而source不会变化</span></span><br><span class="line">newtarget.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123; lastname: 'source', age: 21 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Object.assgin()第一个传入一个空对象，结果和上方相同</span></span><br><span class="line"><span class="keyword">const</span> newSource = <span class="built_in">Object</span>.assign(&#123;&#125;, source);</span><br><span class="line"><span class="built_in">console</span>.log(newSource); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"></span><br><span class="line">newSource.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newSource); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中我们可以看到通过<code>Object.assign(target, source);</code>会返回一个新的值<code>newtarget</code>，这个值的引用地址与<code>target</code>是同一个地址，所以修改<code>newtarget.age = 22;</code>后<code>target</code>和<code>newtarget</code>都会变化。<br><code>Object.assign({}, source)</code>返回的<code>newSource</code>它被修改不会影响到<code>source</code>的变化，因为他的<code>target</code>传入的是一个空对象。</p><h3 id="自己实现一个assgin"><a href="#自己实现一个assgin" class="headerlink" title="自己实现一个assgin"></a>自己实现一个assgin</h3><p><strong>实现目标</strong></p><ul><li>第一个<code>target</code></li><li>支持多个对象合并</li><li>与Object.assign表现一至</li></ul><p>大致分为下面几步：</p><ul><li>判断传入<code>target</code>如果不为对象，或者 传入为<code>null</code>时直接返回<code>Object(target)</code></li><li>获取所有参数，参数列表转为<code>Array</code>类型</li><li>循环上一步生成数组，获取每一个传入的对象</li><li>通过 <code>for...in</code>循环上一步获取的对象，并且通过<code>hasOwnProperty</code>判断当前属性是否是本身上的属性（不是原型上的）</li><li>上一步通过判断的属性，赋值给<code>target</code>对象</li><li>最后返回<code>target</code>对象</li></ul><p><strong>函数版本</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assign</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 验证第一个参数是否为object</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arguments转为数组</span></span><br><span class="line">    <span class="keyword">let</span> copyList = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> len = copyList.length;</span><br><span class="line">    <span class="comment">// 循环复制多个对象的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = copyList[i];</span><br><span class="line">        <span class="comment">// 获取当前对象的属性</span></span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> item) &#123;</span><br><span class="line">            <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">            <span class="keyword">if</span> (item.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="comment">// 复制给目标对象</span></span><br><span class="line">                target[key] = item[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证assign代码</span></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">firstname</span>: <span class="string">'target'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">lastname</span>: <span class="string">'source'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> newtarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="comment">// target与newtarget指向同一个内存地址</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget === target); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改newtarget的age属性，target属性也跟着变化，而source不会变化</span></span><br><span class="line">newtarget.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123; lastname: 'source', age: 21 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Object.assgin()第一个传入一个空对象，结果和上方相同</span></span><br><span class="line"><span class="keyword">const</span> newSource = <span class="built_in">Object</span>.assign(&#123;&#125;, source);</span><br><span class="line"><span class="built_in">console</span>.log(newSource); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"></span><br><span class="line">newSource.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newSource); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Object.defineProperty</strong>版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.newAssign !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">'newAssign'</span>, &#123;</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumberable: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 验证第一个参数是否为object</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>(target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// arguments转为数组</span></span><br><span class="line">            <span class="keyword">let</span> copyList = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> len = copyList.length;</span><br><span class="line">            <span class="comment">// 循环复制多个对象的属性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> item = copyList[i];</span><br><span class="line">                <span class="comment">// 获取当前对象的属性</span></span><br><span class="line">                <span class="keyword">for</span> (key <span class="keyword">in</span> item) &#123;</span><br><span class="line">                    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">                    <span class="keyword">if</span> (item.hasOwnProperty(key)) &#123;</span><br><span class="line">                        <span class="comment">// 复制给目标对象</span></span><br><span class="line">                        target[key] = item[key]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回目标对象</span></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">Object</span>.newAssign(<span class="string">'abc'</span>, <span class="literal">false</span>); <span class="comment">// String &#123;"abc"&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="string">'abc'</span>, <span class="literal">false</span>); <span class="comment">// String &#123;"abc"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.newAssign(&#123;&#125;, <span class="string">'abc'</span>); <span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, <span class="string">'abc'</span>); <span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.newAssign(&#123;&#125;, <span class="string">'abc'</span>, <span class="literal">false</span>, <span class="number">123</span>); <span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, <span class="string">'abc'</span>, <span class="literal">false</span>, <span class="number">123</span>); <span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h3><p><code>slice()</code> 方法返回一个新的<code>数组对象</code>，这一对象是一个由 <code>begin</code>和 <code>end</code>（不包括end）决定的原数组的<code>浅拷贝</code>。原始数组不会被改变。<br><code>slice()</code> 它的定义其实是复制一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> old = [<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'c'</span>, <span class="string">'d'</span>]];</span><br><span class="line"><span class="comment">// 通过slice复制当前数组</span></span><br><span class="line"><span class="keyword">let</span> newValue = old.slice(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// ['a', 'b', ['c', 'd']];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原数组的下标为0的值，新对象没有受到影响，因为下标为0的是基本类型，它们的内存地址是不同的</span></span><br><span class="line">old[<span class="number">0</span>] = <span class="string">'f'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// ['a', 'b', ['c', 'd']];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原数组的下标为2的值，新对象受到影响，因为下标为2的是引用类型，它们的值指向同一个内存地址</span></span><br><span class="line">old[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// ['a', 'b', ['', 'd']];</span></span><br></pre></td></tr></table></figure><h3 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h3><p><code>concat()</code> 方法用于<strong>合并两个或多个数组</strong>。此方法<strong>不会更改</strong>现有数组，而是返回一个<strong>新数组</strong>。</p><p><strong>语法</strong></p><p><code>var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])</code></p><p><strong>返回值</strong><br>新的 Array 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> old = [<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'c'</span>, <span class="string">'d'</span>]];</span><br><span class="line"><span class="comment">// 通过concat返回一个新的Array实例</span></span><br><span class="line"><span class="keyword">var</span> newArr = <span class="built_in">Array</span>.prototype.concat([], old);</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// ['a', 'b', ['c', 'd']];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原数组的下标为0的值，新对象没有受到影响，因为下标为0的是基本类型，它们的内存地址是不同的</span></span><br><span class="line">old[<span class="number">0</span>] = <span class="string">'f'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// ['a', 'b', ['c', 'd']];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原数组的下标为2的值，新对象受到影响，因为下标为2的是引用类型，它们的值指向同一个内存地址</span></span><br><span class="line">old[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// ['a', 'b', ['', 'd']];</span></span><br></pre></td></tr></table></figure><p><code>concat()</code>它的效果是和<code>slice()</code>相同的。</p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p><strong>解构</strong>是<strong>ES6</strong>中的新特性，它可以方便的<strong>浅复制</strong>一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个对象</span></span><br><span class="line"><span class="keyword">var</span> old = &#123;</span><br><span class="line">    name: <span class="string">'old'</span>,</span><br><span class="line">    attr: &#123;</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        sex: <span class="string">'man'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过解构复制attr出来，它只复制了内存地址</span></span><br><span class="line"><span class="keyword">var</span> &#123; attr &#125; = old;</span><br><span class="line"><span class="built_in">console</span>.log(attr); <span class="comment">// &#123;age: 18, sex: "man"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原对象的attr值，新对象受到影响</span></span><br><span class="line">old.attr.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(attr); <span class="comment">// &#123;age: 20, sex: "man"&#125;</span></span><br></pre></td></tr></table></figure><h3 id="…扩展运算符"><a href="#…扩展运算符" class="headerlink" title="…扩展运算符"></a>…扩展运算符</h3><p><code>...扩展运算符</code>也是<strong>ES6</strong>中的新特性，它可以方便的<strong>浅复制</strong>一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个对象</span></span><br><span class="line"><span class="keyword">var</span> old = &#123;</span><br><span class="line">    name: <span class="string">'old'</span>,</span><br><span class="line">    attr: &#123;</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        sex: <span class="string">'man'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过...扩展运算符，它只复制了内存地址</span></span><br><span class="line"><span class="keyword">var</span> newValue = &#123;...old&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原对象的attr.age值，新对象受到影响</span></span><br><span class="line">old.attr.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 20, sex: "man"&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="jquery-extend"><a href="#jquery-extend" class="headerlink" title="jquery.extend"></a>jquery.extend</h3><p><code>jquery.extend()</code>是一个浅拷贝，这个在这里就不多做赘述了，如果想看实现原理的话，可以去看<code>jquery</code>github上的源码实现。</p><h3 id="自己实现一个浅拷贝"><a href="#自己实现一个浅拷贝" class="headerlink" title="自己实现一个浅拷贝"></a>自己实现一个浅拷贝</h3><p>实现一个<strong>浅拷贝</strong>其实很简单，大致步骤如下：</p><ul><li>声明一个新对象</li><li>旧对象的属性赋值给新对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span> (<span class="params">oldObj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明新对象</span></span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 判断传入是否为对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> oldObj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'请传入对象'</span>);</span><br><span class="line">        <span class="keyword">return</span> oldObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环获取传入对象属性</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">        <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">        <span class="keyword">if</span> (oldObj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 把属性复制给新对象</span></span><br><span class="line">            newObj[key] = oldObj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新对象</span></span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个对象</span></span><br><span class="line"><span class="keyword">var</span> old = &#123;</span><br><span class="line">    name: <span class="string">'old'</span>,</span><br><span class="line">    attr: &#123;</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        sex: <span class="string">'man'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 通过shallowCopy</span></span><br><span class="line"><span class="keyword">var</span> newValue = shallowCopy(old);</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始对象的基本类型属性，新对象不受影响</span></span><br><span class="line">old.name = <span class="string">'new'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始对象引用类型属性，新对象受到影响</span></span><br><span class="line">old.attr.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 20, sex: "man"&#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中我们分别介绍了<strong>深拷贝</strong>、<strong>浅拷贝</strong>是什么。着重介绍了我们日常使用的<strong>浅拷贝</strong>，并且自己实现了一个<code>assign()</code>和一个<code>shallowCopy</code>来加深对浅拷贝的理解，下一篇文件会介绍一个<strong>深拷贝</strong>相关的<code>JSON.stringify()/JSON.parse()</code>并且自己实现一个。</p><p>通过上面的实例，可以验证我们对<strong>浅拷贝</strong>的理解是对的，如果是<strong>基本类型</strong>浅拷贝可以把它的值拷贝到新对象中，如果是<strong>引用类型</strong>浅拷贝只能拷贝引用类型的引用地址。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice</a><br><a href="https://mp.weixin.qq.com/s/bvYqA16mU_rRYT1G37onug" target="_blank" rel="noopener">一文搞懂JS中的赋值·浅拷贝·深拷贝</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      本篇文章会介绍什么是深拷贝、什么是浅拷贝，Object.assgin、解构、扩展运算符是深拷贝还是浅拷贝，自己实现一个Object.assgin。
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
      <category term="深拷贝" scheme="http://asyncnode.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>ES系列 ———— Object.defineProperty和Proxy的对比</title>
    <link href="http://asyncnode.com/blog/es6/es-defineproperty-proxy.html"/>
    <id>http://asyncnode.com/blog/es6/es-defineproperty-proxy.html</id>
    <published>2019-09-18T01:12:32.000Z</published>
    <updated>2019-10-24T05:12:36.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在前两篇文章中分别介绍了<code>Object.defineProperty</code>和<code>Proxy</code>两个新的特性，其实看起来<code>Proxy</code>更像是对<code>Object.defineProperty</code>的一种补充和完善(个人见解)。当然不是说<code>Object.defineProperty</code>很差，感觉更像是一开始的定位是为了处理对象的特定属性，但是在<code>Vue</code>等等框架的中被用来劫持整个对象属性，所以后面就出来了<code>Proxy</code>，更强大的劫持功能。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>根据上面两篇文章的介绍，大致优缺点如下：</p><p><strong><em>Proxy相对于defineProperty的优点</em></strong></p><ul><li>对于对象已有属性：<code>Object.defineProperty</code>只能劫持对象的单个属性，如果想劫持整个对象就要<strong>循环递归</strong>调用<code>Object.defineProperty</code>。而<code>Proxy</code>拦截整个对象，并且返回一下新的对象。</li><li>对于对象新增属性：<code>Proxy</code>劫持整个对象，对于新增的属性自动拦截。而<code>Object.defineProperty</code>需要<strong>重新劫持</strong>新增的属性</li><li>对于数组操作： <code>Object.defineProperty</code>无法监控到数组下标的变化。而<code>Proxy</code>可以监听数组变化。</li><li>拦截或劫持方法： <code>Object.defineProperty</code>描述符基本上分为两类<strong>数据描述符</strong>、<strong>存取描述符</strong>、<strong>通用描述符</strong>三种。而<code>Proxy</code>中有<strong>13</strong>种<strong>traps</strong>方法供你选择。</li><li>是否支持取消劫持： <code>Object.defineProperty</code>如果想取消劫持，只能<strong>重写</strong>描述符，但是<strong>configurable: false</strong>时就<strong>不能重写</strong>描述符了。而<code>Proxy</code>可以通过<code>Proxy.revocable</code>返回一个可取消的 <code>Proxy</code> 实例。</li><li>浏览器对劫持或拦截的支持： <code>Proxy</code>在后续应该会有更好的支持，不然<code>Vue</code>也不会修改核心代码。</li><li>性能： <code>Proxy</code>性能是比<code>Object.defineProperty</code>高的，在多个对象属性中。</li></ul><p><strong>Proxy相对于defineProperty的缺点</strong></p><ul><li><code>this指向</code>： <code>defineProperty</code>因为只绑定对象的属性，一般不会涉及到<code>this问题</code>。而<code>Proxy</code>返回的对象的<code>this</code>和<code>target</code>的<code>this</code>不相同。</li><li><code>使用难度</code>: 相对于<code>Proxy</code>的<strong>api</strong>，反而<code>defineProperty</code>上手更容易。</li></ul><p><strong>Proxy和defineProperty的一些注意事项</strong></p><ul><li><code>对象冻结</code>：无论是<code>defineProperty</code>、<code>Object.freeze</code>、<code>Object.seal（密封）</code>都不是深度冻结，如果想深度冻结只能递归实现。</li><li><code>this问题</code>： <code>Proxy</code>在使用是要注意<code>this</code>指向问题。</li></ul><h2 id="各自实现双向绑定"><a href="#各自实现双向绑定" class="headerlink" title="各自实现双向绑定"></a>各自实现双向绑定</h2><p>现在的三大框架非常的流行，在数据流中分为两派<code>React</code>的单项数据流，<code>Angluar/Vue</code>的双向数据流。其实<code>React</code>也是实现了的<strong>双向数据绑定</strong>的，只不过要通过<code>setState</code>来触发。</p><p>在不同框架中实现<strong>双向数据绑定</strong>也是不相同的，大致如下图所示：</p><p><a href="../../images/es/es-defineProperty.png">双向绑定</a></p><p><code>Object.defineProperty</code>和<code>proxy</code>都是<code>Vue</code>不同版本的重要组成部分，它们都是可以实现双向绑定中的<strong>数据劫持</strong>，其实也就是响应式对象，在以前的文章有<a href="/blog/vue/vue-definedProperty.html">深入Vue系列 Vue中的响应式对象</a>、<br><a href="/blog/vue/vue-dep.html">深入Vue系列 Vue中的依赖收集</a>、<a href="/blog/vue/vue-notify.html">深入Vue系列 Vue中的派发更新</a>，如果感兴趣的可以去看看。</p><p>依照<code>Vue</code>代码中的双向绑定思路，大致分为以下三步：</p><ul><li>把普通对象通过<code>Object.defineProperty</code>变为响应式对象</li><li>同时<code>getter</code>中收集依赖，也就是渲染<code>wather</code></li><li>在<code>setter</code>中派发更行</li></ul><p>下面写的实例不会这么复杂，当然也会仿照<code>Vue</code>源码中的<code>mvvm</code>去写。</p><h2 id="Object-defineProperty实现双向绑定"><a href="#Object-defineProperty实现双向绑定" class="headerlink" title="Object.defineProperty实现双向绑定"></a>Object.defineProperty实现双向绑定</h2><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><ul><li>劫持对象的<code>get、set</code>属性</li><li><code>input</code>事件更新对象值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Static Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"mv"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"vm"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 对象配置描述符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"value"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"get value"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"set value"</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"mv"</span>).value = newVal;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"vm"</span>).innerHTML = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// input绑定时间更行对象中的value值</span></span><br><span class="line"><span class="keyword">const</span> InputDom = <span class="built_in">document</span>.getElementById(<span class="string">"mv"</span>);</span><br><span class="line">InputDom.addEventListener(<span class="string">"input"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">  obj.value = event.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面这个代码只是简单了实现最简单的效果，在<code>input</code>中输入代码，同时更新到<code>p</code>中。</p><h3 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h3><h2 id="Proxy实现双向绑定"><a href="#Proxy实现双向绑定" class="headerlink" title="Proxy实现双向绑定"></a>Proxy实现双向绑定</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      Object.defineProperty和Proxy分别是什么，它们之间的优缺点，实现简单的双向绑定。
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>ES系列 ———— Proxy</title>
    <link href="http://asyncnode.com/blog/es6/es6-proxy.html"/>
    <id>http://asyncnode.com/blog/es6/es6-proxy.html</id>
    <published>2019-09-14T10:33:44.000Z</published>
    <updated>2019-10-24T05:12:36.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/blog/es6/es6-definedproperty.html">ES深入系列 Object.defineProperty</a><br><a href="/blog/es6/es6-proxy.html">ES深入系列 Proxy</a><br><a href="/blog/es6/es6-definedproperty-proxy.html">ES深入系列 Object.defineProperty和Proxy的对比</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上一篇<a href="/blog/es6/es6-definedproperty.html">ES系列 Object.defineProperty</a>已经介绍过了<strong>Object.defineProperty</strong>相关内容，这篇文章中会介绍在<strong>Vue 3.x</strong>中代替<code>Object.defineProperty</code>的<code>Proxy</code>。<br>最后会介绍它们之间的<strong>优缺点</strong>和实现<strong>双向绑定简单实例</strong>。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>从字面上可以把<code>Proxy</code>理解为<strong>代理</strong>，但是感觉解释为类似于<strong>代理模式</strong>会更贴合一点。<strong>“阮大佬：Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。”</strong></p><p>首先要了解其中的<strong>术语</strong>。</p><ul><li><code>handler</code>: 包含陷阱（traps）的占位符对象。</li><li><code>traps</code>: 提供属性访问的方法。这类似于操作系统中捕获器的概念。</li><li><code>target</code>: 代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</li></ul><p><code>new Proxy(target, handler)</code>方式创建一下新的对象，参数如下：</p><ul><li><code>target (Object)</code>: 用<code>Proxy</code>包装的目标对象（可以是<strong>任何类型的对象，包括原生数组，函数，甚至另一个代理</strong>）。</li><li><code>handler(Object)</code>: 一个对象，其属性是当执行一个操作时定义代理的行为的函数。</li></ul><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p><code>handler</code> 对象是一个占位符对象，它包含<strong>Proxy</strong>的捕获器。同时<strong>handler</strong>对象包含了用于拦截的<strong>13</strong>种操作。如下：<br>大致可以分为一类<strong>代理对象<code>自身属性</code>操作拦截</strong>：</p><table><thead><tr><th style="text-align:center">拦截方法名</th><th style="text-align:center">详情</th></tr></thead><tbody><tr><td style="text-align:center"><code>handler.get(target, property, receiver)</code></td><td style="text-align:center">在<strong>读取</strong>代理对象的某个<strong>属性时</strong>触发该操作，比如在执行 <code>proxy.foo</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.set(target, property, value, receiver)</code></td><td style="text-align:center">在给代理对象的某个<strong>属性赋值时</strong>触发该操作，比如在执行 <code>proxy.foo = 1</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.has(target, prop)</code></td><td style="text-align:center">在判断代理对象<strong>是否拥有某个属性时</strong>触发该操作，比如在执行 <code>&quot;foo&quot; in proxy</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.defineProperty(target, property, descriptor)</code></td><td style="text-align:center">在<strong>定义代理对象某个属性时的属性描述时</strong>触发该操作，比如在执行 <code>Object.defineProperty(proxy, &quot;foo&quot;, {})</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.deleteProperty(target, property)</code></td><td style="text-align:center">在<strong>删除代理对象的某个属性时</strong>触发该操作，即使用<code>delete</code>运算符，比如在执行 <code>delete proxy.foo</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.getOwnPropertyDescriptor(target, prop)</code></td><td style="text-align:center">在<strong>获取代理对象某个属性的属性描述时</strong>触发该操作，比如在执行 <code>Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;)</code> 时。</td></tr></tbody></table><!-- - `handler.get(target, property, receiver)`: 在**读取**代理对象的某个**属性时**触发该操作，比如在执行 `proxy.foo` 时。- `handler.set(target, property, value, receiver)`: 在给代理对象的某个**属性赋值时**触发该操作，比如在执行 `proxy.foo = 1` 时。 --><!-- - `handler.has(target, prop)`: 在判断代理对象**是否拥有某个属性时**触发该操作，比如在执行 `"foo" in proxy` 时。 --><!-- - `handler.defineProperty(target, property, descriptor)`: 在**定义代理对象某个属性时的属性描述时**触发该操作，比如在执行 `Object.defineProperty(proxy, "foo", {})` 时。 --><!-- - `handler.deleteProperty(target, property)`: 在**删除代理对象的某个属性时**触发该操作，即使用`delete`运算符，比如在执行 `delete proxy.foo` 时。- `handler.getOwnPropertyDescriptor(target, prop)`:在**获取代理对象某个属性的属性描述时**触发该操作，比如在执行 `Object.getOwnPropertyDescriptor(proxy, "foo")` 时。 --><p>另一类<strong>代理对象<code>自身</code>操作拦截</strong>:</p><table><thead><tr><th style="text-align:center">拦截方法名</th><th style="text-align:center">详情</th></tr></thead><tbody><tr><td style="text-align:center"><code>handler.getPrototypeOf(target)</code></td><td style="text-align:center">在<strong>读取代理对象的原型时</strong>触发该操作，比如在执行 <code>Object.getPrototypeOf(proxy)</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.setPrototypeOf(target, prototype)</code></td><td style="text-align:center">在<strong>设置代理对象的原型时</strong>触发该操作，比如在执行 <code>Object.setPrototypeOf(proxy, null)</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.isExtensible(target)</code></td><td style="text-align:center">在判断一个<strong>代理对象是否是可扩展时</strong>触发该操作，比如在执行 <code>Object.isExtensible(proxy)</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.preventExtensions(target)</code></td><td style="text-align:center">在让一个<strong>代理对象不可扩展时</strong>触发该操作，比如在执行 <code>Object.preventExtensions(proxy)</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.apply(target, thisArg, argumentsList)</code></td><td style="text-align:center">拦截 <strong>Proxy 实例作为函数调用</strong>的操作，比如<code>proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)</code>。</td></tr><tr><td style="text-align:center"><code>handler.ownKeys(target)</code></td><td style="text-align:center">拦截<code>Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in</code>循环，<strong>返回一个数组</strong>。该方法返回目标对象<strong>所有自身的属性的属性名</strong>，而Object.keys()的返回结果仅包括<strong>目标对象自身的可遍历属性</strong>。</td></tr><tr><td style="text-align:center"><code>handler.construct(target, argumentsList, newTarget)</code></td><td style="text-align:center">拦截 <strong>Proxy 实例作为构造函数调用</strong>的操作，比如<code>new proxy(...args)</code>。</td></tr></tbody></table><!-- - `handler.getPrototypeOf(target)`: 在**读取代理对象的原型时**触发该操作，比如在执行 `Object.getPrototypeOf(proxy)` 时。 --><!-- - `handler.setPrototypeOf(target, prototype)`: 在**设置代理对象的原型时**触发该操作，比如在执行 `Object.setPrototypeOf(proxy, null)` 时。 --><!-- - `handler.isExtensible(target)`: 在判断一个**代理对象是否是可扩展时**触发该操作，比如在执行 `Object.isExtensible(proxy)` 时。 --><!-- - `handler.preventExtensions(target)`: 在让一个**代理对象不可扩展时**触发该操作，比如在执行 `Object.preventExtensions(proxy)` 时。 --><!-- - `handler.apply(target, thisArg, argumentsList)`: 拦截 **Proxy 实例作为函数调用**的操作，比如`proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)`。 --><!-- - `handler.ownKeys(target)`: 拦截`Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in`循环，**返回一个数组**。该方法返回目标对象**所有自身的属性的属性名**，而Object.keys()的返回结果仅包括**目标对象自身的可遍历属性**。- `handler.construct(target, argumentsList, newTarget)`: 拦截 **Proxy 实例作为构造函数调用**的操作，比如`new proxy(...args)`。 --><p>可以看到<code>Proxy</code>的拦截方法上就比<code>Object.defineProperty</code>的配置多很多，并且在最近的浏览器支持中也是各大浏览器上对<code>Proxy</code>大理支持，优化性能等等。</p><h2 id="代理对象自身属性操作拦截"><a href="#代理对象自身属性操作拦截" class="headerlink" title="代理对象自身属性操作拦截"></a>代理对象自身属性操作拦截</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(target, property, receiver)</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为<strong>目标对象</strong>、<strong>属性名</strong>和 <strong>proxy 实例本身</strong>（<em>严格地说，是操作行为所针对的对象</em>），其中最后一个参数可选。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get: name'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'dangdang'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name;</span><br><span class="line"><span class="comment">// get: name</span></span><br><span class="line"><span class="comment">// dangdang</span></span><br></pre></td></tr></table></figure><p>只要通过<code>proxy.xxx</code>访问了<code>proxy</code>上面的属性，就会触发<code>proxy</code>上配置的<code>get</code>拦截方法。<br>上面这个实例是最简单的实例，其实它可以做很多的事情，举几个例子：</p><ul><li>实现数组读取负数的索引。</li><li>链式操作。</li><li>一个生成各种 DOM 节点的通用函数dom。</li></ul><h4 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h4><p>该方法会拦截目标对象的以下操作:</p><ul><li><strong>访问属性: proxy[foo]和 proxy.bar</strong></li><li><strong>访问原型链上的属性: Object.create(proxy)[foo]</strong></li><li><strong>Reflect.get()</strong></li></ul><h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul><li><strong>get方法可以继承</strong>。</li><li><strong>get第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</strong></li><li><strong>一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</strong></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set(target, property, value, receiver)</code>方法用来拦截某个属性的<strong>赋值</strong>操作，可以接受四个参数，依次为<strong>目标对象</strong>、<strong>属性名</strong>、<strong>属性值</strong>和 <strong>Proxy 实例本身</strong>，其中<strong>最后一个参数可选</strong>。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function (target, property, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'set: dangdang'</span>);</span><br><span class="line">      target[property] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">'dangdang'</span>;</span><br><span class="line"><span class="comment">// set: dangdang</span></span><br><span class="line">proxy.name; <span class="comment">// dangdang</span></span><br></pre></td></tr></table></figure><p>只要给<code>proxy</code>的任意属性赋值，就会触发<code>proxy</code>上配置的<code>set</code>拦截方法。<br>当然这个实例是最简单的使用方式，还有其他的用法，举例如下：</p><ul><li>校验属性是否符合格式（表单验证validation）</li><li>统计函数调用次数</li><li>配合get设置内部私有属性</li></ul><h4 id="拦截-1"><a href="#拦截-1" class="headerlink" title="拦截"></a>拦截</h4><p>该方法会拦截目标对象的以下操作:</p><ul><li><strong>指定属性值: proxy[foo] = bar 和 proxy.foo = bar</strong></li><li><strong>指定继承者的属性值: Object.create(proxy)[foo] = bar</strong></li><li><strong>Reflect.set()</strong></li></ul><h4 id="其他特性-1"><a href="#其他特性-1" class="headerlink" title="其他特性"></a>其他特性</h4><ul><li><strong>get第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</strong></li><li><strong>若目标属性是不可写及不可配置的，则不能改变它的值。</strong></li><li><strong>在严格模式下，若set方法返回false，则会抛出一个 TypeError 异常。</strong></li></ul><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has(target, prop)</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。<br><code>has(target, prop)</code>方法可以接受两个参数，分别是<strong>目标对象</strong>、<strong>需查询的属性名</strong>。</p><p><strong>返回值</strong></p><p><code>has()</code> 方法返回一个 <code>boolean</code> 属性的值.</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  has: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> proxy; <span class="comment">// true</span></span><br><span class="line"><span class="string">'age'</span> <span class="keyword">in</span> proxy; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>设置<code>has(&#39;name&#39;)</code>返回<code>true</code>再通过<code>in</code>检测时返回<code>true</code>，设置<code>has(&#39;age&#39;)</code>返回<code>false</code>再通过<code>in</code>检测时返回<code>false</code>。<br>当然这个实例是最简单的使用方式，还有其他的用法，举例如下：</p><ul><li>可以做私有属性</li></ul><h4 id="拦截-2"><a href="#拦截-2" class="headerlink" title="拦截"></a>拦截</h4><p>这个钩子可以拦截下面这些操作:</p><ul><li><strong>属性查询: foo in proxy</strong></li><li><strong>继承属性查询: foo in Object.create(proxy)</strong></li><li><strong>with 检查: with(proxy) { (foo); }</strong></li><li><strong>Reflect.has()</strong></li></ul><h4 id="其他特性-2"><a href="#其他特性-2" class="headerlink" title="其他特性"></a>其他特性</h4><ul><li><strong>如果目标对象的某一属性本身不可被配置，则该属性不能够被代理隐藏。会抛出TypeError。</strong></li><li><strong>如果目标对象为不可扩展对象，则该对象的属性不能够被代理隐藏。会抛出TypeError。</strong></li><li><strong>has（）方法不判断一个属性是对象自身的属性，还是继承的属性。</strong></li><li><strong>has（）拦截对for…in循环不生效。</strong></li></ul><h3 id="defineProperty（）"><a href="#defineProperty（）" class="headerlink" title="defineProperty（）"></a>defineProperty（）</h3><p><code>defineProperty(target, property, descriptor)</code>方法拦截了<code>Object.defineProperty</code>操作。<br>参数这里就不多做介绍了和<strong>Object.defineProperty</strong>相同，主要关注一下返回值。</p><p><strong>返回值</strong></p><p><code>defineProperty</code> 方法必须以一个 <code>Boolean</code> 返回，表示定义该属性的操作成功与否。</p><p><strong>注意</strong></p><ul><li>如果目标对象<strong>不可扩展</strong>， 将<strong>不能添加</strong>属性。</li><li>不能添加或者修改一个属性为不可配置的，如果它不作为一个目标对象的不可配置的属性存在的话。</li><li>如果目标对象存在一个对应的可配置属性，这个属性可能不会是不可配置的。</li><li>如果一个属性在目标对象中存在对应的属性，那么 <code>Object.defineProperty(target, prop, descriptor)</code> 将不会抛出异常。</li><li>在严格模式下， <code>false</code> 作为 <code>handler.defineProperty</code> 方法的返回值的话将会抛出 <code>TypeError</code> 异常.</li></ul><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty(target, property)</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p><p><strong>返回值</strong></p><p><code>deleteProperty</code> 必须返回一个 <code>Boolean</code> 类型的值，表示了该属性是否被成功删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  deleteProperty: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> proxy.name; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> proxy.age; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>目标对象自身的<strong>不可配置（configurable）的属性</strong>，<strong>不能</strong>被<code>deleteProperty</code>方法删除，否则报错。</li></ul><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个<strong>属性描述对象</strong>或者<code>undefined</code>。</p><p><strong>返回值</strong></p><p><code>getOwnPropertyDescriptor</code> 方法必须返回一个 <code>object</code> 或 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  getOwnPropertyDescriptor: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, property);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'name'</span>); <span class="comment">// &#123;value: "dangdang", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'age'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="代理对象自身操作拦截"><a href="#代理对象自身操作拦截" class="headerlink" title="代理对象自身操作拦截"></a>代理对象自身操作拦截</h2><h3 id="getPrototypeOf-setPrototypeOf"><a href="#getPrototypeOf-setPrototypeOf" class="headerlink" title="getPrototypeOf()/setPrototypeOf()"></a>getPrototypeOf()/setPrototypeOf()</h3><p><strong>原型相关的操作拦截</strong></p><h4 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h4><p><code>getPrototypeOf(target)</code>方法主要用来拦截<strong>获取对象原型</strong>。具体来说，拦截下面这些操作。</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul><p><strong>返回值</strong></p><p><code>getPrototypeOf</code> 方法的返回值必须是<strong>一个对象</strong>或者 <code>null</code>。</p><h4 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h4><p><code>setPrototypeOf(target, obj)</code> 方法主要用来拦截 <code>Object.setPrototypeOf(target, obj)</code>。</p><p><strong>返回值</strong></p><p>如果成功修改了<code>[[Prototype]]</code>, <code>setPrototypeOf</code> 方法返回 <code>true</code>,否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>如果目标对象不可扩展<code>（non-extensible）</code>，<code>setPrototypeOf</code>方法不得改变目标对象的原型。</p><h3 id="preventExtensions-isExtensible"><a href="#preventExtensions-isExtensible" class="headerlink" title="preventExtensions/isExtensible"></a>preventExtensions/isExtensible</h3><p><strong>扩展配置拦截操作</strong></p><h4 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h4><p><code>preventExtensions(target)</code> 方法用于设置对<code>Object.preventExtensions()</code>的拦截。</p><p><strong>返回</strong></p><p><code>preventExtensions</code> 必须返回一个布尔值，否则会被自动转为布尔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy); <span class="comment">// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy1); <span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>如果<code>Object.isExtensible(proxy)</code>是<code>false</code>，<code>Object.preventExtensions(proxy)</code>只能返回<code>true</code>。</p><h4 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h4><p><code>isExtensible(target)</code> 方法用于拦截对对象的<code>Object.isExtensible()</code>。</p><p><strong>返回值</strong></p><p><code>isExtensible</code>方法必须返回一个 <code>Boolean</code>值或可转换成<code>Boolean</code>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//也可以return 1;等表示为true的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(p)); <span class="comment">// "called"</span></span><br><span class="line">                                     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//return 0;return NaN等都会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p); <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code>Object.isExtensible(proxy)</code> 必须同<code>Object.isExtensible(target)</code>返回相同值。也就是必须返回<code>true</code>或者为<code>true</code>的值,返回<code>false</code>和为<code>false</code>的值都会报错。</p><h3 id="apply-construct"><a href="#apply-construct" class="headerlink" title="apply/construct"></a>apply/construct</h3><p><strong>改变this方式</strong></p><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p><code>apply(target, thisArg, argumentsList)</code> 方法用于拦截<strong>函数的调用</strong>、<code>Reflect.apply</code>、<code>call</code>和<code>apply</code>操作。<br><code>apply</code>方法可以接受三个参数，分别是<strong>目标对象</strong>、<strong>被调用时的上下文对象</strong>和<strong>被调用时的参数数组</strong>数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params">target, thisArg, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called:'</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> argumentsList[<span class="number">0</span>] + argumentsList[<span class="number">1</span>] + argumentsList[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code>target</code>必须是可被调用的。也就是说，它<strong>必须是一个函数对象</strong>。</p><h4 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h4><p><code>construct(target, argumentsList, newTarget)</code> 方法用于拦截<code>new</code> 操作符. 为了使<code>new</code>操作符在生成的<code>Proxy</code>对象上生效，用于初始化代理的目标对象自身必须具有<code>[[Construct]]</code>内部方法（即 <code>new targe</code>t 必须是有效的）。</p><p><strong>参数</strong></p><ul><li><code>target</code>：目标对象</li><li><code>args</code>：构造函数的参数对象</li><li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的p）</li></ul><p><strong>返回值</strong></p><p><code>construct</code> 方法<strong>必须返回一个对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, argumentsList, newTarget</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called: '</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: argumentsList[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> p(<span class="number">1</span>).value); <span class="comment">// "called: 1"</span></span><br><span class="line">                            <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p><code>ownKeys(target)</code> 方法用于拦截 <code>Reflect.ownKeys()</code>。</p><p><strong>返回值</strong></p><p><code>ownKeys</code> 方法必须返回<strong>一个可枚举对象</strong>。</p><h4 id="拦截-3"><a href="#拦截-3" class="headerlink" title="拦截"></a>拦截</h4><p>该拦截器可以拦截以下操作:</p><ul><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>Reflect.ownKeys()</code></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果违反了下面的约束，<code>proxy</code>将抛出错误 <code>TypeError</code>:</p><ul><li><code>ownKeys</code> 的结果必须是一个数组.</li><li>数组的元素类型要么是一个 <code>String</code> ，要么是一个 <code>Symbol</code>.</li><li>结果列表必须包含目标对象的所有不可配置<code>（non-configurable ）</code>、自有（<code>own</code>）属性的key.</li><li>如果目标对象不可扩展，那么结果列表必须包含目标对象的所有自有（<code>own</code>）属性的<code>key</code>，不能有其它值。</li></ul><h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable"></a>Proxy.revocable</h2><p><code>Proxy.revocable</code>方法返回一个可取消的 <code>Proxy</code> 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p><p><strong>注意</strong></p><p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 <code>Proxy</code> 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 <code>Proxy</code> 代理的情况下，目标对象内部的<code>this</code>关键字会指向 <code>Proxy</code> 代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() <span class="comment">// false</span></span><br><span class="line">proxy.m()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，一旦<code>proxy</code>代理<code>target.m</code>，后者内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p><p>下面是一个例子，由于<code>this</code>指向的变化，导致 <code>Proxy</code> 无法代理目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name <span class="comment">// 'Jane'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p><p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 <code>Proxy</code> 也无法代理这些原生对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getDate</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章记录了<code>Proxy</code>相关的的一些<code>属性访问的方法</code>，它有<strong>13</strong>种方法，大致分为两类：一类<strong>代理对象<code>自身属性</code>操作拦截</strong>，另一类<strong>代理对象<code>自身</code>操作拦截</strong>。</p><p>下一篇文章对比<code>defineProterty</code>和<code>Proxy</code>之间的优缺点，用它们实现简单的双线绑定。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">mdn Proxy</a><br><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">阮一峰 Proxy</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Object.defineProperty和Proxy分别是什么，它们之间的优缺点，实现简单的双向绑定。
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>ES系列 ———— Object.defineProperty</title>
    <link href="http://asyncnode.com/blog/es6/es6-definedproperty.html"/>
    <id>http://asyncnode.com/blog/es6/es6-definedproperty.html</id>
    <published>2019-09-10T06:23:54.000Z</published>
    <updated>2019-10-24T05:12:36.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/blog/es6/es6-definedproperty.html">ES系列 Object.defineProperty</a><br><a href="/blog/es6/es6-proxy.html">ES系列 Proxy</a><br><a href="/blog/es6/es6-definedproperty-proxy.html">ES系列 Object.defineProperty和Proxy的对比</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果用过<code>VUE</code>框架的话都听说过他的数据观测在<strong>2.x</strong>是是通过<code>Object.defineProperty</code>实现的，其实就是把普通的对象变为<strong>响应式对象</strong>，但是在最近<strong>3.x</strong>中作者要通过<strong>Proxy</strong>重写<code>Vue</code>中的双向绑定核心的<strong>响应式对象</strong>实现，在本篇文章中逐渐了解<code>Object.defineProperty</code>和<code>Proxy</code>是什么，它们之间的区别是什么，和它们之间的有缺点。</p><p>如果想了解<code>Vue</code>中的双向对象的实现，请看本站中的<strong>Vue响应式对象</strong>、<strong>依赖收集</strong>、<strong>派发更新</strong>等等<strong>Vue源码文章</strong>。</p><p>本文章目录：</p><ul><li><code>Object.defineProperty</code>使用简介</li><li><code>Proxy</code>使用简介</li><li><code>Object.defineProperty</code>和<code>Proxy</code>之间的区别和优缺点</li><li>为什么<code>Vue</code>要重写核心的数据观测实现</li><li><code>Object.defineProperty</code>和<code>Proxy</code>实现简单的双向绑定</li></ul><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p><strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.6" target="_blank" rel="noopener">ES5</a></strong> 提供了 <code>Object.defineProperty</code> 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>可以通过<code>Object.defineProperty(obj, prop, descriptor)</code>使用，三个参数分别代表：</p><ul><li><code>obj(Object)</code>: 要在其上定义属性的对象。</li><li><code>prop(String)</code>: 要定义或修改的属性的名称。</li><li><code>descriptor(Object)</code>: 将被定义或修改的属性描述符。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明example并且赋值一个对象字面量</span></span><br><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="comment">// 通过Object.defineProperty 定义一个新的属性count，并且给他赋值为一个value</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出example.count的值</span></span><br><span class="line">example.count; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符和存取描述符</strong>。</p><p><strong>数据描述符和存取描述符均具有</strong>以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下)：</p><ul><li><code>configurable(Boolean)</code>: 当且仅当该属性的 <code>configurable</code> 为 <code>true</code> 时，该属性<strong>描述符</strong>才能够被改变，同时该属性也能从对应的对象上被删除。<strong>默认为 false</strong>。</li><li><code>enumerable(Boolean)</code>: 当且仅当该属性的<code>enumerable</code>为<code>true</code>时，该属性才能够出现在对象的枚举属性中。<strong>默认为 false</strong>。</li></ul><p><strong>数据描述符同时具有以下可选键值：</strong></p><ul><li><code>value(任意有效的Javascript值)</code>： 该属性对应的值。<strong>默认为 undefined</strong>。</li><li><code>writable(Boolean)</code>: 当且仅当该属性的<code>writable</code>为<code>true</code>时，<code>value</code>才能被赋值运算符改变。<strong>默认为 false</strong>。</li></ul><p><strong>存取描述符同时具有以下可选键值：</strong></p><ul><li><code>get(Function 匿名函数)</code>：一个给属性提供 <code>getter</code> 的方法，如果没有 <code>getter</code> 则为 <code>undefined</code>。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入<strong>this</strong>对象（由于继承关系，这里的<strong>this</strong>并不一定是定义该属性的对象）。<strong>默认为 <code>undefined</code></strong>。</li><li><code>set(Function 匿名函数)</code>: 一个给属性提供 <code>setter</code> 的方法，如果没有 <code>setter</code> 则为 <code>undefined</code>。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。<strong>默认为 <code>undefined</code></strong>。</li></ul><p><strong>描述符可同时具有的键值</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>configurable</strong></th><th style="text-align:center"><strong>enumerable</strong></th><th style="text-align:center"><strong>value</strong></th><th style="text-align:center"><strong>writable</strong></th><th style="text-align:center"><strong>get</strong></th><th><strong>set</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>数据描述符</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>No</strong></td><td><strong>No</strong></td></tr><tr><td style="text-align:center"><strong>存取描述符</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>No</strong></td><td style="text-align:center"><strong>No</strong></td><td style="text-align:center"><strong>Yes</strong></td><td><strong>Yes</strong></td></tr></tbody></table><blockquote><p>注意事项： 如果一个描述符同时有(<code>value</code>或<code>writable</code>)和(<code>get</code>或<code>set</code>)关键字，将会产生一个异常。</p></blockquote><p>下面一个一个描述符来通过实例来看一下它真正的效果。</p><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当设置了<code>configurable</code>为<code>false</code>时，就不能在通过<code>defineProperty</code>设置属性描述了。当前的属性不能<strong>删除</strong>、<strong>修改</strong>、<strong>枚举</strong>等。下面请看实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">example.count = <span class="number">2</span>;</span><br><span class="line">example.count; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> example.count;</span><br><span class="line">example.count; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> example) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  wirtable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: count</span></span><br></pre></td></tr></table></figure><h3 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h3><p>当设置<code>Enumerable</code>为<code>false</code>时，当前这个属性不能被<code>for...in</code>和<code>Object.keys()</code>枚举。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当设置<code>writable</code>为<code>false</code>时，写入非可写属性<strong>不会改变它</strong>，也<strong>不会</strong>引发错误。</p><h3 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h3><p><code>get</code> 和 <code>set</code>两个方法在上面是存取属性描述，这两个方法又被称为<code>getter</code>和<code>setter</code>。可以简称为<strong>存取器属性</strong>。</p><p>当配置了<code>get</code>和<code>set</code>，就不能配置<code>value</code>和<code>writable</code>因为它们是互斥的，只能设置其中的一组。</p><p>当想获取一个属性的值时就会触发设置的<code>get</code>方法，当给一个属性赋值时就会触发<code>set</code>属性。</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;, value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProterty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了 get 操作'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了 set 操作'</span>)</span><br><span class="line">    value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">example.count = <span class="number">1</span>; <span class="comment">// 执行了 set 操作</span></span><br><span class="line">example.count; <span class="comment">// 1 执行了 get 操作</span></span><br></pre></td></tr></table></figure><h2 id="其它Object-defineProperty相关"><a href="#其它Object-defineProperty相关" class="headerlink" title="其它Object.defineProperty相关"></a>其它Object.defineProperty相关</h2><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h3><p><code>Object.defineProperties()</code>可以同时设置多个<code>Object.defineProperty</code>。</p><p><code>Object.defineProperties(obj, props)</code> 方法直接在一个对象上定义新的属性或修改现有属性，并<strong>返回</strong>该对象。参数如下：</p><ul><li><code>obj(Object)</code>: 在其上定义或修改属性的对象。</li><li><code>props(Object)</code>: 一个对象包含多个<strong>属性名:descriptor</strong></li></ul><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(example, &#123;</span><br><span class="line">  <span class="string">'count1'</span>: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'count2'</span>: &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h3><p><code>Object.getOwnPropertyNames(Object)</code>方法返回一个由指定对象的<strong>所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组</strong>。</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123; <span class="attr">num</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(example, &#123;</span><br><span class="line">  <span class="string">'count1'</span>: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'count2'</span>: &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(example); <span class="comment">//  ["num", "count1", "count2"]</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h3><p><code>Object.getOwnPropertyDescriptor(obj, prop)</code> 方法返回指定对象上一个<strong>自有属性对应的属性描述符</strong>。<strong>（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</strong>。参数如下：</p><ul><li><code>obj(Object)</code>: 需要查找的目标对象</li><li><code>prop(String)</code>： 目标对象内属性名称</li></ul><p><strong>返回值</strong><br>如果指定的属性存在于对象上，则返回其属性描述符对象<code>（property descriptor）</code>，否则返回 <code>undefined</code>。</p><blockquote><p>在 <strong>ES5</strong> 中，如果该方法的第一个参数不是对象（而是原始类型），那么就会产生出现 <code>TypeError</code>。而在 <strong>ES2015</strong>，第一个的参数不是对象的话就会<strong>被强制转换为对象</strong>。</p></blockquote><h2 id="冻结相关的"><a href="#冻结相关的" class="headerlink" title="冻结相关的"></a>冻结相关的</h2><h3 id="Object-defineProperty冻结"><a href="#Object-defineProperty冻结" class="headerlink" title="Object.defineProperty冻结"></a>Object.defineProperty冻结</h3><p>当<code>Object.defineProperty(obj, name, { value: 1 })</code>这样设置实，当前属性的<strong>writable</strong>、<strong>configurable</strong>、<strong>enumerable</strong>、都默认为<code>false</code>，可以把当前这个<strong>对象属性</strong>看做是一个冻结对象，那这个对象属性是<strong>深冻结还是浅冻结</strong>呢？</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: &#123;</span><br><span class="line">    num: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line">example.count = <span class="number">2</span>;</span><br><span class="line">example.count; <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line"><span class="comment">// 修改属性下的属性</span></span><br><span class="line">example.count.num = <span class="number">3</span>;</span><br><span class="line">example.count; <span class="comment">// &#123;num: 3&#125;</span></span><br></pre></td></tr></table></figure><p>通过上面的实例可以判定<code>defineProperty</code>冻结的对象属性，是<strong>浅冻结</strong>对象，如果是<strong>引用类型</strong>是可以修改的。如果想实现<strong>深层冻结</strong>，就需要递归对象所有的属性设置<code>Object.defineProperty()</code>。</p><h3 id="Object-freeze冻结"><a href="#Object-freeze冻结" class="headerlink" title="Object.freeze冻结"></a>Object.freeze冻结</h3><p><code>Object.freeze(obj)</code> 方法可以冻结一个对象。参数如下：</p><ul><li><code>obj(Object)</code>: 要被冻结的对象。</li></ul><p>一个被冻结的对象再也<strong>不能被修改</strong>；<br>冻结了一个对象则<strong>不能</strong>向这个对象<strong>添加新的属性</strong>，<strong>不能删除已有属性</strong>，不能修改该对象已有属性的<strong>可枚举性</strong>、<strong>可配置性</strong>、<strong>可写性</strong>，以及不能修改已有属性的值。此外，冻结一个对象后该对象的<strong>原型也不能被修改</strong>。<strong>freeze() 返回和传入的参数相同的对象</strong>。</p><p><strong>返回值</strong></p><p>被冻结的对象。</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;</span><br><span class="line">  count: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  num: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(example);</span><br><span class="line"><span class="comment">// 修改值类型无效</span></span><br><span class="line">example.num = <span class="number">11</span>;</span><br><span class="line">example.num; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改引用类型生效</span></span><br><span class="line">example.count[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">example.count; <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图通过 Object.defineProperty 更改属性 抛出 TypeError.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'num'</span>, &#123; <span class="attr">value</span>: <span class="number">11</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也不能更改原型 会抛出 TypeError.</span></span><br><span class="line">example.__proto__ = &#123; <span class="attr">x</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(example, &#123; <span class="attr">x</span>: <span class="number">20</span> &#125;)</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出<code>Object.freeze()</code>也是<strong>浅冻结</strong>，如果冻结的对象有多层引用类型嵌套，子属性是可以修改的。如果想实现<strong>深层冻结</strong>，就需要递归对象所有的属性设置<code>Object.freeze()</code>。</p><h4 id="冻结数组"><a href="#冻结数组" class="headerlink" title="冻结数组"></a>冻结数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>];</span><br><span class="line"><span class="built_in">Object</span>.freeze(a); <span class="comment">// 现在数组不能被修改了.</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// fails silently</span></span><br><span class="line">a.push(<span class="number">2</span>); <span class="comment">// fails silently</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In strict mode such attempts will throw TypeErrors</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  a.push(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fail();</span><br></pre></td></tr></table></figure><h4 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen"></a>Object.isFrozen</h4><p><code>Object.isFrozen(obj)</code>方法判断一个对象是否被冻结。参数如下：</p><ul><li><code>obj(Object)</code>: 被检测的对象。</li></ul><p><strong>返回值</strong></p><p>表示给定对象是否被冻结的<code>Boolean</code>。</p><blockquote><p><strong>在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常</strong>。<br><strong>在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isFrozen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isFrozen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// true                          (ES2015 code)</span></span><br></pre></td></tr></table></figure><h4 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal"></a>Object.seal</h4><p><code>Object.seal(obj)</code>方法封闭一个对象，<strong>阻止添加新属性并将所有现有属性标记为不可配置</strong>。<strong>当前属性的值只要可写就可以改变</strong>。</p><ul><li><code>obj(Object)</code>: 将要被密封的对象。</li></ul><p><strong>返回值</strong></p><p>被密封的对象。</p><blockquote><p><strong>在ES5中，如果这个方法的参数不是一个（原始）对象，那么它将导致TypeError</strong>。<br><strong>在ES2015中，非对象参数将被视为已被密封的普通对象，会直接返回它</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1                             (ES2015 code)</span></span><br></pre></td></tr></table></figure><p>它其他的表现适合<code>Object.freeze</code>是一致的。</p><h3 id="实现一个深度冻结"><a href="#实现一个深度冻结" class="headerlink" title="实现一个深度冻结"></a>实现一个深度冻结</h3><p>这里只实现一个简单的<strong>深度冻结</strong>方法，一些<strong>循环引用</strong>、<strong>特殊类型</strong>没有考虑在内，实现如下：</p><ul><li>递归对象属性，调用冻结方法</li><li>返回冻结完成的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFreeze</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arguments is not object'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> propertyName = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">  propertyName.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[item] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj[item] !== <span class="string">'null'</span>) &#123;</span><br><span class="line">      deepFreeze(obj[item]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> example = deepFreeze(&#123;<span class="attr">example</span>: &#123; <span class="attr">name</span>: <span class="string">'admin'</span> &#125;&#125;);</span><br><span class="line">example.example.name = <span class="number">1</span>;</span><br><span class="line">example.example; <span class="comment">// &#123;name: "admin"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>因为当前文章写得太长了，所以拆分为三篇博客。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">mdn Object.defineProperty()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">mdn Object.defineProperties()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">mdn Object.freeze()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener">mdn Object.seal()</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Object.defineProperty和Proxy分别是什么，它们之间的优缺点，实现简单的双向绑定。
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>用webpack写一个vue单页面的脚手架</title>
    <link href="http://asyncnode.com/blog/webpack/webpack-cli-sap.html"/>
    <id>http://asyncnode.com/blog/webpack/webpack-cli-sap.html</id>
    <published>2019-09-01T02:23:23.000Z</published>
    <updated>2019-10-24T05:12:36.967Z</updated>
    
    <summary type="html">
    
      用webpack写一个vue单页面的脚手架，后面还会有多页面、ssr配置。
    
    </summary>
    
      <category term="WebPack" scheme="http://asyncnode.com/categories/WebPack/"/>
    
    
      <category term="WebPack" scheme="http://asyncnode.com/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>深入Vue系列 ———— Vue中v-model解析、sync修饰符解析</title>
    <link href="http://asyncnode.com/blog/vue/vue-vModel-sync.html"/>
    <id>http://asyncnode.com/blog/vue/vue-vModel-sync.html</id>
    <published>2019-08-29T12:22:18.000Z</published>
    <updated>2019-10-24T05:12:36.967Z</updated>
    
    <content type="html"><![CDATA[<p><em>上善若水，水善利萬物而不爭。——《道德經》</em></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>在平时开发是经常用到一些父子组件通信，经常用到<code>props</code>、<code>vuex</code>等等，这里面记录另外的三种方式<code>v-model</code>、<code>sync</code>是怎么使用，再说是怎么实现，其实<code>v-model</code>、<code>sync</code>都是语法糖。还有<code>$attr</code>、<code>$listener</code>实现父子组件通信。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><hr><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><blockquote><p>2.2.0+ 新增</p></blockquote><p><code>v-mode1</code>其实就是一个语法糖，默认会利用名为<code>value</code>的<code>props</code>和名为<code>input</code>的事件，但是像单选框、复选框等类型的输入龙剑可能会讲<code>value</code>特性用于不同的目的。</p><p><code>v-model</code>的使用场景：当<strong>子组件</strong>需要改变父组件通过<code>props</code>传入的值</p><p><strong><em>父组件</em></strong></p><ul><li>父组件通过<code>v-model</code>绑定值</li><li>如需根据<code>v-model</code>传入的值改变，而触发其他更新请通过<code>watch</code>传入的值</li></ul><p><strong><em>子组件</em></strong></p><ul><li>声明<code>model</code>对象 设置事件<code>event</code>和<code>prop</code>字段</li><li>通过<code>porps</code>接受父组件传送值</li><li>修改是通过<code>this.$emit</code>广播事件</li></ul><p>代码示例：</p><p><strong><em>父组件代码</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;children v-model=<span class="string">"message"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import children from "./</span>children.vue<span class="string">";</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    children</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      message: "</span>parent<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  watch: &#123;</span></span><br><span class="line"><span class="string">    // 监听message变化</span></span><br><span class="line"><span class="string">    message(newV, oldV) &#123;</span></span><br><span class="line"><span class="string">      console.log(newV, oldV);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>子组件代码</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">"message"</span>, <span class="comment">//这个字段，是指父组件设置 v-model 时，将变量值传给子组件的 msg</span></span><br><span class="line">    event: <span class="string">"input"</span> <span class="comment">//这个字段，是指父组件监听 parent-event 事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    message: <span class="built_in">String</span> <span class="comment">//此处必须定义和model的prop相同的props，因为v-model会传值给子组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">//这里模拟异步将msg传到父组件v-model，实现双向控制</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">"input"</span>, <span class="string">"children"</span>);</span><br><span class="line">      <span class="comment">//将这个值通过 emit 触发parent-event，将some传递给父组件的v-model绑定的变量</span></span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个示例是通过<code>v-model</code>实现的，下面不通过<code>v-model</code>实现同样效果。</p><h3 id="不使用-v-model-实现"><a href="#不使用-v-model-实现" class="headerlink" title="不使用 v-model 实现"></a>不使用 v-model 实现</h3><p>代码示例如下：</p><p><strong><em>父组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Children :message=<span class="string">"message"</span> @input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 不变</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p><strong><em>子组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="comment">// 不变</span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    message: String</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit("input", "children");</span></span><br><span class="line"><span class="regexp">    &#125;, 1500);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>只是把<code>v-model</code>拆分为<code>props</code>和<code>@input</code>事件，子组件不需要配置<code>model</code>,只需要接受<code>props</code>和通过<code>this.$emit</code>广播事件就可以。<br>当然这个相对于<code>v-model</code>方法比较简便，但是灵活度查很多，选择使用那种看个人喜好。<br>在线地址：</p><iframe src="https://codesandbox.io/embed/vue-template-zcvn3?fontsize=14" title="Vue Template" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><blockquote><p>2.3.0+ 新增</p></blockquote><p>在有些情况下，我们可能需要对一个 <code>prop</code> 进行<strong><em>“双向绑定”</em></strong>。不幸的是，真正的<strong>双向绑定</strong>会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p><p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。同时也可以通过<code>sync</code>修饰符来实现。</p><p>在上面代码的基础上大致修改如下：</p><p><strong><em>父组件</em></strong></p><ul><li>通过修改触发事件<code>input</code>为<code>update:myPropName</code>实现相同效果</li></ul><p><strong><em>子组件</em></strong></p><ul><li>通过修改<code>this.$emit(update:myPropName)</code></li></ul><p>代码如下：</p><p><strong><em>父组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改如下</span></span><br><span class="line">&lt;Children :message=<span class="string">"message"</span> @update:input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><p><strong><em>子组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"update:input"</span>, <span class="string">"children"</span>);</span><br></pre></td></tr></table></figure><h3 id="sync实现"><a href="#sync实现" class="headerlink" title="sync实现"></a>sync实现</h3><p>上面的代码可以通过<code>sync</code>简写为下面代码：</p><p><strong><em>父组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改如下</span></span><br><span class="line">&lt;Children :messag.sync=<span class="string">"message"</span>/&gt;</span><br></pre></td></tr></table></figure><p><strong><em>子组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"update:messag"</span>, <span class="string">"children"</span>);</span><br></pre></td></tr></table></figure><p>同时<code>sync</code>也支持对象，要配合<code>v-bind</code>实现可以简写为<code>:</code>，但是要注意这个对象如下两条：</p><blockquote><p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 <code>v-model</code>。<br>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p></blockquote><h2 id="attrs、-listeners"><a href="#attrs、-listeners" class="headerlink" title="$attrs、$listeners"></a>$attrs、$listeners</h2><h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li>类型：<code>{ [key: string]: string }</code></li><li>只读</li><li>详细：<br>包含了父作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 <code>prop</code> 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</li></ul><h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li>类型：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></li><li>只读</li><li>详细：<br>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</li></ul><h3 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h3><p>实现父子组件通信</p><p><strong><em>父组件代码</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;Children</span><br><span class="line">      :message=<span class="string">"message"</span></span><br><span class="line">      @upDate=<span class="string">"upDate"</span></span><br><span class="line">      type=<span class="string">"del"</span></span><br><span class="line">      @input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span></span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Children <span class="keyword">from</span> <span class="string">"./Children"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">"parent"</span>,</span><br><span class="line">      type: <span class="string">"del"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    upDate (event) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(event);</span><br><span class="line">      <span class="keyword">this</span>.type = event;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    message: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"更新message值为"</span> + <span class="keyword">this</span>.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>子组件代码</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-bind=<span class="string">"$attrs"</span> v-on=<span class="string">"$listeners"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"children"</span>&gt;&#123;&#123;message&#125;&#125; &lt;span @click=<span class="string">"$listeners.upDate('data')"</span>&gt;&#123;&#123;$attrs.type&#125;&#125;&lt;<span class="regexp">/span&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    message: String</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.log(this.$attrs);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.log(this.$listeners);</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit("input", "children");</span></span><br><span class="line"><span class="regexp">      this.$emit('upDate', 'add')</span></span><br><span class="line"><span class="regexp">    &#125;, 1500);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>同时<code>$attrs</code>、<code>$listeners</code>都是可以跨域父子组件，可以父子子子组件传递，类似于<code>react</code>中的<code>context</code>，只是一部分设计理念相同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实就是检测到<code>.sync</code>修饰符，在<code>complier</code>阶段会编译生成多个<code>prop</code>，生成多个<code>事件</code>。其实像这个<strong>指令</strong>、<strong>修饰符</strong>、<strong>自定义指令</strong>都是在<code>vue</code>编译是解析成为<strong>v8</strong>能执行的代码。</p><p>无论是<code>vue</code>、<code>babel</code>、<code>react</code>的<code>complier</code>编译阶段大致分为三个阶段：</p><ul><li>通过词法解析<code>parse</code>生成抽象<code>AST</code>或<code>抽象代码树</code></li><li>优化<code>AST</code>,比如<code>vue</code>标记静态节点，<code>babal</code>中抽取静态代码，这个阶段被称为<code>optimize</code>或者<code>优化AST树</code></li><li>在<code>AST</code>代码的阶段上，生成可执行代码，这个过程可以叫做<code>codegen</code></li></ul><p><code>v-model</code>、<code>sync</code>都可以实现父子组件通信，并且可以在子组件中修改父组件传入的值。在平常看法的时候进场可以用到这两种方式，具体选择那种方式看个人喜好。在<code>element-ui</code>这个<code>input</code>组件也用到相关的属性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener">$attrs</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model" target="_blank" rel="noopener">自定义组件的-v-model</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-修饰符" target="_blank" rel="noopener">sync-修饰符</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Vue中v-model解析、sync修饰符解析、$attr、$listeners
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScirpt面试题 ———— 有关原型一道笔试题</title>
    <link href="http://asyncnode.com/blog/InterviewQuestion/javascript-prototype.html"/>
    <id>http://asyncnode.com/blog/InterviewQuestion/javascript-prototype.html</id>
    <published>2019-08-25T07:34:21.000Z</published>
    <updated>2019-10-24T05:12:36.935Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>慎終如始，則無敗事。——《道德經》</strong></em></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>这道面试题考察的比较综合，也有很多要注意的点，如果知道答案就没有必要往下看了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Preson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.b = [<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">this</span>.a];</span><br><span class="line">  <span class="keyword">this</span>.c = &#123; <span class="attr">demo</span>: <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, <span class="keyword">this</span>.b, <span class="keyword">this</span>.c.demo);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">this</span>.change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b.push(<span class="keyword">this</span>.a);</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="keyword">this</span>.b.length;</span><br><span class="line">    <span class="keyword">this</span>.c.demo = <span class="keyword">this</span>.a++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Preson();</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Preson();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">22</span>;</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure><h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><hr><p>这道题比较经典考察了<code>JavaScript</code>中很多方面的知识，大致如下几点：</p><ul><li>prototype 原型、原型链问题</li><li>new 改变 this 指向，new 产生实例属性和原型属性</li><li>值类型和引用类型</li><li>原型继承</li></ul><p>是一道比较综合的题前四题比较好答，后面的两题想多或者想少了都会出错。这里就对一些知识点不多做赘述，可以查看往期文章了解。<br><strong>往期文章</strong></p><blockquote><p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript 类型转换（一） 常见数据类型</a> &gt; <code>...后期添加</code></p></blockquote><h2 id="结题需要的知识点"><a href="#结题需要的知识点" class="headerlink" title="结题需要的知识点"></a>结题需要的知识点</h2><hr><p>大致的知识点如下：</p><ol><li><strong>构造函数有一个<code>prototype</code>属性指向原型对象，多个实例属性共享一个原型对象</strong></li><li><strong>实例中的属性都是独立的互相之间不会影响</strong></li><li><strong>每一个实例都有一个隐式原型<code>__proto__</code>指向构造函数的原型对象</strong></li><li><strong><code>this</code>的指向问题，大致如下：</strong></li></ol><ul><li>作为对象方法时，谁调用就指向谁</li><li><code>new</code>、<code>bind</code>、<code>call</code>、<code>apply</code>都会改变 this 的指向</li><li>箭头函数的<code>this</code>从外层普通函数获取</li></ul><ol start="5"><li><strong>对象字面量和数组都是引用对象</strong></li><li><strong>原型链的查找规则： 就近原则</strong></li></ol><ul><li>当实例上存在属性时， 用实例上的</li><li>如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的</li><li>如果原型链都不存在，就用 Object 原型对象上的</li><li>如果 Object 原型对象都不存在， 就是 undefined</li></ul><h2 id="第一问-parent-show"><a href="#第一问-parent-show" class="headerlink" title="第一问 parent.show()"></a>第一问 parent.show()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.show();</span><br></pre></td></tr></table></figure><p>调用<code>parent.show()</code>的方法，其实就是调用<code>parent</code>实例上的<code>show</code>方法，直接输出<code>1, [1, 2, 1], 5</code>;没什么太多解释的，了解<code>new</code>关键字就可以。</p><h2 id="第二问-child1-show-、child2-show"><a href="#第二问-child1-show-、child2-show" class="headerlink" title="第二问 child1.show()、child2.show()"></a>第二问 child1.show()、child2.show()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure><p>首相要了解下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Preson();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>上面代码把<code>Child.prototype</code>指向一个<code>Preson</code>的实例，可以知道<code>Child.prototype.__proto__</code>指向<code>Preson.prototype</code>;<code>Child.prototype.constructor</code>指向<code>Preson</code>。下面是验证代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype.__proto__ === Preson.prototype; <span class="comment">// true</span></span><br><span class="line">Child.prototype.constructor === Preson; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>child1</code>、<code>child2</code>的结构如下图所示：<br><img src="../../images/interviewquestion/javascript-prototype-1-1.png" alt="javascript-prototype"></p><p><code>child1</code>、<code>child2</code>都是<code>Child</code>构造函数实例化产生的，所以<code>child1.show() child2.show()</code>是调用的<code>Child.prototype</code>上的方法，但是注意<code>child1</code>、<code>child2</code>的对象上都声明了一个新属性<code>a</code>。<br>根据上面第<code>6</code>条知识点可知结果为<code>11, [1, 2, 1], 5)</code>、<code>12, [1, 2, 1], 5</code>；</p><p><strong>注意</strong><br>从代码上看<code>child1.__proto__.b</code>数组的第三项是指向<code>child1.__proto__.a</code>的，那我们此时修改<code>child1.__proto__.a</code>的值，是否会影响<code>child1.show()</code>的结果呢:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child1.__proto__.a = <span class="number">12123</span>;</span><br><span class="line">child1.show(); <span class="comment">// 11, [1, 2, 1], 5</span></span><br></pre></td></tr></table></figure><p>是没有影响的，因为<code>parent</code>实例生成的时候，<code>this.a</code>指向了一个原始值<code>2</code>,所以<code>this.b</code>中的第三项实际上是被赋值了一个<strong>原始值</strong>，故此处乍看起来像是<strong>引用类型</strong>的赋值，实则不是。<strong>原始值赋值会开辟新的存储空间</strong>，使得<code>this.a</code>和<code>this.b[2]</code>的值相等，但是却指向了堆内存里的不同地址。</p><h2 id="第三问-parent-show"><a href="#第三问-parent-show" class="headerlink" title="第三问 parent.show()"></a>第三问 parent.show()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.show();</span><br></pre></td></tr></table></figure><p>根据上面第<code>2</code>条知识点，可知<code>preson</code>和<code>Child</code>是<code>Person</code>的不同的实例，它们之间不会相互影响，所以它的经过不会更改为<code>1, [1, 2, 1], 5</code>。</p><h2 id="第四问-child1-show-、child2-show"><a href="#第四问-child1-show-、child2-show" class="headerlink" title="第四问 child1.show()、child2.show()"></a>第四问 child1.show()、child2.show()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面执行了</span></span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line"></span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure><p><code>child1.change()</code>执行了<code>change()</code>时执行过程如下：</p><p><strong><code>this.b.push(this.a)</code></strong><br>由于<code>this</code>的动态指向特性，<code>this.b</code>会指向<code>Child.prototype</code>上的<code>b</code>数组,<code>this.a</code>会指向<code>child1</code>的<code>a</code>属性,所以<code>Child.prototype.b</code>变成了<code>[1,2,1,11]</code>;</p><p><strong><code>this.a = this.b.length</code></strong><br><code>this.b.length</code>经过上一步的添加了一条数据变为了<code>4</code>，所以当前的<code>this.a</code>就是<code>4</code>。</p><p><strong><code>this.c.demo = this.a++;</code></strong><br><code>this.a</code>是<code>4</code>，<code>this.c.demo</code>的值被复制为<code>4</code>，不要忽略<code>this.a++</code>以后的值变为了<code>5</code>。</p><p><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果</p><p><code>child2.change()</code>执行了<code>change()</code>时执行过程如下：<br><strong><code>this.b.push(this.a)</code></strong><br>由于<code>this</code>的动态指向特性，<code>this.b</code>会指向<code>Child.prototype</code>上的<code>b</code>数组,<code>this.a</code>会指向<code>child2</code>的<code>a</code>属性,所以<code>Child.prototype.b</code>变成了<code>[1,2,1,11,12]</code>;</p><p><strong><code>this.a = this.b.length</code></strong><br><code>this.b.length</code>经过上一步的添加了一条数据变为了<code>5</code>，所以当前的<code>this.a</code>就是<code>5</code>。</p><p><strong><code>this.c.demo = this.a++;</code></strong><br><code>this.a</code>是<code>5</code>，<code>this.c.demo</code>的值被复制为<code>5</code>，不要忽略<code>this.a++</code>以后的值变为了<code>6</code>。</p><p>所以会输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child1.show(); <span class="comment">// 5, [1,2,1,11,12], 5</span></span><br><span class="line">child2.show(); <span class="comment">// 6, [1,2,1,11,12], 5</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>前端的所有知识都是比较零散的，所以尽量要建立自己的知识结构图才方便以后的查漏补缺</li><li>因为知识比较零散不便于记忆，最好多找几个切入点把零散的知识串联起来更容易记住</li><li>没有别的办法多写、多看、多记一遍不行就直到记住为止</li></ol><blockquote><p>值类型变量赋值给引用类型时，改变值类型变量的值并不会影响赋值给引用类型中的值，</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, test];</span><br><span class="line">test = <span class="number">2222</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4, 111];</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.cnblogs.com/dashnowords/p/9404237.html" target="_blank" rel="noopener">javascript 基础修炼(1)——一道十面埋伏的原型链面试题</a> &gt; <a href="https://www.php.cn/js-tutorial-410582.html" target="_blank" rel="noopener">javascript 原型链的一道面试题的分析（详细）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      JavaScirpt有关原型一道笔试题
    
    </summary>
    
      <category term="InterviewQuestion" scheme="http://asyncnode.com/categories/InterviewQuestion/"/>
    
    
      <category term="InterviewQuestion" scheme="http://asyncnode.com/tags/InterviewQuestion/"/>
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
