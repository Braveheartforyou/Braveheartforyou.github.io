<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asyncnode</title>
  
  <subtitle>asyncnode</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://asyncnode.com/"/>
  <updated>2019-10-24T05:12:36.958Z</updated>
  <id>http://asyncnode.com/</id>
  
  <author>
    <name>asyncnode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式系列 ———— mvc和mvvm到底是什么</title>
    <link href="http://asyncnode.com/blog/mode/mode-mvc-mvvm.html"/>
    <id>http://asyncnode.com/blog/mode/mode-mvc-mvvm.html</id>
    <published>2019-10-13T06:32:21.000Z</published>
    <updated>2019-10-24T05:12:36.958Z</updated>
    
    <summary type="html">
    
      在现在常用框架中比如说Vue是mvvm模式，react是mvc模式，其实设计模式最早是在建筑工程学中产生的，后面被引申到程序设计中。一开始基本上都是在服务器web语言中听到这种模式的，这篇文章记录清楚mvvm和mvc到底是什么？他们一样？
    
    </summary>
    
      <category term="设计模式" scheme="http://asyncnode.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://asyncnode.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝系列 ———— 分析lodash中的deepcopy</title>
    <link href="http://asyncnode.com/blog/javascript/javascript-loadsh-deepcopy.html"/>
    <id>http://asyncnode.com/blog/javascript/javascript-loadsh-deepcopy.html</id>
    <published>2019-10-07T12:12:58.000Z</published>
    <updated>2019-10-24T05:12:36.952Z</updated>
    
    <summary type="html">
    
      本篇文章学习loadsh中的deepcopy，并且优化自己的在上篇文章中写的deepcopy。
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
      <category term="深拷贝" scheme="http://asyncnode.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝系列 ———— 自己通过递归实现一个深拷贝</title>
    <link href="http://asyncnode.com/blog/javascript/javascript-deepcopy.html"/>
    <id>http://asyncnode.com/blog/javascript/javascript-deepcopy.html</id>
    <published>2019-10-02T15:12:32.000Z</published>
    <updated>2019-10-24T05:12:36.950Z</updated>
    
    <summary type="html">
    
      本篇文章会介绍通过递归实现一个深拷贝，并且解决JSON.parse和JSON.stringify存在的问题。
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
      <category term="深拷贝" scheme="http://asyncnode.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝系列 ———— 自己实现一个JSON.stringify和JSON.parse</title>
    <link href="http://asyncnode.com/blog/javascript/javascript-paser-stringify.html"/>
    <id>http://asyncnode.com/blog/javascript/javascript-paser-stringify.html</id>
    <published>2019-09-27T10:23:56.000Z</published>
    <updated>2019-10-24T05:12:36.953Z</updated>
    
    <summary type="html">
    
      本篇文章会介绍JSON.stringify和JSON.parse用来深拷贝时存在什么问题，并且自己手动实现一个。
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
      <category term="深拷贝" scheme="http://asyncnode.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝系列 ———— 什么是深拷贝、浅拷贝、Object.assign</title>
    <link href="http://asyncnode.com/blog/es6/es6-assign.html"/>
    <id>http://asyncnode.com/blog/es6/es6-assign.html</id>
    <published>2019-09-23T01:45:21.000Z</published>
    <updated>2019-10-24T05:12:36.942Z</updated>
    
    <summary type="html">
    
      本篇文章会介绍什么是深拷贝、什么是浅拷贝，Object.assgin是深拷贝还是浅拷贝，自己实现一个Object.assgin。
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
      <category term="深拷贝" scheme="http://asyncnode.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>ES系列 ———— Object.defineProperty和Proxy的对比</title>
    <link href="http://asyncnode.com/blog/es6/es-defineproperty-proxy.html"/>
    <id>http://asyncnode.com/blog/es6/es-defineproperty-proxy.html</id>
    <published>2019-09-18T01:12:32.000Z</published>
    <updated>2019-10-24T05:12:36.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在前两篇文章中分别介绍了<code>Object.defineProperty</code>和<code>Proxy</code>两个新的特性，其实看起来<code>Proxy</code>更像是对<code>Object.defineProperty</code>的一种补充和完善(个人见解)。当然不是说<code>Object.defineProperty</code>很差，感觉更像是一开始的定位是为了处理对象的特定属性，但是在<code>Vue</code>等等框架的中被用来劫持整个对象属性，所以后面就出来了<code>Proxy</code>，更强大的劫持功能。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>根据上面两篇文章的介绍，大致优缺点如下：</p><p><strong><em>Proxy相对于defineProperty的优点</em></strong></p><ul><li>对于对象已有属性：<code>Object.defineProperty</code>只能劫持对象的单个属性，如果想劫持整个对象就要<strong>循环递归</strong>调用<code>Object.defineProperty</code>。而<code>Proxy</code>拦截整个对象，并且返回一下新的对象。</li><li>对于对象新增属性：<code>Proxy</code>劫持整个对象，对于新增的属性自动拦截。而<code>Object.defineProperty</code>需要<strong>重新劫持</strong>新增的属性</li><li>对于数组操作： <code>Object.defineProperty</code>无法监控到数组下标的变化。而<code>Proxy</code>可以监听数组变化。</li><li>拦截或劫持方法： <code>Object.defineProperty</code>描述符基本上分为两类<strong>数据描述符</strong>、<strong>存取描述符</strong>、<strong>通用描述符</strong>三种。而<code>Proxy</code>中有<strong>13</strong>种<strong>traps</strong>方法供你选择。</li><li>是否支持取消劫持： <code>Object.defineProperty</code>如果想取消劫持，只能<strong>重写</strong>描述符，但是<strong>configurable: false</strong>时就<strong>不能重写</strong>描述符了。而<code>Proxy</code>可以通过<code>Proxy.revocable</code>返回一个可取消的 <code>Proxy</code> 实例。</li><li>浏览器对劫持或拦截的支持： <code>Proxy</code>在后续应该会有更好的支持，不然<code>Vue</code>也不会修改核心代码。</li><li>性能： <code>Proxy</code>性能是比<code>Object.defineProperty</code>高的，在多个对象属性中。</li></ul><p><strong>Proxy相对于defineProperty的缺点</strong></p><ul><li><code>this指向</code>： <code>defineProperty</code>因为只绑定对象的属性，一般不会涉及到<code>this问题</code>。而<code>Proxy</code>返回的对象的<code>this</code>和<code>target</code>的<code>this</code>不相同。</li><li><code>使用难度</code>: 相对于<code>Proxy</code>的<strong>api</strong>，反而<code>defineProperty</code>上手更容易。</li></ul><p><strong>Proxy和defineProperty的一些注意事项</strong></p><ul><li><code>对象冻结</code>：无论是<code>defineProperty</code>、<code>Object.freeze</code>、<code>Object.seal（密封）</code>都不是深度冻结，如果想深度冻结只能递归实现。</li><li><code>this问题</code>： <code>Proxy</code>在使用是要注意<code>this</code>指向问题。</li></ul><h2 id="各自实现双向绑定"><a href="#各自实现双向绑定" class="headerlink" title="各自实现双向绑定"></a>各自实现双向绑定</h2><p>现在的三大框架非常的流行，在数据流中分为两派<code>React</code>的单项数据流，<code>Angluar/Vue</code>的双向数据流。其实<code>React</code>也是实现了的<strong>双向数据绑定</strong>的，只不过要通过<code>setState</code>来触发。</p><p>在不同框架中实现<strong>双向数据绑定</strong>也是不相同的，大致如下图所示：</p><p><a href="../../images/es/es-defineProperty.png">双向绑定</a></p><p><code>Object.defineProperty</code>和<code>proxy</code>都是<code>Vue</code>不同版本的重要组成部分，它们都是可以实现双向绑定中的<strong>数据劫持</strong>，其实也就是响应式对象，在以前的文章有<a href="/blog/vue/vue-definedProperty.html">深入Vue系列 Vue中的响应式对象</a>、<br><a href="/blog/vue/vue-dep.html">深入Vue系列 Vue中的依赖收集</a>、<a href="/blog/vue/vue-notify.html">深入Vue系列 Vue中的派发更新</a>，如果感兴趣的可以去看看。</p><p>依照<code>Vue</code>代码中的双向绑定思路，大致分为以下三步：</p><ul><li>把普通对象通过<code>Object.defineProperty</code>变为响应式对象</li><li>同时<code>getter</code>中收集依赖，也就是渲染<code>wather</code></li><li>在<code>setter</code>中派发更行</li></ul><p>下面写的实例不会这么复杂，当然也会仿照<code>Vue</code>源码中的<code>mvvm</code>去写。</p><h2 id="Object-defineProperty实现双向绑定"><a href="#Object-defineProperty实现双向绑定" class="headerlink" title="Object.defineProperty实现双向绑定"></a>Object.defineProperty实现双向绑定</h2><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><ul><li>劫持对象的<code>get、set</code>属性</li><li><code>input</code>事件更新对象值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Static Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"mv"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"vm"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 对象配置描述符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"value"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"get value"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"set value"</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"mv"</span>).value = newVal;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"vm"</span>).innerHTML = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// input绑定时间更行对象中的value值</span></span><br><span class="line"><span class="keyword">const</span> InputDom = <span class="built_in">document</span>.getElementById(<span class="string">"mv"</span>);</span><br><span class="line">InputDom.addEventListener(<span class="string">"input"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">  obj.value = event.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面这个代码只是简单了实现最简单的效果，在<code>input</code>中输入代码，同时更新到<code>p</code>中。</p><h3 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h3><h2 id="Proxy实现双向绑定"><a href="#Proxy实现双向绑定" class="headerlink" title="Proxy实现双向绑定"></a>Proxy实现双向绑定</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      Object.defineProperty和Proxy分别是什么，它们之间的优缺点，实现简单的双向绑定。
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>ES系列 ———— Proxy</title>
    <link href="http://asyncnode.com/blog/es6/es6-proxy.html"/>
    <id>http://asyncnode.com/blog/es6/es6-proxy.html</id>
    <published>2019-09-14T10:33:44.000Z</published>
    <updated>2019-10-24T05:12:36.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/blog/es6/es6-definedproperty.html">ES深入系列 Object.defineProperty</a><br><a href="/blog/es6/es6-proxy.html">ES深入系列 Proxy</a><br><a href="/blog/es6/es6-definedproperty-proxy.html">ES深入系列 Object.defineProperty和Proxy的对比</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上一篇<a href="/blog/es6/es6-definedproperty.html">ES系列 Object.defineProperty</a>已经介绍过了<strong>Object.defineProperty</strong>相关内容，这篇文章中会介绍在<strong>Vue 3.x</strong>中代替<code>Object.defineProperty</code>的<code>Proxy</code>。<br>最后会介绍它们之间的<strong>优缺点</strong>和实现<strong>双向绑定简单实例</strong>。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>从字面上可以把<code>Proxy</code>理解为<strong>代理</strong>，但是感觉解释为类似于<strong>代理模式</strong>会更贴合一点。<strong>“阮大佬：Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。”</strong></p><p>首先要了解其中的<strong>术语</strong>。</p><ul><li><code>handler</code>: 包含陷阱（traps）的占位符对象。</li><li><code>traps</code>: 提供属性访问的方法。这类似于操作系统中捕获器的概念。</li><li><code>target</code>: 代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</li></ul><p><code>new Proxy(target, handler)</code>方式创建一下新的对象，参数如下：</p><ul><li><code>target (Object)</code>: 用<code>Proxy</code>包装的目标对象（可以是<strong>任何类型的对象，包括原生数组，函数，甚至另一个代理</strong>）。</li><li><code>handler(Object)</code>: 一个对象，其属性是当执行一个操作时定义代理的行为的函数。</li></ul><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p><code>handler</code> 对象是一个占位符对象，它包含<strong>Proxy</strong>的捕获器。同时<strong>handler</strong>对象包含了用于拦截的<strong>13</strong>种操作。如下：<br>大致可以分为一类<strong>代理对象<code>自身属性</code>操作拦截</strong>：</p><table><thead><tr><th style="text-align:center">拦截方法名</th><th style="text-align:center">详情</th></tr></thead><tbody><tr><td style="text-align:center"><code>handler.get(target, property, receiver)</code></td><td style="text-align:center">在<strong>读取</strong>代理对象的某个<strong>属性时</strong>触发该操作，比如在执行 <code>proxy.foo</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.set(target, property, value, receiver)</code></td><td style="text-align:center">在给代理对象的某个<strong>属性赋值时</strong>触发该操作，比如在执行 <code>proxy.foo = 1</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.has(target, prop)</code></td><td style="text-align:center">在判断代理对象<strong>是否拥有某个属性时</strong>触发该操作，比如在执行 <code>&quot;foo&quot; in proxy</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.defineProperty(target, property, descriptor)</code></td><td style="text-align:center">在<strong>定义代理对象某个属性时的属性描述时</strong>触发该操作，比如在执行 <code>Object.defineProperty(proxy, &quot;foo&quot;, {})</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.deleteProperty(target, property)</code></td><td style="text-align:center">在<strong>删除代理对象的某个属性时</strong>触发该操作，即使用<code>delete</code>运算符，比如在执行 <code>delete proxy.foo</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.getOwnPropertyDescriptor(target, prop)</code></td><td style="text-align:center">在<strong>获取代理对象某个属性的属性描述时</strong>触发该操作，比如在执行 <code>Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;)</code> 时。</td></tr></tbody></table><!-- - `handler.get(target, property, receiver)`: 在**读取**代理对象的某个**属性时**触发该操作，比如在执行 `proxy.foo` 时。- `handler.set(target, property, value, receiver)`: 在给代理对象的某个**属性赋值时**触发该操作，比如在执行 `proxy.foo = 1` 时。 --><!-- - `handler.has(target, prop)`: 在判断代理对象**是否拥有某个属性时**触发该操作，比如在执行 `"foo" in proxy` 时。 --><!-- - `handler.defineProperty(target, property, descriptor)`: 在**定义代理对象某个属性时的属性描述时**触发该操作，比如在执行 `Object.defineProperty(proxy, "foo", {})` 时。 --><!-- - `handler.deleteProperty(target, property)`: 在**删除代理对象的某个属性时**触发该操作，即使用`delete`运算符，比如在执行 `delete proxy.foo` 时。- `handler.getOwnPropertyDescriptor(target, prop)`:在**获取代理对象某个属性的属性描述时**触发该操作，比如在执行 `Object.getOwnPropertyDescriptor(proxy, "foo")` 时。 --><p>另一类<strong>代理对象<code>自身</code>操作拦截</strong>:</p><table><thead><tr><th style="text-align:center">拦截方法名</th><th style="text-align:center">详情</th></tr></thead><tbody><tr><td style="text-align:center"><code>handler.getPrototypeOf(target)</code></td><td style="text-align:center">在<strong>读取代理对象的原型时</strong>触发该操作，比如在执行 <code>Object.getPrototypeOf(proxy)</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.setPrototypeOf(target, prototype)</code></td><td style="text-align:center">在<strong>设置代理对象的原型时</strong>触发该操作，比如在执行 <code>Object.setPrototypeOf(proxy, null)</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.isExtensible(target)</code></td><td style="text-align:center">在判断一个<strong>代理对象是否是可扩展时</strong>触发该操作，比如在执行 <code>Object.isExtensible(proxy)</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.preventExtensions(target)</code></td><td style="text-align:center">在让一个<strong>代理对象不可扩展时</strong>触发该操作，比如在执行 <code>Object.preventExtensions(proxy)</code> 时。</td></tr><tr><td style="text-align:center"><code>handler.apply(target, thisArg, argumentsList)</code></td><td style="text-align:center">拦截 <strong>Proxy 实例作为函数调用</strong>的操作，比如<code>proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)</code>。</td></tr><tr><td style="text-align:center"><code>handler.ownKeys(target)</code></td><td style="text-align:center">拦截<code>Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in</code>循环，<strong>返回一个数组</strong>。该方法返回目标对象<strong>所有自身的属性的属性名</strong>，而Object.keys()的返回结果仅包括<strong>目标对象自身的可遍历属性</strong>。</td></tr><tr><td style="text-align:center"><code>handler.construct(target, argumentsList, newTarget)</code></td><td style="text-align:center">拦截 <strong>Proxy 实例作为构造函数调用</strong>的操作，比如<code>new proxy(...args)</code>。</td></tr></tbody></table><!-- - `handler.getPrototypeOf(target)`: 在**读取代理对象的原型时**触发该操作，比如在执行 `Object.getPrototypeOf(proxy)` 时。 --><!-- - `handler.setPrototypeOf(target, prototype)`: 在**设置代理对象的原型时**触发该操作，比如在执行 `Object.setPrototypeOf(proxy, null)` 时。 --><!-- - `handler.isExtensible(target)`: 在判断一个**代理对象是否是可扩展时**触发该操作，比如在执行 `Object.isExtensible(proxy)` 时。 --><!-- - `handler.preventExtensions(target)`: 在让一个**代理对象不可扩展时**触发该操作，比如在执行 `Object.preventExtensions(proxy)` 时。 --><!-- - `handler.apply(target, thisArg, argumentsList)`: 拦截 **Proxy 实例作为函数调用**的操作，比如`proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)`。 --><!-- - `handler.ownKeys(target)`: 拦截`Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in`循环，**返回一个数组**。该方法返回目标对象**所有自身的属性的属性名**，而Object.keys()的返回结果仅包括**目标对象自身的可遍历属性**。- `handler.construct(target, argumentsList, newTarget)`: 拦截 **Proxy 实例作为构造函数调用**的操作，比如`new proxy(...args)`。 --><p>可以看到<code>Proxy</code>的拦截方法上就比<code>Object.defineProperty</code>的配置多很多，并且在最近的浏览器支持中也是各大浏览器上对<code>Proxy</code>大理支持，优化性能等等。</p><h2 id="代理对象自身属性操作拦截"><a href="#代理对象自身属性操作拦截" class="headerlink" title="代理对象自身属性操作拦截"></a>代理对象自身属性操作拦截</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(target, property, receiver)</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为<strong>目标对象</strong>、<strong>属性名</strong>和 <strong>proxy 实例本身</strong>（<em>严格地说，是操作行为所针对的对象</em>），其中最后一个参数可选。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get: name'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'dangdang'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name;</span><br><span class="line"><span class="comment">// get: name</span></span><br><span class="line"><span class="comment">// dangdang</span></span><br></pre></td></tr></table></figure><p>只要通过<code>proxy.xxx</code>访问了<code>proxy</code>上面的属性，就会触发<code>proxy</code>上配置的<code>get</code>拦截方法。<br>上面这个实例是最简单的实例，其实它可以做很多的事情，举几个例子：</p><ul><li>实现数组读取负数的索引。</li><li>链式操作。</li><li>一个生成各种 DOM 节点的通用函数dom。</li></ul><h4 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h4><p>该方法会拦截目标对象的以下操作:</p><ul><li><strong>访问属性: proxy[foo]和 proxy.bar</strong></li><li><strong>访问原型链上的属性: Object.create(proxy)[foo]</strong></li><li><strong>Reflect.get()</strong></li></ul><h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul><li><strong>get方法可以继承</strong>。</li><li><strong>get第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</strong></li><li><strong>一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</strong></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set(target, property, value, receiver)</code>方法用来拦截某个属性的<strong>赋值</strong>操作，可以接受四个参数，依次为<strong>目标对象</strong>、<strong>属性名</strong>、<strong>属性值</strong>和 <strong>Proxy 实例本身</strong>，其中<strong>最后一个参数可选</strong>。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function (target, property, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'set: dangdang'</span>);</span><br><span class="line">      target[property] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">'dangdang'</span>;</span><br><span class="line"><span class="comment">// set: dangdang</span></span><br><span class="line">proxy.name; <span class="comment">// dangdang</span></span><br></pre></td></tr></table></figure><p>只要给<code>proxy</code>的任意属性赋值，就会触发<code>proxy</code>上配置的<code>set</code>拦截方法。<br>当然这个实例是最简单的使用方式，还有其他的用法，举例如下：</p><ul><li>校验属性是否符合格式（表单验证validation）</li><li>统计函数调用次数</li><li>配合get设置内部私有属性</li></ul><h4 id="拦截-1"><a href="#拦截-1" class="headerlink" title="拦截"></a>拦截</h4><p>该方法会拦截目标对象的以下操作:</p><ul><li><strong>指定属性值: proxy[foo] = bar 和 proxy.foo = bar</strong></li><li><strong>指定继承者的属性值: Object.create(proxy)[foo] = bar</strong></li><li><strong>Reflect.set()</strong></li></ul><h4 id="其他特性-1"><a href="#其他特性-1" class="headerlink" title="其他特性"></a>其他特性</h4><ul><li><strong>get第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</strong></li><li><strong>若目标属性是不可写及不可配置的，则不能改变它的值。</strong></li><li><strong>在严格模式下，若set方法返回false，则会抛出一个 TypeError 异常。</strong></li></ul><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has(target, prop)</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。<br><code>has(target, prop)</code>方法可以接受两个参数，分别是<strong>目标对象</strong>、<strong>需查询的属性名</strong>。</p><p><strong>返回值</strong></p><p><code>has()</code> 方法返回一个 <code>boolean</code> 属性的值.</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  has: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> proxy; <span class="comment">// true</span></span><br><span class="line"><span class="string">'age'</span> <span class="keyword">in</span> proxy; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>设置<code>has(&#39;name&#39;)</code>返回<code>true</code>再通过<code>in</code>检测时返回<code>true</code>，设置<code>has(&#39;age&#39;)</code>返回<code>false</code>再通过<code>in</code>检测时返回<code>false</code>。<br>当然这个实例是最简单的使用方式，还有其他的用法，举例如下：</p><ul><li>可以做私有属性</li></ul><h4 id="拦截-2"><a href="#拦截-2" class="headerlink" title="拦截"></a>拦截</h4><p>这个钩子可以拦截下面这些操作:</p><ul><li><strong>属性查询: foo in proxy</strong></li><li><strong>继承属性查询: foo in Object.create(proxy)</strong></li><li><strong>with 检查: with(proxy) { (foo); }</strong></li><li><strong>Reflect.has()</strong></li></ul><h4 id="其他特性-2"><a href="#其他特性-2" class="headerlink" title="其他特性"></a>其他特性</h4><ul><li><strong>如果目标对象的某一属性本身不可被配置，则该属性不能够被代理隐藏。会抛出TypeError。</strong></li><li><strong>如果目标对象为不可扩展对象，则该对象的属性不能够被代理隐藏。会抛出TypeError。</strong></li><li><strong>has（）方法不判断一个属性是对象自身的属性，还是继承的属性。</strong></li><li><strong>has（）拦截对for…in循环不生效。</strong></li></ul><h3 id="defineProperty（）"><a href="#defineProperty（）" class="headerlink" title="defineProperty（）"></a>defineProperty（）</h3><p><code>defineProperty(target, property, descriptor)</code>方法拦截了<code>Object.defineProperty</code>操作。<br>参数这里就不多做介绍了和<strong>Object.defineProperty</strong>相同，主要关注一下返回值。</p><p><strong>返回值</strong></p><p><code>defineProperty</code> 方法必须以一个 <code>Boolean</code> 返回，表示定义该属性的操作成功与否。</p><p><strong>注意</strong></p><ul><li>如果目标对象<strong>不可扩展</strong>， 将<strong>不能添加</strong>属性。</li><li>不能添加或者修改一个属性为不可配置的，如果它不作为一个目标对象的不可配置的属性存在的话。</li><li>如果目标对象存在一个对应的可配置属性，这个属性可能不会是不可配置的。</li><li>如果一个属性在目标对象中存在对应的属性，那么 <code>Object.defineProperty(target, prop, descriptor)</code> 将不会抛出异常。</li><li>在严格模式下， <code>false</code> 作为 <code>handler.defineProperty</code> 方法的返回值的话将会抛出 <code>TypeError</code> 异常.</li></ul><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty(target, property)</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p><p><strong>返回值</strong></p><p><code>deleteProperty</code> 必须返回一个 <code>Boolean</code> 类型的值，表示了该属性是否被成功删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  deleteProperty: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> proxy.name; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> proxy.age; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>目标对象自身的<strong>不可配置（configurable）的属性</strong>，<strong>不能</strong>被<code>deleteProperty</code>方法删除，否则报错。</li></ul><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个<strong>属性描述对象</strong>或者<code>undefined</code>。</p><p><strong>返回值</strong></p><p><code>getOwnPropertyDescriptor</code> 方法必须返回一个 <code>object</code> 或 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  getOwnPropertyDescriptor: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, property);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'name'</span>); <span class="comment">// &#123;value: "dangdang", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'age'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="代理对象自身操作拦截"><a href="#代理对象自身操作拦截" class="headerlink" title="代理对象自身操作拦截"></a>代理对象自身操作拦截</h2><h3 id="getPrototypeOf-setPrototypeOf"><a href="#getPrototypeOf-setPrototypeOf" class="headerlink" title="getPrototypeOf()/setPrototypeOf()"></a>getPrototypeOf()/setPrototypeOf()</h3><p><strong>原型相关的操作拦截</strong></p><h4 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h4><p><code>getPrototypeOf(target)</code>方法主要用来拦截<strong>获取对象原型</strong>。具体来说，拦截下面这些操作。</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul><p><strong>返回值</strong></p><p><code>getPrototypeOf</code> 方法的返回值必须是<strong>一个对象</strong>或者 <code>null</code>。</p><h4 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h4><p><code>setPrototypeOf(target, obj)</code> 方法主要用来拦截 <code>Object.setPrototypeOf(target, obj)</code>。</p><p><strong>返回值</strong></p><p>如果成功修改了<code>[[Prototype]]</code>, <code>setPrototypeOf</code> 方法返回 <code>true</code>,否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>如果目标对象不可扩展<code>（non-extensible）</code>，<code>setPrototypeOf</code>方法不得改变目标对象的原型。</p><h3 id="preventExtensions-isExtensible"><a href="#preventExtensions-isExtensible" class="headerlink" title="preventExtensions/isExtensible"></a>preventExtensions/isExtensible</h3><p><strong>扩展配置拦截操作</strong></p><h4 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h4><p><code>preventExtensions(target)</code> 方法用于设置对<code>Object.preventExtensions()</code>的拦截。</p><p><strong>返回</strong></p><p><code>preventExtensions</code> 必须返回一个布尔值，否则会被自动转为布尔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy); <span class="comment">// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy1); <span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>如果<code>Object.isExtensible(proxy)</code>是<code>false</code>，<code>Object.preventExtensions(proxy)</code>只能返回<code>true</code>。</p><h4 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h4><p><code>isExtensible(target)</code> 方法用于拦截对对象的<code>Object.isExtensible()</code>。</p><p><strong>返回值</strong></p><p><code>isExtensible</code>方法必须返回一个 <code>Boolean</code>值或可转换成<code>Boolean</code>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//也可以return 1;等表示为true的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(p)); <span class="comment">// "called"</span></span><br><span class="line">                                     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//return 0;return NaN等都会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p); <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code>Object.isExtensible(proxy)</code> 必须同<code>Object.isExtensible(target)</code>返回相同值。也就是必须返回<code>true</code>或者为<code>true</code>的值,返回<code>false</code>和为<code>false</code>的值都会报错。</p><h3 id="apply-construct"><a href="#apply-construct" class="headerlink" title="apply/construct"></a>apply/construct</h3><p><strong>改变this方式</strong></p><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p><code>apply(target, thisArg, argumentsList)</code> 方法用于拦截<strong>函数的调用</strong>、<code>Reflect.apply</code>、<code>call</code>和<code>apply</code>操作。<br><code>apply</code>方法可以接受三个参数，分别是<strong>目标对象</strong>、<strong>被调用时的上下文对象</strong>和<strong>被调用时的参数数组</strong>数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params">target, thisArg, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called:'</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> argumentsList[<span class="number">0</span>] + argumentsList[<span class="number">1</span>] + argumentsList[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code>target</code>必须是可被调用的。也就是说，它<strong>必须是一个函数对象</strong>。</p><h4 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h4><p><code>construct(target, argumentsList, newTarget)</code> 方法用于拦截<code>new</code> 操作符. 为了使<code>new</code>操作符在生成的<code>Proxy</code>对象上生效，用于初始化代理的目标对象自身必须具有<code>[[Construct]]</code>内部方法（即 <code>new targe</code>t 必须是有效的）。</p><p><strong>参数</strong></p><ul><li><code>target</code>：目标对象</li><li><code>args</code>：构造函数的参数对象</li><li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的p）</li></ul><p><strong>返回值</strong></p><p><code>construct</code> 方法<strong>必须返回一个对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, argumentsList, newTarget</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called: '</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: argumentsList[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> p(<span class="number">1</span>).value); <span class="comment">// "called: 1"</span></span><br><span class="line">                            <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p><code>ownKeys(target)</code> 方法用于拦截 <code>Reflect.ownKeys()</code>。</p><p><strong>返回值</strong></p><p><code>ownKeys</code> 方法必须返回<strong>一个可枚举对象</strong>。</p><h4 id="拦截-3"><a href="#拦截-3" class="headerlink" title="拦截"></a>拦截</h4><p>该拦截器可以拦截以下操作:</p><ul><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>Reflect.ownKeys()</code></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果违反了下面的约束，<code>proxy</code>将抛出错误 <code>TypeError</code>:</p><ul><li><code>ownKeys</code> 的结果必须是一个数组.</li><li>数组的元素类型要么是一个 <code>String</code> ，要么是一个 <code>Symbol</code>.</li><li>结果列表必须包含目标对象的所有不可配置<code>（non-configurable ）</code>、自有（<code>own</code>）属性的key.</li><li>如果目标对象不可扩展，那么结果列表必须包含目标对象的所有自有（<code>own</code>）属性的<code>key</code>，不能有其它值。</li></ul><h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable"></a>Proxy.revocable</h2><p><code>Proxy.revocable</code>方法返回一个可取消的 <code>Proxy</code> 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p><p><strong>注意</strong></p><p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 <code>Proxy</code> 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 <code>Proxy</code> 代理的情况下，目标对象内部的<code>this</code>关键字会指向 <code>Proxy</code> 代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() <span class="comment">// false</span></span><br><span class="line">proxy.m()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，一旦<code>proxy</code>代理<code>target.m</code>，后者内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p><p>下面是一个例子，由于<code>this</code>指向的变化，导致 <code>Proxy</code> 无法代理目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name <span class="comment">// 'Jane'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p><p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 <code>Proxy</code> 也无法代理这些原生对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getDate</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章记录了<code>Proxy</code>相关的的一些<code>属性访问的方法</code>，它有<strong>13</strong>种方法，大致分为两类：一类<strong>代理对象<code>自身属性</code>操作拦截</strong>，另一类<strong>代理对象<code>自身</code>操作拦截</strong>。</p><p>下一篇文章对比<code>defineProterty</code>和<code>Proxy</code>之间的优缺点，用它们实现简单的双线绑定。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">mdn Proxy</a><br><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">阮一峰 Proxy</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Object.defineProperty和Proxy分别是什么，它们之间的优缺点，实现简单的双向绑定。
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>ES系列 ———— Object.defineProperty</title>
    <link href="http://asyncnode.com/blog/es6/es6-definedproperty.html"/>
    <id>http://asyncnode.com/blog/es6/es6-definedproperty.html</id>
    <published>2019-09-10T06:23:54.000Z</published>
    <updated>2019-10-24T05:12:36.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/blog/es6/es6-definedproperty.html">ES系列 Object.defineProperty</a><br><a href="/blog/es6/es6-proxy.html">ES系列 Proxy</a><br><a href="/blog/es6/es6-definedproperty-proxy.html">ES系列 Object.defineProperty和Proxy的对比</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果用过<code>VUE</code>框架的话都听说过他的数据观测在<strong>2.x</strong>是是通过<code>Object.defineProperty</code>实现的，其实就是把普通的对象变为<strong>响应式对象</strong>，但是在最近<strong>3.x</strong>中作者要通过<strong>Proxy</strong>重写<code>Vue</code>中的双向绑定核心的<strong>响应式对象</strong>实现，在本篇文章中逐渐了解<code>Object.defineProperty</code>和<code>Proxy</code>是什么，它们之间的区别是什么，和它们之间的有缺点。</p><p>如果想了解<code>Vue</code>中的双向对象的实现，请看本站中的<strong>Vue响应式对象</strong>、<strong>依赖收集</strong>、<strong>派发更新</strong>等等<strong>Vue源码文章</strong>。</p><p>本文章目录：</p><ul><li><code>Object.defineProperty</code>使用简介</li><li><code>Proxy</code>使用简介</li><li><code>Object.defineProperty</code>和<code>Proxy</code>之间的区别和优缺点</li><li>为什么<code>Vue</code>要重写核心的数据观测实现</li><li><code>Object.defineProperty</code>和<code>Proxy</code>实现简单的双向绑定</li></ul><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p><strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.6" target="_blank" rel="noopener">ES5</a></strong> 提供了 <code>Object.defineProperty</code> 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>可以通过<code>Object.defineProperty(obj, prop, descriptor)</code>使用，三个参数分别代表：</p><ul><li><code>obj(Object)</code>: 要在其上定义属性的对象。</li><li><code>prop(String)</code>: 要定义或修改的属性的名称。</li><li><code>descriptor(Object)</code>: 将被定义或修改的属性描述符。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明example并且赋值一个对象字面量</span></span><br><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="comment">// 通过Object.defineProperty 定义一个新的属性count，并且给他赋值为一个value</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出example.count的值</span></span><br><span class="line">example.count; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符和存取描述符</strong>。</p><p><strong>数据描述符和存取描述符均具有</strong>以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下)：</p><ul><li><code>configurable(Boolean)</code>: 当且仅当该属性的 <code>configurable</code> 为 <code>true</code> 时，该属性<strong>描述符</strong>才能够被改变，同时该属性也能从对应的对象上被删除。<strong>默认为 false</strong>。</li><li><code>enumerable(Boolean)</code>: 当且仅当该属性的<code>enumerable</code>为<code>true</code>时，该属性才能够出现在对象的枚举属性中。<strong>默认为 false</strong>。</li></ul><p><strong>数据描述符同时具有以下可选键值：</strong></p><ul><li><code>value(任意有效的Javascript值)</code>： 该属性对应的值。<strong>默认为 undefined</strong>。</li><li><code>writable(Boolean)</code>: 当且仅当该属性的<code>writable</code>为<code>true</code>时，<code>value</code>才能被赋值运算符改变。<strong>默认为 false</strong>。</li></ul><p><strong>存取描述符同时具有以下可选键值：</strong></p><ul><li><code>get(Function 匿名函数)</code>：一个给属性提供 <code>getter</code> 的方法，如果没有 <code>getter</code> 则为 <code>undefined</code>。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入<strong>this</strong>对象（由于继承关系，这里的<strong>this</strong>并不一定是定义该属性的对象）。<strong>默认为 <code>undefined</code></strong>。</li><li><code>set(Function 匿名函数)</code>: 一个给属性提供 <code>setter</code> 的方法，如果没有 <code>setter</code> 则为 <code>undefined</code>。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。<strong>默认为 <code>undefined</code></strong>。</li></ul><p><strong>描述符可同时具有的键值</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>configurable</strong></th><th style="text-align:center"><strong>enumerable</strong></th><th style="text-align:center"><strong>value</strong></th><th style="text-align:center"><strong>writable</strong></th><th style="text-align:center"><strong>get</strong></th><th><strong>set</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>数据描述符</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>No</strong></td><td><strong>No</strong></td></tr><tr><td style="text-align:center"><strong>存取描述符</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>Yes</strong></td><td style="text-align:center"><strong>No</strong></td><td style="text-align:center"><strong>No</strong></td><td style="text-align:center"><strong>Yes</strong></td><td><strong>Yes</strong></td></tr></tbody></table><blockquote><p>注意事项： 如果一个描述符同时有(<code>value</code>或<code>writable</code>)和(<code>get</code>或<code>set</code>)关键字，将会产生一个异常。</p></blockquote><p>下面一个一个描述符来通过实例来看一下它真正的效果。</p><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当设置了<code>configurable</code>为<code>false</code>时，就不能在通过<code>defineProperty</code>设置属性描述了。当前的属性不能<strong>删除</strong>、<strong>修改</strong>、<strong>枚举</strong>等。下面请看实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">example.count = <span class="number">2</span>;</span><br><span class="line">example.count; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> example.count;</span><br><span class="line">example.count; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> example) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  wirtable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: count</span></span><br></pre></td></tr></table></figure><h3 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h3><p>当设置<code>Enumerable</code>为<code>false</code>时，当前这个属性不能被<code>for...in</code>和<code>Object.keys()</code>枚举。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当设置<code>writable</code>为<code>false</code>时，写入非可写属性<strong>不会改变它</strong>，也<strong>不会</strong>引发错误。</p><h3 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h3><p><code>get</code> 和 <code>set</code>两个方法在上面是存取属性描述，这两个方法又被称为<code>getter</code>和<code>setter</code>。可以简称为<strong>存取器属性</strong>。</p><p>当配置了<code>get</code>和<code>set</code>，就不能配置<code>value</code>和<code>writable</code>因为它们是互斥的，只能设置其中的一组。</p><p>当想获取一个属性的值时就会触发设置的<code>get</code>方法，当给一个属性赋值时就会触发<code>set</code>属性。</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;, value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProterty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了 get 操作'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了 set 操作'</span>)</span><br><span class="line">    value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">example.count = <span class="number">1</span>; <span class="comment">// 执行了 set 操作</span></span><br><span class="line">example.count; <span class="comment">// 1 执行了 get 操作</span></span><br></pre></td></tr></table></figure><h2 id="其它Object-defineProperty相关"><a href="#其它Object-defineProperty相关" class="headerlink" title="其它Object.defineProperty相关"></a>其它Object.defineProperty相关</h2><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h3><p><code>Object.defineProperties()</code>可以同时设置多个<code>Object.defineProperty</code>。</p><p><code>Object.defineProperties(obj, props)</code> 方法直接在一个对象上定义新的属性或修改现有属性，并<strong>返回</strong>该对象。参数如下：</p><ul><li><code>obj(Object)</code>: 在其上定义或修改属性的对象。</li><li><code>props(Object)</code>: 一个对象包含多个<strong>属性名:descriptor</strong></li></ul><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(example, &#123;</span><br><span class="line">  <span class="string">'count1'</span>: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'count2'</span>: &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h3><p><code>Object.getOwnPropertyNames(Object)</code>方法返回一个由指定对象的<strong>所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组</strong>。</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123; <span class="attr">num</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(example, &#123;</span><br><span class="line">  <span class="string">'count1'</span>: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'count2'</span>: &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(example); <span class="comment">//  ["num", "count1", "count2"]</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h3><p><code>Object.getOwnPropertyDescriptor(obj, prop)</code> 方法返回指定对象上一个<strong>自有属性对应的属性描述符</strong>。<strong>（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</strong>。参数如下：</p><ul><li><code>obj(Object)</code>: 需要查找的目标对象</li><li><code>prop(String)</code>： 目标对象内属性名称</li></ul><p><strong>返回值</strong><br>如果指定的属性存在于对象上，则返回其属性描述符对象<code>（property descriptor）</code>，否则返回 <code>undefined</code>。</p><blockquote><p>在 <strong>ES5</strong> 中，如果该方法的第一个参数不是对象（而是原始类型），那么就会产生出现 <code>TypeError</code>。而在 <strong>ES2015</strong>，第一个的参数不是对象的话就会<strong>被强制转换为对象</strong>。</p></blockquote><h2 id="冻结相关的"><a href="#冻结相关的" class="headerlink" title="冻结相关的"></a>冻结相关的</h2><h3 id="Object-defineProperty冻结"><a href="#Object-defineProperty冻结" class="headerlink" title="Object.defineProperty冻结"></a>Object.defineProperty冻结</h3><p>当<code>Object.defineProperty(obj, name, { value: 1 })</code>这样设置实，当前属性的<strong>writable</strong>、<strong>configurable</strong>、<strong>enumerable</strong>、都默认为<code>false</code>，可以把当前这个<strong>对象属性</strong>看做是一个冻结对象，那这个对象属性是<strong>深冻结还是浅冻结</strong>呢？</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: &#123;</span><br><span class="line">    num: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line">example.count = <span class="number">2</span>;</span><br><span class="line">example.count; <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line"><span class="comment">// 修改属性下的属性</span></span><br><span class="line">example.count.num = <span class="number">3</span>;</span><br><span class="line">example.count; <span class="comment">// &#123;num: 3&#125;</span></span><br></pre></td></tr></table></figure><p>通过上面的实例可以判定<code>defineProperty</code>冻结的对象属性，是<strong>浅冻结</strong>对象，如果是<strong>引用类型</strong>是可以修改的。如果想实现<strong>深层冻结</strong>，就需要递归对象所有的属性设置<code>Object.defineProperty()</code>。</p><h3 id="Object-freeze冻结"><a href="#Object-freeze冻结" class="headerlink" title="Object.freeze冻结"></a>Object.freeze冻结</h3><p><code>Object.freeze(obj)</code> 方法可以冻结一个对象。参数如下：</p><ul><li><code>obj(Object)</code>: 要被冻结的对象。</li></ul><p>一个被冻结的对象再也<strong>不能被修改</strong>；<br>冻结了一个对象则<strong>不能</strong>向这个对象<strong>添加新的属性</strong>，<strong>不能删除已有属性</strong>，不能修改该对象已有属性的<strong>可枚举性</strong>、<strong>可配置性</strong>、<strong>可写性</strong>，以及不能修改已有属性的值。此外，冻结一个对象后该对象的<strong>原型也不能被修改</strong>。<strong>freeze() 返回和传入的参数相同的对象</strong>。</p><p><strong>返回值</strong></p><p>被冻结的对象。</p><p><strong>实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;</span><br><span class="line">  count: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  num: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(example);</span><br><span class="line"><span class="comment">// 修改值类型无效</span></span><br><span class="line">example.num = <span class="number">11</span>;</span><br><span class="line">example.num; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改引用类型生效</span></span><br><span class="line">example.count[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">example.count; <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图通过 Object.defineProperty 更改属性 抛出 TypeError.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'num'</span>, &#123; <span class="attr">value</span>: <span class="number">11</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也不能更改原型 会抛出 TypeError.</span></span><br><span class="line">example.__proto__ = &#123; <span class="attr">x</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(example, &#123; <span class="attr">x</span>: <span class="number">20</span> &#125;)</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出<code>Object.freeze()</code>也是<strong>浅冻结</strong>，如果冻结的对象有多层引用类型嵌套，子属性是可以修改的。如果想实现<strong>深层冻结</strong>，就需要递归对象所有的属性设置<code>Object.freeze()</code>。</p><h4 id="冻结数组"><a href="#冻结数组" class="headerlink" title="冻结数组"></a>冻结数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>];</span><br><span class="line"><span class="built_in">Object</span>.freeze(a); <span class="comment">// 现在数组不能被修改了.</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// fails silently</span></span><br><span class="line">a.push(<span class="number">2</span>); <span class="comment">// fails silently</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In strict mode such attempts will throw TypeErrors</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  a.push(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fail();</span><br></pre></td></tr></table></figure><h4 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen"></a>Object.isFrozen</h4><p><code>Object.isFrozen(obj)</code>方法判断一个对象是否被冻结。参数如下：</p><ul><li><code>obj(Object)</code>: 被检测的对象。</li></ul><p><strong>返回值</strong></p><p>表示给定对象是否被冻结的<code>Boolean</code>。</p><blockquote><p><strong>在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常</strong>。<br><strong>在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isFrozen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isFrozen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// true                          (ES2015 code)</span></span><br></pre></td></tr></table></figure><h4 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal"></a>Object.seal</h4><p><code>Object.seal(obj)</code>方法封闭一个对象，<strong>阻止添加新属性并将所有现有属性标记为不可配置</strong>。<strong>当前属性的值只要可写就可以改变</strong>。</p><ul><li><code>obj(Object)</code>: 将要被密封的对象。</li></ul><p><strong>返回值</strong></p><p>被密封的对象。</p><blockquote><p><strong>在ES5中，如果这个方法的参数不是一个（原始）对象，那么它将导致TypeError</strong>。<br><strong>在ES2015中，非对象参数将被视为已被密封的普通对象，会直接返回它</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1                             (ES2015 code)</span></span><br></pre></td></tr></table></figure><p>它其他的表现适合<code>Object.freeze</code>是一致的。</p><h3 id="实现一个深度冻结"><a href="#实现一个深度冻结" class="headerlink" title="实现一个深度冻结"></a>实现一个深度冻结</h3><p>这里只实现一个简单的<strong>深度冻结</strong>方法，一些<strong>循环引用</strong>、<strong>特殊类型</strong>没有考虑在内，实现如下：</p><ul><li>递归对象属性，调用冻结方法</li><li>返回冻结完成的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFreeze</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arguments is not object'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> propertyName = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">  propertyName.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[item] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj[item] !== <span class="string">'null'</span>) &#123;</span><br><span class="line">      deepFreeze(obj[item]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> example = deepFreeze(&#123;<span class="attr">example</span>: &#123; <span class="attr">name</span>: <span class="string">'admin'</span> &#125;&#125;);</span><br><span class="line">example.example.name = <span class="number">1</span>;</span><br><span class="line">example.example; <span class="comment">// &#123;name: "admin"&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>因为当前文章写得太长了，所以拆分为三篇博客。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">mdn Object.defineProperty()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">mdn Object.defineProperties()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">mdn Object.freeze()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener">mdn Object.seal()</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Object.defineProperty和Proxy分别是什么，它们之间的优缺点，实现简单的双向绑定。
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>用webpack写一个vue单页面的脚手架</title>
    <link href="http://asyncnode.com/blog/webpack/webpack-cli-sap.html"/>
    <id>http://asyncnode.com/blog/webpack/webpack-cli-sap.html</id>
    <published>2019-09-01T02:23:23.000Z</published>
    <updated>2019-10-24T05:12:36.967Z</updated>
    
    <summary type="html">
    
      用webpack写一个vue单页面的脚手架，后面还会有多页面、ssr配置。
    
    </summary>
    
      <category term="WebPack" scheme="http://asyncnode.com/categories/WebPack/"/>
    
    
      <category term="WebPack" scheme="http://asyncnode.com/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>深入Vue系列 ———— Vue中v-model解析、sync修饰符解析</title>
    <link href="http://asyncnode.com/blog/vue/vue-vModel-sync.html"/>
    <id>http://asyncnode.com/blog/vue/vue-vModel-sync.html</id>
    <published>2019-08-29T12:22:18.000Z</published>
    <updated>2019-10-24T05:12:36.967Z</updated>
    
    <content type="html"><![CDATA[<p><em>上善若水，水善利萬物而不爭。——《道德經》</em></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>在平时开发是经常用到一些父子组件通信，经常用到<code>props</code>、<code>vuex</code>等等，这里面记录另外的三种方式<code>v-model</code>、<code>sync</code>是怎么使用，再说是怎么实现，其实<code>v-model</code>、<code>sync</code>都是语法糖。还有<code>$attr</code>、<code>$listener</code>实现父子组件通信。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><hr><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><blockquote><p>2.2.0+ 新增</p></blockquote><p><code>v-mode1</code>其实就是一个语法糖，默认会利用名为<code>value</code>的<code>props</code>和名为<code>input</code>的事件，但是像单选框、复选框等类型的输入龙剑可能会讲<code>value</code>特性用于不同的目的。</p><p><code>v-model</code>的使用场景：当<strong>子组件</strong>需要改变父组件通过<code>props</code>传入的值</p><p><strong><em>父组件</em></strong></p><ul><li>父组件通过<code>v-model</code>绑定值</li><li>如需根据<code>v-model</code>传入的值改变，而触发其他更新请通过<code>watch</code>传入的值</li></ul><p><strong><em>子组件</em></strong></p><ul><li>声明<code>model</code>对象 设置事件<code>event</code>和<code>prop</code>字段</li><li>通过<code>porps</code>接受父组件传送值</li><li>修改是通过<code>this.$emit</code>广播事件</li></ul><p>代码示例：</p><p><strong><em>父组件代码</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;children v-model=<span class="string">"message"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import children from "./</span>children.vue<span class="string">";</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    children</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      message: "</span>parent<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  watch: &#123;</span></span><br><span class="line"><span class="string">    // 监听message变化</span></span><br><span class="line"><span class="string">    message(newV, oldV) &#123;</span></span><br><span class="line"><span class="string">      console.log(newV, oldV);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>子组件代码</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">"message"</span>, <span class="comment">//这个字段，是指父组件设置 v-model 时，将变量值传给子组件的 msg</span></span><br><span class="line">    event: <span class="string">"input"</span> <span class="comment">//这个字段，是指父组件监听 parent-event 事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    message: <span class="built_in">String</span> <span class="comment">//此处必须定义和model的prop相同的props，因为v-model会传值给子组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">//这里模拟异步将msg传到父组件v-model，实现双向控制</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">"input"</span>, <span class="string">"children"</span>);</span><br><span class="line">      <span class="comment">//将这个值通过 emit 触发parent-event，将some传递给父组件的v-model绑定的变量</span></span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个示例是通过<code>v-model</code>实现的，下面不通过<code>v-model</code>实现同样效果。</p><h3 id="不使用-v-model-实现"><a href="#不使用-v-model-实现" class="headerlink" title="不使用 v-model 实现"></a>不使用 v-model 实现</h3><p>代码示例如下：</p><p><strong><em>父组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Children :message=<span class="string">"message"</span> @input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 不变</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p><strong><em>子组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="comment">// 不变</span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    message: String</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit("input", "children");</span></span><br><span class="line"><span class="regexp">    &#125;, 1500);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>只是把<code>v-model</code>拆分为<code>props</code>和<code>@input</code>事件，子组件不需要配置<code>model</code>,只需要接受<code>props</code>和通过<code>this.$emit</code>广播事件就可以。<br>当然这个相对于<code>v-model</code>方法比较简便，但是灵活度查很多，选择使用那种看个人喜好。<br>在线地址：</p><iframe src="https://codesandbox.io/embed/vue-template-zcvn3?fontsize=14" title="Vue Template" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><blockquote><p>2.3.0+ 新增</p></blockquote><p>在有些情况下，我们可能需要对一个 <code>prop</code> 进行<strong><em>“双向绑定”</em></strong>。不幸的是，真正的<strong>双向绑定</strong>会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p><p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。同时也可以通过<code>sync</code>修饰符来实现。</p><p>在上面代码的基础上大致修改如下：</p><p><strong><em>父组件</em></strong></p><ul><li>通过修改触发事件<code>input</code>为<code>update:myPropName</code>实现相同效果</li></ul><p><strong><em>子组件</em></strong></p><ul><li>通过修改<code>this.$emit(update:myPropName)</code></li></ul><p>代码如下：</p><p><strong><em>父组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改如下</span></span><br><span class="line">&lt;Children :message=<span class="string">"message"</span> @update:input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><p><strong><em>子组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"update:input"</span>, <span class="string">"children"</span>);</span><br></pre></td></tr></table></figure><h3 id="sync实现"><a href="#sync实现" class="headerlink" title="sync实现"></a>sync实现</h3><p>上面的代码可以通过<code>sync</code>简写为下面代码：</p><p><strong><em>父组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改如下</span></span><br><span class="line">&lt;Children :messag.sync=<span class="string">"message"</span>/&gt;</span><br></pre></td></tr></table></figure><p><strong><em>子组件代码修改</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"update:messag"</span>, <span class="string">"children"</span>);</span><br></pre></td></tr></table></figure><p>同时<code>sync</code>也支持对象，要配合<code>v-bind</code>实现可以简写为<code>:</code>，但是要注意这个对象如下两条：</p><blockquote><p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 <code>v-model</code>。<br>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p></blockquote><h2 id="attrs、-listeners"><a href="#attrs、-listeners" class="headerlink" title="$attrs、$listeners"></a>$attrs、$listeners</h2><h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li>类型：<code>{ [key: string]: string }</code></li><li>只读</li><li>详细：<br>包含了父作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 <code>prop</code> 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</li></ul><h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li>类型：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></li><li>只读</li><li>详细：<br>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</li></ul><h3 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h3><p>实现父子组件通信</p><p><strong><em>父组件代码</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;Children</span><br><span class="line">      :message=<span class="string">"message"</span></span><br><span class="line">      @upDate=<span class="string">"upDate"</span></span><br><span class="line">      type=<span class="string">"del"</span></span><br><span class="line">      @input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span></span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Children <span class="keyword">from</span> <span class="string">"./Children"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">"parent"</span>,</span><br><span class="line">      type: <span class="string">"del"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    upDate (event) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(event);</span><br><span class="line">      <span class="keyword">this</span>.type = event;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    message: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"更新message值为"</span> + <span class="keyword">this</span>.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>子组件代码</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-bind=<span class="string">"$attrs"</span> v-on=<span class="string">"$listeners"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"children"</span>&gt;&#123;&#123;message&#125;&#125; &lt;span @click=<span class="string">"$listeners.upDate('data')"</span>&gt;&#123;&#123;$attrs.type&#125;&#125;&lt;<span class="regexp">/span&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    message: String</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.log(this.$attrs);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.log(this.$listeners);</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit("input", "children");</span></span><br><span class="line"><span class="regexp">      this.$emit('upDate', 'add')</span></span><br><span class="line"><span class="regexp">    &#125;, 1500);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>同时<code>$attrs</code>、<code>$listeners</code>都是可以跨域父子组件，可以父子子子组件传递，类似于<code>react</code>中的<code>context</code>，只是一部分设计理念相同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实就是检测到<code>.sync</code>修饰符，在<code>complier</code>阶段会编译生成多个<code>prop</code>，生成多个<code>事件</code>。其实像这个<strong>指令</strong>、<strong>修饰符</strong>、<strong>自定义指令</strong>都是在<code>vue</code>编译是解析成为<strong>v8</strong>能执行的代码。</p><p>无论是<code>vue</code>、<code>babel</code>、<code>react</code>的<code>complier</code>编译阶段大致分为三个阶段：</p><ul><li>通过词法解析<code>parse</code>生成抽象<code>AST</code>或<code>抽象代码树</code></li><li>优化<code>AST</code>,比如<code>vue</code>标记静态节点，<code>babal</code>中抽取静态代码，这个阶段被称为<code>optimize</code>或者<code>优化AST树</code></li><li>在<code>AST</code>代码的阶段上，生成可执行代码，这个过程可以叫做<code>codegen</code></li></ul><p><code>v-model</code>、<code>sync</code>都可以实现父子组件通信，并且可以在子组件中修改父组件传入的值。在平常看法的时候进场可以用到这两种方式，具体选择那种方式看个人喜好。在<code>element-ui</code>这个<code>input</code>组件也用到相关的属性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener">$attrs</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model" target="_blank" rel="noopener">自定义组件的-v-model</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-修饰符" target="_blank" rel="noopener">sync-修饰符</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Vue中v-model解析、sync修饰符解析、$attr、$listeners
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScirpt面试题 ———— 有关原型一道笔试题</title>
    <link href="http://asyncnode.com/blog/InterviewQuestion/javascript-prototype.html"/>
    <id>http://asyncnode.com/blog/InterviewQuestion/javascript-prototype.html</id>
    <published>2019-08-25T07:34:21.000Z</published>
    <updated>2019-10-24T05:12:36.935Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>慎終如始，則無敗事。——《道德經》</strong></em></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>这道面试题考察的比较综合，也有很多要注意的点，如果知道答案就没有必要往下看了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Preson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.b = [<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">this</span>.a];</span><br><span class="line">  <span class="keyword">this</span>.c = &#123; <span class="attr">demo</span>: <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, <span class="keyword">this</span>.b, <span class="keyword">this</span>.c.demo);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">this</span>.change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b.push(<span class="keyword">this</span>.a);</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="keyword">this</span>.b.length;</span><br><span class="line">    <span class="keyword">this</span>.c.demo = <span class="keyword">this</span>.a++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Preson();</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Preson();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">22</span>;</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure><h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><hr><p>这道题比较经典考察了<code>JavaScript</code>中很多方面的知识，大致如下几点：</p><ul><li>prototype 原型、原型链问题</li><li>new 改变 this 指向，new 产生实例属性和原型属性</li><li>值类型和引用类型</li><li>原型继承</li></ul><p>是一道比较综合的题前四题比较好答，后面的两题想多或者想少了都会出错。这里就对一些知识点不多做赘述，可以查看往期文章了解。<br><strong>往期文章</strong></p><blockquote><p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript 类型转换（一） 常见数据类型</a> &gt; <code>...后期添加</code></p></blockquote><h2 id="结题需要的知识点"><a href="#结题需要的知识点" class="headerlink" title="结题需要的知识点"></a>结题需要的知识点</h2><hr><p>大致的知识点如下：</p><ol><li><strong>构造函数有一个<code>prototype</code>属性指向原型对象，多个实例属性共享一个原型对象</strong></li><li><strong>实例中的属性都是独立的互相之间不会影响</strong></li><li><strong>每一个实例都有一个隐式原型<code>__proto__</code>指向构造函数的原型对象</strong></li><li><strong><code>this</code>的指向问题，大致如下：</strong></li></ol><ul><li>作为对象方法时，谁调用就指向谁</li><li><code>new</code>、<code>bind</code>、<code>call</code>、<code>apply</code>都会改变 this 的指向</li><li>箭头函数的<code>this</code>从外层普通函数获取</li></ul><ol start="5"><li><strong>对象字面量和数组都是引用对象</strong></li><li><strong>原型链的查找规则： 就近原则</strong></li></ol><ul><li>当实例上存在属性时， 用实例上的</li><li>如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的</li><li>如果原型链都不存在，就用 Object 原型对象上的</li><li>如果 Object 原型对象都不存在， 就是 undefined</li></ul><h2 id="第一问-parent-show"><a href="#第一问-parent-show" class="headerlink" title="第一问 parent.show()"></a>第一问 parent.show()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.show();</span><br></pre></td></tr></table></figure><p>调用<code>parent.show()</code>的方法，其实就是调用<code>parent</code>实例上的<code>show</code>方法，直接输出<code>1, [1, 2, 1], 5</code>;没什么太多解释的，了解<code>new</code>关键字就可以。</p><h2 id="第二问-child1-show-、child2-show"><a href="#第二问-child1-show-、child2-show" class="headerlink" title="第二问 child1.show()、child2.show()"></a>第二问 child1.show()、child2.show()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure><p>首相要了解下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Preson();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>上面代码把<code>Child.prototype</code>指向一个<code>Preson</code>的实例，可以知道<code>Child.prototype.__proto__</code>指向<code>Preson.prototype</code>;<code>Child.prototype.constructor</code>指向<code>Preson</code>。下面是验证代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype.__proto__ === Preson.prototype; <span class="comment">// true</span></span><br><span class="line">Child.prototype.constructor === Preson; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>child1</code>、<code>child2</code>的结构如下图所示：<br><img src="../../images/interviewquestion/javascript-prototype-1-1.png" alt="javascript-prototype"></p><p><code>child1</code>、<code>child2</code>都是<code>Child</code>构造函数实例化产生的，所以<code>child1.show() child2.show()</code>是调用的<code>Child.prototype</code>上的方法，但是注意<code>child1</code>、<code>child2</code>的对象上都声明了一个新属性<code>a</code>。<br>根据上面第<code>6</code>条知识点可知结果为<code>11, [1, 2, 1], 5)</code>、<code>12, [1, 2, 1], 5</code>；</p><p><strong>注意</strong><br>从代码上看<code>child1.__proto__.b</code>数组的第三项是指向<code>child1.__proto__.a</code>的，那我们此时修改<code>child1.__proto__.a</code>的值，是否会影响<code>child1.show()</code>的结果呢:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child1.__proto__.a = <span class="number">12123</span>;</span><br><span class="line">child1.show(); <span class="comment">// 11, [1, 2, 1], 5</span></span><br></pre></td></tr></table></figure><p>是没有影响的，因为<code>parent</code>实例生成的时候，<code>this.a</code>指向了一个原始值<code>2</code>,所以<code>this.b</code>中的第三项实际上是被赋值了一个<strong>原始值</strong>，故此处乍看起来像是<strong>引用类型</strong>的赋值，实则不是。<strong>原始值赋值会开辟新的存储空间</strong>，使得<code>this.a</code>和<code>this.b[2]</code>的值相等，但是却指向了堆内存里的不同地址。</p><h2 id="第三问-parent-show"><a href="#第三问-parent-show" class="headerlink" title="第三问 parent.show()"></a>第三问 parent.show()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.show();</span><br></pre></td></tr></table></figure><p>根据上面第<code>2</code>条知识点，可知<code>preson</code>和<code>Child</code>是<code>Person</code>的不同的实例，它们之间不会相互影响，所以它的经过不会更改为<code>1, [1, 2, 1], 5</code>。</p><h2 id="第四问-child1-show-、child2-show"><a href="#第四问-child1-show-、child2-show" class="headerlink" title="第四问 child1.show()、child2.show()"></a>第四问 child1.show()、child2.show()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面执行了</span></span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line"></span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure><p><code>child1.change()</code>执行了<code>change()</code>时执行过程如下：</p><p><strong><code>this.b.push(this.a)</code></strong><br>由于<code>this</code>的动态指向特性，<code>this.b</code>会指向<code>Child.prototype</code>上的<code>b</code>数组,<code>this.a</code>会指向<code>child1</code>的<code>a</code>属性,所以<code>Child.prototype.b</code>变成了<code>[1,2,1,11]</code>;</p><p><strong><code>this.a = this.b.length</code></strong><br><code>this.b.length</code>经过上一步的添加了一条数据变为了<code>4</code>，所以当前的<code>this.a</code>就是<code>4</code>。</p><p><strong><code>this.c.demo = this.a++;</code></strong><br><code>this.a</code>是<code>4</code>，<code>this.c.demo</code>的值被复制为<code>4</code>，不要忽略<code>this.a++</code>以后的值变为了<code>5</code>。</p><p><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果</p><p><code>child2.change()</code>执行了<code>change()</code>时执行过程如下：<br><strong><code>this.b.push(this.a)</code></strong><br>由于<code>this</code>的动态指向特性，<code>this.b</code>会指向<code>Child.prototype</code>上的<code>b</code>数组,<code>this.a</code>会指向<code>child2</code>的<code>a</code>属性,所以<code>Child.prototype.b</code>变成了<code>[1,2,1,11,12]</code>;</p><p><strong><code>this.a = this.b.length</code></strong><br><code>this.b.length</code>经过上一步的添加了一条数据变为了<code>5</code>，所以当前的<code>this.a</code>就是<code>5</code>。</p><p><strong><code>this.c.demo = this.a++;</code></strong><br><code>this.a</code>是<code>5</code>，<code>this.c.demo</code>的值被复制为<code>5</code>，不要忽略<code>this.a++</code>以后的值变为了<code>6</code>。</p><p>所以会输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child1.show(); <span class="comment">// 5, [1,2,1,11,12], 5</span></span><br><span class="line">child2.show(); <span class="comment">// 6, [1,2,1,11,12], 5</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>前端的所有知识都是比较零散的，所以尽量要建立自己的知识结构图才方便以后的查漏补缺</li><li>因为知识比较零散不便于记忆，最好多找几个切入点把零散的知识串联起来更容易记住</li><li>没有别的办法多写、多看、多记一遍不行就直到记住为止</li></ol><blockquote><p>值类型变量赋值给引用类型时，改变值类型变量的值并不会影响赋值给引用类型中的值，</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, test];</span><br><span class="line">test = <span class="number">2222</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4, 111];</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.cnblogs.com/dashnowords/p/9404237.html" target="_blank" rel="noopener">javascript 基础修炼(1)——一道十面埋伏的原型链面试题</a> &gt; <a href="https://www.php.cn/js-tutorial-410582.html" target="_blank" rel="noopener">javascript 原型链的一道面试题的分析（详细）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      JavaScirpt有关原型一道笔试题
    
    </summary>
    
      <category term="InterviewQuestion" scheme="http://asyncnode.com/categories/InterviewQuestion/"/>
    
    
      <category term="InterviewQuestion" scheme="http://asyncnode.com/tags/InterviewQuestion/"/>
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入element-ui组件 ———— input组件</title>
    <link href="http://asyncnode.com/blog/vue/vue-element-input.html"/>
    <id>http://asyncnode.com/blog/vue/vue-element-input.html</id>
    <published>2019-08-21T07:27:13.000Z</published>
    <updated>2019-10-24T05:12:36.964Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>察见渊鱼者不详，智料隐匿者有殃。——《列子·说符》</em></strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>在日常开发<code>PC</code>管理端界面的时候，会用到<strong>element-ui</strong>或者<strong>iview</strong>ui框架，比较常用的<code>input</code>组件是怎么封装的呢，以<code>element-ui</code>框架的<code>input</code>组件为例，分析一下它是怎么封装实现的，也可以为以后自己封装框架提供思路。</p><p>因为代码还是挺多的，主要分析几个点：</p><ul><li>支持<strong>前置内容</strong>、<strong>后置内容</strong>、<strong>后置元素</strong></li><li>支持所有原声的<code>type</code>，并且可以切换<code>password</code>模式</li><li>支持<code>readonly</code>、<code>disabled</code>、<code>autocomplete</code>、<code>maxlength</code>、<code>minlength</code>等等</li><li>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code></li><li><code>element-ui</code>是怎么做到类似与<code>vue</code>的双向绑定的</li><li><code>type</code>为<code>textare</code>模式时，做到<code>calcTextareaHeight</code></li></ul><p>下面就一步一步分下，主要的点会着重分析，比较简单或者比较不重要的点会快速带过。</p><p>源码参考<a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/input.vue" target="_blank" rel="noopener">element-ui input</a></p><h2 id="前置、后置"><a href="#前置、后置" class="headerlink" title="前置、后置"></a>前置、后置</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"type !== 'textarea'"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 前置元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"el-input-group__prepend"</span> <span class="attr">v-if</span>=<span class="string">"$slots.prepend"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"prepend"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 前置内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"el-input__prefix"</span> <span class="attr">v-if</span>=<span class="string">"$slots.prefix || prefixIcon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"prefix"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-input__icon"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-if</span>=<span class="string">"prefixIcon"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:class</span>=<span class="string">"prefixIcon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  // 主题代码 省略</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 后置内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-input__suffix"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"getSuffixVisible()"</span>&gt;</span></span><br><span class="line">    // 省略内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 后置元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"el-input-group__append"</span> <span class="attr">v-if</span>=<span class="string">"$slots.append"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"append"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  // 省略内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码可以首先通过<code>type</code>区分开<code>textarea</code>单独处理，<strong>前后置</strong>又分为两类：</p><ul><li>一类直接通过<code>prop</code>传入<code>prefix-icon</code>、<code>suffix-icon</code>传入前后置<code>icon-class</code>显示不同的内容</li><li>另一类是通过<code>vue</code>中的内容分发机制<code>slot</code>显示不同的内容，更灵活</li></ul><p>在后置内容中也会处理<code>clearable</code>、<code>PwdVisible</code>、<code>show-word-limit</code>显示不同的内容。</p><h2 id="原声type、其它原声属性"><a href="#原声type、其它原声属性" class="headerlink" title="原声type、其它原声属性"></a>原声type、其它原声属性</h2><p>以<code>input</code>为例，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 其它地方省略</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:tabindex</span>=<span class="string">"tabindex"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">"type !== 'textarea'"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind</span>=<span class="string">"$attrs"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:type</span>=<span class="string">"showPassword ? (passwordVisible ? 'text': 'password') : type"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:disabled</span>=<span class="string">"inputDisabled"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:readonly</span>=<span class="string">"readonly"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:autocomplete</span>=<span class="string">"autoComplete || autocomplete"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"input"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionstart</span>=<span class="string">"handleCompositionStart"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionupdate</span>=<span class="string">"handleCompositionUpdate"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionend</span>=<span class="string">"handleCompositionEnd"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">"handleInput"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">"handleFocus"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"handleBlur"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">change</span>=<span class="string">"handleChange"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:aria-label</span>=<span class="string">"label"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">// 其它地方省略</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 其它地方省略</span></span></span><br><span class="line"><span class="javascript">      disabled: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      readonly: <span class="built_in">Boolean</span>,</span></span><br><span class="line">      autocomplete: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">'off'</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">/** @Deprecated in next major version */</span></span></span><br><span class="line">      autoComplete: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line">        validator(val) &#123;</span><br><span class="line"><span class="javascript">          process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.warn(<span class="string">'[Element Warn][Input]\'auto-complete\' property will be deprecated in next major version. please use \'autocomplete\' instead.'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="comment">// 其它地方省略</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里先不关注事件，只关注属性的设置，<code>element-ui</code>支持所有<code>input</code>原声的属性，其实就是通过<code>prop</code>传入<code>type</code>传入，如果是非<code>password</code>就直接赋值给<code>input</code>标签的<code>type</code>属性。<br>如果是<code>password</code>类型判断是否传入<code>show-password</code>字段，根据传入判断给<code>input</code>的<code>type</code>复制为<code>password</code>或者<code>text</code>。</p><h2 id="其它原声属性"><a href="#其它原声属性" class="headerlink" title="其它原声属性"></a>其它原声属性</h2><p>其它属性如<code>disabled</code>、<code>readonly</code>、<code>autocomplete</code>都是通过显示的<code>prop</code>传入，哪像一些没有显示接受的<code>prop</code>怎么获取到的呢，比如说<code>maxlength</code>、<code>minlength</code>这种没有显示接收的怎么获取到的呢。<br>是通过<code>v-bind=&quot;$attrs&quot;</code>获取到的，使用的时候直接通过<code>this.$attrs.XXXX</code>就可以使用对应的属性。<code>element-ui</code>中在检测输入长度是否超过设置的长度是有使用到如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略部分代码</span></span><br><span class="line">isWordLimitVisible() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.showWordLimit &amp;&amp;</span><br><span class="line">    <span class="keyword">this</span>.$attrs.maxlength &amp;&amp;</span><br><span class="line">    (<span class="keyword">this</span>.type === <span class="string">'text'</span> || <span class="keyword">this</span>.type === <span class="string">'textarea'</span>) &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.inputDisabled &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.readonly &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.showPassword;</span><br><span class="line">&#125;,</span><br><span class="line">upperLimit() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$attrs.maxlength;</span><br><span class="line">&#125;,</span><br><span class="line">textLength() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.value === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(<span class="keyword">this</span>.value).length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value || <span class="string">''</span>).length;</span><br><span class="line">&#125;,</span><br><span class="line">inputExceed() &#123;</span><br><span class="line">  <span class="comment">// show exceed style if length of initial value greater then maxlength</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isWordLimitVisible &amp;&amp;</span><br><span class="line">    (<span class="keyword">this</span>.textLength &gt; <span class="keyword">this</span>.upperLimit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 忽略部分代码</span></span><br></pre></td></tr></table></figure><p>如果不太了解<code>v-bind=&quot;$attrs&quot;</code>的使用可以看我另一篇文章<a href="/blog/vue/vue-vModel-sync.html">Vue中v-model解析、sync修饰符解析</a></p><h2 id="原声事件、双向绑定"><a href="#原声事件、双向绑定" class="headerlink" title="原声事件、双向绑定"></a>原声事件、双向绑定</h2><p>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code>。</p><p>常用的时间就不用多做介绍了，就是比较新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code>是用来出里一段文字输入的事件。详细信息请看：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart" target="_blank" rel="noopener">compositionstart</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionupdate" target="_blank" rel="noopener">compositionupdate</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionend" target="_blank" rel="noopener">compositionend</a></p><p>在外层就可以监听的到<code>input</code>标签的<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>事件，是因为组件内部在每一个方法中都有一个<code>this.$emit(&#39;input/focus/blur/change&#39;, evnet.target.value/event)</code>。</p><p>那是怎么做到修改外层通过<code>v-model</code>绑定的值的呢？</p><p>要想了解他是怎么实现双向绑定的就要了解<code>v-model</code>是什么，<code>v-model</code>其实就是一个语法糖，在<code>vue</code>编译阶段就会解析为<code>:value=&quot;绑定的值&quot;</code>和默认的<code>@input=(value) =&gt; {绑定的值 = value}</code>。然后再是在<code>input</code>标签上绑定的<code>handleInput</code>方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleInput(event) &#123;</span><br><span class="line">  <span class="comment">// should not emit input during composition</span></span><br><span class="line">  <span class="comment">// see: https://github.com/ElemeFE/element/issues/10516</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isComposing) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// hack for https://github.com/ElemeFE/element/issues/8548</span></span><br><span class="line">  <span class="comment">// should remove the following line when we don't support IE</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.value === <span class="keyword">this</span>.nativeInputValue) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, event.target.value);</span><br><span class="line">  <span class="comment">// ensure native input value is controlled</span></span><br><span class="line">  <span class="comment">// see: https://github.com/ElemeFE/element/issues/12850</span></span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="keyword">this</span>.setNativeInputValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里<code>input</code>的组件的属性基本上就解释完成，<code>textare</code>基本上都是一样的，但是<code>textarea</code>有一点特殊的操作。</p><h2 id="textarea高度自适应"><a href="#textarea高度自适应" class="headerlink" title="textarea高度自适应"></a>textarea高度自适应</h2><p>它是怎么实现高度自适应的，具体的实现代码是在<a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/calcTextareaHeight.js" target="_blank" rel="noopener">calcTextareaHeight</a>，大致分为几部：</p><ul><li>创建一个临时隐藏的<code>textarea</code>元素</li><li>通过隐藏的<code>textarea</code>计算显示的<code>textarea</code>元素的高度</li><li>并且判断<code>minRows</code>、<code>maxRows</code>属性</li><li>最后删除<code>textarea</code>元素，并且清空<code>dom</code>引用</li></ul><p>在<code>input</code>组件中通过创建<code>watch</code>监听<code>value</code>值的变化，每次<code>value</code>变化从新计算<code>textarea</code>元素的高度。</p><p><strong>创建一个临时隐藏的<code>textarea</code>元素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hiddenTextarea;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="comment">// 保证只执行一次</span></span><br><span class="line"><span class="keyword">if</span> (!hiddenTextarea) &#123;</span><br><span class="line">  <span class="comment">// 创建textarea</span></span><br><span class="line">  hiddenTextarea = <span class="built_in">document</span>.createElement(<span class="string">'textarea'</span>);</span><br><span class="line">  <span class="comment">// 添加到页面中</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(hiddenTextarea);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure><p><strong>通过隐藏的<code>textarea</code>计算显示的<code>textarea</code>元素的高度</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HIDDEN_STYLE = <span class="string">`</span></span><br><span class="line"><span class="string">  height:0 !important;</span></span><br><span class="line"><span class="string">  visibility:hidden !important;</span></span><br><span class="line"><span class="string">  overflow:hidden !important;</span></span><br><span class="line"><span class="string">  position:absolute !important;</span></span><br><span class="line"><span class="string">  z-index:-1000 !important;</span></span><br><span class="line"><span class="string">  top:0 !important;</span></span><br><span class="line"><span class="string">  right:0 !important</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONTEXT_STYLE = [</span><br><span class="line">  <span class="string">'letter-spacing'</span>,</span><br><span class="line">  <span class="string">'line-height'</span>,</span><br><span class="line">  <span class="string">'padding-top'</span>,</span><br><span class="line">  <span class="string">'padding-bottom'</span>,</span><br><span class="line">  <span class="string">'font-family'</span>,</span><br><span class="line">  <span class="string">'font-weight'</span>,</span><br><span class="line">  <span class="string">'font-size'</span>,</span><br><span class="line">  <span class="string">'text-rendering'</span>,</span><br><span class="line">  <span class="string">'text-transform'</span>,</span><br><span class="line">  <span class="string">'width'</span>,</span><br><span class="line">  <span class="string">'text-indent'</span>,</span><br><span class="line">  <span class="string">'padding-left'</span>,</span><br><span class="line">  <span class="string">'padding-right'</span>,</span><br><span class="line">  <span class="string">'border-width'</span>,</span><br><span class="line">  <span class="string">'box-sizing'</span></span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateNodeStyling</span>(<span class="params">targetElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> style = <span class="built_in">window</span>.getComputedStyle(targetElement);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> boxSizing = style.getPropertyValue(<span class="string">'box-sizing'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paddingSize = (</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'padding-bottom'</span>)) +</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'padding-top'</span>))</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> borderSize = (</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'border-bottom-width'</span>)) +</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'border-top-width'</span>))</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> contextStyle = CONTEXT_STYLE</span><br><span class="line">    .map(<span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>:<span class="subst">$&#123;style.getPropertyValue(name)&#125;</span>`</span>)</span><br><span class="line">    .join(<span class="string">';'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; contextStyle, paddingSize, borderSize, boxSizing &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    paddingSize,</span><br><span class="line">    borderSize,</span><br><span class="line">    boxSizing,</span><br><span class="line">    contextStyle</span><br><span class="line">&#125; = calculateNodeStyling(targetElement);</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">hiddenTextarea.setAttribute(<span class="string">'style'</span>, <span class="string">`<span class="subst">$&#123;contextStyle&#125;</span>;<span class="subst">$&#123;HIDDEN_STYLE&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 设置value</span></span><br><span class="line">hiddenTextarea.value = targetElement.value || targetElement.placeholder || <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 获取隐藏textarea滚动整体高度</span></span><br><span class="line"><span class="keyword">let</span> height = hiddenTextarea.scrollHeight;</span><br><span class="line"><span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"><span class="comment">// 判断盒模型</span></span><br><span class="line"><span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果为border-box本身的高度加上borderSize</span></span><br><span class="line">  height = height + borderSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (boxSizing === <span class="string">'content-box'</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果为content-box本身的高度加上paddingSize</span></span><br><span class="line">  height = height - paddingSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把隐藏textarea的vlaue设置为空</span></span><br><span class="line">hiddenTextarea.value = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 获取每行高度： row的高度为滚动高度-padding</span></span><br><span class="line"><span class="keyword">let</span> singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure><p><strong>并且判断<code>minRows</code>、<code>maxRows</code>属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="comment">// 判断是否有设置minRows</span></span><br><span class="line">  <span class="keyword">if</span> (minRows !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 最小高度 = 每行高度 * 最小行数</span></span><br><span class="line">    <span class="keyword">let</span> minHeight = singleRowHeight * minRows;</span><br><span class="line">    <span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果boxSizing为border-box时： 最小高度 = 原最小高度 + padding + border;</span></span><br><span class="line">      minHeight = minHeight + paddingSize + borderSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取当前计算的最小高度和上面计算出的scrollHeight度中的最大值</span></span><br><span class="line">    height = <span class="built_in">Math</span>.max(minHeight, height);</span><br><span class="line">    <span class="comment">// 赋值给result.minHeight</span></span><br><span class="line">    result.minHeight = <span class="string">`<span class="subst">$&#123; minHeight &#125;</span>px`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否有设置maxRows</span></span><br><span class="line">  <span class="keyword">if</span> (maxRows !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 最大高度 = 每行高度 * 最大行数</span></span><br><span class="line">    <span class="keyword">let</span> maxHeight = singleRowHeight * maxRows;</span><br><span class="line">    <span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果boxSizing为border-box时： 最小高度 = 原最小高度 + padding + border;</span></span><br><span class="line">      maxHeight = maxHeight + paddingSize + borderSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取当前计算的最大高度和上面计算出的scrollHeight度中的最小值</span></span><br><span class="line">    height = <span class="built_in">Math</span>.min(maxHeight, height);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 赋值给result.minHeight</span></span><br><span class="line">  result.height = <span class="string">`<span class="subst">$&#123; height &#125;</span>px`</span>;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure><p><strong>最后删除<code>textarea</code>元素，并且清空<code>dom</code>引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存在parentNode 就清除parentNode包含的hiddenTextarea 元素</span></span><br><span class="line">hiddenTextarea.parentNode &amp;&amp; hiddenTextarea.parentNode.removeChild(hiddenTextarea);</span><br><span class="line"><span class="comment">// 清空dom引用释放变量</span></span><br><span class="line">hiddenTextarea = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 返回最小高度和最大高度</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>到此<code>textarea</code>结束，可能还有很多细节没有记录到，如果有什么意见请评论。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整篇文章都是根据几点分析的，如下：</p><ul><li>支持<strong>前置内容</strong>、<strong>后置内容</strong>、<strong>后置元素</strong></li><li>支持所有原声的<code>type</code>，并且可以切换<code>password</code>模式</li><li>支持<code>readonly</code>、<code>disabled</code>、<code>autocomplete</code>、<code>maxlength</code>、<code>minlength</code>等等</li><li>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code></li><li><code>element-ui</code>是怎么做到类似与<code>vue</code>的双向绑定的</li><li><code>type</code>为<code>textare</code>模式时，做到<code>calcTextareaHeight</code></li></ul><p>当然还有很多的点没有记录到比如说<code>clear</code>、<code>emitter</code>、<code>Migrating</code>等等，这个会在后面的文章中着重介绍。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/input.vue" target="_blank" rel="noopener">element-ui input</a><br><a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/calcTextareaHeight.js" target="_blank" rel="noopener">element-ui calcTextareaHeight</a></p>]]></content>
    
    <summary type="html">
    
      element-ui中的input怎么实现值的双向绑定、自适应高度的
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Array系列(三) Array中的forEach方法可以用break、continue跳出循环？</title>
    <link href="http://asyncnode.com/blog/es6/es6-Array-break-continue.html"/>
    <id>http://asyncnode.com/blog/es6/es6-Array-break-continue.html</id>
    <published>2019-08-17T01:24:31.000Z</published>
    <updated>2019-10-24T05:12:36.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>飄風不終朝，驟雨不終日。——《道德經》</em></strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>在<code>Array.prototype</code>上有很多方法，比较常用的就是<code>every</code>、<code>filter</code>、<code>forEach</code>、<code>map</code>、<code>some</code>这些循环方法，可以通过<code>break</code>、<code>comtinue</code>跳出循环？<br>现在基本上都是通过<code>forEach</code>、<code>every</code>来代替<code>for</code>循环，<code>for</code>循环可以通过<code>break</code>、<code>continue</code>跳出循环。而 forEach 可以不可以呢，下面一步一步的验证一下。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><hr><p>在<code>for</code>中遇到<code>break</code>就会退出当前循环，后面的循环不会再执行。代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure><p>在<code>for</code>中遇到<code>continue</code>就会退出当前本次循环，后面的循环会执行。代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>for</code>中不能使用 return，不然会报错</p></blockquote><h2 id="forEach、every、some、filter、map"><a href="#forEach、every、some、filter、map" class="headerlink" title="forEach、every、some、filter、map"></a>forEach、every、some、filter、map</h2><hr><p>如果想退出<code>forEach</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure><p>如果想退出<code>every</code>，就只能通过<code>return</code>, 它会退出当前循环，后面的循环不会再执行。代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure><p>如果想退出<code>some</code>，就只能通过<code>return</code>, <code>return false</code>和<code>return true</code>它的表现是不一致的。<code>return false</code>它的表现和<code>forEach</code>中的表现一致。 代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure><p><code>return true</code>和<code>every</code>表现一致，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure><p>如果想退出<code>filter</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure><p>如果想退出<code>map</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>forEach</code>、<code>every</code>、<code>some</code>中不能用<code>break</code>、<code>continue</code>跳出循环，不然会报错。</p></blockquote><p>都知道<code>filter</code>、<code>map</code>会返回一个新的数组，而<code>every</code>、<code>some</code>会返回一个<code>Boolean</code>类型的。</p><h2 id="some-和-every-需要注意的地方"><a href="#some-和-every-需要注意的地方" class="headerlink" title="some 和 every 需要注意的地方"></a>some 和 every 需要注意的地方</h2><hr><p><code>some()</code> 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个 Boolean 类型的值。<code>polyfill</code>实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.some = <span class="function"><span class="keyword">function</span>(<span class="params">callbackfn, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = <span class="built_in">Number</span>(<span class="keyword">this</span>.length);</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">let</span> Pk = <span class="built_in">String</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (Pk <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = <span class="keyword">this</span>[Pk];</span><br><span class="line">      <span class="keyword">if</span> (callbackfn.call(thisArg, kValue, k, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，遇到回调返回值是 <code>true</code> 的话，函数就直接返回、结束了。这是种短路算法，并不是所有回调都执行一遍，然后再最后求所有与值。<code>every</code> 也类似，不过与之相反，遇到回调返回值是 <code>false</code> 时，整体就直接返回 <code>false</code> 了。<br>从实现上表达出的语义来讲，<code>some</code> 是在说：<strong>有一个成功，我就成功，而 <code>every</code> 是在说：有一个失败，我就失败</strong><br><strong>另外要强调一点，对于稀疏数组，不存在的索引值时，回调函数是不执行的</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">Array.prototype.some()</a><br><a href="https://juejin.im/post/5d08a565e51d45773d468614#heading-2" target="_blank" rel="noopener">不再写 break 和 continue 了</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Array中的forEach方法可以用break、continue跳出循环？
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Array系列(四) Array常用的方法和实现reduce、map、filter、forEach</title>
    <link href="http://asyncnode.com/blog/es6/es6-Array-function.html"/>
    <id>http://asyncnode.com/blog/es6/es6-Array-function.html</id>
    <published>2019-08-14T03:12:21.000Z</published>
    <updated>2019-10-24T05:12:36.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>挫其銳，解其紛，和其光，同其塵。</em></strong></p><blockquote><p><a href="/blog/es6/es6-Array.html">ES6 Array 系列(一) 一些常用 array 的扩展方法</a><br><a href="/blog/es6/es6-Array1.html">ES6 Array 系列(二) 一些常用 array 的扩展方法（二）</a><br><a href="/blog/es6/es6-Array-break-continue.html">ES6 Array 系列(三) Array 中的 forEach 方法可以用 break、continue 跳出循环？</a><br><a href="/blog/es6/es6-Array-function.html">ES6 Array 系列(四) Array 常用的方法和实现 reduce、map、filter、forEach</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p><code>Array.prototype</code>上有很多方法，可以很方便的实现各种循环、过滤对数组做很多的处理，这里主要记录自己怎么实现几个方法<code>map</code>、<code>forEach</code>、<code>filter</code>、<code>reduce</code>，怎么使用就不多做讲解了因为在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">mdn 中 Array</a>或者别人的文章中有很多的讲解了。</p><h2 id="实现-reduce"><a href="#实现-reduce" class="headerlink" title="实现 reduce"></a>实现 reduce</h2><hr><p>首先要了解<code>reduce</code>它有两个参数，第一个参数是一个回调方法<code>callback</code>，第二个参数是一个初始值<code>initialValue</code>。<br>大致实现步骤如下：</p><ul><li>判断参数，判断调用方法本身是否为 Array</li><li>声明要用的变量</li><li>判断是否有初始值，如果没有则从本身数组中取，取到直接跳出循环</li><li>循环调用 callback</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfReduce = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initalValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明要用到的变量</span></span><br><span class="line">  <span class="comment">// 要循环的数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="comment">// 开始的数组索引 默认为 0</span></span><br><span class="line">  <span class="keyword">let</span> startIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为有初始化值 initalValue</span></span><br><span class="line">  <span class="keyword">if</span> (initalValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果初始值为 undefined 循环从数组中找到有值，并且退出循环</span></span><br><span class="line">    <span class="comment">// 过滤稀疏值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startIndex = i;</span><br><span class="line">        res = arr[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = initalValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在上一步拿到初始值，循环调用传入的回调函数，并且过滤松散值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex++; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = callback.call(<span class="literal">null</span>, res, arr[i], i, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试一下<code>selfReduce</code>和<code>reduce</code>方法是否表现一致，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev + next;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 15</span></span><br><span class="line">arr.selfReduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev + next;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>其实也可以去看一下官方的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">mdn reduce polyfill</a>。</p><h2 id="实现-map"><a href="#实现-map" class="headerlink" title="实现 map"></a>实现 map</h2><hr><p><code>map</code>的使用这里不多做赘述，只记录它的两种实现方式一种通过<code>for</code>循环实现，另一种通过<code>reduce</code>实现。</p><h3 id="for-循环实现"><a href="#for-循环实现" class="headerlink" title="for 循环实现"></a>for 循环实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfMap = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明要用到的变量</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> aMap = [];</span><br><span class="line">  <span class="comment">// 循环调用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    <span class="comment">// 过滤稀疏值</span></span><br><span class="line">    <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    aMap[i] = callback.call(context, arr[i], i, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> aMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试实现<code>selfMap</code>和<code>map</code>是否一致，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">aTest.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line">aTest.selfMap(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><h3 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceMap = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aMap = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 使用reduce实现循环</span></span><br><span class="line">  <span class="keyword">return</span> aMap.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拼接上次循环结果和当前结果</span></span><br><span class="line">    <span class="comment">// 循环调用callback</span></span><br><span class="line">    <span class="keyword">return</span> [...pre, callback.call(context, cur, index, <span class="keyword">this</span>)];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试实现<code>reduceMap</code>和<code>map</code>是否一致，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">aTest.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line">aTest.reduceMap(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><h2 id="filter-实现"><a href="#filter-实现" class="headerlink" title="filter 实现"></a>filter 实现</h2><hr><p>filter 也用到很多次，这里也不多做赘述直接看两种实现方法：</p><h3 id="for-循环实现-1"><a href="#for-循环实现-1" class="headerlink" title="for 循环实现"></a>for 循环实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfFilter = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = aArr.length;</span><br><span class="line">  <span class="keyword">let</span> aFArr = [];</span><br><span class="line">  <span class="comment">// 循环调用callback</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!aArr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callback.call(context, aArr[i], i, <span class="keyword">this</span>) &amp;&amp; aFArr.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> aFArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="reduce-实现-1"><a href="#reduce-实现-1" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceFilter = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环调用callback</span></span><br><span class="line">  aArr.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> callback.call(context, cur, index, <span class="keyword">this</span>) ? [...pre, cur] : [...pre];</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> aArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">aTest.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aTest.selfFilter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aTest.reduceFilter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="实现-forEach"><a href="#实现-forEach" class="headerlink" title="实现 forEach"></a>实现 forEach</h2><hr><p>for 循环实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfForeach = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    callback.call(context, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reduce 循环实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceForeach = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...pre, callback.call(context, cur, index, <span class="keyword">this</span>)];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上理解了怎么实现，无论是使用 for 来实现还是用 reduce 实现，基本上没有太大的差别。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">Array.prototype.reduce()</a><br><a href="https://juejin.im/post/5cef46226fb9a07eaf2b7516#heading-4" target="_blank" rel="noopener">一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧</a><br><a href="https://juejin.im/post/5c0b7f03e51d452eec725729" target="_blank" rel="noopener">JS Array.reduce 实现 Array.map 和 Array.filter</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Array常用的方法和实现reduce、map、filter、forEach
    
    </summary>
    
      <category term="JavaScript" scheme="http://asyncnode.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>css中的多种垂直水平居中</title>
    <link href="http://asyncnode.com/blog/css/css-center.html"/>
    <id>http://asyncnode.com/blog/css/css-center.html</id>
    <published>2019-08-10T12:13:12.000Z</published>
    <updated>2019-10-24T05:12:36.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在面试的时候<strong>css面试题</strong>里面基本上都会问一个元素<strong>垂直水平居中</strong>，其实这个有多种方式实现，同时元素可以是<strong>固定宽高、不固定宽高</strong>的。</p><p><strong>固定宽高</strong></p><ul><li>position absolute + 负margin</li><li>position absolute + margin auto</li><li>position absolute + calc</li></ul><p><strong>不固定宽高</strong></p><ul><li>position absolute + transform</li><li>css-table</li><li>flex</li><li>grid</li></ul><p>下面就直接上代码，公用的<code>html代码</code>和<code>css代码</code>就写在这里后面都会在这个基础上增加代码。<br><strong>html公用代码</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-center"</span>&gt;</span></span><br><span class="line">        box-center</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>css公用代码</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有两个元素它们是父子级的关系，要达到的效果是子元素要在父元素中垂直水平居中</strong>。</p><h2 id="固定宽高"><a href="#固定宽高" class="headerlink" title="固定宽高"></a>固定宽高</h2><p>固定宽高的意思就是要居中的这个元素它的<strong>宽高都是固定的值</strong>，下面一个一个用代码实现。</p><h3 id="position-absolute-负margin"><a href="#position-absolute-负margin" class="headerlink" title="position absolute + 负margin"></a>position absolute + 负margin</h3><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用绝对定位让子元素基于父元素的左上角偏移50%，但是这样不是真正的居中因为它多移动了本身元素的<strong>宽度的一半</strong>和<strong>高度的一半</strong>，这个时候我们可以通过<code>负margin</code>来修正这个问题，所以就有了<code>-50px</code>这两个属性。</p><h3 id="position-absolute-margin-auto"><a href="#position-absolute-margin-auto" class="headerlink" title="position absolute + margin auto"></a>position absolute + margin auto</h3><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了。</p><h3 id="position-absolute-calc"><a href="#position-absolute-calc" class="headerlink" title="position absolute + calc"></a>position absolute + calc</h3><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(50% - 50px);</span><br><span class="line">    <span class="attribute">left</span>: <span class="built_in">calc</span>(50% - 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>calc</code>计算属性减去元素本身高度和宽度的一半。</p><h2 id="不固定宽高"><a href="#不固定宽高" class="headerlink" title="不固定宽高"></a>不固定宽高</h2><p>固定宽高的意思就是要居中的这个元素它的<strong>宽高都是不固定的值</strong>，不固定宽高的方法是可以覆盖上面固定宽高的方法，下面一个一个用代码实现。</p><h3 id="position-absolute-transform"><a href="#position-absolute-transform" class="headerlink" title="position absolute + transform"></a>position absolute + transform</h3><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复绝对定位的问题，还可以使用css3新增的<code>transform</code>，<code>transform</code>的<code>translate</code>属性也可以设置百分比，其是相对于自身的宽和高，所以可以讲<code>translate</code>设置为<code>-50%</code>，就可以做到居中了。</p><h3 id="css-table"><a href="#css-table" class="headerlink" title="css-table"></a>css-table</h3><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>display: table-cell</code>把<code>div</code>元素变为<code>table</code>元素的实现效果，通过这个特性也可以实现垂直水平居中。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>flex</code>的两个属性实现垂直水平居中。</p><h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>grid</code>布局实现居中，如果<code>grid</code>不太了解可以看<a href="/blog/css/css-grid.html">grid布局</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有两种比较特殊的垂直水平居中的方式，应用场景比较少或者代价比较大，所以在这几记录一下如下：</p><ul><li>行内元素居中</li><li>table布局</li></ul><h3 id="行内元素居中"><a href="#行内元素居中" class="headerlink" title="行内元素居中"></a>行内元素居中</h3><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">    font-size: 0; // 兼容代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">line-height</span>: initial;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>container</code>设置为行内元素，通过<code>text-align</code>就可以做到水平居中，通过<code>vertical-align</code>也可以在垂直方向做到居中。</p><h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><p>改变<code>html</code>结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-center"</span>&gt;</span>box-center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>css</code>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>table</code>属性实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面实现总结如下面表格所示：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">居中元素定宽高固定</th><th style="text-align:center">PC兼容性</th><th style="text-align:center">移动端兼容性</th></tr></thead><tbody><tr><td style="text-align:center">position absolute + 负margin</td><td style="text-align:center">固定宽高</td><td style="text-align:center">ie6+, chrome4+, firefox2+</td><td style="text-align:center">安卓2.3+, iOS6+</td></tr><tr><td style="text-align:center">position absolute + margin auto</td><td style="text-align:center">固定宽高</td><td style="text-align:center">ie6+, chrome4+, firefox2+</td><td style="text-align:center">安卓2.3+, iOS6+</td></tr><tr><td style="text-align:center">position absolute + calc</td><td style="text-align:center">固定宽高</td><td style="text-align:center">ie9+, chrome19+, firefox4+</td><td style="text-align:center">安卓4.4+, iOS6+</td></tr><tr><td style="text-align:center">position absolute + transform</td><td style="text-align:center">不固定宽高</td><td style="text-align:center">ie9+, chrome4+, firefox3.5+</td><td style="text-align:center">安卓3+, iOS6+</td></tr><tr><td style="text-align:center">css-table</td><td style="text-align:center">不固定宽高</td><td style="text-align:center">ie8+, chrome4+, firefox2+</td><td style="text-align:center">安卓2.3+, iOS6+</td></tr><tr><td style="text-align:center">flex</td><td style="text-align:center">不固定宽高</td><td style="text-align:center">ie10+, chrome4+, firefox2+</td><td style="text-align:center">安卓2.3+, iOS6+</td></tr><tr><td style="text-align:center">grid</td><td style="text-align:center">不固定宽高</td><td style="text-align:center">ie10+, chrome57+, firefox52+</td><td style="text-align:center">安卓6+, iOS10.3+</td></tr><tr><td style="text-align:center">table布局</td><td style="text-align:center">不固定宽高</td><td style="text-align:center">ie6+, chrome4+, firefox2+</td><td style="text-align:center">安卓2.3+, iOS6+</td></tr><tr><td style="text-align:center">行内元素居中</td><td style="text-align:center">不固定宽高</td><td style="text-align:center">ie6+, chrome4+, firefox2+</td><td style="text-align:center">安卓2.3+, iOS6+</td></tr></tbody></table><p>推荐用法：</p><ul><li>PC端<strong>有兼容性</strong>要求，宽高固定，推荐<code>absolute + 负margin</code></li><li>PC端<strong>有兼容</strong>要求，宽高不固定，推荐<code>css-table</code></li><li>PC端<strong>无兼容性</strong>要求，推荐<code>flex</code></li><li>移动端推荐使用<code>flex</code></li></ul><p>以后肯定<code>grid</code>会大方异彩。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://yanhaijing.com/css/2018/01/17/horizontal-vertical-center/" target="_blank" rel="noopener">CSS实现水平垂直居中的1010种方式 原创</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      css中的多种垂直水平居中
    
    </summary>
    
      <category term="Css" scheme="http://asyncnode.com/categories/Css/"/>
    
    
      <category term="Css" scheme="http://asyncnode.com/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>var和let、const对比</title>
    <link href="http://asyncnode.com/blog/es6/es6-variable.html"/>
    <id>http://asyncnode.com/blog/es6/es6-variable.html</id>
    <published>2019-08-06T04:03:54.000Z</published>
    <updated>2019-10-24T05:12:36.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>在<strong>ECMAScript6</strong>中新增两个变量声明的指令<code>let</code>和<code>const</code>，以前经常用的<code>var</code>有什么区别。</p><h2 id="var声明"><a href="#var声明" class="headerlink" title="var声明"></a>var声明</h2><hr><p><code>var</code> <strong>声明语句</strong>声明一个变量，并可选地将其初始化为一个值。</p><ul><li>可重复声明</li><li>变量提升</li><li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>通过<code>var</code>关键字声明一个<code>count</code>变量，并且<code>count</code>的值为1。</p><h3 id="可重复声明"><a href="#可重复声明" class="headerlink" title="可重复声明"></a>可重复声明</h3><p>可以重复声明<code>count</code>变量，也可以重新赋值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">2</span>;</span><br><span class="line">count = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><code>var</code>声明的变量是存在<strong>变量提升</strong>的 ，由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>提升将影响变量声明，而不会影响其值的初始化</strong>。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>var</code>声明变量的作用域限制在其声明位置的<strong>上下文中</strong>，而非声明变量总是<strong>全局</strong>的。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line">    sum = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">x();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.sum); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>建议始终声明变量，无论它们是在函数还是全局作用域内。</li></ul></blockquote><h2 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h2><hr><p><code>let</code>允许你声明一个作用域被限制在 <code>块级中的变量</code>、<code>语句或者表达式</code>。与 <code>var</code> 关键字不同的是， <code>var</code>声明的变量只能是<code>全局</code>或者<code>整个函数块</code>的。</p><ul><li>不可重复声明，可以重复赋值</li><li>块作用域</li><li>暂存死区</li><li>不存在变量提升</li></ul><h3 id="不可重复声明，可以重复赋值"><a href="#不可重复声明，可以重复赋值" class="headerlink" title="不可重复声明，可以重复赋值"></a>不可重复声明，可以重复赋值</h3><p><strong><code>let</code>不可以重复同样名称的变量，但是可以重复给同一个变量多次赋值</strong>。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">2</span>; <span class="comment">// Identifier 'count' has already been declared</span></span><br><span class="line">count = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p><code>let</code>声明的变量只在其声明的<strong>块或子块中</strong>可用，这一点，与<code>var</code>相似。二者之间最主要的区别在于<code>var</code>声明的变量的作用域是<strong>整个封闭函数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">        <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">        <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>let声明</strong>的变量不会挂载顶层对象下面，会临时创建一个<code>scope</code>来储存<strong>let声明</strong>，执行完成清除，示例代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">debugger</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> count = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sum = <span class="number">2</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在执行完<code>let count = 1;</code>，效果如下图所示：<br><img src="../../images/es/es-let.png" alt="let"><br>当<strong>javascript</strong>执行完成后，<code>scope</code>也会被清空。</p><h3 id="暂存死区-不存在变量提升"><a href="#暂存死区-不存在变量提升" class="headerlink" title="暂存死区/不存在变量提升"></a>暂存死区/不存在变量提升</h3><p><code>let</code> 被创建在包含该声明的（块）作用域顶部，<strong>一般被称为“提升”</strong>。与通过  <code>var</code> 声明的有初始化值 <code>undefined</code> 的变量不同，通过 <code>let</code> 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 <code>ReferenceError</code>。该变量处在一个自块顶部到初始化处理的“暂存死区”中。<br>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// Uncaught ReferenceError: Cannot access 'count' before initialization</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h2><hr><p>常量是块级作用域，很像使用 <code>let</code> 语句定义的变量。常量的值<strong>不能</strong>通过重新赋值来改变，并且<strong>不能</strong>重新声明。</p><ul><li>不能重复声明</li><li>不能重复赋值</li><li>块级作用域</li><li>暂存死区</li><li>不存在变量提升</li><li>一旦声明，必须马上赋值</li></ul><p><code>不能重复声明</code>、<code>块级作用域</code>、<code>块级作用域</code>、<code>不存在变量提升</code>在这里不再赘述和<code>let</code>中的表现相同，请看上文。</p><h3 id="一旦声明，必须马上赋值"><a href="#一旦声明，必须马上赋值" class="headerlink" title="一旦声明，必须马上赋值"></a>一旦声明，必须马上赋值</h3><p><code>const</code> 声明之后必须马上赋值，否则会报错，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count; <span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="不能重复赋值"><a href="#不能重复赋值" class="headerlink" title="不能重复赋值"></a>不能重复赋值</h3><p><code>const</code>声明创建一个值的<strong>只读引用</strong>。但这并不意味着它所持有的值是<strong>不可变</strong>的，只是<strong>变量标识符</strong>不能重新分配。<br><strong>JavaScript</strong>中的数据类型分为两大类：<code>值类型</code>、<code>引用类型</code>。</p><p><strong>值类型</strong></p><p>用<code>const</code>声明的变量被首次被赋值为<strong>值类型</strong>，它的值就不能改变了，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">2</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p><strong>引用类型</strong></p><p>只要不改变量的<strong>指针地址</strong>就不会报错，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    name: <span class="string">'nihao'</span>,</span><br><span class="line">    age: <span class="number">17</span></span><br><span class="line">&#125;;</span><br><span class="line">user.name = <span class="string">'大家好'</span>;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结对比如下面表格所示：</p><table><thead><tr><th style="text-align:center">/</th><th style="text-align:center">能否重复声明</th><th style="text-align:center">能否重复赋值</th><th style="text-align:center">作用域</th><th style="text-align:center">变量提升</th><th style="text-align:center">暂存死区</th><th style="text-align:center">声明是否需要立即赋值</th></tr></thead><tbody><tr><td style="text-align:center">var</td><td style="text-align:center">能</td><td style="text-align:center">能</td><td style="text-align:center">函数作用域/全局作用域</td><td style="text-align:center">存在变量提升</td><td style="text-align:center">不存在暂存死区</td><td style="text-align:center">不需要立即赋值</td></tr><tr><td style="text-align:center">let</td><td style="text-align:center">不能</td><td style="text-align:center">能</td><td style="text-align:center">块级作用域/全局作用域</td><td style="text-align:center">不存在</td><td style="text-align:center">存在暂存死区</td><td style="text-align:center">不需要立即赋值</td></tr><tr><td style="text-align:center">const</td><td style="text-align:center">不能</td><td style="text-align:center">不能</td><td style="text-align:center">块级作用域/全局作用域</td><td style="text-align:center">不存在</td><td style="text-align:center">存在暂存死区</td><td style="text-align:center">需要立即赋值</td></tr></tbody></table><p>他们的特性基本上如上面表格所示，可以根据各个不同的需要，选择var、let、const来声明变量。</p><blockquote><p><a href="http://asyncnode.com/blog/javascript/javascript-Type-conversion.html">JavaScript类型转换（一） 常见数据类型</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var" target="_blank" rel="noopener">var 声明语句</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let 声明语句</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const 声明语句</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247483812&amp;idx=1&amp;sn=9bab06614e079bd9cc533a3b2cd02a75&amp;chksm=faec857ccd9b0c6a9b58e49f747651ffdf484acdd6fc82318a0964e4c339dbda6586e340ca4d&amp;mpshare=1&amp;scene=1&amp;srcid=082024th073paIFjxG2PXq8C&amp;sharer_sharetime=1566313518851&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b#rd" target="_blank" rel="noopener">JS 系列一：var、let、const、解构、展开、函数</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjAyMzY1OQ==&amp;mid=2247483768&amp;idx=1&amp;sn=328166a7f78be132b77215060e96128b&amp;chksm=cf5c4cfcf82bc5ea327e302b81401165663f3ad91d35270ee4e537f7b27081cad4fecffc4776&amp;mpshare=1&amp;scene=1&amp;srcid=0820mIdzuPo1JIpEQKyVpaGY&amp;sharer_sharetime=1566313451138&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b#rd" target="_blank" rel="noopener">ES6中let、const与var的区别</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      var和let、const对比
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://asyncnode.com/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>javascript中new相关的面试题</title>
    <link href="http://asyncnode.com/blog/InterviewQuestion/new-javascript.html"/>
    <id>http://asyncnode.com/blog/InterviewQuestion/new-javascript.html</id>
    <published>2019-08-03T15:13:45.000Z</published>
    <updated>2019-10-24T05:12:36.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个Foo 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Foo创建了一个叫getName的静态属性存储了一个匿名函数</span></span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>); &#125;;</span><br><span class="line"><span class="comment">// Foo的原型对象新创建了一个叫getName的匿名函数</span></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>); &#125;;</span><br><span class="line"><span class="comment">// 声明一个匿名，并且赋值给全局变量getName (函数表达式)</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="comment">// 声明一个全局函数getName (函数声明)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">5</span>); &#125;</span><br><span class="line"></span><br><span class="line">Foo.getName(); <span class="comment">// 第一问</span></span><br><span class="line">getName(); <span class="comment">// 第二问</span></span><br><span class="line">Foo().getName(); <span class="comment">// 第三问</span></span><br><span class="line">getName(); <span class="comment">// 第四问</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 第五问</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 第六问</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 第七问</span></span><br></pre></td></tr></table></figure><p><strong>如果这几个问题能直接回答出来，后面就没必要看了</strong>。</p><p><strong>简单了解一下javascript中的原型继承</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Preson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = name; <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">//公有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">//私有方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Preson.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//公有方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">Preson.name = <span class="string">'Wscats'</span>; <span class="comment">//静态属性</span></span><br><span class="line">Preson.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Son = <span class="keyword">new</span> Preson(<span class="string">'Son'</span>); <span class="comment">//实例化</span></span><br></pre></td></tr></table></figure><p>注意下面几点：</p><ul><li><strong>调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的</strong></li><li><strong>静态方法和静态属性就是我们无需实例化就可以调用</strong></li><li><strong>而对象的私有方法和属性,外部是不可以访问的</strong></li><li><strong>静态属性不能被继承</strong></li></ul><p>首先看一下代码，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>); &#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>); &#125;;</span><br></pre></td></tr></table></figure><p>首先看一下<code>Foo.getName</code>会在<code>Foo.prototype.constructor</code>中添加一个<code>getName</code>属性，如果直接调用<code>Foo.getName</code>他就直接调用<code>Foo.prototype.constructor</code>上得<code>getName</code>属性。<br>如果没有通过<code>new</code>关键字调用<code>Foo</code>的话，是不能访问<code>prototype</code>中的<code>getName</code>属性。<br>代码结果如下：<br><img src="../../images/interviewquestion/interviewquestion-javascirpt-1-1.png" alt="interviewquestion-javascript"></p><h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo.getName(); <span class="comment">// 第一问</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>根据上面的说明，可以得出第一问的<code>Foo.getName</code>就是会访问<code>constructor</code>上得静态属性，结果就是<code>2</code>。</p><h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getName(); <span class="comment">// 第二问</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>首先要介绍一下<strong>函数声明</strong>和<strong>函数表达式</strong>，如下：</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里考察的是<strong>变量提升</strong>的技巧，简单来说就是<strong>函数声明</strong>存在变量提升，不了解变量提升的话可以看另一篇文章<a href="/blog/javascript/hoisting.html">javascript中的变量提升</a>，所以这一题的答案就是4。</p><h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo().getName(); <span class="comment">// 第三问</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>Foo().getName()</code>; 先执行了<code>Foo</code>函数，然后调用<code>Foo</code>函数的返回值对象的<code>getName</code>属性函数。主要考察<code>this</code>指向问题和在<code>Foo</code>函数中没有<code>var</code>声明变量问题。<br>要注意<code>Foo</code>函数中的<code>getName</code>声明是没有<code>var</code>的，所以它会在全局作用域中创建一个<code>getName</code>，如果全局作用域中存在这个属性就会<strong>覆盖</strong>全局作用域的已存在的属性。<br>所以当<code>Foo</code>函数执行完成之后<code>getName = function () { console.log(1);}</code>会覆盖<code>getName = function () { console.log(4); }</code>。</p><blockquote><p>注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。</p></blockquote><p><code>Foo</code>函数的返回值是<code>this</code>，而<code>JS</code>的<code>this</code>问题已经有非常多的文章介绍，简单来讲this的指向就是由函数的调用方式决定的。<br>所以答案就是<strong>输出1</strong>。<br>这里最主要考察两个知识点，一个是作用域问题、一个是this指向问题，这个就不多做解释直接看往期文章。</p><h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getName(); <span class="comment">// 第四问</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>直接调用<code>getName</code>函数，相当于<code>window.getName()</code>，因为这个变量已经被<code>Foo</code>函数执行时修改了，所以结果和第三问相同也会<strong>输出1</strong>。</p><h2 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 第五问</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>第五问主要考察的是<font color="#ff502c">JS中的运算符优先级</font>，所以首先要了解<strong>JS中的运算符优先级</strong>，可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">MDN运算符优先级</a>学习这里就不多展示，只展示用到的如下图所示：<br><img src="../../images/interviewquestion/interviewquestion-javascirpt-1-2.png" alt="interviewquestion-javascript"><br>可以在上面看到一下两点：</p><ul><li>成员访问<code>.</code>的优先级为<strong>(19)</strong>比new无参数列表<strong>(18)</strong>优先级高</li><li>当点运算完后又因为有个括号()，此时就是变成new有参数列表<strong>(19)</strong>，所以直接执行new，<code>new constructor</code> 后面可以跟<strong>一个指定对象实例的类型的类或函数</strong>。它是把<code>Foo.getName()</code>看做一个<strong>整体</strong>，而不是调用了<code>new</code>完成以后的<strong>函数</strong>，不信的话可以运行<code>new (Foo.getName)</code>这个代码，它的结果和本题的<strong>结果一致</strong>。<br>所以我们可以把代码改写成<code>new (Foo.getName)()</code>这样可以清晰的看到他的执行顺序，大的执行顺序分为两部步如下：</li></ul><ol><li>先执行<code>Foo.getName</code></li><li>再是<code>new (Foo.getName)()</code></li></ol><p>所以这里实际上将<strong>getName函数</strong>作为了<strong>构造函数</strong>来执行，所以<strong>结果是2</strong>。</p><h2 id="第六问"><a href="#第六问" class="headerlink" title="第六问"></a>第六问</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 第六问</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>根据上面的<strong>运算符优先级</strong>可知，首先new有参数列表(19)跟点的优先级(19)是同级，同级的话按照<strong>从左向右的执行顺序</strong>，所以先执行new有参数列表(19)再执行点的优先级(19)，最后再函数调用(18)。</p><blockquote><p>new有参数列表(19)-&gt;.成员访问(19)-&gt;()函数调用(18)<br>根据优先级可以把上面的问题该写为<code>(new Foo()).getName()</code>，这样可以更清晰的看到它的执行过程。</p></blockquote><h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><p>在传统语言中构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象，而在JS中构造函数可以有返回值也可以没有。大致可以分总结为三类：</p><ul><li>没有返回值则按照其他语言一样返回实例化对象。</li><li>若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（String,Number,Boolean,Null,Undefined）则与无返回值相同，实际返回其实例化对象。</li><li>若返回值是引用类型，则实际返回值为这个引用类型。</li></ul><p>原题中，由于返回的是<code>this</code>，而this在构造函数中本来就代表当前实例化对象，最终<code>Foo</code>函数返回<strong>实例化对象</strong>。<br>之后调用实例化对象的<code>getName</code>函数，因为在Foo构造函数中没有为<strong>实例化对象</strong>添加任何属性，当前对象的<strong>原型对象(prototype)</strong>中寻找<code>getName</code>函数。所以会执行<code>prototype</code>上得<code>getName</code>的方法也就是<code>function () { alert (3);};</code>，<strong>结果为3</strong>。</p><h2 id="第七问"><a href="#第七问" class="headerlink" title="第七问"></a>第七问</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 第七问</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>根据第六问的优先级可以把第七问的代码改写为<code>new ((new Foo()).getName)()</code>，所以得到的<strong>结果也为3</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实有很多关于<strong>this指向</strong>、<strong>构造函数返回值</strong>、<strong>作用域</strong>都没有记录的很完整，以前有些过一些文章但是并没有整理，慢慢会整理好。</p>]]></content>
    
    <summary type="html">
    
      这一篇记录一道new相关的面试题，详细分析答案。
    
    </summary>
    
      <category term="InterviewQuestion" scheme="http://asyncnode.com/categories/InterviewQuestion/"/>
    
    
      <category term="InterviewQuestion" scheme="http://asyncnode.com/tags/InterviewQuestion/"/>
    
      <category term="JavaScript" scheme="http://asyncnode.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Https系列（三） Https+blob 视频播放</title>
    <link href="http://asyncnode.com/blog/http/http-https-blob.html"/>
    <id>http://asyncnode.com/blog/http/http-https-blob.html</id>
    <published>2019-07-30T10:23:54.000Z</published>
    <updated>2019-10-24T05:12:36.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自从HTML5提供了video标签，在网页中播放视频已经变成一个非常简单的事，只要一个video标签src属性设置为视频的地址就完事了。由于src指向真实的视频网络地址，在早期一般网站资源文件不怎么<strong>通过referer设置防盗链</strong>，所以可以随意的下载视频，也就有了后来通过blob加密视频文件。</p><blockquote><p>目前的云存储服务商大部分都支持referer防盗链。其原理就是在访问资源时，请求头会带上发起请求的页面地址，判断其不存在（表示直接访问图片地址）或不在白名单内，即为盗链。</p></blockquote><p>现在许多视频在线观看网站，你如果打开<code>chrome</code>查看其<code>video</code>标签，会发现它的<code>src</code>是一个以<code>blob:</code>开头的地址。</p><h2 id="Blob和ArrayBuffer"><a href="#Blob和ArrayBuffer" class="headerlink" title="Blob和ArrayBuffer"></a>Blob和ArrayBuffer</h2><p><code>Blob</code>是<strong>二进制原始数据</strong>但是类似<strong>文件</strong>的对象，ArrayBuffer对象用来表示<strong>通用的、固定长度</strong>的<strong>原始二进制数据缓冲区</strong>。<br>同时他们是可以互相转换的<code>Blob</code>和<code>ArrayBuffer</code>。</p><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p><font color="#ff502c"></font></p><p><font color="#ff502c">Blob</font>对象表示一个<font color="#ff502c">不可变、原始数据</font>的类文件对象。<font color="#ff502c">Blob</font> 表示的不一定是<code>JavaScript</code><font color="#ff502c">原生格式的数据。<code>File</code> 接口基于<code>Blob</code>，继承了 <code>blob</code> 的功能并将其扩展使其支持用户系统上的文件。<br>使用 <code>Blob()</code> 构造函穿新创建的 Blob 对象。常用的方法和属性如下：</font></p><ul><li><code>slice()</code>方法： 创建包含另一个<code>blob</code>数据的子集<code>blob</code></li><li><code>Blob.size</code>属性（只读）： Blob 对象中所包含数据的大小（字节）。</li><li><code>Blob.type</code>属性（只读）： 一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型未知，则该值为空字符串。</li></ul><blockquote><ul><li>注意：slice()方法原本接受length作为第二个参数，以表示复制到新Blob 对象的字节数。如果设置的参数使start + length超出了源Blob对象的大小，那返回的则是从start到结尾的数据。</li><li>File对象其实继承自Blob对象，并提供了提供了name ， lastModifiedDate， size ，type 等基础元数据。</li></ul></blockquote><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p><font color="#ff502c">ArrayBuffer</font>(length)来获得一片连续的内存空间，它不能直接读写，但可根据需要将其传递到TypedArray视图或 DataView 对象来解释原始缓冲区。实际上视图只是给你提供了一个某种类型的读写接口，让你可以操作<font color="#ff502c">ArrayBuffer</font>里的数据。<strong>TypedArray需指定一个数组类型来保证数组成员都是同一个数据类型，而DataView数组成员可以是不同的数据类型</strong>。</p><p><code>TypedArray</code> 对象描述一个底层的<strong>二进制数据缓存区</strong>的一个类似数组(array-like)视图，<code>TypedArray</code>对象如下几种：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小（字节单位）</th><th style="text-align:center">描述</th><th style="text-align:center">Web  IDL type</th><th style="text-align:center">C语言中的等效类型</th></tr></thead><tbody><tr><td style="text-align:center">Int8Array</td><td style="text-align:center">1</td><td style="text-align:center">8位二进制带符号整数 -2^7~(2^7) - 1</td><td style="text-align:center">byte</td><td style="text-align:center">int8_t</td></tr><tr><td style="text-align:center">Uint8Array</td><td style="text-align:center">1</td><td style="text-align:center">8位无符号整数 0~(2^8) - 1</td><td style="text-align:center">octet</td><td style="text-align:center">uint8_t</td></tr><tr><td style="text-align:center">Int16Array</td><td style="text-align:center">2</td><td style="text-align:center">16位二进制带符号整数 -2^15~(2^15)-1</td><td style="text-align:center">short</td><td style="text-align:center">int16_t</td></tr><tr><td style="text-align:center">Uint16Array</td><td style="text-align:center">2</td><td style="text-align:center">16位无符号整数 0~(2^16) - 1</td><td style="text-align:center">unsigned short</td><td style="text-align:center">uint16_t</td></tr><tr><td style="text-align:center">Int32Array</td><td style="text-align:center">4</td><td style="text-align:center">32位二进制带符号整数 -2^31~(2^31)-1</td><td style="text-align:center">long</td><td style="text-align:center">int32_t</td></tr><tr><td style="text-align:center">Uint32Array</td><td style="text-align:center">4</td><td style="text-align:center">32位无符号整数 0~(2^32) - 1</td><td style="text-align:center">unsigned int</td><td style="text-align:center">uint32_t</td></tr><tr><td style="text-align:center">Float32Array</td><td style="text-align:center">4</td><td style="text-align:center">32位IEEE浮点数</td><td style="text-align:center">unrestricted float</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">Float64Array</td><td style="text-align:center">8</td><td style="text-align:center">64位IEEE浮点数</td><td style="text-align:center">unrestricted double</td><td style="text-align:center">double</td></tr></tbody></table><h2 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL"></a>URL.createObjectURL</h2><p><code>URL.createObjectURL()</code> 静态方法会创建一个 <code>DOMString</code>，其中包含一个表示参数中给出的对象的<code>URL</code>。这个 <code>URL</code> 的<strong>生命周期</strong>和创建它的窗口中的 <code>document</code> 绑定。这个新的URL 对象表示指定的 <code>File</code> 对象或 <code>Blob</code> 对象。</p><blockquote><p><code>DOMString</code>可以说是会话<strong>(session)</strong>级的，所以你在新的<code>tab</code>打开也就无效了</p></blockquote><p>video标签的src属性，不管是相对路径，绝对路径，或者一个网络地址，归根结底都是指向一个<font color="#ff502c">文件资源的地址</font>。上面的<code>Blob</code>其实是一个可以当作<font color="#ff502c">文件</font>用的<font color="#ff502c">二进制数据</font>，那么只要我们可以生成一个指向<code>Blob</code>的地址，再通过<font color="#ff502c">URL.createObjectURL</font>生成一个临时地址，赋值给你<code>video</code>标签的<code>src</code>属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> videoURL = URL.createObjectURL(video); <span class="comment">// blob:https://www.aaa.com/12212aa1s1</span></span><br></pre></td></tr></table></figure></p><p>通过<font color="#ff502c">URL.revokeObjectURL(objectURL)</font> 释放一个之前已经存在的、通过调用 <font color="#ff502c">URL.createObjectURL()</font> 创建的 <code>URL</code> 对象。</p><blockquote><p>如果是以文件协议打开的html文件（即url为file://开头），则地址中<a href="http://localhost:1234会变成null，而且此时这个Blob" target="_blank" rel="noopener">http://localhost:1234会变成null，而且此时这个Blob</a> URL是无法直接访问的。</p></blockquote><h2 id="HLS和MPEG-DASH"><a href="#HLS和MPEG-DASH" class="headerlink" title="HLS和MPEG DASH"></a>HLS和MPEG DASH</h2><p>HLS （HTTP Live Streaming）, 是由 Apple 公司实现的基于 HTTP 的媒体流传输协议。HLS以ts为传输格式，m3u8为索引文件（文件中包含了所要用到的ts文件名称，时长等信息，可以用播放器播放，也可以用vscode之类的编辑器打开查看），在移动端大部分浏览器都支持，也就是说你可以用video标签直接加载一个m3u8文件播放视频或者直播，但是在pc端，除了苹果的Safari，需要引入库来支持。<br>用到此方案的视频网站比如优酷，可以在视频播放时通过调试查看Network里的xhr请求，会发现一个m3u8文件，和每隔一段时间请求几个ts文件。<br><img src="../../images/http/https-1-1.png" alt="https"><br><img src="../../images/http/https-1-2.png" alt="https"><br>但是除了HLS，还有Adobe的HDS，微软的MSS，方案一多就要有个标准点的东西，于是就有了MPEG DASH。<br>DASH（Dynamic Adaptive Streaming over HTTP） ，是一种在互联网上传送动态码率的Video Streaming技术，类似于苹果的HLS，DASH会通过media presentation description (MPD)将视频内容切片成一个很短的文件片段，每个切片都有多个不同的码率，DASH Client可以根据网络的情况选择一个码率进行播放，支持在不同码率之间无缝切换。<br>Youtube，B站都是用的这个方案。这个方案索引文件通常是mpd文件（类似HLS的m3u8文件功能），传输格式推荐的是fmp4（Fragmented MP4）,文件扩展名通常为.m4s或直接用.mp4。所以用调试查看b站视频播放时的网络请求，会发现每隔一段时间有几个m4s文件请求。<br><img src="../../images/http/https-1-3.png" alt="https"><br>不管是HLS还是DASH们，都有对应的库甚至是高级的播放器方便我们使用，但我们其实是想要学习一点实现。其实抛开掉索引文件的解析拿到实际媒体文件的传输地址，摆在我们面前的只有一个如何将多个视频数据合并让video标签可以无缝播放。</p><blockquote><p>与之相关的一篇B站文章推荐给感兴趣的朋友：<a href="https://www.bilibili.com/read/cv855111/" target="_blank" rel="noopener">我们为什么使用DASH</a></p></blockquote><h2 id="MediaSource"><a href="#MediaSource" class="headerlink" title="MediaSource"></a>MediaSource</h2><p>video标签src指向一个视频地址，视频播完了再将src修改为下一段的视频地址然后播放，这显然不符合我们无缝播放的要求。其实有了我们前面Blob URL的学习，我们可能就会想到一个思路，用Blob URL指向一个视频二进制数据，然后不断将下一段视频的二进制数据添加拼接进去。这样就可以在不影响播放的情况下，不断的更新视频内容并播放下去，想想是不是有点流的意思出来了。<br>要实现这个功能我们要通过MediaSource来实现，MediaSource接口功能也很纯粹，作为一个媒体数据容器可以和HTMLMediaElement进行绑定。基本流程就是通过URL.createObjectURL创建容器的BLob URL，设置到video标签的src上，在播放过程中，我们仍然可以通过MediaSource.appendBuffer方法往容器里添加数据，达到更新视频内容的目的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line"><span class="comment">//视频资源存放路径，假设下面有5个分段视频 video1.mp4 ~ video5.mp4，第一个段为初始化视频init.mp4</span></span><br><span class="line"><span class="keyword">const</span> assetURL = <span class="string">"http://www.demo.com"</span>;</span><br><span class="line"><span class="comment">//视频格式和编码信息，主要为判断浏览器是否支持视频格式，但如果信息和视频不符可能会报错</span></span><br><span class="line"><span class="keyword">const</span> mimeCodec = <span class="string">'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'</span>; </span><br><span class="line"><span class="keyword">if</span> (<span class="string">'MediaSource'</span> <span class="keyword">in</span> <span class="built_in">window</span> &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123;</span><br><span class="line"><span class="keyword">const</span> mediaSource = <span class="keyword">new</span> MediaSource();</span><br><span class="line">video.src = URL.createObjectURL(mediaSource); <span class="comment">//将video与MediaSource绑定，此处生成一个Blob URL</span></span><br><span class="line">mediaSource.addEventListener(<span class="string">'sourceopen'</span>, sourceOpen); <span class="comment">//可以理解为容器打开</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//浏览器不支持该视频格式</span></span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'Unsupported MIME type or codec: '</span>, mimeCodec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sourceOpen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> mediaSource = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">const</span> sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNextVideo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//ajax代码实现翻看上文，数据请求类型为arraybuffer</span></span><br><span class="line">    ajax(url, <span class="function"><span class="keyword">function</span>(<span class="params">buf</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//往容器中添加请求到的数据，不会影响当下的视频播放。</span></span><br><span class="line">    sourceBuffer.appendBuffer(buf);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次appendBuffer数据更新完之后就会触发</span></span><br><span class="line">sourceBuffer.addEventListener(<span class="string">"updateend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//第一个初始化视频加载完就开始播放</span></span><br><span class="line">    video.play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="comment">//一段视频加载完成后，请求下一段视频</span></span><br><span class="line">    getNextVideo(<span class="string">`<span class="subst">$&#123;assetURL&#125;</span>/video<span class="subst">$&#123;i&#125;</span>.mp4`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="comment">//全部视频片段加载完关闭容器</span></span><br><span class="line">    mediaSource.endOfStream();</span><br><span class="line">    URL.revokeObjectURL(video.src); <span class="comment">//Blob URL已经使用并加载，不需要再次使用的话可以释放掉。</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//加载初始视频</span></span><br><span class="line">getNextVideo(<span class="string">`<span class="subst">$&#123;assetURL&#125;</span>/init.mp4`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这段代码修改自MDN的MediaSource词条中的示例代码，原例子中只有加载一段视频，我修改为了多段视频，代码里面很多地方还可以优化精简，这里没做就当是为了方便我们看逻辑。<br>此时我们已经基本实现了一个简易的流媒体播放功能，如果愿意可以再加入m3u8或mpd文件的解析，设计一下UI界面，就可以实现一个流媒体播放器了。<br>最后提一下一个坑，很多人跑了MDN的MediaSource示例代码，可能会发现使用官方提供的视频是没问题的，但是用了自己的mp4视频就会报错，这是因为fmp4文件扩展名通常为.m4s或直接用.mp4，但却是特殊的mp4文件。</p><h2 id="Fragmented-MP4"><a href="#Fragmented-MP4" class="headerlink" title="Fragmented MP4"></a>Fragmented MP4</h2><p>通常我们使用的mp4文件是嵌套结构的，客户端必须要从头加载一个 MP4 文件，才能够完整播放，不能从中间一段开始播放。而Fragmented MP4（简称fmp4），就如它的名字碎片mp4，是由一系列的片段组成，如果服务器支持 byte-range 请求，那么，这些片段可以独立的进行请求到客户端进行播放，而不需要加载整个文件。<br>我们可以通过这个网站判断一个mp4文件<a href="http://nickdesaulniers.github.io/mp4info/" target="_blank" rel="noopener">是否为Fragmented MP4网站地址</a>。<br>我们通过<a href="https://ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a>或<a href="https://www.bento4.com/" target="_blank" rel="noopener">Bento4</a>的mp4fragment来将普通mp4转换为Fragmented MP4，两个工具都是命令行工具，按照各自系统下载下来对应的压缩包，解压后设置环境变量指向文件夹中的bin目录，就可以使用相关命令了。<br>Bento4的mp4fragment，没有太多参数，命令如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp4fragment video.mp4 video-fragmented.mp4</span><br></pre></td></tr></table></figure></p><p>FFmpeg会需要设置一些参数，命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i video.mp4 -movflags empty_moov+default_base_moof+frag_keyframe video-fragmented.mp4</span><br></pre></td></tr></table></figure></p><blockquote><p>Tips：网上大部分的资料中转换时是不带default_base_moof这个参数的，虽然可以转换成功，但是经测试如果不添加此参数网页中MediaSource处理视频时会报错。<br>视频的切割分段可以使用Bento4的mp4slipt，命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp4split video.mp4 --media-segment video-%llu.mp4 --pattern-parameters N</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="来个实例"><a href="#来个实例" class="headerlink" title="来个实例"></a>来个实例</h2><p>服务端使用的<code>nodejs</code>，<code>koa</code>框架，这里的操作很简单，就是用<font color="#ff502c">fs.readFileSync</font>直接打开视频文件，得到的<code>data</code>结果是二进制的数据，直接作为结果返回。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="built_in">require</span>(<span class="string">'buffer'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">const</span> video = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// open 一个放在服务器的视频</span></span><br><span class="line">        <span class="keyword">let</span> data = fs.readFileSync(<span class="string">'XXX.XXX.XXX/simple.mp4'</span>);</span><br><span class="line">        ctx.response.body = data;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(&#123;</span><br><span class="line">            status: <span class="number">500</span>,</span><br><span class="line">            message: <span class="string">'视频传输错误'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">router.get(<span class="string">'/video'</span>, video);</span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line">app.liseten(<span class="number">3002</span>);</span><br></pre></td></tr></table></figure></p><p>前端代码，这里使用的最原生的<font color="#ff502c">XMLHttpRequest</font>对象语法，这里最重要的一点是要设置<font color="#ff502c">responseType为blob</font>，这样接收到<code>response</code>直接就是一个<code>blob</code>对象供我们使用。这个<code>responseType</code>属性不属于<code>http</code>头部信息，而是ajax请求中XHR对象的属性(默认为””也就是text类型，而在一些封装XHR的框架中，一般把默认值设为json)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://localhost:3001/video'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取blob对象</span></span><br><span class="line">        <span class="keyword">let</span> blob = <span class="keyword">this</span>.response</span><br><span class="line">        <span class="built_in">console</span>.log(blob)</span><br><span class="line">        <span class="comment">// 获取blob对象地址，并把值赋给容器</span></span><br><span class="line">        $(<span class="string">"#sound"</span>).attr(<span class="string">"src"</span>, URL.createObjectURL(blob));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure></p><p>这样就可以得到以blob:开头的临时url地址，而且在向服务端请求时页隐藏了真实的视频地址.</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p><a href="https://juejin.im/post/5d1ea7a8e51d454fd8057bea" target="_blank" rel="noopener">为什么视频网站的视频链接地址是blob？</a><br><a href="https://www.jianshu.com/p/04727924273d" target="_blank" rel="noopener">通过BLOB加密视频文件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      https+blob 视频播放
    
    </summary>
    
      <category term="Http" scheme="http://asyncnode.com/categories/Http/"/>
    
    
      <category term="Http" scheme="http://asyncnode.com/tags/Http/"/>
    
      <category term="Https" scheme="http://asyncnode.com/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>深入理解css系列 css中padding</title>
    <link href="http://asyncnode.com/blog/css/css-padding.html"/>
    <id>http://asyncnode.com/blog/css/css-padding.html</id>
    <published>2019-07-26T11:44:21.000Z</published>
    <updated>2019-10-24T05:12:36.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/blog/css/css-absolute.html">深入理解 css 系列 css 中 absolute</a><br><a href="/blog/css/css-border.html">深入理解 css 系列 css 中 border</a><br><a href="/blog/css/css-float.html">深入理解 css 系列 css 中 float</a><br><a href="/blog/css/css-relative.html">深入理解 css 系列 css 中 relative</a><br><a href="/blog/css/css-margin.html">深入理解 css 系列 css 中 margin</a><br><a href="/blog/css/css-padding.html">深入理解 css 系列 css 中 padding</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p><strong>padding</strong> 简写属性在一个声明中设置所有内边距属性。所有浏览器都支持 <code>padding</code> 属性，这里就多做赘述了，但是要注意以下：</p><blockquote><p>任何的版本的 <code>Internet Explorer</code> （包括 IE8）都不支持属性值 <code>&quot;inherit&quot;</code>。</p></blockquote><p><strong>可能的值</strong></p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">auto</td><td style="text-align:center">浏览器计算内边距。</td></tr><tr><td style="text-align:center">length</td><td style="text-align:center">规定以具体单位计的内边距值，比如像素（px）、厘米(cm)等。默认值是 0px。</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center"><strong>规定基于父元素的宽度的百分比的内边距。</strong></td></tr><tr><td style="text-align:center">inherit</td><td style="text-align:center">规定应该从父元素继承内边距。</td></tr></tbody></table><blockquote><p><strong>padding 不支持负值</strong></p></blockquote><p>本篇目录：</p><ul><li><code>padding</code> 对 <code>block</code> 元素的影响</li><li><code>padding</code> 对 <code>inline</code> 元素的影响</li><li>关于 <code>padding</code> 的百分比值</li><li><code>padding</code> 的应用场景</li></ul><h2 id="padding-对-block-的影响"><a href="#padding-对-block-的影响" class="headerlink" title="padding 对 block 的影响"></a>padding 对 block 的影响</h2><ul><li><code>width</code> 固定</li><li><code>width</code> 为 <code>auto</code> 或者 <code>box-sizing</code> 为 <code>border-box</code> 的时候</li></ul><h3 id="width-固定"><a href="#width-固定" class="headerlink" title="width 固定"></a>width 固定</h3><p><code>padding</code> 是会影响元素的尺寸的，<code>padding</code> 会对 <code>block</code> 元素的尺寸产生影响。代码如下：<br><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>css</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示结果如下：<br><img src="../../images/css/css-padding-1-1.png" alt="css padding"><br>验证了上面的猜测，<strong>padding 会对 block 元素的尺寸产生影响</strong>；</p><h3 id="width-为-auto-或者-box-sizing-为-border-box-的时候"><a href="#width-为-auto-或者-box-sizing-为-border-box-的时候" class="headerlink" title="width 为 auto 或者 box-sizing 为 border-box 的时候"></a>width 为 auto 或者 box-sizing 为 border-box 的时候</h3><p>首先要知道 <code>box-sizing</code> 为 <code>border-box</code> 代表什么意思，其实就是盒模型为 ie 模式。ie 的盒模型就是他的<strong>content+padding+border</strong>都算在盒模型内。<br>这个用上面的例子就不太合适，看下面的一个例子：<br><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  文字的应该怎么放置？</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>css</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示如下：<br><img src="../../images/css/padding-1-2.png" alt="css padding"></p><!-- ![css padding](../../images/css/padding-1-4.png) --><p>对于 <code>block</code> 水平元素，但是<strong>width:auto</strong>或<strong>box-sizing 为 border-box</strong>的时候 <code>padding</code><strong>不会影响</strong>元素的尺寸。</p><p>修改 css 代码如下：<br><strong>css</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/css/padding-1-3.png" alt="css padding"><br><img src="../../images/css/padding-1-4.png" alt="css padding"><br>当<code>padding</code>大小<strong>超过宽度</strong>时，宽度按<code>padding的宽度</code>显示，里面的<strong>文字按最小宽度</strong>显示。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li><strong>padding 值大于元素本身的宽度时，一定会影响尺寸</strong>。</li><li><strong>width 非 auto，padding 影响尺寸</strong>。</li><li><strong>width 为 auto 或 box-sizing 为 border-box，同时 padding 值没有超过元素本身的宽度，不影响尺寸</strong>。</li></ul><h2 id="padding-对-inline-元素的影响"><a href="#padding-对-inline-元素的影响" class="headerlink" title="padding 对 inline 元素的影响"></a>padding 对 inline 元素的影响</h2><p>在上面代码的基础上修改代码如下：<br><strong>css</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果如下：<br><img src="../../images/css/padding-1-5.png" alt="css padding"><br><img src="../../images/css/padding-1-6.png" alt="css padding"><br><strong>水平 padding 影响尺寸，垂直 padding 不影响尺寸，但会影响背景色（占据空间）</strong>。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul><li><strong>水平 padding 影响尺寸，垂直 padding 不影响尺寸，但会影响背景色（占据空间）</strong>。</li></ul><h2 id="关于-padding-的百分比值"><a href="#关于-padding-的百分比值" class="headerlink" title="关于 padding 的百分比值"></a>关于 padding 的百分比值</h2><ul><li>关于 block 元素的 padding 的百分比值</li><li>关于 inline 元素的 padding 的百分比值</li></ul><h3 id="block-元素的-padding-的百分比值"><a href="#block-元素的-padding-的百分比值" class="headerlink" title="block 元素的 padding 的百分比值"></a>block 元素的 padding 的百分比值</h3><p><strong>padding 百分比均是相对于父元素的宽度计算的</strong>。实现效果如下：</p><p><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>css</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="comment">/* width: 100px; */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果如下，可以明显看到<code>box</code>的宽高都是<code>100px</code>;<br><img src="../../images/css/padding-1-7.png" alt="css padding"><br><img src="../../images/css/padding-1-8.png" alt="css padding"></p><h3 id="inline-水平元素的-padding-百分比值"><a href="#inline-水平元素的-padding-百分比值" class="headerlink" title="inline 水平元素的 padding 百分比值"></a>inline 水平元素的 padding 百分比值</h3><p>注意以下几点：</p><ul><li>同样相对于宽度计算</li><li>默认的高度宽度细节有差异</li><li>padding 会断行</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#8ec63f</span>;</span></span><br><span class="line">    padding: 50%;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>若干文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="../../images/css/padding-1-9.png" alt="css-padding" width="50%"><br><img src="../../images/css/padding-1-10.png" alt="css-padding" width="50%"></p><p><code>iniline</code>元素的垂直 padding 会让“幽灵空白节点”显现，也就是规范中的“strut”出现。</p><h2 id="标签元素的内置-paading"><a href="#标签元素的内置-paading" class="headerlink" title="标签元素的内置 paading"></a>标签元素的内置 paading</h2><ul><li>ol/li 元素内置 padding-left, 但单位是 px 不是 em;<ol><li>例如 chrom 浏览器下是 40px;</li><li>所以如果字号很小，间距就会很开；</li><li>如果字号很大，序号就会爬到容器外面</li></ol></li></ul><blockquote><p>备注：文字大小一般为 12px~14px ，padding-left 为 22px~25px，基本可以实号与下面的内容对齐。</p></blockquote><ul><li>所有浏览器 input/textarea 输入框内置 padding</li><li>所有浏览器 button 按钮内置 padding</li><li>所有浏览器 radio/chexbox 单复选框无内置 padding</li><li>button 按钮元素的 padding 最难控制<br>button 使用：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"btn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">label &#123; display: inline-block; line-height: 20px; padding: 10px; &#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现一个在任何浏览器上高度为<code>40px</code>按钮。</p><h2 id="padding-的应用场景"><a href="#padding-的应用场景" class="headerlink" title="padding 的应用场景"></a>padding 的应用场景</h2><ul><li>实现 3 道杠效果</li><li>实现白眼效果</li><li>1:1 头图布局</li><li>实现等高布局</li><li>两栏自适应布局</li></ul><h3 id="实现-3-道杠效果"><a href="#实现-3-道杠效果" class="headerlink" title="实现 3 道杠效果"></a>实现 3 道杠效果</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    padding: 15px 0;</span><br><span class="line">    border-top: 30px solid currentColor;</span><br><span class="line">    border-bottom: 30px solid currentColor;</span><br><span class="line">    background-color: currentColor;</span><br><span class="line">    background-clip: content-box;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>备注：background-clip:content-box ; /<strong>背景色不在 padding 区域显示</strong>/</p></blockquote><p>其实自己实现一个是最好的，借鉴一张别人的图如下：<br><img src="../../images/css/padding-2-1.png" alt="css-padding" width="50%"></p><h3 id="实现白眼效果"><a href="#实现白眼效果" class="headerlink" title="实现白眼效果"></a>实现白眼效果</h3><p><img src="../../images/css/padding-2-2.png" alt="css-padding" width="50%"></p><blockquote><p>备注：background-clip:content-box ; /<strong>背景色不在padding区域显示</strong>/</p></blockquote><h3 id="实现一个-1-1-布局"><a href="#实现一个-1-1-布局" class="headerlink" title="实现一个 1:1 布局"></a>实现一个 1:1 布局</h3><p><img src="../../images/css/padding-2-3.png" alt="css-padding" width="50%"></p><h3 id="实现等高布局"><a href="#实现等高布局" class="headerlink" title="实现等高布局"></a>实现等高布局</h3><p><img src="../../images/css/padding-2-4.png" alt="css-padding" width="50%"></p><blockquote><p>很大的 margin-bottom 负值，再用很大的 padding-bottom 填充缺失的空间</p></blockquote><h3 id="两栏自适应布局"><a href="#两栏自适应布局" class="headerlink" title="两栏自适应布局"></a>两栏自适应布局</h3><p><img src="../../images/css/padding-2-5.png" alt="css-padding" width="50%"><br><img src="../../images/css/padding-2-6.png" alt="css-padding" width="50%"></p><h2 id="总计"><a href="#总计" class="headerlink" title="总计"></a>总计</h2><font color="#ff502c">padding 对 block 元素的影响</font><ul><li><strong>padding 值大于元素本身的宽度时，一定会影响尺寸</strong>。</li><li><strong>width 非 auto，padding 影响尺寸</strong>。</li><li><strong>width 为 auto 或 box-sizing 为 border-box，同时 padding 值没有超过元素本身的宽度，不影响尺寸</strong></li></ul><font color="#ff502c">padding 对 inline 元素的影响</font><ul><li><strong>水平 padding 影响尺寸，垂直 padding 不影响尺寸，但会影响背景色（占据空间）</strong></li></ul><font color="#ff502c">关于 padding 的百分比值</font><ul><li><strong>block 元素的 padding 的百分比值</strong><ol><li>padding 百分比均是相对于父元素的宽度计算的</li></ol></li><li><strong>inline 水平元素的 padding 百分比值</strong><ol><li>同样相对于宽度计算</li><li>默认的高度宽度细节有差异</li><li>padding 会断行</li></ol></li></ul><font color="#ff502c">padding 的应用场景</font><ul><li><strong>实现 3 道杠效果</strong></li><li><strong>实现白眼效果</strong></li><li><strong>1:1 头图布局</strong></li><li><strong>实现等高布局</strong></li><li><strong>两栏自适应布局</strong></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.cnblogs.com/qianxunpu/p/8303228.html" target="_blank" rel="noopener">css 之深入理解 padding</a><br><a href="https://www.imooc.com/learn/710" target="_blank" rel="noopener">CSS 深入理解之 padding</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      深入理解css中padding，其实padding并没有认为那没简单。
    
    </summary>
    
      <category term="Css" scheme="http://asyncnode.com/categories/Css/"/>
    
    
      <category term="Css" scheme="http://asyncnode.com/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>深入Vue系列 next-tick原理和源码解析</title>
    <link href="http://asyncnode.com/blog/vue/vue-next-tick.html"/>
    <id>http://asyncnode.com/blog/vue/vue-next-tick.html</id>
    <published>2019-07-23T04:32:54.000Z</published>
    <updated>2019-10-24T05:12:36.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 vue 的官方文档中有一个 API 叫做 nextTick，将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$nextTick([callback]);</span><br></pre></td></tr></table></figure><ul><li>参数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line">[callback];</span><br></pre></td></tr></table></figure><p><strong>用法</strong><br>放在<code>Vue.nextTick()</code>回调函数中的执行的应该是<strong>涉及 DOM</strong>操作的 JavaScript 代码。</p><p>Vue 的响应式原理：在 data 选项里所有属性都会被<code>watcher</code>监控，当修改了<code>data</code>的某一个值，并不会<strong>立即</strong>反映到视图中。Vue 会将我们对<code>data</code>的更改放到<code>watcher</code>的一个队列中（异步），只有在当前任务空闲时才会去执行<code>watcher</code>队列任务。这就有一个延迟时间，所以对 dom 的操作要放在<code>$nextTick</code>中来操作，才能获取到最新的<code>dom</code>。</p><blockquote><p><a href="/blog/vue/vue-definedProperty.html">响应式对象 Observer</a> &gt; <a href="/blog/vue/vue-dep.html">依赖收集 Dep</a> &gt; <a href="/blog/vue/vue-notify.html">派发更新 Watcher</a></p></blockquote><p><code>nextTick</code> 是 Vue 的一个<strong>核心</strong>实现，如果还不了解 js 运行机制，可以看一下另一篇文章<a href="/blog/javascript/evenloop.html">js 运行机制</a>，这里就不多赘述了。</p><p>在浏览器环境中常见的 macro task 和 micro task 如下：<br><strong>macro task</strong>：</p><ul><li><code>setTimeout、setTimeInterval</code></li><li><code>MessageChannel</code></li><li><code>postMessage</code></li><li><code>setImmediate</code></li><li><code>requestAnimationFrame</code></li><li><code>I/O</code></li><li><code>UI 渲染</code>a</li></ul><p><strong>micro task</strong>：</p><ul><li>MutationObsever</li><li>Promise.then</li><li>process.nextTick</li></ul><h2 id="vue-源码解析"><a href="#vue-源码解析" class="headerlink" title="vue 源码解析"></a>vue 源码解析</h2><p>在<a href="/blog/vue/vue-notify.html">派发更新 Watcher</a>里面有用到<code>nextTick(flushScheduerQueue)</code>，其实就是<code>vue</code>对派发更新的一个优化。下面直接看源码，在 src/core/util/next-tick.js 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nextTick，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。</span></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">"shared/util"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">"./error"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">"./env"</span>;</span><br><span class="line"><span class="comment">// flushScheduerQueue</span></span><br><span class="line"><span class="comment">/*存放异步执行的回调*/</span></span><br><span class="line"><span class="keyword">const</span> callbacks = [];</span><br><span class="line"><span class="comment">//一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*下一个tick时的回调*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//复制callback</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//清除callbacks</span></span><br><span class="line">  callbacks.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    <span class="comment">//触发callback的回调函数</span></span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span></span><br><span class="line"><span class="comment">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span></span><br><span class="line"><span class="comment">// microtasks have too high a priority and fire in between supposedly</span></span><br><span class="line"><span class="comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span></span><br><span class="line"><span class="comment">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span></span><br><span class="line"><span class="comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span></span><br><span class="line"><span class="comment">// Here we use microtask by default, but expose a way to force (macro) task when</span></span><br><span class="line"><span class="comment">// needed (e.g. in event handlers attached by v-on).</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  其大概的意思就是：在Vue2.4之前的版本中，nextTick几乎都是基于microTask实现的，</span></span><br><span class="line"><span class="comment">  但是由于microTask的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，</span></span><br><span class="line"><span class="comment">  就会导致一些诡异的问题；但是如果全部都改成macroTask，对一些有重绘和动画的场</span></span><br><span class="line"><span class="comment">  景也会有性能的影响。所以最终nextTick采取的策略是默认走microTask，对于一些DOM</span></span><br><span class="line"><span class="comment">  的交互事件，如v-on绑定的事件回调处理函数的处理，会强制走macroTask。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"><span class="keyword">let</span> microTimerFunc;</span><br><span class="line"><span class="keyword">let</span> macroTimerFunc;</span><br><span class="line"><span class="keyword">let</span> useMacroTask = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine (macro) task defer implementation.</span></span><br><span class="line"><span class="comment">// Technically setImmediate should be the ideal choice, but it's only available</span></span><br><span class="line"><span class="comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span></span><br><span class="line"><span class="comment">// events triggered in the same loop is by using MessageChannel.</span></span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而对于macroTask的执行，Vue优先检测是否支持原生setImmediate（高版本IE和Edge支持），</span></span><br><span class="line"><span class="comment">// 不支持的话再去检测是否支持原生MessageChannel，如果还不支持的话为setTimeout(fn, 0)。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">"undefined"</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="keyword">typeof</span> MessageChannel !== <span class="string">"undefined"</span> &amp;&amp;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    在Vue 2.4版本以前使用的MutationObserver来模拟异步任务。</span></span><br><span class="line"><span class="comment">    而Vue 2.5版本以后，由于兼容性弃用了MutationObserver。</span></span><br><span class="line"><span class="comment">    Vue 2.5+版本使用了MessageChannel来模拟macroTask。</span></span><br><span class="line"><span class="comment">    除了IE以外，messageChannel的兼容性还是比较可观的。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">"[object MessageChannelConstructor]"</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    可见，新建一个MessageChannel对象，该对象通过port1来检测信息，port2发送信息。</span></span><br><span class="line"><span class="comment">    通过port2的主动postMessage来触发port1的onmessage事件，</span></span><br><span class="line"><span class="comment">    进而把回调函数flushCallbacks作为macroTask参与事件循环。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = flushCallbacks;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine microtask defer implementation.</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">"undefined"</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">    <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// fallback to macro</span></span><br><span class="line">  microTimerFunc = macroTimerFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap a function so that if any code inside triggers state change,</span></span><br><span class="line"><span class="comment"> * the changes are queued using a (macro) task instead of a microtask.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    推送到队列中下一个tick时执行</span></span><br><span class="line"><span class="comment">    cb 回调函数</span></span><br><span class="line"><span class="comment">    ctx 上下文</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withMacroTask</span>(<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    fn._withTask ||</span><br><span class="line">    (fn._withTask = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      useMacroTask = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">const</span> res = fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      useMacroTask = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">"nextTick"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      microTimerFunc();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nextTick</code>这就是我们在上一节执行 <code>nextTick(flushSchedulerQueue)</code> 所用到的函数。它的逻辑也很简单，把传入的回调函数 <code>cb</code> 压入 <code>callbacks</code> 数组，最后一次性地根据 <code>useMacroTask</code> 条件执行 <code>macroTimerFunc</code> 或者是 <code>microTimerFunc</code>，而它们都会在下一个 <code>tick</code> 执行 <code>flushCallbacks</code>。<br><code>flushCallbacks</code> 这个方法就是挨个<strong>同步</strong>的去执行<code>callbacks</code>中的回调函数，<code>callbacks</code>中的回调函数是在调用 <code>nextTick</code> 的时候添加进去的；<br>这里使用 <code>callbacks</code> 而不是直接在 <code>nextTick</code> 中执行回调函数的原因是保证在同一个 <code>tick</code> 内多次执行 <code>nextTick</code>，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 <code>tick</code> 执行完毕。<br>注意这里有个比较难理解的地方，第一次调用 <code>nextTick</code> 的时候 <code>pending</code> 为<code>false</code>。<br>此时已经<code>push</code>到浏览器<code>event loop</code>中一个<strong>宏任务</strong>或<strong>微任务</strong>的<code>task</code>，如果在没有<code>flush</code>掉的情况下继续往<code>callbacks</code>里面添加。<br>那么在执行这个占位<code>queue</code>的时候会执行之后添加的回调，所以<code>macroTimerFunc</code>、<code>microTimerFunc</code> 相当于<code>task queue</code>的占位。<br>以后 <code>pending</code> 为<code>true</code>则继续往占位<code>queue</code>里面添加，<code>event loop</code>轮到这个<code>task queue</code>的时候将一并执行。<br>执行 <code>flushCallbacks</code> 时 <code>pending</code> 置<code>false</code>，允许下一轮执行 <code>nextTick</code> 时往<code>event loop</code>占位。</p><p><strong>macroTimerFunc、microTimerFunc</strong><br><code>next-tick.js</code> 申明了 <code>microTimerFunc</code> 和 <code>macroTimerFunc</code> 2 个变量，它们分别对应的是 <code>micro task</code> 的函数和 <code>macro task</code> 的函数。对于 <code>macro task</code> 的实现，优先检测是否支持原生 <code>setImmediate</code>，这是一个高版本 <code>IE</code> 和 <code>Edge</code>才支持的特性，不支持的话再去检测是否支持原生的 <code>MessageChannel</code>，如果也不支持的话就会降级为 <code>setTimeout</code> 0；而对于 <code>micro task</code> 的实现，则检测浏览器是否原生支持 <code>Promise，</code>不支持的话直接指向 <code>macro task</code> 的实现。</p><p><strong>nextTick 实现</strong></p><ol><li>首先 <code>nextTick</code> 把传入的 <code>cb</code> 回调函数用 <code>try-catch</code> 包裹后放在一个<strong>匿名函数</strong>中推入<code>callbacks</code>数组中。<br>这么做是因为防止单个 <code>cb</code> 如果执行错误不至于让整个<strong>JS 线程挂掉</strong>。<br>每个 cb 都包裹是防止这些回调函数如果执行错误不会相互影响，比如前一个抛错了后一个仍然可以执行。</li><li>然后检查 <code>pending</code> 状态，这个跟之前介绍的 <code>queueWatcher</code> 中的 <code>waiting</code> 是一个意思。<br>它是一个标记位，一开始是 <code>false</code> 在进入<code>macroTimerFunc</code>、<code>microTimerFunc</code>方法前被置为 <code>true</code>。因此下次调用 <code>nextTick</code> 就不会进入<code>macroTimerFunc</code>、<code>microTimerFunc</code>方法。<br>这两个方法中会在下一个 <code>macro/micro tick</code> 时候 <code>flushCallbacks</code> 异步的去执行<code>callbacks队</code>列中收集的任务，而 <code>flushCallbacks</code> 方法在执行一开始会把 <code>pending</code> 置 <code>false</code>。<br>因此下一次调用 <code>nextTick</code> 时候又能开启新一轮的 <code>macroTimerFunc</code>、<code>microTimerFunc</code>，这样就形成了 vue 中的 <code>event loop</code>。</li><li>最后检查是否传入了 <code>cb</code>。因为 <code>nextTick</code> 还支持 Promise 化的调用：<code>nextTick().then(() =&gt; {})</code>。所以如果没有传入 <code>cb</code> 就直接<code>return了一个Promise</code>实例，并且把<code>resolve</code>传递给<code>_resolve</code>。这样后者执行的时候就跳到我们调用的时候传递进 then 的方法中。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;span id=<span class="string">'name'</span> ref=<span class="string">'name'</span>&gt;&#123;&#123; name &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click='change'&gt;change name&lt;/</span>button&gt;</span><br><span class="line">    &lt;div id=<span class="string">'content'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'userName'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change() &#123;</span><br><span class="line">        <span class="keyword">const</span> $name = <span class="keyword">this</span>.$refs.name</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'同步方式1：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML)</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setter前：'</span> + $name.innerHTML))</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">' setterName '</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'同步方式2：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML)</span><br><span class="line">        <span class="comment">// setTimeout(() =&gt; &#123;console("setTimeout方式：" + this.$refs.name.innerHTML)&#125;</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'setTimeout方式：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setter后：'</span> + $name.innerHTML))</span><br><span class="line">        <span class="keyword">this</span>.$nextTick().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Promise方式：'</span> + $name.innerHTML))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>执行结果如下图所示：<br><img src="../../images/vue/vue-nextTick-1-1.png" alt="vue-nextTick"></p><ol><li>同步方式： 当把<code>data</code>中的<code>name</code>修改之后，此时会触发<code>name</code>的 <code>setter</code> 中的 <code>dep.notify</code> 通知依赖本<code>data</code>的<code>render watcher</code>去 <code>update</code>，<code>update</code> 会把 <code>flushSchedulerQueue</code> 函数传递给 <code>nextTick</code>，<code>render watcher</code>在 <code>flushSchedulerQueue</code> 函数运行时 <code>watcher.run</code> 再走 <code>diff -&gt; patch</code> 那一套重渲染 <code>re-render</code> 视图，这个过程中会重新依赖收集，这个过程是异步的；所以当我们直接修改了<code>name</code>之后打印，这时异步的改动还没有被 <code>patch</code> 到视图上，所以获取视图上的 DOM 元素还是原来的内容。</li><li>setter 前： <code>setter</code>前为什么还打印原来的是原来内容呢，是因为 <code>nextTick</code> 在被调用的时候把回调挨个<code>push</code>进<code>callbacks</code>数组，之后执行的时候也是 for 循环出来挨个执行，所以是类似于队列这样一个概念，先入先出；在修改<code>name</code>之后，触发把<code>render watcher</code>填入 <code>schedulerQueue</code> 队列并把他的执行函数 <code>flushSchedulerQueue</code> 传递给 <code>nextTick</code> ，此时<code>callbacks</code>队列中已经有了 <code>setter</code>前函数 了，因为这个 <code>cb</code> 是在 <code>setter</code>前函数 之后被<code>push</code>进<code>callbacks</code>队列的，那么先入先出的执行<code>callbacks</code>中回调的时候先执行 <code>setter</code>前函数，这时并未执行<code>render watcher</code>的 <code>watcher.run</code>，所以打印 DOM 元素仍然是原来的内容。</li><li>setter 后： <code>setter</code>后这时已经执行完 <code>flushSchedulerQueue</code>，这时<code>render watcher</code>已经把改动 <code>patch</code> 到视图上，所以此时获取 DOM 是改过之后的内容。</li><li>Promise 方式： 相当于 <code>Promise.then</code> 的方式执行这个函数，此时 DOM 已经更改。</li><li>setTimeout 方式： 最后执行<code>macro task</code>的任务，此时 DOM 已经更改。</li></ol><p>注意，在执行 <code>setter</code>前函数 这个异步任务之前，同步的代码已经执行完毕。异步的任务都还未执行，所有的 <code>$nextTick</code> 函数也执行完毕。所有回调都被<code>push</code>进了<code>callbacks</code>队列中等待执行，所以在<code>setter</code>前函数执行的时候。此时<code>callbacks</code>队列是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[setter前函数, flushSchedulerQueue, setter后函数, <span class="built_in">Promise</span>方式函数];</span><br></pre></td></tr></table></figure><p>它是一个<code>micro task</code>队列，执行完毕之后执行<code>macro task</code> <code>setTimeout</code>，所以打印出上面的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>nextTick</code>是把要执行的任务推入到一个队列中，在下一个<code>tick</code>同步执行</li><li>数据改变后触发渲染<code>watcher</code>的<code>update</code>，但是<code>watchers</code>的<code>flush</code>是在<code>nextTick</code>后，所以重新渲染是异步的</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/next-tick.html#js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">nextTick</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a><br><a href="https://juejin.im/post/5b50760f5188251ad06b61be" target="_blank" rel="noopener">Vue 源码阅读 - 批量异步更新与 nextTick 原理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Vue的next-tick其实也是在eventloop的原理实现的
    
    </summary>
    
      <category term="Vue" scheme="http://asyncnode.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://asyncnode.com/tags/Vue/"/>
    
  </entry>
  
</feed>
