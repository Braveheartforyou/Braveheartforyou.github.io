<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式系列 ———— mvc和mvvm到底是什么</title>
    <url>/blog/mode/mode-mvc-mvvm.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝系列 ———— 分析lodash中的deepcopy</title>
    <url>/blog/javascript/javascript-loadsh-deepcopy.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝系列 ———— 自己通过递归实现一个深拷贝</title>
    <url>/blog/javascript/javascript-deepcopy.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝系列 ———— 自己实现一个JSON.stringify和JSON.parse</title>
    <url>/blog/javascript/javascript-paser-stringify.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝系列 ———— 什么是深拷贝、浅拷贝、Object.assign</title>
    <url>/blog/es6/es6-assign.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>ES系列 ———— Object.defineProperty和Proxy的对比</title>
    <url>/blog/es6/es-defineproperty-proxy.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在前两篇文章中分别介绍了<code>Object.defineProperty</code>和<code>Proxy</code>两个新的特性，其实看起来<code>Proxy</code>更像是对<code>Object.defineProperty</code>的一种补充和完善(个人见解)。当然不是说<code>Object.defineProperty</code>很差，感觉更像是一开始的定位是为了处理对象的特定属性，但是在<code>Vue</code>等等框架的中被用来劫持整个对象属性，所以后面就出来了<code>Proxy</code>，更强大的劫持功能。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>根据上面两篇文章的介绍，大致优缺点如下：</p>
<p><strong><em>Proxy相对于defineProperty的优点</em></strong></p>
<ul>
<li>对于对象已有属性：<code>Object.defineProperty</code>只能劫持对象的单个属性，如果想劫持整个对象就要<strong>循环递归</strong>调用<code>Object.defineProperty</code>。而<code>Proxy</code>拦截整个对象，并且返回一下新的对象。</li>
<li>对于对象新增属性：<code>Proxy</code>劫持整个对象，对于新增的属性自动拦截。而<code>Object.defineProperty</code>需要<strong>重新劫持</strong>新增的属性</li>
<li>对于数组操作： <code>Object.defineProperty</code>无法监控到数组下标的变化。而<code>Proxy</code>可以监听数组变化。</li>
<li>拦截或劫持方法： <code>Object.defineProperty</code>描述符基本上分为两类<strong>数据描述符</strong>、<strong>存取描述符</strong>、<strong>通用描述符</strong>三种。而<code>Proxy</code>中有<strong>13</strong>种<strong>traps</strong>方法供你选择。</li>
<li>是否支持取消劫持： <code>Object.defineProperty</code>如果想取消劫持，只能<strong>重写</strong>描述符，但是<strong>configurable: false</strong>时就<strong>不能重写</strong>描述符了。而<code>Proxy</code>可以通过<code>Proxy.revocable</code>返回一个可取消的 <code>Proxy</code> 实例。</li>
<li>浏览器对劫持或拦截的支持： <code>Proxy</code>在后续应该会有更好的支持，不然<code>Vue</code>也不会修改核心代码。</li>
<li>性能： <code>Proxy</code>性能是比<code>Object.defineProperty</code>高的，在多个对象属性中。</li>
</ul>
<p><strong>Proxy相对于defineProperty的缺点</strong></p>
<ul>
<li><code>this指向</code>： <code>defineProperty</code>因为只绑定对象的属性，一般不会涉及到<code>this问题</code>。而<code>Proxy</code>返回的对象的<code>this</code>和<code>target</code>的<code>this</code>不相同。</li>
<li><code>使用难度</code>: 相对于<code>Proxy</code>的<strong>api</strong>，反而<code>defineProperty</code>上手更容易。</li>
</ul>
<p><strong>Proxy和defineProperty的一些注意事项</strong></p>
<ul>
<li><code>对象冻结</code>：无论是<code>defineProperty</code>、<code>Object.freeze</code>、<code>Object.seal（密封）</code>都不是深度冻结，如果想深度冻结只能递归实现。</li>
<li><code>this问题</code>： <code>Proxy</code>在使用是要注意<code>this</code>指向问题。</li>
</ul>
<h2 id="各自实现双向绑定"><a href="#各自实现双向绑定" class="headerlink" title="各自实现双向绑定"></a>各自实现双向绑定</h2><p>现在的三大框架非常的流行，在数据流中分为两派<code>React</code>的单项数据流，<code>Angluar/Vue</code>的双向数据流。其实<code>React</code>也是实现了的<strong>双向数据绑定</strong>的，只不过要通过<code>setState</code>来触发。</p>
<p>在不同框架中实现<strong>双向数据绑定</strong>也是不相同的，大致如下图所示：</p>
<p><a href="../../images/es/es-defineProperty.png">双向绑定</a></p>
<p><code>Object.defineProperty</code>和<code>proxy</code>都是<code>Vue</code>不同版本的重要组成部分，它们都是可以实现双向绑定中的<strong>数据劫持</strong>，其实也就是响应式对象，在以前的文章有<a href="/blog/vue/vue-definedProperty.html">深入Vue系列 Vue中的响应式对象</a>、<br><a href="/blog/vue/vue-dep.html">深入Vue系列 Vue中的依赖收集</a>、<a href="/blog/vue/vue-notify.html">深入Vue系列 Vue中的派发更新</a>，如果感兴趣的可以去看看。</p>
<p>依照<code>Vue</code>代码中的双向绑定思路，大致分为以下三步：</p>
<ul>
<li>把普通对象通过<code>Object.defineProperty</code>变为响应式对象</li>
<li>同时<code>getter</code>中收集依赖，也就是渲染<code>wather</code></li>
<li>在<code>setter</code>中派发更行</li>
</ul>
<p>下面写的实例不会这么复杂，当然也会仿照<code>Vue</code>源码中的<code>mvvm</code>去写。</p>
<h2 id="Object-defineProperty实现双向绑定"><a href="#Object-defineProperty实现双向绑定" class="headerlink" title="Object.defineProperty实现双向绑定"></a>Object.defineProperty实现双向绑定</h2><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><ul>
<li>劫持对象的<code>get、set</code>属性</li>
<li><code>input</code>事件更新对象值</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Static Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"mv"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"vm"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 对象配置描述符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"value"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"get value"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"set value"</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"mv"</span>).value = newVal;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"vm"</span>).innerHTML = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// input绑定时间更行对象中的value值</span></span><br><span class="line"><span class="keyword">const</span> InputDom = <span class="built_in">document</span>.getElementById(<span class="string">"mv"</span>);</span><br><span class="line">InputDom.addEventListener(<span class="string">"input"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">  obj.value = event.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这个代码只是简单了实现最简单的效果，在<code>input</code>中输入代码，同时更新到<code>p</code>中。</p>
<h3 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h3><h2 id="Proxy实现双向绑定"><a href="#Proxy实现双向绑定" class="headerlink" title="Proxy实现双向绑定"></a>Proxy实现双向绑定</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES系列 ———— Proxy</title>
    <url>/blog/es6/es6-proxy.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/es6/es6-definedproperty.html">ES深入系列 Object.defineProperty</a><br><a href="/blog/es6/es6-proxy.html">ES深入系列 Proxy</a><br><a href="/blog/es6/es6-definedproperty-proxy.html">ES深入系列 Object.defineProperty和Proxy的对比</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上一篇<a href="/blog/es6/es6-definedproperty.html">ES系列 Object.defineProperty</a>已经介绍过了<strong>Object.defineProperty</strong>相关内容，这篇文章中会介绍在<strong>Vue 3.x</strong>中代替<code>Object.defineProperty</code>的<code>Proxy</code>。<br>最后会介绍它们之间的<strong>优缺点</strong>和实现<strong>双向绑定简单实例</strong>。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>从字面上可以把<code>Proxy</code>理解为<strong>代理</strong>，但是感觉解释为类似于<strong>代理模式</strong>会更贴合一点。<strong>“阮大佬：Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。”</strong></p>
<p>首先要了解其中的<strong>术语</strong>。</p>
<ul>
<li><code>handler</code>: 包含陷阱（traps）的占位符对象。</li>
<li><code>traps</code>: 提供属性访问的方法。这类似于操作系统中捕获器的概念。</li>
<li><code>target</code>: 代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</li>
</ul>
<p><code>new Proxy(target, handler)</code>方式创建一下新的对象，参数如下：</p>
<ul>
<li><code>target (Object)</code>: 用<code>Proxy</code>包装的目标对象（可以是<strong>任何类型的对象，包括原生数组，函数，甚至另一个代理</strong>）。</li>
<li><code>handler(Object)</code>: 一个对象，其属性是当执行一个操作时定义代理的行为的函数。</li>
</ul>
<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p><code>handler</code> 对象是一个占位符对象，它包含<strong>Proxy</strong>的捕获器。同时<strong>handler</strong>对象包含了用于拦截的<strong>13</strong>种操作。如下：<br>大致可以分为一类<strong>代理对象<code>自身属性</code>操作拦截</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">拦截方法名</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>handler.get(target, property, receiver)</code></td>
<td style="text-align:center">在<strong>读取</strong>代理对象的某个<strong>属性时</strong>触发该操作，比如在执行 <code>proxy.foo</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.set(target, property, value, receiver)</code></td>
<td style="text-align:center">在给代理对象的某个<strong>属性赋值时</strong>触发该操作，比如在执行 <code>proxy.foo = 1</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.has(target, prop)</code></td>
<td style="text-align:center">在判断代理对象<strong>是否拥有某个属性时</strong>触发该操作，比如在执行 <code>&quot;foo&quot; in proxy</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.defineProperty(target, property, descriptor)</code></td>
<td style="text-align:center">在<strong>定义代理对象某个属性时的属性描述时</strong>触发该操作，比如在执行 <code>Object.defineProperty(proxy, &quot;foo&quot;, {})</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.deleteProperty(target, property)</code></td>
<td style="text-align:center">在<strong>删除代理对象的某个属性时</strong>触发该操作，即使用<code>delete</code>运算符，比如在执行 <code>delete proxy.foo</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.getOwnPropertyDescriptor(target, prop)</code></td>
<td style="text-align:center">在<strong>获取代理对象某个属性的属性描述时</strong>触发该操作，比如在执行 <code>Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;)</code> 时。</td>
</tr>
</tbody>
</table>
<!-- - `handler.get(target, property, receiver)`: 在**读取**代理对象的某个**属性时**触发该操作，比如在执行 `proxy.foo` 时。
- `handler.set(target, property, value, receiver)`: 在给代理对象的某个**属性赋值时**触发该操作，比如在执行 `proxy.foo = 1` 时。 -->
<!-- - `handler.has(target, prop)`: 在判断代理对象**是否拥有某个属性时**触发该操作，比如在执行 `"foo" in proxy` 时。 -->
<!-- - `handler.defineProperty(target, property, descriptor)`: 在**定义代理对象某个属性时的属性描述时**触发该操作，比如在执行 `Object.defineProperty(proxy, "foo", {})` 时。 -->
<!-- - `handler.deleteProperty(target, property)`: 在**删除代理对象的某个属性时**触发该操作，即使用`delete`运算符，比如在执行 `delete proxy.foo` 时。
- `handler.getOwnPropertyDescriptor(target, prop)`:在**获取代理对象某个属性的属性描述时**触发该操作，比如在执行 `Object.getOwnPropertyDescriptor(proxy, "foo")` 时。 -->
<p>另一类<strong>代理对象<code>自身</code>操作拦截</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">拦截方法名</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>handler.getPrototypeOf(target)</code></td>
<td style="text-align:center">在<strong>读取代理对象的原型时</strong>触发该操作，比如在执行 <code>Object.getPrototypeOf(proxy)</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.setPrototypeOf(target, prototype)</code></td>
<td style="text-align:center">在<strong>设置代理对象的原型时</strong>触发该操作，比如在执行 <code>Object.setPrototypeOf(proxy, null)</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.isExtensible(target)</code></td>
<td style="text-align:center">在判断一个<strong>代理对象是否是可扩展时</strong>触发该操作，比如在执行 <code>Object.isExtensible(proxy)</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.preventExtensions(target)</code></td>
<td style="text-align:center">在让一个<strong>代理对象不可扩展时</strong>触发该操作，比如在执行 <code>Object.preventExtensions(proxy)</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.apply(target, thisArg, argumentsList)</code></td>
<td style="text-align:center">拦截 <strong>Proxy 实例作为函数调用</strong>的操作，比如<code>proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.ownKeys(target)</code></td>
<td style="text-align:center">拦截<code>Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in</code>循环，<strong>返回一个数组</strong>。该方法返回目标对象<strong>所有自身的属性的属性名</strong>，而Object.keys()的返回结果仅包括<strong>目标对象自身的可遍历属性</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.construct(target, argumentsList, newTarget)</code></td>
<td style="text-align:center">拦截 <strong>Proxy 实例作为构造函数调用</strong>的操作，比如<code>new proxy(...args)</code>。</td>
</tr>
</tbody>
</table>
<!-- - `handler.getPrototypeOf(target)`: 在**读取代理对象的原型时**触发该操作，比如在执行 `Object.getPrototypeOf(proxy)` 时。 -->
<!-- - `handler.setPrototypeOf(target, prototype)`: 在**设置代理对象的原型时**触发该操作，比如在执行 `Object.setPrototypeOf(proxy, null)` 时。 -->
<!-- - `handler.isExtensible(target)`: 在判断一个**代理对象是否是可扩展时**触发该操作，比如在执行 `Object.isExtensible(proxy)` 时。 -->
<!-- - `handler.preventExtensions(target)`: 在让一个**代理对象不可扩展时**触发该操作，比如在执行 `Object.preventExtensions(proxy)` 时。 -->
<!-- - `handler.apply(target, thisArg, argumentsList)`: 拦截 **Proxy 实例作为函数调用**的操作，比如`proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)`。 -->
<!-- - `handler.ownKeys(target)`: 拦截`Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in`循环，**返回一个数组**。该方法返回目标对象**所有自身的属性的属性名**，而Object.keys()的返回结果仅包括**目标对象自身的可遍历属性**。
- `handler.construct(target, argumentsList, newTarget)`: 拦截 **Proxy 实例作为构造函数调用**的操作，比如`new proxy(...args)`。 -->
<p>可以看到<code>Proxy</code>的拦截方法上就比<code>Object.defineProperty</code>的配置多很多，并且在最近的浏览器支持中也是各大浏览器上对<code>Proxy</code>大理支持，优化性能等等。</p>
<h2 id="代理对象自身属性操作拦截"><a href="#代理对象自身属性操作拦截" class="headerlink" title="代理对象自身属性操作拦截"></a>代理对象自身属性操作拦截</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(target, property, receiver)</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为<strong>目标对象</strong>、<strong>属性名</strong>和 <strong>proxy 实例本身</strong>（<em>严格地说，是操作行为所针对的对象</em>），其中最后一个参数可选。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get: name'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'dangdang'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name;</span><br><span class="line"><span class="comment">// get: name</span></span><br><span class="line"><span class="comment">// dangdang</span></span><br></pre></td></tr></table></figure>
<p>只要通过<code>proxy.xxx</code>访问了<code>proxy</code>上面的属性，就会触发<code>proxy</code>上配置的<code>get</code>拦截方法。<br>上面这个实例是最简单的实例，其实它可以做很多的事情，举几个例子：</p>
<ul>
<li>实现数组读取负数的索引。</li>
<li>链式操作。</li>
<li>一个生成各种 DOM 节点的通用函数dom。</li>
</ul>
<h4 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h4><p>该方法会拦截目标对象的以下操作:</p>
<ul>
<li><strong>访问属性: proxy[foo]和 proxy.bar</strong></li>
<li><strong>访问原型链上的属性: Object.create(proxy)[foo]</strong></li>
<li><strong>Reflect.get()</strong></li>
</ul>
<h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li><strong>get方法可以继承</strong>。</li>
<li><strong>get第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</strong></li>
<li><strong>一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</strong></li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set(target, property, value, receiver)</code>方法用来拦截某个属性的<strong>赋值</strong>操作，可以接受四个参数，依次为<strong>目标对象</strong>、<strong>属性名</strong>、<strong>属性值</strong>和 <strong>Proxy 实例本身</strong>，其中<strong>最后一个参数可选</strong>。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function (target, property, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'set: dangdang'</span>);</span><br><span class="line">      target[property] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">'dangdang'</span>;</span><br><span class="line"><span class="comment">// set: dangdang</span></span><br><span class="line">proxy.name; <span class="comment">// dangdang</span></span><br></pre></td></tr></table></figure>
<p>只要给<code>proxy</code>的任意属性赋值，就会触发<code>proxy</code>上配置的<code>set</code>拦截方法。<br>当然这个实例是最简单的使用方式，还有其他的用法，举例如下：</p>
<ul>
<li>校验属性是否符合格式（表单验证validation）</li>
<li>统计函数调用次数</li>
<li>配合get设置内部私有属性</li>
</ul>
<h4 id="拦截-1"><a href="#拦截-1" class="headerlink" title="拦截"></a>拦截</h4><p>该方法会拦截目标对象的以下操作:</p>
<ul>
<li><strong>指定属性值: proxy[foo] = bar 和 proxy.foo = bar</strong></li>
<li><strong>指定继承者的属性值: Object.create(proxy)[foo] = bar</strong></li>
<li><strong>Reflect.set()</strong></li>
</ul>
<h4 id="其他特性-1"><a href="#其他特性-1" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li><strong>get第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</strong></li>
<li><strong>若目标属性是不可写及不可配置的，则不能改变它的值。</strong></li>
<li><strong>在严格模式下，若set方法返回false，则会抛出一个 TypeError 异常。</strong></li>
</ul>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has(target, prop)</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。<br><code>has(target, prop)</code>方法可以接受两个参数，分别是<strong>目标对象</strong>、<strong>需查询的属性名</strong>。</p>
<p><strong>返回值</strong></p>
<p><code>has()</code> 方法返回一个 <code>boolean</code> 属性的值.</p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  has: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> proxy; <span class="comment">// true</span></span><br><span class="line"><span class="string">'age'</span> <span class="keyword">in</span> proxy; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>设置<code>has(&#39;name&#39;)</code>返回<code>true</code>再通过<code>in</code>检测时返回<code>true</code>，设置<code>has(&#39;age&#39;)</code>返回<code>false</code>再通过<code>in</code>检测时返回<code>false</code>。<br>当然这个实例是最简单的使用方式，还有其他的用法，举例如下：</p>
<ul>
<li>可以做私有属性</li>
</ul>
<h4 id="拦截-2"><a href="#拦截-2" class="headerlink" title="拦截"></a>拦截</h4><p>这个钩子可以拦截下面这些操作:</p>
<ul>
<li><strong>属性查询: foo in proxy</strong></li>
<li><strong>继承属性查询: foo in Object.create(proxy)</strong></li>
<li><strong>with 检查: with(proxy) { (foo); }</strong></li>
<li><strong>Reflect.has()</strong></li>
</ul>
<h4 id="其他特性-2"><a href="#其他特性-2" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li><strong>如果目标对象的某一属性本身不可被配置，则该属性不能够被代理隐藏。会抛出TypeError。</strong></li>
<li><strong>如果目标对象为不可扩展对象，则该对象的属性不能够被代理隐藏。会抛出TypeError。</strong></li>
<li><strong>has（）方法不判断一个属性是对象自身的属性，还是继承的属性。</strong></li>
<li><strong>has（）拦截对for…in循环不生效。</strong></li>
</ul>
<h3 id="defineProperty（）"><a href="#defineProperty（）" class="headerlink" title="defineProperty（）"></a>defineProperty（）</h3><p><code>defineProperty(target, property, descriptor)</code>方法拦截了<code>Object.defineProperty</code>操作。<br>参数这里就不多做介绍了和<strong>Object.defineProperty</strong>相同，主要关注一下返回值。</p>
<p><strong>返回值</strong></p>
<p><code>defineProperty</code> 方法必须以一个 <code>Boolean</code> 返回，表示定义该属性的操作成功与否。</p>
<p><strong>注意</strong></p>
<ul>
<li>如果目标对象<strong>不可扩展</strong>， 将<strong>不能添加</strong>属性。</li>
<li>不能添加或者修改一个属性为不可配置的，如果它不作为一个目标对象的不可配置的属性存在的话。</li>
<li>如果目标对象存在一个对应的可配置属性，这个属性可能不会是不可配置的。</li>
<li>如果一个属性在目标对象中存在对应的属性，那么 <code>Object.defineProperty(target, prop, descriptor)</code> 将不会抛出异常。</li>
<li>在严格模式下， <code>false</code> 作为 <code>handler.defineProperty</code> 方法的返回值的话将会抛出 <code>TypeError</code> 异常.</li>
</ul>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty(target, property)</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<p><strong>返回值</strong></p>
<p><code>deleteProperty</code> 必须返回一个 <code>Boolean</code> 类型的值，表示了该属性是否被成功删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  deleteProperty: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> proxy.name; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> proxy.age; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>目标对象自身的<strong>不可配置（configurable）的属性</strong>，<strong>不能</strong>被<code>deleteProperty</code>方法删除，否则报错。</li>
</ul>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个<strong>属性描述对象</strong>或者<code>undefined</code>。</p>
<p><strong>返回值</strong></p>
<p><code>getOwnPropertyDescriptor</code> 方法必须返回一个 <code>object</code> 或 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  getOwnPropertyDescriptor: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, property);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'name'</span>); <span class="comment">// &#123;value: "dangdang", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'age'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="代理对象自身操作拦截"><a href="#代理对象自身操作拦截" class="headerlink" title="代理对象自身操作拦截"></a>代理对象自身操作拦截</h2><h3 id="getPrototypeOf-setPrototypeOf"><a href="#getPrototypeOf-setPrototypeOf" class="headerlink" title="getPrototypeOf()/setPrototypeOf()"></a>getPrototypeOf()/setPrototypeOf()</h3><p><strong>原型相关的操作拦截</strong></p>
<h4 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h4><p><code>getPrototypeOf(target)</code>方法主要用来拦截<strong>获取对象原型</strong>。具体来说，拦截下面这些操作。</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p><strong>返回值</strong></p>
<p><code>getPrototypeOf</code> 方法的返回值必须是<strong>一个对象</strong>或者 <code>null</code>。</p>
<h4 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h4><p><code>setPrototypeOf(target, obj)</code> 方法主要用来拦截 <code>Object.setPrototypeOf(target, obj)</code>。</p>
<p><strong>返回值</strong></p>
<p>如果成功修改了<code>[[Prototype]]</code>, <code>setPrototypeOf</code> 方法返回 <code>true</code>,否则返回 <code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>如果目标对象不可扩展<code>（non-extensible）</code>，<code>setPrototypeOf</code>方法不得改变目标对象的原型。</p>
<h3 id="preventExtensions-isExtensible"><a href="#preventExtensions-isExtensible" class="headerlink" title="preventExtensions/isExtensible"></a>preventExtensions/isExtensible</h3><p><strong>扩展配置拦截操作</strong></p>
<h4 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h4><p><code>preventExtensions(target)</code> 方法用于设置对<code>Object.preventExtensions()</code>的拦截。</p>
<p><strong>返回</strong></p>
<p><code>preventExtensions</code> 必须返回一个布尔值，否则会被自动转为布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy); <span class="comment">// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy1); <span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>如果<code>Object.isExtensible(proxy)</code>是<code>false</code>，<code>Object.preventExtensions(proxy)</code>只能返回<code>true</code>。</p>
<h4 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h4><p><code>isExtensible(target)</code> 方法用于拦截对对象的<code>Object.isExtensible()</code>。</p>
<p><strong>返回值</strong></p>
<p><code>isExtensible</code>方法必须返回一个 <code>Boolean</code>值或可转换成<code>Boolean</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//也可以return 1;等表示为true的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(p)); <span class="comment">// "called"</span></span><br><span class="line">                                     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//return 0;return NaN等都会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p); <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p><code>Object.isExtensible(proxy)</code> 必须同<code>Object.isExtensible(target)</code>返回相同值。也就是必须返回<code>true</code>或者为<code>true</code>的值,返回<code>false</code>和为<code>false</code>的值都会报错。</p>
<h3 id="apply-construct"><a href="#apply-construct" class="headerlink" title="apply/construct"></a>apply/construct</h3><p><strong>改变this方式</strong></p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p><code>apply(target, thisArg, argumentsList)</code> 方法用于拦截<strong>函数的调用</strong>、<code>Reflect.apply</code>、<code>call</code>和<code>apply</code>操作。<br><code>apply</code>方法可以接受三个参数，分别是<strong>目标对象</strong>、<strong>被调用时的上下文对象</strong>和<strong>被调用时的参数数组</strong>数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params">target, thisArg, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called:'</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> argumentsList[<span class="number">0</span>] + argumentsList[<span class="number">1</span>] + argumentsList[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p><code>target</code>必须是可被调用的。也就是说，它<strong>必须是一个函数对象</strong>。</p>
<h4 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h4><p><code>construct(target, argumentsList, newTarget)</code> 方法用于拦截<code>new</code> 操作符. 为了使<code>new</code>操作符在生成的<code>Proxy</code>对象上生效，用于初始化代理的目标对象自身必须具有<code>[[Construct]]</code>内部方法（即 <code>new targe</code>t 必须是有效的）。</p>
<p><strong>参数</strong></p>
<ul>
<li><code>target</code>：目标对象</li>
<li><code>args</code>：构造函数的参数对象</li>
<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的p）</li>
</ul>
<p><strong>返回值</strong></p>
<p><code>construct</code> 方法<strong>必须返回一个对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, argumentsList, newTarget</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called: '</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: argumentsList[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> p(<span class="number">1</span>).value); <span class="comment">// "called: 1"</span></span><br><span class="line">                            <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p><code>ownKeys(target)</code> 方法用于拦截 <code>Reflect.ownKeys()</code>。</p>
<p><strong>返回值</strong></p>
<p><code>ownKeys</code> 方法必须返回<strong>一个可枚举对象</strong>。</p>
<h4 id="拦截-3"><a href="#拦截-3" class="headerlink" title="拦截"></a>拦截</h4><p>该拦截器可以拦截以下操作:</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>Reflect.ownKeys()</code></li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果违反了下面的约束，<code>proxy</code>将抛出错误 <code>TypeError</code>:</p>
<ul>
<li><code>ownKeys</code> 的结果必须是一个数组.</li>
<li>数组的元素类型要么是一个 <code>String</code> ，要么是一个 <code>Symbol</code>.</li>
<li>结果列表必须包含目标对象的所有不可配置<code>（non-configurable ）</code>、自有（<code>own</code>）属性的key.</li>
<li>如果目标对象不可扩展，那么结果列表必须包含目标对象的所有自有（<code>own</code>）属性的<code>key</code>，不能有其它值。</li>
</ul>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable"></a>Proxy.revocable</h2><p><code>Proxy.revocable</code>方法返回一个可取消的 <code>Proxy</code> 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>
<p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><strong>注意</strong></p>
<p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 <code>Proxy</code> 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 <code>Proxy</code> 代理的情况下，目标对象内部的<code>this</code>关键字会指向 <code>Proxy</code> 代理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() <span class="comment">// false</span></span><br><span class="line">proxy.m()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，一旦<code>proxy</code>代理<code>target.m</code>，后者内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>
<p>下面是一个例子，由于<code>this</code>指向的变化，导致 <code>Proxy</code> 无法代理目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name <span class="comment">// 'Jane'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 <code>Proxy</code> 也无法代理这些原生对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>getDate</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章记录了<code>Proxy</code>相关的的一些<code>属性访问的方法</code>，它有<strong>13</strong>种方法，大致分为两类：一类<strong>代理对象<code>自身属性</code>操作拦截</strong>，另一类<strong>代理对象<code>自身</code>操作拦截</strong>。</p>
<p>下一篇文章对比<code>defineProterty</code>和<code>Proxy</code>之间的优缺点，用它们实现简单的双线绑定。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">mdn Proxy</a><br><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">阮一峰 Proxy</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES系列 ———— Object.defineProperty</title>
    <url>/blog/es6/es6-definedproperty.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/es6/es6-definedproperty.html">ES系列 Object.defineProperty</a><br><a href="/blog/es6/es6-proxy.html">ES系列 Proxy</a><br><a href="/blog/es6/es6-definedproperty-proxy.html">ES系列 Object.defineProperty和Proxy的对比</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果用过<code>VUE</code>框架的话都听说过他的数据观测在<strong>2.x</strong>是是通过<code>Object.defineProperty</code>实现的，其实就是把普通的对象变为<strong>响应式对象</strong>，但是在最近<strong>3.x</strong>中作者要通过<strong>Proxy</strong>重写<code>Vue</code>中的双向绑定核心的<strong>响应式对象</strong>实现，在本篇文章中逐渐了解<code>Object.defineProperty</code>和<code>Proxy</code>是什么，它们之间的区别是什么，和它们之间的有缺点。</p>
<p>如果想了解<code>Vue</code>中的双向对象的实现，请看本站中的<strong>Vue响应式对象</strong>、<strong>依赖收集</strong>、<strong>派发更新</strong>等等<strong>Vue源码文章</strong>。</p>
<p>本文章目录：</p>
<ul>
<li><code>Object.defineProperty</code>使用简介</li>
<li><code>Proxy</code>使用简介</li>
<li><code>Object.defineProperty</code>和<code>Proxy</code>之间的区别和优缺点</li>
<li>为什么<code>Vue</code>要重写核心的数据观测实现</li>
<li><code>Object.defineProperty</code>和<code>Proxy</code>实现简单的双向绑定</li>
</ul>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p><strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.6" target="_blank" rel="noopener">ES5</a></strong> 提供了 <code>Object.defineProperty</code> 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>可以通过<code>Object.defineProperty(obj, prop, descriptor)</code>使用，三个参数分别代表：</p>
<ul>
<li><code>obj(Object)</code>: 要在其上定义属性的对象。</li>
<li><code>prop(String)</code>: 要定义或修改的属性的名称。</li>
<li><code>descriptor(Object)</code>: 将被定义或修改的属性描述符。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明example并且赋值一个对象字面量</span></span><br><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="comment">// 通过Object.defineProperty 定义一个新的属性count，并且给他赋值为一个value</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出example.count的值</span></span><br><span class="line">example.count; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符和存取描述符</strong>。</p>
<p><strong>数据描述符和存取描述符均具有</strong>以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下)：</p>
<ul>
<li><code>configurable(Boolean)</code>: 当且仅当该属性的 <code>configurable</code> 为 <code>true</code> 时，该属性<strong>描述符</strong>才能够被改变，同时该属性也能从对应的对象上被删除。<strong>默认为 false</strong>。</li>
<li><code>enumerable(Boolean)</code>: 当且仅当该属性的<code>enumerable</code>为<code>true</code>时，该属性才能够出现在对象的枚举属性中。<strong>默认为 false</strong>。</li>
</ul>
<p><strong>数据描述符同时具有以下可选键值：</strong></p>
<ul>
<li><code>value(任意有效的Javascript值)</code>： 该属性对应的值。<strong>默认为 undefined</strong>。</li>
<li><code>writable(Boolean)</code>: 当且仅当该属性的<code>writable</code>为<code>true</code>时，<code>value</code>才能被赋值运算符改变。<strong>默认为 false</strong>。</li>
</ul>
<p><strong>存取描述符同时具有以下可选键值：</strong></p>
<ul>
<li><code>get(Function 匿名函数)</code>：一个给属性提供 <code>getter</code> 的方法，如果没有 <code>getter</code> 则为 <code>undefined</code>。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入<strong>this</strong>对象（由于继承关系，这里的<strong>this</strong>并不一定是定义该属性的对象）。<strong>默认为 <code>undefined</code></strong>。</li>
<li><code>set(Function 匿名函数)</code>: 一个给属性提供 <code>setter</code> 的方法，如果没有 <code>setter</code> 则为 <code>undefined</code>。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。<strong>默认为 <code>undefined</code></strong>。</li>
</ul>
<p><strong>描述符可同时具有的键值</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>configurable</strong></th>
<th style="text-align:center"><strong>enumerable</strong></th>
<th style="text-align:center"><strong>value</strong></th>
<th style="text-align:center"><strong>writable</strong></th>
<th style="text-align:center"><strong>get</strong></th>
<th><strong>set</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>数据描述符</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>No</strong></td>
<td><strong>No</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>存取描述符</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>No</strong></td>
<td style="text-align:center"><strong>No</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td><strong>Yes</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意事项： 如果一个描述符同时有(<code>value</code>或<code>writable</code>)和(<code>get</code>或<code>set</code>)关键字，将会产生一个异常。</p>
</blockquote>
<p>下面一个一个描述符来通过实例来看一下它真正的效果。</p>
<h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当设置了<code>configurable</code>为<code>false</code>时，就不能在通过<code>defineProperty</code>设置属性描述了。当前的属性不能<strong>删除</strong>、<strong>修改</strong>、<strong>枚举</strong>等。下面请看实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">example.count = <span class="number">2</span>;</span><br><span class="line">example.count; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> example.count;</span><br><span class="line">example.count; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> example) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  wirtable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: count</span></span><br></pre></td></tr></table></figure>
<h3 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h3><p>当设置<code>Enumerable</code>为<code>false</code>时，当前这个属性不能被<code>for...in</code>和<code>Object.keys()</code>枚举。</p>
<h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当设置<code>writable</code>为<code>false</code>时，写入非可写属性<strong>不会改变它</strong>，也<strong>不会</strong>引发错误。</p>
<h3 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h3><p><code>get</code> 和 <code>set</code>两个方法在上面是存取属性描述，这两个方法又被称为<code>getter</code>和<code>setter</code>。可以简称为<strong>存取器属性</strong>。</p>
<p>当配置了<code>get</code>和<code>set</code>，就不能配置<code>value</code>和<code>writable</code>因为它们是互斥的，只能设置其中的一组。</p>
<p>当想获取一个属性的值时就会触发设置的<code>get</code>方法，当给一个属性赋值时就会触发<code>set</code>属性。</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;, value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProterty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了 get 操作'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了 set 操作'</span>)</span><br><span class="line">    value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">example.count = <span class="number">1</span>; <span class="comment">// 执行了 set 操作</span></span><br><span class="line">example.count; <span class="comment">// 1 执行了 get 操作</span></span><br></pre></td></tr></table></figure>
<h2 id="其它Object-defineProperty相关"><a href="#其它Object-defineProperty相关" class="headerlink" title="其它Object.defineProperty相关"></a>其它Object.defineProperty相关</h2><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h3><p><code>Object.defineProperties()</code>可以同时设置多个<code>Object.defineProperty</code>。</p>
<p><code>Object.defineProperties(obj, props)</code> 方法直接在一个对象上定义新的属性或修改现有属性，并<strong>返回</strong>该对象。参数如下：</p>
<ul>
<li><code>obj(Object)</code>: 在其上定义或修改属性的对象。</li>
<li><code>props(Object)</code>: 一个对象包含多个<strong>属性名:descriptor</strong></li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(example, &#123;</span><br><span class="line">  <span class="string">'count1'</span>: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'count2'</span>: &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h3><p><code>Object.getOwnPropertyNames(Object)</code>方法返回一个由指定对象的<strong>所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组</strong>。</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123; <span class="attr">num</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(example, &#123;</span><br><span class="line">  <span class="string">'count1'</span>: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'count2'</span>: &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(example); <span class="comment">//  ["num", "count1", "count2"]</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h3><p><code>Object.getOwnPropertyDescriptor(obj, prop)</code> 方法返回指定对象上一个<strong>自有属性对应的属性描述符</strong>。<strong>（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</strong>。参数如下：</p>
<ul>
<li><code>obj(Object)</code>: 需要查找的目标对象</li>
<li><code>prop(String)</code>： 目标对象内属性名称</li>
</ul>
<p><strong>返回值</strong><br>如果指定的属性存在于对象上，则返回其属性描述符对象<code>（property descriptor）</code>，否则返回 <code>undefined</code>。</p>
<blockquote>
<p>在 <strong>ES5</strong> 中，如果该方法的第一个参数不是对象（而是原始类型），那么就会产生出现 <code>TypeError</code>。而在 <strong>ES2015</strong>，第一个的参数不是对象的话就会<strong>被强制转换为对象</strong>。</p>
</blockquote>
<h2 id="冻结相关的"><a href="#冻结相关的" class="headerlink" title="冻结相关的"></a>冻结相关的</h2><h3 id="Object-defineProperty冻结"><a href="#Object-defineProperty冻结" class="headerlink" title="Object.defineProperty冻结"></a>Object.defineProperty冻结</h3><p>当<code>Object.defineProperty(obj, name, { value: 1 })</code>这样设置实，当前属性的<strong>writable</strong>、<strong>configurable</strong>、<strong>enumerable</strong>、都默认为<code>false</code>，可以把当前这个<strong>对象属性</strong>看做是一个冻结对象，那这个对象属性是<strong>深冻结还是浅冻结</strong>呢？</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: &#123;</span><br><span class="line">    num: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line">example.count = <span class="number">2</span>;</span><br><span class="line">example.count; <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line"><span class="comment">// 修改属性下的属性</span></span><br><span class="line">example.count.num = <span class="number">3</span>;</span><br><span class="line">example.count; <span class="comment">// &#123;num: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上面的实例可以判定<code>defineProperty</code>冻结的对象属性，是<strong>浅冻结</strong>对象，如果是<strong>引用类型</strong>是可以修改的。如果想实现<strong>深层冻结</strong>，就需要递归对象所有的属性设置<code>Object.defineProperty()</code>。</p>
<h3 id="Object-freeze冻结"><a href="#Object-freeze冻结" class="headerlink" title="Object.freeze冻结"></a>Object.freeze冻结</h3><p><code>Object.freeze(obj)</code> 方法可以冻结一个对象。参数如下：</p>
<ul>
<li><code>obj(Object)</code>: 要被冻结的对象。</li>
</ul>
<p>一个被冻结的对象再也<strong>不能被修改</strong>；<br>冻结了一个对象则<strong>不能</strong>向这个对象<strong>添加新的属性</strong>，<strong>不能删除已有属性</strong>，不能修改该对象已有属性的<strong>可枚举性</strong>、<strong>可配置性</strong>、<strong>可写性</strong>，以及不能修改已有属性的值。此外，冻结一个对象后该对象的<strong>原型也不能被修改</strong>。<strong>freeze() 返回和传入的参数相同的对象</strong>。</p>
<p><strong>返回值</strong></p>
<p>被冻结的对象。</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;</span><br><span class="line">  count: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  num: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(example);</span><br><span class="line"><span class="comment">// 修改值类型无效</span></span><br><span class="line">example.num = <span class="number">11</span>;</span><br><span class="line">example.num; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改引用类型生效</span></span><br><span class="line">example.count[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">example.count; <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图通过 Object.defineProperty 更改属性 抛出 TypeError.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'num'</span>, &#123; <span class="attr">value</span>: <span class="number">11</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也不能更改原型 会抛出 TypeError.</span></span><br><span class="line">example.__proto__ = &#123; <span class="attr">x</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(example, &#123; <span class="attr">x</span>: <span class="number">20</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>通过上面代码可以看出<code>Object.freeze()</code>也是<strong>浅冻结</strong>，如果冻结的对象有多层引用类型嵌套，子属性是可以修改的。如果想实现<strong>深层冻结</strong>，就需要递归对象所有的属性设置<code>Object.freeze()</code>。</p>
<h4 id="冻结数组"><a href="#冻结数组" class="headerlink" title="冻结数组"></a>冻结数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>];</span><br><span class="line"><span class="built_in">Object</span>.freeze(a); <span class="comment">// 现在数组不能被修改了.</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// fails silently</span></span><br><span class="line">a.push(<span class="number">2</span>); <span class="comment">// fails silently</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In strict mode such attempts will throw TypeErrors</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  a.push(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fail();</span><br></pre></td></tr></table></figure>
<h4 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen"></a>Object.isFrozen</h4><p><code>Object.isFrozen(obj)</code>方法判断一个对象是否被冻结。参数如下：</p>
<ul>
<li><code>obj(Object)</code>: 被检测的对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>表示给定对象是否被冻结的<code>Boolean</code>。</p>
<blockquote>
<p><strong>在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常</strong>。<br><strong>在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isFrozen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isFrozen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// true                          (ES2015 code)</span></span><br></pre></td></tr></table></figure>
<h4 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal"></a>Object.seal</h4><p><code>Object.seal(obj)</code>方法封闭一个对象，<strong>阻止添加新属性并将所有现有属性标记为不可配置</strong>。<strong>当前属性的值只要可写就可以改变</strong>。</p>
<ul>
<li><code>obj(Object)</code>: 将要被密封的对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>被密封的对象。</p>
<blockquote>
<p><strong>在ES5中，如果这个方法的参数不是一个（原始）对象，那么它将导致TypeError</strong>。<br><strong>在ES2015中，非对象参数将被视为已被密封的普通对象，会直接返回它</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1                             (ES2015 code)</span></span><br></pre></td></tr></table></figure>
<p>它其他的表现适合<code>Object.freeze</code>是一致的。</p>
<h3 id="实现一个深度冻结"><a href="#实现一个深度冻结" class="headerlink" title="实现一个深度冻结"></a>实现一个深度冻结</h3><p>这里只实现一个简单的<strong>深度冻结</strong>方法，一些<strong>循环引用</strong>、<strong>特殊类型</strong>没有考虑在内，实现如下：</p>
<ul>
<li>递归对象属性，调用冻结方法</li>
<li>返回冻结完成的对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFreeze</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arguments is not object'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> propertyName = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">  propertyName.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[item] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj[item] !== <span class="string">'null'</span>) &#123;</span><br><span class="line">      deepFreeze(obj[item]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> example = deepFreeze(&#123;<span class="attr">example</span>: &#123; <span class="attr">name</span>: <span class="string">'admin'</span> &#125;&#125;);</span><br><span class="line">example.example.name = <span class="number">1</span>;</span><br><span class="line">example.example; <span class="comment">// &#123;name: "admin"&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>因为当前文章写得太长了，所以拆分为三篇博客。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">mdn Object.defineProperty()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">mdn Object.defineProperties()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">mdn Object.freeze()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener">mdn Object.seal()</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>用webpack写一个vue单页面的脚手架</title>
    <url>/blog/webpack/webpack-cli-sap.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 ———— Vue中v-model解析、sync修饰符解析</title>
    <url>/blog/vue/vue-vModel-sync.html</url>
    <content><![CDATA[<p><em>上善若水，水善利萬物而不爭。——《道德經》</em></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>在平时开发是经常用到一些父子组件通信，经常用到<code>props</code>、<code>vuex</code>等等，这里面记录另外的三种方式<code>v-model</code>、<code>sync</code>是怎么使用，再说是怎么实现，其实<code>v-model</code>、<code>sync</code>都是语法糖。还有<code>$attr</code>、<code>$listener</code>实现父子组件通信。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><hr>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><blockquote>
<p>2.2.0+ 新增</p>
</blockquote>
<p><code>v-mode1</code>其实就是一个语法糖，默认会利用名为<code>value</code>的<code>props</code>和名为<code>input</code>的事件，但是像单选框、复选框等类型的输入龙剑可能会讲<code>value</code>特性用于不同的目的。</p>
<p><code>v-model</code>的使用场景：当<strong>子组件</strong>需要改变父组件通过<code>props</code>传入的值</p>
<p><strong><em>父组件</em></strong></p>
<ul>
<li>父组件通过<code>v-model</code>绑定值</li>
<li>如需根据<code>v-model</code>传入的值改变，而触发其他更新请通过<code>watch</code>传入的值</li>
</ul>
<p><strong><em>子组件</em></strong></p>
<ul>
<li>声明<code>model</code>对象 设置事件<code>event</code>和<code>prop</code>字段</li>
<li>通过<code>porps</code>接受父组件传送值</li>
<li>修改是通过<code>this.$emit</code>广播事件</li>
</ul>
<p>代码示例：</p>
<p><strong><em>父组件代码</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;children v-model=<span class="string">"message"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import children from "./</span>children.vue<span class="string">";</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    children</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      message: "</span>parent<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  watch: &#123;</span></span><br><span class="line"><span class="string">    // 监听message变化</span></span><br><span class="line"><span class="string">    message(newV, oldV) &#123;</span></span><br><span class="line"><span class="string">      console.log(newV, oldV);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">"message"</span>, <span class="comment">//这个字段，是指父组件设置 v-model 时，将变量值传给子组件的 msg</span></span><br><span class="line">    event: <span class="string">"input"</span> <span class="comment">//这个字段，是指父组件监听 parent-event 事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    message: <span class="built_in">String</span> <span class="comment">//此处必须定义和model的prop相同的props，因为v-model会传值给子组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">//这里模拟异步将msg传到父组件v-model，实现双向控制</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">"input"</span>, <span class="string">"children"</span>);</span><br><span class="line">      <span class="comment">//将这个值通过 emit 触发parent-event，将some传递给父组件的v-model绑定的变量</span></span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这个示例是通过<code>v-model</code>实现的，下面不通过<code>v-model</code>实现同样效果。</p>
<h3 id="不使用-v-model-实现"><a href="#不使用-v-model-实现" class="headerlink" title="不使用 v-model 实现"></a>不使用 v-model 实现</h3><p>代码示例如下：</p>
<p><strong><em>父组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Children :message=<span class="string">"message"</span> @input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 不变</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="comment">// 不变</span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    message: String</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit("input", "children");</span></span><br><span class="line"><span class="regexp">    &#125;, 1500);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p>只是把<code>v-model</code>拆分为<code>props</code>和<code>@input</code>事件，子组件不需要配置<code>model</code>,只需要接受<code>props</code>和通过<code>this.$emit</code>广播事件就可以。<br>当然这个相对于<code>v-model</code>方法比较简便，但是灵活度查很多，选择使用那种看个人喜好。<br>在线地址：</p>
<iframe src="https://codesandbox.io/embed/vue-template-zcvn3?fontsize=14" title="Vue Template" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><blockquote>
<p>2.3.0+ 新增</p>
</blockquote>
<p>在有些情况下，我们可能需要对一个 <code>prop</code> 进行<strong><em>“双向绑定”</em></strong>。不幸的是，真正的<strong>双向绑定</strong>会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p>
<p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。同时也可以通过<code>sync</code>修饰符来实现。</p>
<p>在上面代码的基础上大致修改如下：</p>
<p><strong><em>父组件</em></strong></p>
<ul>
<li>通过修改触发事件<code>input</code>为<code>update:myPropName</code>实现相同效果</li>
</ul>
<p><strong><em>子组件</em></strong></p>
<ul>
<li>通过修改<code>this.$emit(update:myPropName)</code></li>
</ul>
<p>代码如下：</p>
<p><strong><em>父组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改如下</span></span><br><span class="line">&lt;Children :message=<span class="string">"message"</span> @update:input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"update:input"</span>, <span class="string">"children"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="sync实现"><a href="#sync实现" class="headerlink" title="sync实现"></a>sync实现</h3><p>上面的代码可以通过<code>sync</code>简写为下面代码：</p>
<p><strong><em>父组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改如下</span></span><br><span class="line">&lt;Children :messag.sync=<span class="string">"message"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"update:messag"</span>, <span class="string">"children"</span>);</span><br></pre></td></tr></table></figure>
<p>同时<code>sync</code>也支持对象，要配合<code>v-bind</code>实现可以简写为<code>:</code>，但是要注意这个对象如下两条：</p>
<blockquote>
<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 <code>v-model</code>。<br>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
</blockquote>
<h2 id="attrs、-listeners"><a href="#attrs、-listeners" class="headerlink" title="$attrs、$listeners"></a>$attrs、$listeners</h2><h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><blockquote>
<p>2.4.0 新增</p>
</blockquote>
<ul>
<li>类型：<code>{ [key: string]: string }</code></li>
<li>只读</li>
<li>详细：<br>包含了父作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 <code>prop</code> 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</li>
</ul>
<h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h3><blockquote>
<p>2.4.0 新增</p>
</blockquote>
<ul>
<li>类型：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></li>
<li>只读</li>
<li>详细：<br>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</li>
</ul>
<h3 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h3><p>实现父子组件通信</p>
<p><strong><em>父组件代码</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;Children</span><br><span class="line">      :message=<span class="string">"message"</span></span><br><span class="line">      @upDate=<span class="string">"upDate"</span></span><br><span class="line">      type=<span class="string">"del"</span></span><br><span class="line">      @input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span></span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Children <span class="keyword">from</span> <span class="string">"./Children"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">"parent"</span>,</span><br><span class="line">      type: <span class="string">"del"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    upDate (event) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(event);</span><br><span class="line">      <span class="keyword">this</span>.type = event;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    message: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"更新message值为"</span> + <span class="keyword">this</span>.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-bind=<span class="string">"$attrs"</span> v-on=<span class="string">"$listeners"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"children"</span>&gt;&#123;&#123;message&#125;&#125; &lt;span @click=<span class="string">"$listeners.upDate('data')"</span>&gt;&#123;&#123;$attrs.type&#125;&#125;&lt;<span class="regexp">/span&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    message: String</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.log(this.$attrs);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.log(this.$listeners);</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit("input", "children");</span></span><br><span class="line"><span class="regexp">      this.$emit('upDate', 'add')</span></span><br><span class="line"><span class="regexp">    &#125;, 1500);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p>同时<code>$attrs</code>、<code>$listeners</code>都是可以跨域父子组件，可以父子子子组件传递，类似于<code>react</code>中的<code>context</code>，只是一部分设计理念相同。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实就是检测到<code>.sync</code>修饰符，在<code>complier</code>阶段会编译生成多个<code>prop</code>，生成多个<code>事件</code>。其实像这个<strong>指令</strong>、<strong>修饰符</strong>、<strong>自定义指令</strong>都是在<code>vue</code>编译是解析成为<strong>v8</strong>能执行的代码。</p>
<p>无论是<code>vue</code>、<code>babel</code>、<code>react</code>的<code>complier</code>编译阶段大致分为三个阶段：</p>
<ul>
<li>通过词法解析<code>parse</code>生成抽象<code>AST</code>或<code>抽象代码树</code></li>
<li>优化<code>AST</code>,比如<code>vue</code>标记静态节点，<code>babal</code>中抽取静态代码，这个阶段被称为<code>optimize</code>或者<code>优化AST树</code></li>
<li>在<code>AST</code>代码的阶段上，生成可执行代码，这个过程可以叫做<code>codegen</code></li>
</ul>
<p><code>v-model</code>、<code>sync</code>都可以实现父子组件通信，并且可以在子组件中修改父组件传入的值。在平常看法的时候进场可以用到这两种方式，具体选择那种方式看个人喜好。在<code>element-ui</code>这个<code>input</code>组件也用到相关的属性。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener">$attrs</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model" target="_blank" rel="noopener">自定义组件的-v-model</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-修饰符" target="_blank" rel="noopener">sync-修饰符</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScirpt面试题 ———— 有关原型一道笔试题</title>
    <url>/blog/InterviewQuestion/javascript-prototype.html</url>
    <content><![CDATA[<p><em><strong>慎終如始，則無敗事。——《道德經》</strong></em></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>这道面试题考察的比较综合，也有很多要注意的点，如果知道答案就没有必要往下看了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Preson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.b = [<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">this</span>.a];</span><br><span class="line">  <span class="keyword">this</span>.c = &#123; <span class="attr">demo</span>: <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, <span class="keyword">this</span>.b, <span class="keyword">this</span>.c.demo);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">this</span>.change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b.push(<span class="keyword">this</span>.a);</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="keyword">this</span>.b.length;</span><br><span class="line">    <span class="keyword">this</span>.c.demo = <span class="keyword">this</span>.a++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Preson();</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Preson();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">22</span>;</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure>
<h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><hr>
<p>这道题比较经典考察了<code>JavaScript</code>中很多方面的知识，大致如下几点：</p>
<ul>
<li>prototype 原型、原型链问题</li>
<li>new 改变 this 指向，new 产生实例属性和原型属性</li>
<li>值类型和引用类型</li>
<li>原型继承</li>
</ul>
<p>是一道比较综合的题前四题比较好答，后面的两题想多或者想少了都会出错。这里就对一些知识点不多做赘述，可以查看往期文章了解。<br><strong>往期文章</strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript 类型转换（一） 常见数据类型</a> &gt; <code>...后期添加</code></p>
</blockquote>
<h2 id="结题需要的知识点"><a href="#结题需要的知识点" class="headerlink" title="结题需要的知识点"></a>结题需要的知识点</h2><hr>
<p>大致的知识点如下：</p>
<ol>
<li><strong>构造函数有一个<code>prototype</code>属性指向原型对象，多个实例属性共享一个原型对象</strong></li>
<li><strong>实例中的属性都是独立的互相之间不会影响</strong></li>
<li><strong>每一个实例都有一个隐式原型<code>__proto__</code>指向构造函数的原型对象</strong></li>
<li><strong><code>this</code>的指向问题，大致如下：</strong></li>
</ol>
<ul>
<li>作为对象方法时，谁调用就指向谁</li>
<li><code>new</code>、<code>bind</code>、<code>call</code>、<code>apply</code>都会改变 this 的指向</li>
<li>箭头函数的<code>this</code>从外层普通函数获取</li>
</ul>
<ol start="5">
<li><strong>对象字面量和数组都是引用对象</strong></li>
<li><strong>原型链的查找规则： 就近原则</strong></li>
</ol>
<ul>
<li>当实例上存在属性时， 用实例上的</li>
<li>如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的</li>
<li>如果原型链都不存在，就用 Object 原型对象上的</li>
<li>如果 Object 原型对象都不存在， 就是 undefined</li>
</ul>
<h2 id="第一问-parent-show"><a href="#第一问-parent-show" class="headerlink" title="第一问 parent.show()"></a>第一问 parent.show()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.show();</span><br></pre></td></tr></table></figure>
<p>调用<code>parent.show()</code>的方法，其实就是调用<code>parent</code>实例上的<code>show</code>方法，直接输出<code>1, [1, 2, 1], 5</code>;没什么太多解释的，了解<code>new</code>关键字就可以。</p>
<h2 id="第二问-child1-show-、child2-show"><a href="#第二问-child1-show-、child2-show" class="headerlink" title="第二问 child1.show()、child2.show()"></a>第二问 child1.show()、child2.show()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure>
<p>首相要了解下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Preson();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">22</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码把<code>Child.prototype</code>指向一个<code>Preson</code>的实例，可以知道<code>Child.prototype.__proto__</code>指向<code>Preson.prototype</code>;<code>Child.prototype.constructor</code>指向<code>Preson</code>。下面是验证代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype.__proto__ === Preson.prototype; <span class="comment">// true</span></span><br><span class="line">Child.prototype.constructor === Preson; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>child1</code>、<code>child2</code>的结构如下图所示：<br><img src="../../images/interviewquestion/javascript-prototype-1-1.png" alt="javascript-prototype"></p>
<p><code>child1</code>、<code>child2</code>都是<code>Child</code>构造函数实例化产生的，所以<code>child1.show() child2.show()</code>是调用的<code>Child.prototype</code>上的方法，但是注意<code>child1</code>、<code>child2</code>的对象上都声明了一个新属性<code>a</code>。<br>根据上面第<code>6</code>条知识点可知结果为<code>11, [1, 2, 1], 5)</code>、<code>12, [1, 2, 1], 5</code>；</p>
<p><strong>注意</strong><br>从代码上看<code>child1.__proto__.b</code>数组的第三项是指向<code>child1.__proto__.a</code>的，那我们此时修改<code>child1.__proto__.a</code>的值，是否会影响<code>child1.show()</code>的结果呢:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child1.__proto__.a = <span class="number">12123</span>;</span><br><span class="line">child1.show(); <span class="comment">// 11, [1, 2, 1], 5</span></span><br></pre></td></tr></table></figure>
<p>是没有影响的，因为<code>parent</code>实例生成的时候，<code>this.a</code>指向了一个原始值<code>2</code>,所以<code>this.b</code>中的第三项实际上是被赋值了一个<strong>原始值</strong>，故此处乍看起来像是<strong>引用类型</strong>的赋值，实则不是。<strong>原始值赋值会开辟新的存储空间</strong>，使得<code>this.a</code>和<code>this.b[2]</code>的值相等，但是却指向了堆内存里的不同地址。</p>
<h2 id="第三问-parent-show"><a href="#第三问-parent-show" class="headerlink" title="第三问 parent.show()"></a>第三问 parent.show()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.show();</span><br></pre></td></tr></table></figure>
<p>根据上面第<code>2</code>条知识点，可知<code>preson</code>和<code>Child</code>是<code>Person</code>的不同的实例，它们之间不会相互影响，所以它的经过不会更改为<code>1, [1, 2, 1], 5</code>。</p>
<h2 id="第四问-child1-show-、child2-show"><a href="#第四问-child1-show-、child2-show" class="headerlink" title="第四问 child1.show()、child2.show()"></a>第四问 child1.show()、child2.show()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面执行了</span></span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line"></span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure>
<p><code>child1.change()</code>执行了<code>change()</code>时执行过程如下：</p>
<p><strong><code>this.b.push(this.a)</code></strong><br>由于<code>this</code>的动态指向特性，<code>this.b</code>会指向<code>Child.prototype</code>上的<code>b</code>数组,<code>this.a</code>会指向<code>child1</code>的<code>a</code>属性,所以<code>Child.prototype.b</code>变成了<code>[1,2,1,11]</code>;</p>
<p><strong><code>this.a = this.b.length</code></strong><br><code>this.b.length</code>经过上一步的添加了一条数据变为了<code>4</code>，所以当前的<code>this.a</code>就是<code>4</code>。</p>
<p><strong><code>this.c.demo = this.a++;</code></strong><br><code>this.a</code>是<code>4</code>，<code>this.c.demo</code>的值被复制为<code>4</code>，不要忽略<code>this.a++</code>以后的值变为了<code>5</code>。</p>
<p><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果</p>
<p><code>child2.change()</code>执行了<code>change()</code>时执行过程如下：<br><strong><code>this.b.push(this.a)</code></strong><br>由于<code>this</code>的动态指向特性，<code>this.b</code>会指向<code>Child.prototype</code>上的<code>b</code>数组,<code>this.a</code>会指向<code>child2</code>的<code>a</code>属性,所以<code>Child.prototype.b</code>变成了<code>[1,2,1,11,12]</code>;</p>
<p><strong><code>this.a = this.b.length</code></strong><br><code>this.b.length</code>经过上一步的添加了一条数据变为了<code>5</code>，所以当前的<code>this.a</code>就是<code>5</code>。</p>
<p><strong><code>this.c.demo = this.a++;</code></strong><br><code>this.a</code>是<code>5</code>，<code>this.c.demo</code>的值被复制为<code>5</code>，不要忽略<code>this.a++</code>以后的值变为了<code>6</code>。</p>
<p>所以会输出如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child1.show(); <span class="comment">// 5, [1,2,1,11,12], 5</span></span><br><span class="line">child2.show(); <span class="comment">// 6, [1,2,1,11,12], 5</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>前端的所有知识都是比较零散的，所以尽量要建立自己的知识结构图才方便以后的查漏补缺</li>
<li>因为知识比较零散不便于记忆，最好多找几个切入点把零散的知识串联起来更容易记住</li>
<li>没有别的办法多写、多看、多记一遍不行就直到记住为止</li>
</ol>
<blockquote>
<p>值类型变量赋值给引用类型时，改变值类型变量的值并不会影响赋值给引用类型中的值，</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, test];</span><br><span class="line">test = <span class="number">2222</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4, 111];</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/dashnowords/p/9404237.html" target="_blank" rel="noopener">javascript 基础修炼(1)——一道十面埋伏的原型链面试题</a> &gt; <a href="https://www.php.cn/js-tutorial-410582.html" target="_blank" rel="noopener">javascript 原型链的一道面试题的分析（详细）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>InterviewQuestion</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入element-ui组件 ———— input组件</title>
    <url>/blog/vue/vue-element-input.html</url>
    <content><![CDATA[<p><strong><em>察见渊鱼者不详，智料隐匿者有殃。——《列子·说符》</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>在日常开发<code>PC</code>管理端界面的时候，会用到<strong>element-ui</strong>或者<strong>iview</strong>ui框架，比较常用的<code>input</code>组件是怎么封装的呢，以<code>element-ui</code>框架的<code>input</code>组件为例，分析一下它是怎么封装实现的，也可以为以后自己封装框架提供思路。</p>
<p>因为代码还是挺多的，主要分析几个点：</p>
<ul>
<li>支持<strong>前置内容</strong>、<strong>后置内容</strong>、<strong>后置元素</strong></li>
<li>支持所有原声的<code>type</code>，并且可以切换<code>password</code>模式</li>
<li>支持<code>readonly</code>、<code>disabled</code>、<code>autocomplete</code>、<code>maxlength</code>、<code>minlength</code>等等</li>
<li>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code></li>
<li><code>element-ui</code>是怎么做到类似与<code>vue</code>的双向绑定的</li>
<li><code>type</code>为<code>textare</code>模式时，做到<code>calcTextareaHeight</code></li>
</ul>
<p>下面就一步一步分下，主要的点会着重分析，比较简单或者比较不重要的点会快速带过。</p>
<p>源码参考<a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/input.vue" target="_blank" rel="noopener">element-ui input</a></p>
<h2 id="前置、后置"><a href="#前置、后置" class="headerlink" title="前置、后置"></a>前置、后置</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"type !== 'textarea'"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 前置元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"el-input-group__prepend"</span> <span class="attr">v-if</span>=<span class="string">"$slots.prepend"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"prepend"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 前置内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"el-input__prefix"</span> <span class="attr">v-if</span>=<span class="string">"$slots.prefix || prefixIcon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"prefix"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-input__icon"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-if</span>=<span class="string">"prefixIcon"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:class</span>=<span class="string">"prefixIcon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  // 主题代码 省略</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 后置内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-input__suffix"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"getSuffixVisible()"</span>&gt;</span></span><br><span class="line">    // 省略内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 后置元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"el-input-group__append"</span> <span class="attr">v-if</span>=<span class="string">"$slots.append"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"append"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  // 省略内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码可以首先通过<code>type</code>区分开<code>textarea</code>单独处理，<strong>前后置</strong>又分为两类：</p>
<ul>
<li>一类直接通过<code>prop</code>传入<code>prefix-icon</code>、<code>suffix-icon</code>传入前后置<code>icon-class</code>显示不同的内容</li>
<li>另一类是通过<code>vue</code>中的内容分发机制<code>slot</code>显示不同的内容，更灵活</li>
</ul>
<p>在后置内容中也会处理<code>clearable</code>、<code>PwdVisible</code>、<code>show-word-limit</code>显示不同的内容。</p>
<h2 id="原声type、其它原声属性"><a href="#原声type、其它原声属性" class="headerlink" title="原声type、其它原声属性"></a>原声type、其它原声属性</h2><p>以<code>input</code>为例，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 其它地方省略</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:tabindex</span>=<span class="string">"tabindex"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">"type !== 'textarea'"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind</span>=<span class="string">"$attrs"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:type</span>=<span class="string">"showPassword ? (passwordVisible ? 'text': 'password') : type"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:disabled</span>=<span class="string">"inputDisabled"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:readonly</span>=<span class="string">"readonly"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:autocomplete</span>=<span class="string">"autoComplete || autocomplete"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"input"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionstart</span>=<span class="string">"handleCompositionStart"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionupdate</span>=<span class="string">"handleCompositionUpdate"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionend</span>=<span class="string">"handleCompositionEnd"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">"handleInput"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">"handleFocus"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"handleBlur"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">change</span>=<span class="string">"handleChange"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:aria-label</span>=<span class="string">"label"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">// 其它地方省略</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 其它地方省略</span></span></span><br><span class="line"><span class="javascript">      disabled: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      readonly: <span class="built_in">Boolean</span>,</span></span><br><span class="line">      autocomplete: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">'off'</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">/** @Deprecated in next major version */</span></span></span><br><span class="line">      autoComplete: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line">        validator(val) &#123;</span><br><span class="line"><span class="javascript">          process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.warn(<span class="string">'[Element Warn][Input]\'auto-complete\' property will be deprecated in next major version. please use \'autocomplete\' instead.'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="comment">// 其它地方省略</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里先不关注事件，只关注属性的设置，<code>element-ui</code>支持所有<code>input</code>原声的属性，其实就是通过<code>prop</code>传入<code>type</code>传入，如果是非<code>password</code>就直接赋值给<code>input</code>标签的<code>type</code>属性。<br>如果是<code>password</code>类型判断是否传入<code>show-password</code>字段，根据传入判断给<code>input</code>的<code>type</code>复制为<code>password</code>或者<code>text</code>。</p>
<h2 id="其它原声属性"><a href="#其它原声属性" class="headerlink" title="其它原声属性"></a>其它原声属性</h2><p>其它属性如<code>disabled</code>、<code>readonly</code>、<code>autocomplete</code>都是通过显示的<code>prop</code>传入，哪像一些没有显示接受的<code>prop</code>怎么获取到的呢，比如说<code>maxlength</code>、<code>minlength</code>这种没有显示接收的怎么获取到的呢。<br>是通过<code>v-bind=&quot;$attrs&quot;</code>获取到的，使用的时候直接通过<code>this.$attrs.XXXX</code>就可以使用对应的属性。<code>element-ui</code>中在检测输入长度是否超过设置的长度是有使用到如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略部分代码</span></span><br><span class="line">isWordLimitVisible() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.showWordLimit &amp;&amp;</span><br><span class="line">    <span class="keyword">this</span>.$attrs.maxlength &amp;&amp;</span><br><span class="line">    (<span class="keyword">this</span>.type === <span class="string">'text'</span> || <span class="keyword">this</span>.type === <span class="string">'textarea'</span>) &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.inputDisabled &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.readonly &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.showPassword;</span><br><span class="line">&#125;,</span><br><span class="line">upperLimit() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$attrs.maxlength;</span><br><span class="line">&#125;,</span><br><span class="line">textLength() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.value === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(<span class="keyword">this</span>.value).length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value || <span class="string">''</span>).length;</span><br><span class="line">&#125;,</span><br><span class="line">inputExceed() &#123;</span><br><span class="line">  <span class="comment">// show exceed style if length of initial value greater then maxlength</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isWordLimitVisible &amp;&amp;</span><br><span class="line">    (<span class="keyword">this</span>.textLength &gt; <span class="keyword">this</span>.upperLimit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 忽略部分代码</span></span><br></pre></td></tr></table></figure>
<p>如果不太了解<code>v-bind=&quot;$attrs&quot;</code>的使用可以看我另一篇文章<a href="/blog/vue/vue-vModel-sync.html">Vue中v-model解析、sync修饰符解析</a></p>
<h2 id="原声事件、双向绑定"><a href="#原声事件、双向绑定" class="headerlink" title="原声事件、双向绑定"></a>原声事件、双向绑定</h2><p>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code>。</p>
<p>常用的时间就不用多做介绍了，就是比较新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code>是用来出里一段文字输入的事件。详细信息请看：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart" target="_blank" rel="noopener">compositionstart</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionupdate" target="_blank" rel="noopener">compositionupdate</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionend" target="_blank" rel="noopener">compositionend</a></p>
<p>在外层就可以监听的到<code>input</code>标签的<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>事件，是因为组件内部在每一个方法中都有一个<code>this.$emit(&#39;input/focus/blur/change&#39;, evnet.target.value/event)</code>。</p>
<p>那是怎么做到修改外层通过<code>v-model</code>绑定的值的呢？</p>
<p>要想了解他是怎么实现双向绑定的就要了解<code>v-model</code>是什么，<code>v-model</code>其实就是一个语法糖，在<code>vue</code>编译阶段就会解析为<code>:value=&quot;绑定的值&quot;</code>和默认的<code>@input=(value) =&gt; {绑定的值 = value}</code>。然后再是在<code>input</code>标签上绑定的<code>handleInput</code>方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleInput(event) &#123;</span><br><span class="line">  <span class="comment">// should not emit input during composition</span></span><br><span class="line">  <span class="comment">// see: https://github.com/ElemeFE/element/issues/10516</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isComposing) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// hack for https://github.com/ElemeFE/element/issues/8548</span></span><br><span class="line">  <span class="comment">// should remove the following line when we don't support IE</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.value === <span class="keyword">this</span>.nativeInputValue) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, event.target.value);</span><br><span class="line">  <span class="comment">// ensure native input value is controlled</span></span><br><span class="line">  <span class="comment">// see: https://github.com/ElemeFE/element/issues/12850</span></span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="keyword">this</span>.setNativeInputValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里<code>input</code>的组件的属性基本上就解释完成，<code>textare</code>基本上都是一样的，但是<code>textarea</code>有一点特殊的操作。</p>
<h2 id="textarea高度自适应"><a href="#textarea高度自适应" class="headerlink" title="textarea高度自适应"></a>textarea高度自适应</h2><p>它是怎么实现高度自适应的，具体的实现代码是在<a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/calcTextareaHeight.js" target="_blank" rel="noopener">calcTextareaHeight</a>，大致分为几部：</p>
<ul>
<li>创建一个临时隐藏的<code>textarea</code>元素</li>
<li>通过隐藏的<code>textarea</code>计算显示的<code>textarea</code>元素的高度</li>
<li>并且判断<code>minRows</code>、<code>maxRows</code>属性</li>
<li>最后删除<code>textarea</code>元素，并且清空<code>dom</code>引用</li>
</ul>
<p>在<code>input</code>组件中通过创建<code>watch</code>监听<code>value</code>值的变化，每次<code>value</code>变化从新计算<code>textarea</code>元素的高度。</p>
<p><strong>创建一个临时隐藏的<code>textarea</code>元素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hiddenTextarea;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="comment">// 保证只执行一次</span></span><br><span class="line"><span class="keyword">if</span> (!hiddenTextarea) &#123;</span><br><span class="line">  <span class="comment">// 创建textarea</span></span><br><span class="line">  hiddenTextarea = <span class="built_in">document</span>.createElement(<span class="string">'textarea'</span>);</span><br><span class="line">  <span class="comment">// 添加到页面中</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(hiddenTextarea);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure>
<p><strong>通过隐藏的<code>textarea</code>计算显示的<code>textarea</code>元素的高度</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HIDDEN_STYLE = <span class="string">`</span></span><br><span class="line"><span class="string">  height:0 !important;</span></span><br><span class="line"><span class="string">  visibility:hidden !important;</span></span><br><span class="line"><span class="string">  overflow:hidden !important;</span></span><br><span class="line"><span class="string">  position:absolute !important;</span></span><br><span class="line"><span class="string">  z-index:-1000 !important;</span></span><br><span class="line"><span class="string">  top:0 !important;</span></span><br><span class="line"><span class="string">  right:0 !important</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONTEXT_STYLE = [</span><br><span class="line">  <span class="string">'letter-spacing'</span>,</span><br><span class="line">  <span class="string">'line-height'</span>,</span><br><span class="line">  <span class="string">'padding-top'</span>,</span><br><span class="line">  <span class="string">'padding-bottom'</span>,</span><br><span class="line">  <span class="string">'font-family'</span>,</span><br><span class="line">  <span class="string">'font-weight'</span>,</span><br><span class="line">  <span class="string">'font-size'</span>,</span><br><span class="line">  <span class="string">'text-rendering'</span>,</span><br><span class="line">  <span class="string">'text-transform'</span>,</span><br><span class="line">  <span class="string">'width'</span>,</span><br><span class="line">  <span class="string">'text-indent'</span>,</span><br><span class="line">  <span class="string">'padding-left'</span>,</span><br><span class="line">  <span class="string">'padding-right'</span>,</span><br><span class="line">  <span class="string">'border-width'</span>,</span><br><span class="line">  <span class="string">'box-sizing'</span></span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateNodeStyling</span>(<span class="params">targetElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> style = <span class="built_in">window</span>.getComputedStyle(targetElement);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> boxSizing = style.getPropertyValue(<span class="string">'box-sizing'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paddingSize = (</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'padding-bottom'</span>)) +</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'padding-top'</span>))</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> borderSize = (</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'border-bottom-width'</span>)) +</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'border-top-width'</span>))</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> contextStyle = CONTEXT_STYLE</span><br><span class="line">    .map(<span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>:<span class="subst">$&#123;style.getPropertyValue(name)&#125;</span>`</span>)</span><br><span class="line">    .join(<span class="string">';'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; contextStyle, paddingSize, borderSize, boxSizing &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    paddingSize,</span><br><span class="line">    borderSize,</span><br><span class="line">    boxSizing,</span><br><span class="line">    contextStyle</span><br><span class="line">&#125; = calculateNodeStyling(targetElement);</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">hiddenTextarea.setAttribute(<span class="string">'style'</span>, <span class="string">`<span class="subst">$&#123;contextStyle&#125;</span>;<span class="subst">$&#123;HIDDEN_STYLE&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 设置value</span></span><br><span class="line">hiddenTextarea.value = targetElement.value || targetElement.placeholder || <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 获取隐藏textarea滚动整体高度</span></span><br><span class="line"><span class="keyword">let</span> height = hiddenTextarea.scrollHeight;</span><br><span class="line"><span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"><span class="comment">// 判断盒模型</span></span><br><span class="line"><span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果为border-box本身的高度加上borderSize</span></span><br><span class="line">  height = height + borderSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (boxSizing === <span class="string">'content-box'</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果为content-box本身的高度加上paddingSize</span></span><br><span class="line">  height = height - paddingSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把隐藏textarea的vlaue设置为空</span></span><br><span class="line">hiddenTextarea.value = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 获取每行高度： row的高度为滚动高度-padding</span></span><br><span class="line"><span class="keyword">let</span> singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure>
<p><strong>并且判断<code>minRows</code>、<code>maxRows</code>属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="comment">// 判断是否有设置minRows</span></span><br><span class="line">  <span class="keyword">if</span> (minRows !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 最小高度 = 每行高度 * 最小行数</span></span><br><span class="line">    <span class="keyword">let</span> minHeight = singleRowHeight * minRows;</span><br><span class="line">    <span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果boxSizing为border-box时： 最小高度 = 原最小高度 + padding + border;</span></span><br><span class="line">      minHeight = minHeight + paddingSize + borderSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取当前计算的最小高度和上面计算出的scrollHeight度中的最大值</span></span><br><span class="line">    height = <span class="built_in">Math</span>.max(minHeight, height);</span><br><span class="line">    <span class="comment">// 赋值给result.minHeight</span></span><br><span class="line">    result.minHeight = <span class="string">`<span class="subst">$&#123; minHeight &#125;</span>px`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否有设置maxRows</span></span><br><span class="line">  <span class="keyword">if</span> (maxRows !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 最大高度 = 每行高度 * 最大行数</span></span><br><span class="line">    <span class="keyword">let</span> maxHeight = singleRowHeight * maxRows;</span><br><span class="line">    <span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果boxSizing为border-box时： 最小高度 = 原最小高度 + padding + border;</span></span><br><span class="line">      maxHeight = maxHeight + paddingSize + borderSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取当前计算的最大高度和上面计算出的scrollHeight度中的最小值</span></span><br><span class="line">    height = <span class="built_in">Math</span>.min(maxHeight, height);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 赋值给result.minHeight</span></span><br><span class="line">  result.height = <span class="string">`<span class="subst">$&#123; height &#125;</span>px`</span>;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure>
<p><strong>最后删除<code>textarea</code>元素，并且清空<code>dom</code>引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果存在parentNode 就清除parentNode包含的hiddenTextarea 元素</span></span><br><span class="line">hiddenTextarea.parentNode &amp;&amp; hiddenTextarea.parentNode.removeChild(hiddenTextarea);</span><br><span class="line"><span class="comment">// 清空dom引用释放变量</span></span><br><span class="line">hiddenTextarea = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 返回最小高度和最大高度</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>到此<code>textarea</code>结束，可能还有很多细节没有记录到，如果有什么意见请评论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整篇文章都是根据几点分析的，如下：</p>
<ul>
<li>支持<strong>前置内容</strong>、<strong>后置内容</strong>、<strong>后置元素</strong></li>
<li>支持所有原声的<code>type</code>，并且可以切换<code>password</code>模式</li>
<li>支持<code>readonly</code>、<code>disabled</code>、<code>autocomplete</code>、<code>maxlength</code>、<code>minlength</code>等等</li>
<li>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code></li>
<li><code>element-ui</code>是怎么做到类似与<code>vue</code>的双向绑定的</li>
<li><code>type</code>为<code>textare</code>模式时，做到<code>calcTextareaHeight</code></li>
</ul>
<p>当然还有很多的点没有记录到比如说<code>clear</code>、<code>emitter</code>、<code>Migrating</code>等等，这个会在后面的文章中着重介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/input.vue" target="_blank" rel="noopener">element-ui input</a><br><a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/calcTextareaHeight.js" target="_blank" rel="noopener">element-ui calcTextareaHeight</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Array系列(三) Array中的forEach方法可以用break、continue跳出循环？</title>
    <url>/blog/es6/es6-Array-break-continue.html</url>
    <content><![CDATA[<p><strong><em>飄風不終朝，驟雨不終日。——《道德經》</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>在<code>Array.prototype</code>上有很多方法，比较常用的就是<code>every</code>、<code>filter</code>、<code>forEach</code>、<code>map</code>、<code>some</code>这些循环方法，可以通过<code>break</code>、<code>comtinue</code>跳出循环？<br>现在基本上都是通过<code>forEach</code>、<code>every</code>来代替<code>for</code>循环，<code>for</code>循环可以通过<code>break</code>、<code>continue</code>跳出循环。而 forEach 可以不可以呢，下面一步一步的验证一下。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><hr>
<p>在<code>for</code>中遇到<code>break</code>就会退出当前循环，后面的循环不会再执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure>
<p>在<code>for</code>中遇到<code>continue</code>就会退出当前本次循环，后面的循环会执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>for</code>中不能使用 return，不然会报错</p>
</blockquote>
<h2 id="forEach、every、some、filter、map"><a href="#forEach、every、some、filter、map" class="headerlink" title="forEach、every、some、filter、map"></a>forEach、every、some、filter、map</h2><hr>
<p>如果想退出<code>forEach</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<p>如果想退出<code>every</code>，就只能通过<code>return</code>, 它会退出当前循环，后面的循环不会再执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure>
<p>如果想退出<code>some</code>，就只能通过<code>return</code>, <code>return false</code>和<code>return true</code>它的表现是不一致的。<code>return false</code>它的表现和<code>forEach</code>中的表现一致。 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<p><code>return true</code>和<code>every</code>表现一致，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure>
<p>如果想退出<code>filter</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<p>如果想退出<code>map</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">"-"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>forEach</code>、<code>every</code>、<code>some</code>中不能用<code>break</code>、<code>continue</code>跳出循环，不然会报错。</p>
</blockquote>
<p>都知道<code>filter</code>、<code>map</code>会返回一个新的数组，而<code>every</code>、<code>some</code>会返回一个<code>Boolean</code>类型的。</p>
<h2 id="some-和-every-需要注意的地方"><a href="#some-和-every-需要注意的地方" class="headerlink" title="some 和 every 需要注意的地方"></a>some 和 every 需要注意的地方</h2><hr>
<p><code>some()</code> 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个 Boolean 类型的值。<code>polyfill</code>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.some = <span class="function"><span class="keyword">function</span>(<span class="params">callbackfn, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = <span class="built_in">Number</span>(<span class="keyword">this</span>.length);</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">let</span> Pk = <span class="built_in">String</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (Pk <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = <span class="keyword">this</span>[Pk];</span><br><span class="line">      <span class="keyword">if</span> (callbackfn.call(thisArg, kValue, k, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，遇到回调返回值是 <code>true</code> 的话，函数就直接返回、结束了。这是种短路算法，并不是所有回调都执行一遍，然后再最后求所有与值。<code>every</code> 也类似，不过与之相反，遇到回调返回值是 <code>false</code> 时，整体就直接返回 <code>false</code> 了。<br>从实现上表达出的语义来讲，<code>some</code> 是在说：<strong>有一个成功，我就成功，而 <code>every</code> 是在说：有一个失败，我就失败</strong><br><strong>另外要强调一点，对于稀疏数组，不存在的索引值时，回调函数是不执行的</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">Array.prototype.some()</a><br><a href="https://juejin.im/post/5d08a565e51d45773d468614#heading-2" target="_blank" rel="noopener">不再写 break 和 continue 了</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Array系列(四) Array常用的方法和实现reduce、map、filter、forEach</title>
    <url>/blog/es6/es6-Array-function.html</url>
    <content><![CDATA[<p><strong><em>挫其銳，解其紛，和其光，同其塵。</em></strong></p>
<blockquote>
<p><a href="/blog/es6/es6-Array.html">ES6 Array 系列(一) 一些常用 array 的扩展方法</a><br><a href="/blog/es6/es6-Array1.html">ES6 Array 系列(二) 一些常用 array 的扩展方法（二）</a><br><a href="/blog/es6/es6-Array-break-continue.html">ES6 Array 系列(三) Array 中的 forEach 方法可以用 break、continue 跳出循环？</a><br><a href="/blog/es6/es6-Array-function.html">ES6 Array 系列(四) Array 常用的方法和实现 reduce、map、filter、forEach</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><code>Array.prototype</code>上有很多方法，可以很方便的实现各种循环、过滤对数组做很多的处理，这里主要记录自己怎么实现几个方法<code>map</code>、<code>forEach</code>、<code>filter</code>、<code>reduce</code>，怎么使用就不多做讲解了因为在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">mdn 中 Array</a>或者别人的文章中有很多的讲解了。</p>
<h2 id="实现-reduce"><a href="#实现-reduce" class="headerlink" title="实现 reduce"></a>实现 reduce</h2><hr>
<p>首先要了解<code>reduce</code>它有两个参数，第一个参数是一个回调方法<code>callback</code>，第二个参数是一个初始值<code>initialValue</code>。<br>大致实现步骤如下：</p>
<ul>
<li>判断参数，判断调用方法本身是否为 Array</li>
<li>声明要用的变量</li>
<li>判断是否有初始值，如果没有则从本身数组中取，取到直接跳出循环</li>
<li>循环调用 callback</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfReduce = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initalValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明要用到的变量</span></span><br><span class="line">  <span class="comment">// 要循环的数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="comment">// 开始的数组索引 默认为 0</span></span><br><span class="line">  <span class="keyword">let</span> startIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为有初始化值 initalValue</span></span><br><span class="line">  <span class="keyword">if</span> (initalValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果初始值为 undefined 循环从数组中找到有值，并且退出循环</span></span><br><span class="line">    <span class="comment">// 过滤稀疏值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startIndex = i;</span><br><span class="line">        res = arr[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = initalValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在上一步拿到初始值，循环调用传入的回调函数，并且过滤松散值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex++; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = callback.call(<span class="literal">null</span>, res, arr[i], i, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试一下<code>selfReduce</code>和<code>reduce</code>方法是否表现一致，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev + next;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 15</span></span><br><span class="line">arr.selfReduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev + next;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>其实也可以去看一下官方的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">mdn reduce polyfill</a>。</p>
<h2 id="实现-map"><a href="#实现-map" class="headerlink" title="实现 map"></a>实现 map</h2><hr>
<p><code>map</code>的使用这里不多做赘述，只记录它的两种实现方式一种通过<code>for</code>循环实现，另一种通过<code>reduce</code>实现。</p>
<h3 id="for-循环实现"><a href="#for-循环实现" class="headerlink" title="for 循环实现"></a>for 循环实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfMap = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明要用到的变量</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> aMap = [];</span><br><span class="line">  <span class="comment">// 循环调用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    <span class="comment">// 过滤稀疏值</span></span><br><span class="line">    <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    aMap[i] = callback.call(context, arr[i], i, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> aMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试实现<code>selfMap</code>和<code>map</code>是否一致，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">aTest.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line">aTest.selfMap(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceMap = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aMap = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 使用reduce实现循环</span></span><br><span class="line">  <span class="keyword">return</span> aMap.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拼接上次循环结果和当前结果</span></span><br><span class="line">    <span class="comment">// 循环调用callback</span></span><br><span class="line">    <span class="keyword">return</span> [...pre, callback.call(context, cur, index, <span class="keyword">this</span>)];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试实现<code>reduceMap</code>和<code>map</code>是否一致，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">aTest.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line">aTest.reduceMap(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h2 id="filter-实现"><a href="#filter-实现" class="headerlink" title="filter 实现"></a>filter 实现</h2><hr>
<p>filter 也用到很多次，这里也不多做赘述直接看两种实现方法：</p>
<h3 id="for-循环实现-1"><a href="#for-循环实现-1" class="headerlink" title="for 循环实现"></a>for 循环实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfFilter = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = aArr.length;</span><br><span class="line">  <span class="keyword">let</span> aFArr = [];</span><br><span class="line">  <span class="comment">// 循环调用callback</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!aArr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callback.call(context, aArr[i], i, <span class="keyword">this</span>) &amp;&amp; aFArr.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> aFArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reduce-实现-1"><a href="#reduce-实现-1" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceFilter = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环调用callback</span></span><br><span class="line">  aArr.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> callback.call(context, cur, index, <span class="keyword">this</span>) ? [...pre, cur] : [...pre];</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> aArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">aTest.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aTest.selfFilter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aTest.reduceFilter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="实现-forEach"><a href="#实现-forEach" class="headerlink" title="实现 forEach"></a>实现 forEach</h2><hr>
<p>for 循环实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfForeach = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    callback.call(context, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>reduce 循环实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceForeach = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Array.prototype.reduce"</span> + <span class="string">"called on null or undefined"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...pre, callback.call(context, cur, index, <span class="keyword">this</span>)];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上理解了怎么实现，无论是使用 for 来实现还是用 reduce 实现，基本上没有太大的差别。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">Array.prototype.reduce()</a><br><a href="https://juejin.im/post/5cef46226fb9a07eaf2b7516#heading-4" target="_blank" rel="noopener">一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧</a><br><a href="https://juejin.im/post/5c0b7f03e51d452eec725729" target="_blank" rel="noopener">JS Array.reduce 实现 Array.map 和 Array.filter</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的多种垂直水平居中</title>
    <url>/blog/css/css-center.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在面试的时候<strong>css面试题</strong>里面基本上都会问一个元素<strong>垂直水平居中</strong>，其实这个有多种方式实现，同时元素可以是<strong>固定宽高、不固定宽高</strong>的。</p>
<p><strong>固定宽高</strong></p>
<ul>
<li>position absolute + 负margin</li>
<li>position absolute + margin auto</li>
<li>position absolute + calc</li>
</ul>
<p><strong>不固定宽高</strong></p>
<ul>
<li>position absolute + transform</li>
<li>css-table</li>
<li>flex</li>
<li>grid</li>
</ul>
<p>下面就直接上代码，公用的<code>html代码</code>和<code>css代码</code>就写在这里后面都会在这个基础上增加代码。<br><strong>html公用代码</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-center"</span>&gt;</span></span><br><span class="line">        box-center</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css公用代码</strong>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有两个元素它们是父子级的关系，要达到的效果是子元素要在父元素中垂直水平居中</strong>。</p>
<h2 id="固定宽高"><a href="#固定宽高" class="headerlink" title="固定宽高"></a>固定宽高</h2><p>固定宽高的意思就是要居中的这个元素它的<strong>宽高都是固定的值</strong>，下面一个一个用代码实现。</p>
<h3 id="position-absolute-负margin"><a href="#position-absolute-负margin" class="headerlink" title="position absolute + 负margin"></a>position absolute + 负margin</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用绝对定位让子元素基于父元素的左上角偏移50%，但是这样不是真正的居中因为它多移动了本身元素的<strong>宽度的一半</strong>和<strong>高度的一半</strong>，这个时候我们可以通过<code>负margin</code>来修正这个问题，所以就有了<code>-50px</code>这两个属性。</p>
<h3 id="position-absolute-margin-auto"><a href="#position-absolute-margin-auto" class="headerlink" title="position absolute + margin auto"></a>position absolute + margin auto</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了。</p>
<h3 id="position-absolute-calc"><a href="#position-absolute-calc" class="headerlink" title="position absolute + calc"></a>position absolute + calc</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(50% - 50px);</span><br><span class="line">    <span class="attribute">left</span>: <span class="built_in">calc</span>(50% - 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>calc</code>计算属性减去元素本身高度和宽度的一半。</p>
<h2 id="不固定宽高"><a href="#不固定宽高" class="headerlink" title="不固定宽高"></a>不固定宽高</h2><p>固定宽高的意思就是要居中的这个元素它的<strong>宽高都是不固定的值</strong>，不固定宽高的方法是可以覆盖上面固定宽高的方法，下面一个一个用代码实现。</p>
<h3 id="position-absolute-transform"><a href="#position-absolute-transform" class="headerlink" title="position absolute + transform"></a>position absolute + transform</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修复绝对定位的问题，还可以使用css3新增的<code>transform</code>，<code>transform</code>的<code>translate</code>属性也可以设置百分比，其是相对于自身的宽和高，所以可以讲<code>translate</code>设置为<code>-50%</code>，就可以做到居中了。</p>
<h3 id="css-table"><a href="#css-table" class="headerlink" title="css-table"></a>css-table</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>display: table-cell</code>把<code>div</code>元素变为<code>table</code>元素的实现效果，通过这个特性也可以实现垂直水平居中。</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>flex</code>的两个属性实现垂直水平居中。</p>
<h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>grid</code>布局实现居中，如果<code>grid</code>不太了解可以看<a href="/blog/css/css-grid.html">grid布局</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有两种比较特殊的垂直水平居中的方式，应用场景比较少或者代价比较大，所以在这几记录一下如下：</p>
<ul>
<li>行内元素居中</li>
<li>table布局</li>
</ul>
<h3 id="行内元素居中"><a href="#行内元素居中" class="headerlink" title="行内元素居中"></a>行内元素居中</h3><p>css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">    font-size: 0; // 兼容代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">line-height</span>: initial;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把<code>container</code>设置为行内元素，通过<code>text-align</code>就可以做到水平居中，通过<code>vertical-align</code>也可以在垂直方向做到居中。</p>
<h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><p>改变<code>html</code>结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-center"</span>&gt;</span>box-center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>css</code>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用<code>table</code>属性实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面实现总结如下面表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">居中元素定宽高固定</th>
<th style="text-align:center">PC兼容性</th>
<th style="text-align:center">移动端兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">position absolute + 负margin</td>
<td style="text-align:center">固定宽高</td>
<td style="text-align:center">ie6+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">position absolute + margin auto</td>
<td style="text-align:center">固定宽高</td>
<td style="text-align:center">ie6+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">position absolute + calc</td>
<td style="text-align:center">固定宽高</td>
<td style="text-align:center">ie9+, chrome19+, firefox4+</td>
<td style="text-align:center">安卓4.4+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">position absolute + transform</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie9+, chrome4+, firefox3.5+</td>
<td style="text-align:center">安卓3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">css-table</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie8+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">flex</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie10+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">grid</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie10+, chrome57+, firefox52+</td>
<td style="text-align:center">安卓6+, iOS10.3+</td>
</tr>
<tr>
<td style="text-align:center">table布局</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie6+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">行内元素居中</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie6+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓2.3+, iOS6+</td>
</tr>
</tbody>
</table>
<p>推荐用法：</p>
<ul>
<li>PC端<strong>有兼容性</strong>要求，宽高固定，推荐<code>absolute + 负margin</code></li>
<li>PC端<strong>有兼容</strong>要求，宽高不固定，推荐<code>css-table</code></li>
<li>PC端<strong>无兼容性</strong>要求，推荐<code>flex</code></li>
<li>移动端推荐使用<code>flex</code></li>
</ul>
<p>以后肯定<code>grid</code>会大方异彩。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://yanhaijing.com/css/2018/01/17/horizontal-vertical-center/" target="_blank" rel="noopener">CSS实现水平垂直居中的1010种方式 原创</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>var和let、const对比</title>
    <url>/blog/es6/es6-variable.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>

<p>在<strong>ECMAScript6</strong>中新增两个变量声明的指令<code>let</code>和<code>const</code>，以前经常用的<code>var</code>有什么区别。</p>
<h2 id="var声明"><a href="#var声明" class="headerlink" title="var声明"></a>var声明</h2><hr>

<p><code>var</code> <strong>声明语句</strong>声明一个变量，并可选地将其初始化为一个值。</p>
<ul>
<li>可重复声明</li>
<li>变量提升</li>
<li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>通过<code>var</code>关键字声明一个<code>count</code>变量，并且<code>count</code>的值为1。</p>
<h3 id="可重复声明"><a href="#可重复声明" class="headerlink" title="可重复声明"></a>可重复声明</h3><p>可以重复声明<code>count</code>变量，也可以重新赋值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">2</span>;</span><br><span class="line">count = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><code>var</code>声明的变量是存在<strong>变量提升</strong>的 ，由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>提升将影响变量声明，而不会影响其值的初始化</strong>。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>var</code>声明变量的作用域限制在其声明位置的<strong>上下文中</strong>，而非声明变量总是<strong>全局</strong>的。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line">    sum = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">x();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.sum); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>建议始终声明变量，无论它们是在函数还是全局作用域内。</li>
</ul>
</blockquote>
<h2 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h2><hr>

<p><code>let</code>允许你声明一个作用域被限制在 <code>块级中的变量</code>、<code>语句或者表达式</code>。与 <code>var</code> 关键字不同的是， <code>var</code>声明的变量只能是<code>全局</code>或者<code>整个函数块</code>的。</p>
<ul>
<li>不可重复声明，可以重复赋值</li>
<li>块作用域</li>
<li>暂存死区</li>
<li>不存在变量提升</li>
</ul>
<h3 id="不可重复声明，可以重复赋值"><a href="#不可重复声明，可以重复赋值" class="headerlink" title="不可重复声明，可以重复赋值"></a>不可重复声明，可以重复赋值</h3><p><strong><code>let</code>不可以重复同样名称的变量，但是可以重复给同一个变量多次赋值</strong>。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">2</span>; <span class="comment">// Identifier 'count' has already been declared</span></span><br><span class="line">count = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p><code>let</code>声明的变量只在其声明的<strong>块或子块中</strong>可用，这一点，与<code>var</code>相似。二者之间最主要的区别在于<code>var</code>声明的变量的作用域是<strong>整个封闭函数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">        <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">        <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>let声明</strong>的变量不会挂载顶层对象下面，会临时创建一个<code>scope</code>来储存<strong>let声明</strong>，执行完成清除，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">debugger</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> count = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sum = <span class="number">2</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在执行完<code>let count = 1;</code>，效果如下图所示：<br><img src="../../images/es/es-let.png" alt="let"><br>当<strong>javascript</strong>执行完成后，<code>scope</code>也会被清空。</p>
<h3 id="暂存死区-不存在变量提升"><a href="#暂存死区-不存在变量提升" class="headerlink" title="暂存死区/不存在变量提升"></a>暂存死区/不存在变量提升</h3><p><code>let</code> 被创建在包含该声明的（块）作用域顶部，<strong>一般被称为“提升”</strong>。与通过  <code>var</code> 声明的有初始化值 <code>undefined</code> 的变量不同，通过 <code>let</code> 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 <code>ReferenceError</code>。该变量处在一个自块顶部到初始化处理的“暂存死区”中。<br>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// Uncaught ReferenceError: Cannot access 'count' before initialization</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h2><hr>

<p>常量是块级作用域，很像使用 <code>let</code> 语句定义的变量。常量的值<strong>不能</strong>通过重新赋值来改变，并且<strong>不能</strong>重新声明。</p>
<ul>
<li>不能重复声明</li>
<li>不能重复赋值</li>
<li>块级作用域</li>
<li>暂存死区</li>
<li>不存在变量提升</li>
<li>一旦声明，必须马上赋值</li>
</ul>
<p><code>不能重复声明</code>、<code>块级作用域</code>、<code>块级作用域</code>、<code>不存在变量提升</code>在这里不再赘述和<code>let</code>中的表现相同，请看上文。</p>
<h3 id="一旦声明，必须马上赋值"><a href="#一旦声明，必须马上赋值" class="headerlink" title="一旦声明，必须马上赋值"></a>一旦声明，必须马上赋值</h3><p><code>const</code> 声明之后必须马上赋值，否则会报错，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count; <span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="不能重复赋值"><a href="#不能重复赋值" class="headerlink" title="不能重复赋值"></a>不能重复赋值</h3><p><code>const</code>声明创建一个值的<strong>只读引用</strong>。但这并不意味着它所持有的值是<strong>不可变</strong>的，只是<strong>变量标识符</strong>不能重新分配。<br><strong>JavaScript</strong>中的数据类型分为两大类：<code>值类型</code>、<code>引用类型</code>。</p>
<p><strong>值类型</strong></p>
<p>用<code>const</code>声明的变量被首次被赋值为<strong>值类型</strong>，它的值就不能改变了，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">2</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p><strong>引用类型</strong></p>
<p>只要不改变量的<strong>指针地址</strong>就不会报错，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    name: <span class="string">'nihao'</span>,</span><br><span class="line">    age: <span class="number">17</span></span><br><span class="line">&#125;;</span><br><span class="line">user.name = <span class="string">'大家好'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结对比如下面表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">/</th>
<th style="text-align:center">能否重复声明</th>
<th style="text-align:center">能否重复赋值</th>
<th style="text-align:center">作用域</th>
<th style="text-align:center">变量提升</th>
<th style="text-align:center">暂存死区</th>
<th style="text-align:center">声明是否需要立即赋值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">var</td>
<td style="text-align:center">能</td>
<td style="text-align:center">能</td>
<td style="text-align:center">函数作用域/全局作用域</td>
<td style="text-align:center">存在变量提升</td>
<td style="text-align:center">不存在暂存死区</td>
<td style="text-align:center">不需要立即赋值</td>
</tr>
<tr>
<td style="text-align:center">let</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">能</td>
<td style="text-align:center">块级作用域/全局作用域</td>
<td style="text-align:center">不存在</td>
<td style="text-align:center">存在暂存死区</td>
<td style="text-align:center">不需要立即赋值</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">块级作用域/全局作用域</td>
<td style="text-align:center">不存在</td>
<td style="text-align:center">存在暂存死区</td>
<td style="text-align:center">需要立即赋值</td>
</tr>
</tbody>
</table>
<p>他们的特性基本上如上面表格所示，可以根据各个不同的需要，选择var、let、const来声明变量。</p>
<blockquote>
<p><a href="http://asyncnode.com/blog/javascript/javascript-Type-conversion.html">JavaScript类型转换（一） 常见数据类型</a></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var" target="_blank" rel="noopener">var 声明语句</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let 声明语句</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const 声明语句</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247483812&amp;idx=1&amp;sn=9bab06614e079bd9cc533a3b2cd02a75&amp;chksm=faec857ccd9b0c6a9b58e49f747651ffdf484acdd6fc82318a0964e4c339dbda6586e340ca4d&amp;mpshare=1&amp;scene=1&amp;srcid=082024th073paIFjxG2PXq8C&amp;sharer_sharetime=1566313518851&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b#rd" target="_blank" rel="noopener">JS 系列一：var、let、const、解构、展开、函数</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjAyMzY1OQ==&amp;mid=2247483768&amp;idx=1&amp;sn=328166a7f78be132b77215060e96128b&amp;chksm=cf5c4cfcf82bc5ea327e302b81401165663f3ad91d35270ee4e537f7b27081cad4fecffc4776&amp;mpshare=1&amp;scene=1&amp;srcid=0820mIdzuPo1JIpEQKyVpaGY&amp;sharer_sharetime=1566313451138&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b#rd" target="_blank" rel="noopener">ES6中let、const与var的区别</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中new相关的面试题</title>
    <url>/blog/InterviewQuestion/new-javascript.html</url>
    <content><![CDATA[<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个Foo 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Foo创建了一个叫getName的静态属性存储了一个匿名函数</span></span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>); &#125;;</span><br><span class="line"><span class="comment">// Foo的原型对象新创建了一个叫getName的匿名函数</span></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>); &#125;;</span><br><span class="line"><span class="comment">// 声明一个匿名，并且赋值给全局变量getName (函数表达式)</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="comment">// 声明一个全局函数getName (函数声明)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">5</span>); &#125;</span><br><span class="line"></span><br><span class="line">Foo.getName(); <span class="comment">// 第一问</span></span><br><span class="line">getName(); <span class="comment">// 第二问</span></span><br><span class="line">Foo().getName(); <span class="comment">// 第三问</span></span><br><span class="line">getName(); <span class="comment">// 第四问</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 第五问</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 第六问</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 第七问</span></span><br></pre></td></tr></table></figure>
<p><strong>如果这几个问题能直接回答出来，后面就没必要看了</strong>。</p>
<p><strong>简单了解一下javascript中的原型继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Preson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = name; <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">//公有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">//私有方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Preson.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//公有方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">Preson.name = <span class="string">'Wscats'</span>; <span class="comment">//静态属性</span></span><br><span class="line">Preson.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Son = <span class="keyword">new</span> Preson(<span class="string">'Son'</span>); <span class="comment">//实例化</span></span><br></pre></td></tr></table></figure>
<p>注意下面几点：</p>
<ul>
<li><strong>调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的</strong></li>
<li><strong>静态方法和静态属性就是我们无需实例化就可以调用</strong></li>
<li><strong>而对象的私有方法和属性,外部是不可以访问的</strong></li>
<li><strong>静态属性不能被继承</strong></li>
</ul>
<p>首先看一下代码，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>); &#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>); &#125;;</span><br></pre></td></tr></table></figure>
<p>首先看一下<code>Foo.getName</code>会在<code>Foo.prototype.constructor</code>中添加一个<code>getName</code>属性，如果直接调用<code>Foo.getName</code>他就直接调用<code>Foo.prototype.constructor</code>上得<code>getName</code>属性。<br>如果没有通过<code>new</code>关键字调用<code>Foo</code>的话，是不能访问<code>prototype</code>中的<code>getName</code>属性。<br>代码结果如下：<br><img src="../../images/interviewquestion/interviewquestion-javascirpt-1-1.png" alt="interviewquestion-javascript"></p>
<h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Foo.getName(); <span class="comment">// 第一问</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>根据上面的说明，可以得出第一问的<code>Foo.getName</code>就是会访问<code>constructor</code>上得静态属性，结果就是<code>2</code>。</p>
<h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getName(); <span class="comment">// 第二问</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>首先要介绍一下<strong>函数声明</strong>和<strong>函数表达式</strong>，如下：</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里考察的是<strong>变量提升</strong>的技巧，简单来说就是<strong>函数声明</strong>存在变量提升，不了解变量提升的话可以看另一篇文章<a href="/blog/javascript/hoisting.html">javascript中的变量提升</a>，所以这一题的答案就是4。</p>
<h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Foo().getName(); <span class="comment">// 第三问</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>Foo().getName()</code>; 先执行了<code>Foo</code>函数，然后调用<code>Foo</code>函数的返回值对象的<code>getName</code>属性函数。主要考察<code>this</code>指向问题和在<code>Foo</code>函数中没有<code>var</code>声明变量问题。<br>要注意<code>Foo</code>函数中的<code>getName</code>声明是没有<code>var</code>的，所以它会在全局作用域中创建一个<code>getName</code>，如果全局作用域中存在这个属性就会<strong>覆盖</strong>全局作用域的已存在的属性。<br>所以当<code>Foo</code>函数执行完成之后<code>getName = function () { console.log(1);}</code>会覆盖<code>getName = function () { console.log(4); }</code>。</p>
<blockquote>
<p>注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。</p>
</blockquote>
<p><code>Foo</code>函数的返回值是<code>this</code>，而<code>JS</code>的<code>this</code>问题已经有非常多的文章介绍，简单来讲this的指向就是由函数的调用方式决定的。<br>所以答案就是<strong>输出1</strong>。<br>这里最主要考察两个知识点，一个是作用域问题、一个是this指向问题，这个就不多做解释直接看往期文章。</p>
<h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getName(); <span class="comment">// 第四问</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>直接调用<code>getName</code>函数，相当于<code>window.getName()</code>，因为这个变量已经被<code>Foo</code>函数执行时修改了，所以结果和第三问相同也会<strong>输出1</strong>。</p>
<h2 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 第五问</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>第五问主要考察的是<font color="#ff502c">JS中的运算符优先级</font>，所以首先要了解<strong>JS中的运算符优先级</strong>，可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">MDN运算符优先级</a>学习这里就不多展示，只展示用到的如下图所示：<br><img src="../../images/interviewquestion/interviewquestion-javascirpt-1-2.png" alt="interviewquestion-javascript"><br>可以在上面看到一下两点：</p>
<ul>
<li>成员访问<code>.</code>的优先级为<strong>(19)</strong>比new无参数列表<strong>(18)</strong>优先级高</li>
<li>当点运算完后又因为有个括号()，此时就是变成new有参数列表<strong>(19)</strong>，所以直接执行new，<code>new constructor</code> 后面可以跟<strong>一个指定对象实例的类型的类或函数</strong>。它是把<code>Foo.getName()</code>看做一个<strong>整体</strong>，而不是调用了<code>new</code>完成以后的<strong>函数</strong>，不信的话可以运行<code>new (Foo.getName)</code>这个代码，它的结果和本题的<strong>结果一致</strong>。<br>所以我们可以把代码改写成<code>new (Foo.getName)()</code>这样可以清晰的看到他的执行顺序，大的执行顺序分为两部步如下：</li>
</ul>
<ol>
<li>先执行<code>Foo.getName</code></li>
<li>再是<code>new (Foo.getName)()</code></li>
</ol>
<p>所以这里实际上将<strong>getName函数</strong>作为了<strong>构造函数</strong>来执行，所以<strong>结果是2</strong>。</p>
<h2 id="第六问"><a href="#第六问" class="headerlink" title="第六问"></a>第六问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 第六问</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>根据上面的<strong>运算符优先级</strong>可知，首先new有参数列表(19)跟点的优先级(19)是同级，同级的话按照<strong>从左向右的执行顺序</strong>，所以先执行new有参数列表(19)再执行点的优先级(19)，最后再函数调用(18)。</p>
<blockquote>
<p>new有参数列表(19)-&gt;.成员访问(19)-&gt;()函数调用(18)<br>根据优先级可以把上面的问题该写为<code>(new Foo()).getName()</code>，这样可以更清晰的看到它的执行过程。</p>
</blockquote>
<h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><p>在传统语言中构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象，而在JS中构造函数可以有返回值也可以没有。大致可以分总结为三类：</p>
<ul>
<li>没有返回值则按照其他语言一样返回实例化对象。</li>
<li>若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（String,Number,Boolean,Null,Undefined）则与无返回值相同，实际返回其实例化对象。</li>
<li>若返回值是引用类型，则实际返回值为这个引用类型。</li>
</ul>
<p>原题中，由于返回的是<code>this</code>，而this在构造函数中本来就代表当前实例化对象，最终<code>Foo</code>函数返回<strong>实例化对象</strong>。<br>之后调用实例化对象的<code>getName</code>函数，因为在Foo构造函数中没有为<strong>实例化对象</strong>添加任何属性，当前对象的<strong>原型对象(prototype)</strong>中寻找<code>getName</code>函数。所以会执行<code>prototype</code>上得<code>getName</code>的方法也就是<code>function () { alert (3);};</code>，<strong>结果为3</strong>。</p>
<h2 id="第七问"><a href="#第七问" class="headerlink" title="第七问"></a>第七问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 第七问</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>根据第六问的优先级可以把第七问的代码改写为<code>new ((new Foo()).getName)()</code>，所以得到的<strong>结果也为3</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实有很多关于<strong>this指向</strong>、<strong>构造函数返回值</strong>、<strong>作用域</strong>都没有记录的很完整，以前有些过一些文章但是并没有整理，慢慢会整理好。</p>
]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>InterviewQuestion</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Https系列（三） Https+blob 视频播放</title>
    <url>/blog/http/http-https-blob.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自从HTML5提供了video标签，在网页中播放视频已经变成一个非常简单的事，只要一个video标签src属性设置为视频的地址就完事了。由于src指向真实的视频网络地址，在早期一般网站资源文件不怎么<strong>通过referer设置防盗链</strong>，所以可以随意的下载视频，也就有了后来通过blob加密视频文件。</p>
<blockquote>
<p>目前的云存储服务商大部分都支持referer防盗链。其原理就是在访问资源时，请求头会带上发起请求的页面地址，判断其不存在（表示直接访问图片地址）或不在白名单内，即为盗链。</p>
</blockquote>
<p>现在许多视频在线观看网站，你如果打开<code>chrome</code>查看其<code>video</code>标签，会发现它的<code>src</code>是一个以<code>blob:</code>开头的地址。</p>
<h2 id="Blob和ArrayBuffer"><a href="#Blob和ArrayBuffer" class="headerlink" title="Blob和ArrayBuffer"></a>Blob和ArrayBuffer</h2><p><code>Blob</code>是<strong>二进制原始数据</strong>但是类似<strong>文件</strong>的对象，ArrayBuffer对象用来表示<strong>通用的、固定长度</strong>的<strong>原始二进制数据缓冲区</strong>。<br>同时他们是可以互相转换的<code>Blob</code>和<code>ArrayBuffer</code>。</p>
<h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p><font color="#ff502c"></font></p>
<p><font color="#ff502c">Blob</font>对象表示一个<font color="#ff502c">不可变、原始数据</font>的类文件对象。<font color="#ff502c">Blob</font> 表示的不一定是<code>JavaScript</code><font color="#ff502c">原生格式的数据。<code>File</code> 接口基于<code>Blob</code>，继承了 <code>blob</code> 的功能并将其扩展使其支持用户系统上的文件。<br>使用 <code>Blob()</code> 构造函穿新创建的 Blob 对象。常用的方法和属性如下：</font></p>
<ul>
<li><code>slice()</code>方法： 创建包含另一个<code>blob</code>数据的子集<code>blob</code></li>
<li><code>Blob.size</code>属性（只读）： Blob 对象中所包含数据的大小（字节）。</li>
<li><code>Blob.type</code>属性（只读）： 一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型未知，则该值为空字符串。</li>
</ul>
<blockquote>
<ul>
<li>注意：slice()方法原本接受length作为第二个参数，以表示复制到新Blob 对象的字节数。如果设置的参数使start + length超出了源Blob对象的大小，那返回的则是从start到结尾的数据。</li>
<li>File对象其实继承自Blob对象，并提供了提供了name ， lastModifiedDate， size ，type 等基础元数据。</li>
</ul>
</blockquote>
<h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p><font color="#ff502c">ArrayBuffer</font>(length)来获得一片连续的内存空间，它不能直接读写，但可根据需要将其传递到TypedArray视图或 DataView 对象来解释原始缓冲区。实际上视图只是给你提供了一个某种类型的读写接口，让你可以操作<font color="#ff502c">ArrayBuffer</font>里的数据。<strong>TypedArray需指定一个数组类型来保证数组成员都是同一个数据类型，而DataView数组成员可以是不同的数据类型</strong>。</p>
<p><code>TypedArray</code> 对象描述一个底层的<strong>二进制数据缓存区</strong>的一个类似数组(array-like)视图，<code>TypedArray</code>对象如下几种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小（字节单位）</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">Web  IDL type</th>
<th style="text-align:center">C语言中的等效类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Int8Array</td>
<td style="text-align:center">1</td>
<td style="text-align:center">8位二进制带符号整数 -2^7~(2^7) - 1</td>
<td style="text-align:center">byte</td>
<td style="text-align:center">int8_t</td>
</tr>
<tr>
<td style="text-align:center">Uint8Array</td>
<td style="text-align:center">1</td>
<td style="text-align:center">8位无符号整数 0~(2^8) - 1</td>
<td style="text-align:center">octet</td>
<td style="text-align:center">uint8_t</td>
</tr>
<tr>
<td style="text-align:center">Int16Array</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16位二进制带符号整数 -2^15~(2^15)-1</td>
<td style="text-align:center">short</td>
<td style="text-align:center">int16_t</td>
</tr>
<tr>
<td style="text-align:center">Uint16Array</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16位无符号整数 0~(2^16) - 1</td>
<td style="text-align:center">unsigned short</td>
<td style="text-align:center">uint16_t</td>
</tr>
<tr>
<td style="text-align:center">Int32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32位二进制带符号整数 -2^31~(2^31)-1</td>
<td style="text-align:center">long</td>
<td style="text-align:center">int32_t</td>
</tr>
<tr>
<td style="text-align:center">Uint32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32位无符号整数 0~(2^32) - 1</td>
<td style="text-align:center">unsigned int</td>
<td style="text-align:center">uint32_t</td>
</tr>
<tr>
<td style="text-align:center">Float32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32位IEEE浮点数</td>
<td style="text-align:center">unrestricted float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">Float64Array</td>
<td style="text-align:center">8</td>
<td style="text-align:center">64位IEEE浮点数</td>
<td style="text-align:center">unrestricted double</td>
<td style="text-align:center">double</td>
</tr>
</tbody>
</table>
<h2 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL"></a>URL.createObjectURL</h2><p><code>URL.createObjectURL()</code> 静态方法会创建一个 <code>DOMString</code>，其中包含一个表示参数中给出的对象的<code>URL</code>。这个 <code>URL</code> 的<strong>生命周期</strong>和创建它的窗口中的 <code>document</code> 绑定。这个新的URL 对象表示指定的 <code>File</code> 对象或 <code>Blob</code> 对象。</p>
<blockquote>
<p><code>DOMString</code>可以说是会话<strong>(session)</strong>级的，所以你在新的<code>tab</code>打开也就无效了</p>
</blockquote>
<p>video标签的src属性，不管是相对路径，绝对路径，或者一个网络地址，归根结底都是指向一个<font color="#ff502c">文件资源的地址</font>。上面的<code>Blob</code>其实是一个可以当作<font color="#ff502c">文件</font>用的<font color="#ff502c">二进制数据</font>，那么只要我们可以生成一个指向<code>Blob</code>的地址，再通过<font color="#ff502c">URL.createObjectURL</font>生成一个临时地址，赋值给你<code>video</code>标签的<code>src</code>属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> videoURL = URL.createObjectURL(video); <span class="comment">// blob:https://www.aaa.com/12212aa1s1</span></span><br></pre></td></tr></table></figure></p>
<p>通过<font color="#ff502c">URL.revokeObjectURL(objectURL)</font> 释放一个之前已经存在的、通过调用 <font color="#ff502c">URL.createObjectURL()</font> 创建的 <code>URL</code> 对象。</p>
<blockquote>
<p>如果是以文件协议打开的html文件（即url为file://开头），则地址中<a href="http://localhost:1234会变成null，而且此时这个Blob" target="_blank" rel="noopener">http://localhost:1234会变成null，而且此时这个Blob</a> URL是无法直接访问的。</p>
</blockquote>
<h2 id="HLS和MPEG-DASH"><a href="#HLS和MPEG-DASH" class="headerlink" title="HLS和MPEG DASH"></a>HLS和MPEG DASH</h2><p>HLS （HTTP Live Streaming）, 是由 Apple 公司实现的基于 HTTP 的媒体流传输协议。HLS以ts为传输格式，m3u8为索引文件（文件中包含了所要用到的ts文件名称，时长等信息，可以用播放器播放，也可以用vscode之类的编辑器打开查看），在移动端大部分浏览器都支持，也就是说你可以用video标签直接加载一个m3u8文件播放视频或者直播，但是在pc端，除了苹果的Safari，需要引入库来支持。<br>用到此方案的视频网站比如优酷，可以在视频播放时通过调试查看Network里的xhr请求，会发现一个m3u8文件，和每隔一段时间请求几个ts文件。<br><img src="../../images/http/https-1-1.png" alt="https"><br><img src="../../images/http/https-1-2.png" alt="https"><br>但是除了HLS，还有Adobe的HDS，微软的MSS，方案一多就要有个标准点的东西，于是就有了MPEG DASH。<br>DASH（Dynamic Adaptive Streaming over HTTP） ，是一种在互联网上传送动态码率的Video Streaming技术，类似于苹果的HLS，DASH会通过media presentation description (MPD)将视频内容切片成一个很短的文件片段，每个切片都有多个不同的码率，DASH Client可以根据网络的情况选择一个码率进行播放，支持在不同码率之间无缝切换。<br>Youtube，B站都是用的这个方案。这个方案索引文件通常是mpd文件（类似HLS的m3u8文件功能），传输格式推荐的是fmp4（Fragmented MP4）,文件扩展名通常为.m4s或直接用.mp4。所以用调试查看b站视频播放时的网络请求，会发现每隔一段时间有几个m4s文件请求。<br><img src="../../images/http/https-1-3.png" alt="https"><br>不管是HLS还是DASH们，都有对应的库甚至是高级的播放器方便我们使用，但我们其实是想要学习一点实现。其实抛开掉索引文件的解析拿到实际媒体文件的传输地址，摆在我们面前的只有一个如何将多个视频数据合并让video标签可以无缝播放。</p>
<blockquote>
<p>与之相关的一篇B站文章推荐给感兴趣的朋友：<a href="https://www.bilibili.com/read/cv855111/" target="_blank" rel="noopener">我们为什么使用DASH</a></p>
</blockquote>
<h2 id="MediaSource"><a href="#MediaSource" class="headerlink" title="MediaSource"></a>MediaSource</h2><p>video标签src指向一个视频地址，视频播完了再将src修改为下一段的视频地址然后播放，这显然不符合我们无缝播放的要求。其实有了我们前面Blob URL的学习，我们可能就会想到一个思路，用Blob URL指向一个视频二进制数据，然后不断将下一段视频的二进制数据添加拼接进去。这样就可以在不影响播放的情况下，不断的更新视频内容并播放下去，想想是不是有点流的意思出来了。<br>要实现这个功能我们要通过MediaSource来实现，MediaSource接口功能也很纯粹，作为一个媒体数据容器可以和HTMLMediaElement进行绑定。基本流程就是通过URL.createObjectURL创建容器的BLob URL，设置到video标签的src上，在播放过程中，我们仍然可以通过MediaSource.appendBuffer方法往容器里添加数据，达到更新视频内容的目的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line"><span class="comment">//视频资源存放路径，假设下面有5个分段视频 video1.mp4 ~ video5.mp4，第一个段为初始化视频init.mp4</span></span><br><span class="line"><span class="keyword">const</span> assetURL = <span class="string">"http://www.demo.com"</span>;</span><br><span class="line"><span class="comment">//视频格式和编码信息，主要为判断浏览器是否支持视频格式，但如果信息和视频不符可能会报错</span></span><br><span class="line"><span class="keyword">const</span> mimeCodec = <span class="string">'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'</span>; </span><br><span class="line"><span class="keyword">if</span> (<span class="string">'MediaSource'</span> <span class="keyword">in</span> <span class="built_in">window</span> &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123;</span><br><span class="line"><span class="keyword">const</span> mediaSource = <span class="keyword">new</span> MediaSource();</span><br><span class="line">video.src = URL.createObjectURL(mediaSource); <span class="comment">//将video与MediaSource绑定，此处生成一个Blob URL</span></span><br><span class="line">mediaSource.addEventListener(<span class="string">'sourceopen'</span>, sourceOpen); <span class="comment">//可以理解为容器打开</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//浏览器不支持该视频格式</span></span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'Unsupported MIME type or codec: '</span>, mimeCodec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sourceOpen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> mediaSource = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">const</span> sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNextVideo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//ajax代码实现翻看上文，数据请求类型为arraybuffer</span></span><br><span class="line">    ajax(url, <span class="function"><span class="keyword">function</span>(<span class="params">buf</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//往容器中添加请求到的数据，不会影响当下的视频播放。</span></span><br><span class="line">    sourceBuffer.appendBuffer(buf);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次appendBuffer数据更新完之后就会触发</span></span><br><span class="line">sourceBuffer.addEventListener(<span class="string">"updateend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//第一个初始化视频加载完就开始播放</span></span><br><span class="line">    video.play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="comment">//一段视频加载完成后，请求下一段视频</span></span><br><span class="line">    getNextVideo(<span class="string">`<span class="subst">$&#123;assetURL&#125;</span>/video<span class="subst">$&#123;i&#125;</span>.mp4`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="comment">//全部视频片段加载完关闭容器</span></span><br><span class="line">    mediaSource.endOfStream();</span><br><span class="line">    URL.revokeObjectURL(video.src); <span class="comment">//Blob URL已经使用并加载，不需要再次使用的话可以释放掉。</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//加载初始视频</span></span><br><span class="line">getNextVideo(<span class="string">`<span class="subst">$&#123;assetURL&#125;</span>/init.mp4`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这段代码修改自MDN的MediaSource词条中的示例代码，原例子中只有加载一段视频，我修改为了多段视频，代码里面很多地方还可以优化精简，这里没做就当是为了方便我们看逻辑。<br>此时我们已经基本实现了一个简易的流媒体播放功能，如果愿意可以再加入m3u8或mpd文件的解析，设计一下UI界面，就可以实现一个流媒体播放器了。<br>最后提一下一个坑，很多人跑了MDN的MediaSource示例代码，可能会发现使用官方提供的视频是没问题的，但是用了自己的mp4视频就会报错，这是因为fmp4文件扩展名通常为.m4s或直接用.mp4，但却是特殊的mp4文件。</p>
<h2 id="Fragmented-MP4"><a href="#Fragmented-MP4" class="headerlink" title="Fragmented MP4"></a>Fragmented MP4</h2><p>通常我们使用的mp4文件是嵌套结构的，客户端必须要从头加载一个 MP4 文件，才能够完整播放，不能从中间一段开始播放。而Fragmented MP4（简称fmp4），就如它的名字碎片mp4，是由一系列的片段组成，如果服务器支持 byte-range 请求，那么，这些片段可以独立的进行请求到客户端进行播放，而不需要加载整个文件。<br>我们可以通过这个网站判断一个mp4文件<a href="http://nickdesaulniers.github.io/mp4info/" target="_blank" rel="noopener">是否为Fragmented MP4网站地址</a>。<br>我们通过<a href="https://ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a>或<a href="https://www.bento4.com/" target="_blank" rel="noopener">Bento4</a>的mp4fragment来将普通mp4转换为Fragmented MP4，两个工具都是命令行工具，按照各自系统下载下来对应的压缩包，解压后设置环境变量指向文件夹中的bin目录，就可以使用相关命令了。<br>Bento4的mp4fragment，没有太多参数，命令如下:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mp4fragment video.mp4 video-fragmented.mp4</span><br></pre></td></tr></table></figure></p>
<p>FFmpeg会需要设置一些参数，命令如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i video.mp4 -movflags empty_moov+default_base_moof+frag_keyframe video-fragmented.mp4</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Tips：网上大部分的资料中转换时是不带default_base_moof这个参数的，虽然可以转换成功，但是经测试如果不添加此参数网页中MediaSource处理视频时会报错。<br>视频的切割分段可以使用Bento4的mp4slipt，命令如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mp4split video.mp4 --media-segment video-%llu.mp4 --pattern-parameters N</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="来个实例"><a href="#来个实例" class="headerlink" title="来个实例"></a>来个实例</h2><p>服务端使用的<code>nodejs</code>，<code>koa</code>框架，这里的操作很简单，就是用<font color="#ff502c">fs.readFileSync</font>直接打开视频文件，得到的<code>data</code>结果是二进制的数据，直接作为结果返回。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="built_in">require</span>(<span class="string">'buffer'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">const</span> video = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// open 一个放在服务器的视频</span></span><br><span class="line">        <span class="keyword">let</span> data = fs.readFileSync(<span class="string">'XXX.XXX.XXX/simple.mp4'</span>);</span><br><span class="line">        ctx.response.body = data;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(&#123;</span><br><span class="line">            status: <span class="number">500</span>,</span><br><span class="line">            message: <span class="string">'视频传输错误'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">router.get(<span class="string">'/video'</span>, video);</span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line">app.liseten(<span class="number">3002</span>);</span><br></pre></td></tr></table></figure></p>
<p>前端代码，这里使用的最原生的<font color="#ff502c">XMLHttpRequest</font>对象语法，这里最重要的一点是要设置<font color="#ff502c">responseType为blob</font>，这样接收到<code>response</code>直接就是一个<code>blob</code>对象供我们使用。这个<code>responseType</code>属性不属于<code>http</code>头部信息，而是ajax请求中XHR对象的属性(默认为””也就是text类型，而在一些封装XHR的框架中，一般把默认值设为json)。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://localhost:3001/video'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取blob对象</span></span><br><span class="line">        <span class="keyword">let</span> blob = <span class="keyword">this</span>.response</span><br><span class="line">        <span class="built_in">console</span>.log(blob)</span><br><span class="line">        <span class="comment">// 获取blob对象地址，并把值赋给容器</span></span><br><span class="line">        $(<span class="string">"#sound"</span>).attr(<span class="string">"src"</span>, URL.createObjectURL(blob));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure></p>
<p>这样就可以得到以blob:开头的临时url地址，而且在向服务端请求时页隐藏了真实的视频地址.</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><a href="https://juejin.im/post/5d1ea7a8e51d454fd8057bea" target="_blank" rel="noopener">为什么视频网站的视频链接地址是blob？</a><br><a href="https://www.jianshu.com/p/04727924273d" target="_blank" rel="noopener">通过BLOB加密视频文件</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列 css中padding</title>
    <url>/blog/css/css-padding.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/css/css-absolute.html">深入理解 css 系列 css 中 absolute</a><br><a href="/blog/css/css-border.html">深入理解 css 系列 css 中 border</a><br><a href="/blog/css/css-float.html">深入理解 css 系列 css 中 float</a><br><a href="/blog/css/css-relative.html">深入理解 css 系列 css 中 relative</a><br><a href="/blog/css/css-margin.html">深入理解 css 系列 css 中 margin</a><br><a href="/blog/css/css-padding.html">深入理解 css 系列 css 中 padding</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><strong>padding</strong> 简写属性在一个声明中设置所有内边距属性。所有浏览器都支持 <code>padding</code> 属性，这里就多做赘述了，但是要注意以下：</p>
<blockquote>
<p>任何的版本的 <code>Internet Explorer</code> （包括 IE8）都不支持属性值 <code>&quot;inherit&quot;</code>。</p>
</blockquote>
<p><strong>可能的值</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">auto</td>
<td style="text-align:center">浏览器计算内边距。</td>
</tr>
<tr>
<td style="text-align:center">length</td>
<td style="text-align:center">规定以具体单位计的内边距值，比如像素（px）、厘米(cm)等。默认值是 0px。</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center"><strong>规定基于父元素的宽度的百分比的内边距。</strong></td>
</tr>
<tr>
<td style="text-align:center">inherit</td>
<td style="text-align:center">规定应该从父元素继承内边距。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>padding 不支持负值</strong></p>
</blockquote>
<p>本篇目录：</p>
<ul>
<li><code>padding</code> 对 <code>block</code> 元素的影响</li>
<li><code>padding</code> 对 <code>inline</code> 元素的影响</li>
<li>关于 <code>padding</code> 的百分比值</li>
<li><code>padding</code> 的应用场景</li>
</ul>
<h2 id="padding-对-block-的影响"><a href="#padding-对-block-的影响" class="headerlink" title="padding 对 block 的影响"></a>padding 对 block 的影响</h2><ul>
<li><code>width</code> 固定</li>
<li><code>width</code> 为 <code>auto</code> 或者 <code>box-sizing</code> 为 <code>border-box</code> 的时候</li>
</ul>
<h3 id="width-固定"><a href="#width-固定" class="headerlink" title="width 固定"></a>width 固定</h3><p><code>padding</code> 是会影响元素的尺寸的，<code>padding</code> 会对 <code>block</code> 元素的尺寸产生影响。代码如下：<br><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示结果如下：<br><img src="../../images/css/css-padding-1-1.png" alt="css padding"><br>验证了上面的猜测，<strong>padding 会对 block 元素的尺寸产生影响</strong>；</p>
<h3 id="width-为-auto-或者-box-sizing-为-border-box-的时候"><a href="#width-为-auto-或者-box-sizing-为-border-box-的时候" class="headerlink" title="width 为 auto 或者 box-sizing 为 border-box 的时候"></a>width 为 auto 或者 box-sizing 为 border-box 的时候</h3><p>首先要知道 <code>box-sizing</code> 为 <code>border-box</code> 代表什么意思，其实就是盒模型为 ie 模式。ie 的盒模型就是他的<strong>content+padding+border</strong>都算在盒模型内。<br>这个用上面的例子就不太合适，看下面的一个例子：<br><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  文字的应该怎么放置？</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示如下：<br><img src="../../images/css/padding-1-2.png" alt="css padding"></p>
<!-- ![css padding](../../images/css/padding-1-4.png) -->
<p>对于 <code>block</code> 水平元素，但是<strong>width:auto</strong>或<strong>box-sizing 为 border-box</strong>的时候 <code>padding</code><strong>不会影响</strong>元素的尺寸。</p>
<p>修改 css 代码如下：<br><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/css/padding-1-3.png" alt="css padding"><br><img src="../../images/css/padding-1-4.png" alt="css padding"><br>当<code>padding</code>大小<strong>超过宽度</strong>时，宽度按<code>padding的宽度</code>显示，里面的<strong>文字按最小宽度</strong>显示。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>padding 值大于元素本身的宽度时，一定会影响尺寸</strong>。</li>
<li><strong>width 非 auto，padding 影响尺寸</strong>。</li>
<li><strong>width 为 auto 或 box-sizing 为 border-box，同时 padding 值没有超过元素本身的宽度，不影响尺寸</strong>。</li>
</ul>
<h2 id="padding-对-inline-元素的影响"><a href="#padding-对-inline-元素的影响" class="headerlink" title="padding 对 inline 元素的影响"></a>padding 对 inline 元素的影响</h2><p>在上面代码的基础上修改代码如下：<br><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下：<br><img src="../../images/css/padding-1-5.png" alt="css padding"><br><img src="../../images/css/padding-1-6.png" alt="css padding"><br><strong>水平 padding 影响尺寸，垂直 padding 不影响尺寸，但会影响背景色（占据空间）</strong>。</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>水平 padding 影响尺寸，垂直 padding 不影响尺寸，但会影响背景色（占据空间）</strong>。</li>
</ul>
<h2 id="关于-padding-的百分比值"><a href="#关于-padding-的百分比值" class="headerlink" title="关于 padding 的百分比值"></a>关于 padding 的百分比值</h2><ul>
<li>关于 block 元素的 padding 的百分比值</li>
<li>关于 inline 元素的 padding 的百分比值</li>
</ul>
<h3 id="block-元素的-padding-的百分比值"><a href="#block-元素的-padding-的百分比值" class="headerlink" title="block 元素的 padding 的百分比值"></a>block 元素的 padding 的百分比值</h3><p><strong>padding 百分比均是相对于父元素的宽度计算的</strong>。实现效果如下：</p>
<p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="comment">/* width: 100px; */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下，可以明显看到<code>box</code>的宽高都是<code>100px</code>;<br><img src="../../images/css/padding-1-7.png" alt="css padding"><br><img src="../../images/css/padding-1-8.png" alt="css padding"></p>
<h3 id="inline-水平元素的-padding-百分比值"><a href="#inline-水平元素的-padding-百分比值" class="headerlink" title="inline 水平元素的 padding 百分比值"></a>inline 水平元素的 padding 百分比值</h3><p>注意以下几点：</p>
<ul>
<li>同样相对于宽度计算</li>
<li>默认的高度宽度细节有差异</li>
<li>padding 会断行</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#8ec63f</span>;</span></span><br><span class="line">    padding: 50%;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>若干文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="../../images/css/padding-1-9.png" alt="css-padding" width="50%"><br><img src="../../images/css/padding-1-10.png" alt="css-padding" width="50%"></p>
<p><code>iniline</code>元素的垂直 padding 会让“幽灵空白节点”显现，也就是规范中的“strut”出现。</p>
<h2 id="标签元素的内置-paading"><a href="#标签元素的内置-paading" class="headerlink" title="标签元素的内置 paading"></a>标签元素的内置 paading</h2><ul>
<li>ol/li 元素内置 padding-left, 但单位是 px 不是 em;<ol>
<li>例如 chrom 浏览器下是 40px;</li>
<li>所以如果字号很小，间距就会很开；</li>
<li>如果字号很大，序号就会爬到容器外面</li>
</ol>
</li>
</ul>
<blockquote>
<p>备注：文字大小一般为 12px~14px ，padding-left 为 22px~25px，基本可以实号与下面的内容对齐。</p>
</blockquote>
<ul>
<li>所有浏览器 input/textarea 输入框内置 padding</li>
<li>所有浏览器 button 按钮内置 padding</li>
<li>所有浏览器 radio/chexbox 单复选框无内置 padding</li>
<li>button 按钮元素的 padding 最难控制<br>button 使用：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"btn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">label &#123; display: inline-block; line-height: 20px; padding: 10px; &#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以实现一个在任何浏览器上高度为<code>40px</code>按钮。</p>
<h2 id="padding-的应用场景"><a href="#padding-的应用场景" class="headerlink" title="padding 的应用场景"></a>padding 的应用场景</h2><ul>
<li>实现 3 道杠效果</li>
<li>实现白眼效果</li>
<li>1:1 头图布局</li>
<li>实现等高布局</li>
<li>两栏自适应布局</li>
</ul>
<h3 id="实现-3-道杠效果"><a href="#实现-3-道杠效果" class="headerlink" title="实现 3 道杠效果"></a>实现 3 道杠效果</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    padding: 15px 0;</span><br><span class="line">    border-top: 30px solid currentColor;</span><br><span class="line">    border-bottom: 30px solid currentColor;</span><br><span class="line">    background-color: currentColor;</span><br><span class="line">    background-clip: content-box;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注：background-clip:content-box ; /<strong>背景色不在 padding 区域显示</strong>/</p>
</blockquote>
<p>其实自己实现一个是最好的，借鉴一张别人的图如下：<br><img src="../../images/css/padding-2-1.png" alt="css-padding" width="50%"></p>
<h3 id="实现白眼效果"><a href="#实现白眼效果" class="headerlink" title="实现白眼效果"></a>实现白眼效果</h3><p><img src="../../images/css/padding-2-2.png" alt="css-padding" width="50%"></p>
<blockquote>
<p>备注：background-clip:content-box ; /<strong>背景色不在padding区域显示</strong>/</p>
</blockquote>
<h3 id="实现一个-1-1-布局"><a href="#实现一个-1-1-布局" class="headerlink" title="实现一个 1:1 布局"></a>实现一个 1:1 布局</h3><p><img src="../../images/css/padding-2-3.png" alt="css-padding" width="50%"></p>
<h3 id="实现等高布局"><a href="#实现等高布局" class="headerlink" title="实现等高布局"></a>实现等高布局</h3><p><img src="../../images/css/padding-2-4.png" alt="css-padding" width="50%"></p>
<blockquote>
<p>很大的 margin-bottom 负值，再用很大的 padding-bottom 填充缺失的空间</p>
</blockquote>
<h3 id="两栏自适应布局"><a href="#两栏自适应布局" class="headerlink" title="两栏自适应布局"></a>两栏自适应布局</h3><p><img src="../../images/css/padding-2-5.png" alt="css-padding" width="50%"><br><img src="../../images/css/padding-2-6.png" alt="css-padding" width="50%"></p>
<h2 id="总计"><a href="#总计" class="headerlink" title="总计"></a>总计</h2><font color="#ff502c">padding 对 block 元素的影响</font>

<ul>
<li><strong>padding 值大于元素本身的宽度时，一定会影响尺寸</strong>。</li>
<li><strong>width 非 auto，padding 影响尺寸</strong>。</li>
<li><strong>width 为 auto 或 box-sizing 为 border-box，同时 padding 值没有超过元素本身的宽度，不影响尺寸</strong></li>
</ul>
<font color="#ff502c">padding 对 inline 元素的影响</font>

<ul>
<li><strong>水平 padding 影响尺寸，垂直 padding 不影响尺寸，但会影响背景色（占据空间）</strong></li>
</ul>
<font color="#ff502c">关于 padding 的百分比值</font>

<ul>
<li><strong>block 元素的 padding 的百分比值</strong><ol>
<li>padding 百分比均是相对于父元素的宽度计算的</li>
</ol>
</li>
<li><strong>inline 水平元素的 padding 百分比值</strong><ol>
<li>同样相对于宽度计算</li>
<li>默认的高度宽度细节有差异</li>
<li>padding 会断行</li>
</ol>
</li>
</ul>
<font color="#ff502c">padding 的应用场景</font>

<ul>
<li><strong>实现 3 道杠效果</strong></li>
<li><strong>实现白眼效果</strong></li>
<li><strong>1:1 头图布局</strong></li>
<li><strong>实现等高布局</strong></li>
<li><strong>两栏自适应布局</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/qianxunpu/p/8303228.html" target="_blank" rel="noopener">css 之深入理解 padding</a><br><a href="https://www.imooc.com/learn/710" target="_blank" rel="noopener">CSS 深入理解之 padding</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 next-tick原理和源码解析</title>
    <url>/blog/vue/vue-next-tick.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 vue 的官方文档中有一个 API 叫做 nextTick，将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.$nextTick([callback]);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line">[callback];</span><br></pre></td></tr></table></figure>
<p><strong>用法</strong><br>放在<code>Vue.nextTick()</code>回调函数中的执行的应该是<strong>涉及 DOM</strong>操作的 JavaScript 代码。</p>
<p>Vue 的响应式原理：在 data 选项里所有属性都会被<code>watcher</code>监控，当修改了<code>data</code>的某一个值，并不会<strong>立即</strong>反映到视图中。Vue 会将我们对<code>data</code>的更改放到<code>watcher</code>的一个队列中（异步），只有在当前任务空闲时才会去执行<code>watcher</code>队列任务。这就有一个延迟时间，所以对 dom 的操作要放在<code>$nextTick</code>中来操作，才能获取到最新的<code>dom</code>。</p>
<blockquote>
<p><a href="/blog/vue/vue-definedProperty.html">响应式对象 Observer</a> &gt; <a href="/blog/vue/vue-dep.html">依赖收集 Dep</a> &gt; <a href="/blog/vue/vue-notify.html">派发更新 Watcher</a></p>
</blockquote>
<p><code>nextTick</code> 是 Vue 的一个<strong>核心</strong>实现，如果还不了解 js 运行机制，可以看一下另一篇文章<a href="/blog/javascript/evenloop.html">js 运行机制</a>，这里就不多赘述了。</p>
<p>在浏览器环境中常见的 macro task 和 micro task 如下：<br><strong>macro task</strong>：</p>
<ul>
<li><code>setTimeout、setTimeInterval</code></li>
<li><code>MessageChannel</code></li>
<li><code>postMessage</code></li>
<li><code>setImmediate</code></li>
<li><code>requestAnimationFrame</code></li>
<li><code>I/O</code></li>
<li><code>UI 渲染</code>a</li>
</ul>
<p><strong>micro task</strong>：</p>
<ul>
<li>MutationObsever</li>
<li>Promise.then</li>
<li>process.nextTick</li>
</ul>
<h2 id="vue-源码解析"><a href="#vue-源码解析" class="headerlink" title="vue 源码解析"></a>vue 源码解析</h2><p>在<a href="/blog/vue/vue-notify.html">派发更新 Watcher</a>里面有用到<code>nextTick(flushScheduerQueue)</code>，其实就是<code>vue</code>对派发更新的一个优化。下面直接看源码，在 src/core/util/next-tick.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nextTick，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。</span></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">"shared/util"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">"./error"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">"./env"</span>;</span><br><span class="line"><span class="comment">// flushScheduerQueue</span></span><br><span class="line"><span class="comment">/*存放异步执行的回调*/</span></span><br><span class="line"><span class="keyword">const</span> callbacks = [];</span><br><span class="line"><span class="comment">//一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*下一个tick时的回调*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//复制callback</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//清除callbacks</span></span><br><span class="line">  callbacks.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    <span class="comment">//触发callback的回调函数</span></span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span></span><br><span class="line"><span class="comment">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span></span><br><span class="line"><span class="comment">// microtasks have too high a priority and fire in between supposedly</span></span><br><span class="line"><span class="comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span></span><br><span class="line"><span class="comment">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span></span><br><span class="line"><span class="comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span></span><br><span class="line"><span class="comment">// Here we use microtask by default, but expose a way to force (macro) task when</span></span><br><span class="line"><span class="comment">// needed (e.g. in event handlers attached by v-on).</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  其大概的意思就是：在Vue2.4之前的版本中，nextTick几乎都是基于microTask实现的，</span></span><br><span class="line"><span class="comment">  但是由于microTask的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，</span></span><br><span class="line"><span class="comment">  就会导致一些诡异的问题；但是如果全部都改成macroTask，对一些有重绘和动画的场</span></span><br><span class="line"><span class="comment">  景也会有性能的影响。所以最终nextTick采取的策略是默认走microTask，对于一些DOM</span></span><br><span class="line"><span class="comment">  的交互事件，如v-on绑定的事件回调处理函数的处理，会强制走macroTask。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"><span class="keyword">let</span> microTimerFunc;</span><br><span class="line"><span class="keyword">let</span> macroTimerFunc;</span><br><span class="line"><span class="keyword">let</span> useMacroTask = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine (macro) task defer implementation.</span></span><br><span class="line"><span class="comment">// Technically setImmediate should be the ideal choice, but it's only available</span></span><br><span class="line"><span class="comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span></span><br><span class="line"><span class="comment">// events triggered in the same loop is by using MessageChannel.</span></span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而对于macroTask的执行，Vue优先检测是否支持原生setImmediate（高版本IE和Edge支持），</span></span><br><span class="line"><span class="comment">// 不支持的话再去检测是否支持原生MessageChannel，如果还不支持的话为setTimeout(fn, 0)。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">"undefined"</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="keyword">typeof</span> MessageChannel !== <span class="string">"undefined"</span> &amp;&amp;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    在Vue 2.4版本以前使用的MutationObserver来模拟异步任务。</span></span><br><span class="line"><span class="comment">    而Vue 2.5版本以后，由于兼容性弃用了MutationObserver。</span></span><br><span class="line"><span class="comment">    Vue 2.5+版本使用了MessageChannel来模拟macroTask。</span></span><br><span class="line"><span class="comment">    除了IE以外，messageChannel的兼容性还是比较可观的。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">"[object MessageChannelConstructor]"</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    可见，新建一个MessageChannel对象，该对象通过port1来检测信息，port2发送信息。</span></span><br><span class="line"><span class="comment">    通过port2的主动postMessage来触发port1的onmessage事件，</span></span><br><span class="line"><span class="comment">    进而把回调函数flushCallbacks作为macroTask参与事件循环。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = flushCallbacks;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine microtask defer implementation.</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">"undefined"</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">    <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// fallback to macro</span></span><br><span class="line">  microTimerFunc = macroTimerFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap a function so that if any code inside triggers state change,</span></span><br><span class="line"><span class="comment"> * the changes are queued using a (macro) task instead of a microtask.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    推送到队列中下一个tick时执行</span></span><br><span class="line"><span class="comment">    cb 回调函数</span></span><br><span class="line"><span class="comment">    ctx 上下文</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withMacroTask</span>(<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    fn._withTask ||</span><br><span class="line">    (fn._withTask = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      useMacroTask = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">const</span> res = fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      useMacroTask = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">"nextTick"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      microTimerFunc();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nextTick</code>这就是我们在上一节执行 <code>nextTick(flushSchedulerQueue)</code> 所用到的函数。它的逻辑也很简单，把传入的回调函数 <code>cb</code> 压入 <code>callbacks</code> 数组，最后一次性地根据 <code>useMacroTask</code> 条件执行 <code>macroTimerFunc</code> 或者是 <code>microTimerFunc</code>，而它们都会在下一个 <code>tick</code> 执行 <code>flushCallbacks</code>。<br><code>flushCallbacks</code> 这个方法就是挨个<strong>同步</strong>的去执行<code>callbacks</code>中的回调函数，<code>callbacks</code>中的回调函数是在调用 <code>nextTick</code> 的时候添加进去的；<br>这里使用 <code>callbacks</code> 而不是直接在 <code>nextTick</code> 中执行回调函数的原因是保证在同一个 <code>tick</code> 内多次执行 <code>nextTick</code>，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 <code>tick</code> 执行完毕。<br>注意这里有个比较难理解的地方，第一次调用 <code>nextTick</code> 的时候 <code>pending</code> 为<code>false</code>。<br>此时已经<code>push</code>到浏览器<code>event loop</code>中一个<strong>宏任务</strong>或<strong>微任务</strong>的<code>task</code>，如果在没有<code>flush</code>掉的情况下继续往<code>callbacks</code>里面添加。<br>那么在执行这个占位<code>queue</code>的时候会执行之后添加的回调，所以<code>macroTimerFunc</code>、<code>microTimerFunc</code> 相当于<code>task queue</code>的占位。<br>以后 <code>pending</code> 为<code>true</code>则继续往占位<code>queue</code>里面添加，<code>event loop</code>轮到这个<code>task queue</code>的时候将一并执行。<br>执行 <code>flushCallbacks</code> 时 <code>pending</code> 置<code>false</code>，允许下一轮执行 <code>nextTick</code> 时往<code>event loop</code>占位。</p>
<p><strong>macroTimerFunc、microTimerFunc</strong><br><code>next-tick.js</code> 申明了 <code>microTimerFunc</code> 和 <code>macroTimerFunc</code> 2 个变量，它们分别对应的是 <code>micro task</code> 的函数和 <code>macro task</code> 的函数。对于 <code>macro task</code> 的实现，优先检测是否支持原生 <code>setImmediate</code>，这是一个高版本 <code>IE</code> 和 <code>Edge</code>才支持的特性，不支持的话再去检测是否支持原生的 <code>MessageChannel</code>，如果也不支持的话就会降级为 <code>setTimeout</code> 0；而对于 <code>micro task</code> 的实现，则检测浏览器是否原生支持 <code>Promise，</code>不支持的话直接指向 <code>macro task</code> 的实现。</p>
<p><strong>nextTick 实现</strong></p>
<ol>
<li>首先 <code>nextTick</code> 把传入的 <code>cb</code> 回调函数用 <code>try-catch</code> 包裹后放在一个<strong>匿名函数</strong>中推入<code>callbacks</code>数组中。<br>这么做是因为防止单个 <code>cb</code> 如果执行错误不至于让整个<strong>JS 线程挂掉</strong>。<br>每个 cb 都包裹是防止这些回调函数如果执行错误不会相互影响，比如前一个抛错了后一个仍然可以执行。</li>
<li>然后检查 <code>pending</code> 状态，这个跟之前介绍的 <code>queueWatcher</code> 中的 <code>waiting</code> 是一个意思。<br>它是一个标记位，一开始是 <code>false</code> 在进入<code>macroTimerFunc</code>、<code>microTimerFunc</code>方法前被置为 <code>true</code>。因此下次调用 <code>nextTick</code> 就不会进入<code>macroTimerFunc</code>、<code>microTimerFunc</code>方法。<br>这两个方法中会在下一个 <code>macro/micro tick</code> 时候 <code>flushCallbacks</code> 异步的去执行<code>callbacks队</code>列中收集的任务，而 <code>flushCallbacks</code> 方法在执行一开始会把 <code>pending</code> 置 <code>false</code>。<br>因此下一次调用 <code>nextTick</code> 时候又能开启新一轮的 <code>macroTimerFunc</code>、<code>microTimerFunc</code>，这样就形成了 vue 中的 <code>event loop</code>。</li>
<li>最后检查是否传入了 <code>cb</code>。因为 <code>nextTick</code> 还支持 Promise 化的调用：<code>nextTick().then(() =&gt; {})</code>。所以如果没有传入 <code>cb</code> 就直接<code>return了一个Promise</code>实例，并且把<code>resolve</code>传递给<code>_resolve</code>。这样后者执行的时候就跳到我们调用的时候传递进 then 的方法中。</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;span id=<span class="string">'name'</span> ref=<span class="string">'name'</span>&gt;&#123;&#123; name &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click='change'&gt;change name&lt;/</span>button&gt;</span><br><span class="line">    &lt;div id=<span class="string">'content'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'userName'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change() &#123;</span><br><span class="line">        <span class="keyword">const</span> $name = <span class="keyword">this</span>.$refs.name</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'同步方式1：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML)</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setter前：'</span> + $name.innerHTML))</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">' setterName '</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'同步方式2：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML)</span><br><span class="line">        <span class="comment">// setTimeout(() =&gt; &#123;console("setTimeout方式：" + this.$refs.name.innerHTML)&#125;</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'setTimeout方式：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setter后：'</span> + $name.innerHTML))</span><br><span class="line">        <span class="keyword">this</span>.$nextTick().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Promise方式：'</span> + $name.innerHTML))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行结果如下图所示：<br><img src="../../images/vue/vue-nextTick-1-1.png" alt="vue-nextTick"></p>
<ol>
<li>同步方式： 当把<code>data</code>中的<code>name</code>修改之后，此时会触发<code>name</code>的 <code>setter</code> 中的 <code>dep.notify</code> 通知依赖本<code>data</code>的<code>render watcher</code>去 <code>update</code>，<code>update</code> 会把 <code>flushSchedulerQueue</code> 函数传递给 <code>nextTick</code>，<code>render watcher</code>在 <code>flushSchedulerQueue</code> 函数运行时 <code>watcher.run</code> 再走 <code>diff -&gt; patch</code> 那一套重渲染 <code>re-render</code> 视图，这个过程中会重新依赖收集，这个过程是异步的；所以当我们直接修改了<code>name</code>之后打印，这时异步的改动还没有被 <code>patch</code> 到视图上，所以获取视图上的 DOM 元素还是原来的内容。</li>
<li>setter 前： <code>setter</code>前为什么还打印原来的是原来内容呢，是因为 <code>nextTick</code> 在被调用的时候把回调挨个<code>push</code>进<code>callbacks</code>数组，之后执行的时候也是 for 循环出来挨个执行，所以是类似于队列这样一个概念，先入先出；在修改<code>name</code>之后，触发把<code>render watcher</code>填入 <code>schedulerQueue</code> 队列并把他的执行函数 <code>flushSchedulerQueue</code> 传递给 <code>nextTick</code> ，此时<code>callbacks</code>队列中已经有了 <code>setter</code>前函数 了，因为这个 <code>cb</code> 是在 <code>setter</code>前函数 之后被<code>push</code>进<code>callbacks</code>队列的，那么先入先出的执行<code>callbacks</code>中回调的时候先执行 <code>setter</code>前函数，这时并未执行<code>render watcher</code>的 <code>watcher.run</code>，所以打印 DOM 元素仍然是原来的内容。</li>
<li>setter 后： <code>setter</code>后这时已经执行完 <code>flushSchedulerQueue</code>，这时<code>render watcher</code>已经把改动 <code>patch</code> 到视图上，所以此时获取 DOM 是改过之后的内容。</li>
<li>Promise 方式： 相当于 <code>Promise.then</code> 的方式执行这个函数，此时 DOM 已经更改。</li>
<li>setTimeout 方式： 最后执行<code>macro task</code>的任务，此时 DOM 已经更改。</li>
</ol>
<p>注意，在执行 <code>setter</code>前函数 这个异步任务之前，同步的代码已经执行完毕。异步的任务都还未执行，所有的 <code>$nextTick</code> 函数也执行完毕。所有回调都被<code>push</code>进了<code>callbacks</code>队列中等待执行，所以在<code>setter</code>前函数执行的时候。此时<code>callbacks</code>队列是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[setter前函数, flushSchedulerQueue, setter后函数, <span class="built_in">Promise</span>方式函数];</span><br></pre></td></tr></table></figure>
<p>它是一个<code>micro task</code>队列，执行完毕之后执行<code>macro task</code> <code>setTimeout</code>，所以打印出上面的结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>nextTick</code>是把要执行的任务推入到一个队列中，在下一个<code>tick</code>同步执行</li>
<li>数据改变后触发渲染<code>watcher</code>的<code>update</code>，但是<code>watchers</code>的<code>flush</code>是在<code>nextTick</code>后，所以重新渲染是异步的</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/next-tick.html#js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">nextTick</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a><br><a href="https://juejin.im/post/5b50760f5188251ad06b61be" target="_blank" rel="noopener">Vue 源码阅读 - 批量异步更新与 nextTick 原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>css实现Sticky footer效果</title>
    <url>/blog/css/css-footer.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在网页设计中，Sticky footers设计是最古老和最常见的效果之一，大多数人都曾经经历过。所谓 “Sticky Footer”，并不是什么新的前端概念和技术，它指的就是一种网页效果： <strong>如果页面内容不足够长时，页脚固定在浏览器窗口的底部；如果内容足够长时，页脚固定在页面的最底部。但如果网页内容不够长，置底的页脚就会保持在浏览器窗口底部</strong>。</p>
<p>大致分为两种，一种是footer为固定高度、一种为不固定的高度，当然不固定高度是包含了固定高度的，他们实现方式是不同的<br>。</p>
<h2 id="固定footer高度"><a href="#固定footer高度" class="headerlink" title="固定footer高度"></a>固定footer高度</h2><ul>
<li>负margin-bottom实现</li>
<li>calc()</li>
<li>position: absolute</li>
</ul>
<h3 id="负margin-bottom实现"><a href="#负margin-bottom实现" class="headerlink" title="负margin-bottom实现"></a>负margin-bottom实现</h3><p>把wrapper部分最小高度设为100%，再利用内容部分的负底部外边距值来达到当高度不满时，页脚保持在窗口底部，当高度超出则随之推出的效果。<br>html代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    html,</span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123; <span class="attribute">height</span>: <span class="number">100%</span>; <span class="attribute">margin</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        min-height: 100%;</span><br><span class="line"><span class="css">        <span class="comment">/* 等于footer的高度 */</span></span></span><br><span class="line">        margin-bottom: -50px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span>&#123;</span></span><br><span class="line">        height: 50px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>.wrapper</code>的 <code>margin-bottom</code>值需要和<code>.footer</code>的负的<code>height</code>值保持一致，这一点不太友好。</p>
<h3 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h3><p>使用CSS3新增的计算函数calc()</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 等于footer的高度 */</span></span></span><br><span class="line">        min-height: calc(100vh - 50px);</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">        height: 50px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不需考虑 calc() 以及 vh 单位的兼容情况，这是个很理想的实现方案。同样的问题是 footer 的高度值需要与 content 其中的计算值一致。<br>一般都是不建议使用css计算属性，会造成一定的性能损失。</p>
<h3 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position: absolute"></a>position: absolute</h3><p>通过绝对定位处理应该是常见的方案，只要使得页脚一直定位在主容器预留占位位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        min-height: 100%;</span><br><span class="line">        padding-bottom: 50px;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 50px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>wrapper 的 padding-bottom 需要与 footer 的 height 一致。</p>
<h2 id="不固定footer高度"><a href="#不固定footer高度" class="headerlink" title="不固定footer高度"></a>不固定footer高度</h2><ul>
<li>使用flexbox弹性盒布局</li>
<li>grid布局</li>
<li>table布局</li>
</ul>
<p>不固定footer高度是包含固定高度的Sticky footer的。</p>
<h3 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h3><p>弹性布局，把主轴设置为column，再通过吧.content的felx设置为1（1, 1, auto）.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        min-height: 100vh;</span><br><span class="line">        flex-direction: column;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">        flex: 1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">        min-height: 50px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不知道flex布局的一些属性或者用法，可以看我另一篇博客。</p>
<h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>grid是比较新的css3的属性，没有看过可以看我另外一篇博客。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        display: grid;</span><br><span class="line">        min-height: 100vh;</span><br><span class="line">        grid-template-rows: 1fr auto;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">        grid-row-start: 2;</span><br><span class="line">        grid-row-end: 3;</span><br><span class="line">        min-height: 50px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>网格布局（Grid layout）现在的支持还不太好，如果想查询浏览器或者在webview上的属性兼容性。可以去<a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a>查询，但是以后肯定是grid的天下。</p>
<h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><p>display: table的兼容性应该是最好的，直接上代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        display: table;</span><br><span class="line">        width: 100%;</span><br><span class="line">        min-height: 100vh;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">        display: table-row;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">        min-height: 50px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，使用 table 方案存在一个比较常见的样式限制，通常 margin、padding、border 等属性会不符合预期。 笔者不建议使用这个方案。当然，问题也是可以解决的：别把其他样式写在 table 上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每个方案都有自己的优势和劣势，根据页面具体需求，选择最适合的方案。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE3MjE1Mw%3D%3D&amp;mid=2247483693&amp;idx=1&amp;sn=ea846c8a1b404a8a0aa5a5175059e0f4&amp;chksm=fbb2a7fbccc52eed1b62f21503d93449c8425c464d5b4ac576facadf560f95ab9ea8aca5484b&amp;mpshare=1&amp;scene=23&amp;srcid=1120MlKsKxWYxEsbttZ5V0CO" target="_blank" rel="noopener">各种CSS实现Sticky Footer</a><br><a href="https://www.jianshu.com/p/8fdb81e074e2" target="_blank" rel="noopener">CSS五种方式实现Footer置底</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的grid布局</title>
    <url>/blog/css/css-grid.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSS 网格布局擅长于将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系（前提是HTML生成了这些区域）。<br>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。<br>在Grid布局中，所有css属性分为两类，一类作用到grid容器上，还有一类作用在grid项目上。<br>如下表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">作用在grid容器上</th>
<th style="text-align:center">作用在grid子项上</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>grid-template-columns</strong> <br> <strong>grid-template-rows</strong> <br> <strong>grid-template-areas</strong> <br> <strong>grid-template</strong> <br> <strong>grid-column-gap </strong> <br> <strong>grid-row-gap </strong> <br> <strong>grid-gap </strong> <br> <strong>justify-items </strong> <br> <strong>align-items </strong> <br> <strong>place-items </strong> <br> <strong>justify-content </strong> <br> <strong>align-content </strong> <br> <strong>place-content </strong> <br> <strong>grid-auto-columns </strong> <br> <strong>grid-auto-rows </strong> <br> <strong>grid-auto-flow </strong> <br> <strong>grid </strong></td>
<td style="text-align:center"><strong>grid-column-start</strong> <br> <strong> grid-column-end</strong> <br> <strong> grid-row-start</strong> <br> <strong> grid-row-end</strong> <br> <strong> grid-column</strong> <br> <strong> grid-row</strong> <br> <strong> grid-area</strong> <br> <strong> justify-self</strong> <br> <strong> align-self</strong> <br> <strong> place-self</strong> <br></td>
</tr>
</tbody>
</table>
<h2 id="作用在grid容器上的CSS属性"><a href="#作用在grid容器上的CSS属性" class="headerlink" title="作用在grid容器上的CSS属性"></a>作用在grid容器上的CSS属性</h2><p>基础代码为：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width"</span>&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #00ff00"</span>&gt;</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #ff0000"&gt;</span></span><br><span class="line"><span class="regexp">      2</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #0000ff; color: #fff"</span>&gt;</span><br><span class="line">      <span class="number">3</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #ffff00"&gt;</span></span><br><span class="line"><span class="regexp">      4</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #00ffff"</span>&gt;</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #0f0f0f; color: #fff"&gt;</span></span><br><span class="line"><span class="regexp">      6</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #f0f0f0"</span>&gt;</span><br><span class="line">      <span class="number">7</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #ff00ff"&gt;</span></span><br><span class="line"><span class="regexp">      8</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #fff000"</span>&gt;</span><br><span class="line">      <span class="number">9</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #00ff00"&gt;</span></span><br><span class="line"><span class="regexp">      10</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #000fff; color: #fff"</span>&gt;</span><br><span class="line">      <span class="number">11</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #00ffff"&gt;</span></span><br><span class="line"><span class="regexp">      12</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="grid-template-columns和grid-template-rows"><a href="#grid-template-columns和grid-template-rows" class="headerlink" title="grid-template-columns和grid-template-rows"></a>grid-template-columns和grid-template-rows</h3><p>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码会指定一个3列4行的网格，列宽和行高都是100px;<br><img src="../../images/css/grid-1-1.png" alt="css grid"></p>
<p><strong>值</strong></p>
<ul>
<li>可以为 px  或者 百分比（%）</li>
<li>auto</li>
<li>repeat( [ <positive-integer> | auto-fill | auto-fit ] , <track-list> )</track-list></positive-integer></li>
<li>fr(fraction)是单词fraction的缩写，表示分数</li>
<li>max-content、min-content、minmax(min, max)</li>
</ul>
<p>px和百分比我们就不介绍了。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们把第一列设置为auto，效果如下：<br><img src="../../images/css/grid-1-2.png" alt="css grid"></p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>表示网格轨道的重复部分，以一种更简洁的方式去表示大量而且重复列的表达式。函数接收两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。在第一个基础上改写代码如下：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 100px);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个效果和直接写三个100px的效果是一样的。</p>
<h3 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h3><p><code>fr</code>是单词fraction的缩写，表示分数。</p>
<ul>
<li>先从简单例子看起：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>1:1:1，网格宽度三等分，实时效果如下：<br><img src="../../images/css/grid-1-3.png" alt="css grid"></p>
<ul>
<li>如果有固定尺寸值，则划分剩余空间大小，例如：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="../../images/css/grid-1-4.png" alt="css grid"><br>后面两列是grid容器宽度减去100像素后的1/2。</p>
<ul>
<li>如果和auto混用会如何呢<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="../../images/css/grid-1-5.png" alt="css grid"><br>auto 在和 px、百分比一起用的时候是撑满剩下的空间。但是和fr一起用的时候为内容宽度。</p>
<h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h3><p>grid-template-areas属性是 grid areas 在CSS中的特定命名。<br><strong>语法</strong><br><strong>值</strong><br><code>none</code><br>  网格容器没有定义任何的网格区块(grid areas)。<br><code>&lt;string&gt;+</code><br>  每一个给定的字符串会生成一行，一个字符串中用空格分隔的每一个单元(cell)会生成一列。多个同名的，跨越相邻行或列的单元称为网格区块(grid area)。非矩形的网格区块是无效的。</p>
<p>代码如下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #00ff00"</span>&gt;</span></span><br><span class="line">  1</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #ff0000"</span>&gt;</span></span><br><span class="line">  2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #0000ff; color: #fff"</span>&gt;</span></span><br><span class="line">  3</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #ffff00"</span>&gt;</span></span><br><span class="line">  4</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">      <span class="string">"头部 头部 头部"</span></span><br><span class="line">      <span class="string">"nav content content"</span></span><br><span class="line">      <span class="string">"nav content content"</span></span><br><span class="line">      <span class="string">"foot foot foot"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: 头部;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: nav;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: foot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的网格区域一定要形成规整的矩形区域，什么L形，凹的或凸的形状都是不支持的，会认为是无效的属性值。<br><img src="../../images/css/grid-1-6.png" alt="css grid"></p>
<h3 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h3><p><code>grid-template</code> 是一个简写的CSS属性，用于定义 grid columns, rows 和areas。<br>语法如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-template: &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;;</span><br></pre></td></tr></table></figure></p>
<p>用grid-template实现上面的效果，代码如下：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>: </span><br><span class="line">      <span class="string">"头部 头部 头部"</span> <span class="number">1</span>fr</span><br><span class="line">      <span class="string">"nav content content"</span> <span class="number">1</span>fr</span><br><span class="line">      <span class="string">"nav content content"</span> <span class="number">1</span>fr</span><br><span class="line">      <span class="string">"foot foot foot"</span> <span class="number">1</span>fr</span><br><span class="line">      / <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它实现的效果和上面的一样。</p>
<blockquote>
<p>由于<code>grid-template</code>不会重置一些隐式的grid属性（如<code>grid-auto-columns</code>，<code>grid-auto-rows</code>和<code>grid-auto-flow</code>），因此，大多数时候，还是推荐使用grid代替grid-template。</p>
</blockquote>
<h3 id="grid-column-gap和grid-row-gap、grid-gap"><a href="#grid-column-gap和grid-row-gap、grid-gap" class="headerlink" title="grid-column-gap和grid-row-gap、grid-gap"></a>grid-column-gap和grid-row-gap、grid-gap</h3><p>grid-column-gap和grid-row-gap属性用来定义网格中网格间隙的尺寸。你可以理解成田地之间走路的田垄宽度。<br>语法如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-column-gap: 10px; // 水平间隔 10px</span><br><span class="line">grid-row-gap: 10px; // 垂直间隔 10px</span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-column-gap</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">grid-row-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="../../images/css/grid-1-7.png" alt="css grid"></p>
<h4 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h4><p>CSS grid-gap属性是grid-column-gap和grid-row-gap属性的缩写。语法如下：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-gap</span>: &lt;<span class="selector-tag">grid-row-gap</span>&gt; &lt;<span class="selector-tag">grid-column-gap</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>实现和上面一样的布局代码如下：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span>;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span>;</span><br><span class="line"><span class="selector-tag">grid-gap</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="justify-items、align-items、palce-items"><a href="#justify-items、align-items、palce-items" class="headerlink" title="justify-items、align-items、palce-items"></a>justify-items、align-items、palce-items</h3><p>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。<br><strong>语法如下</strong><br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">justify-items: start | end | center | stretch;</span><br><span class="line">align-items: start | end | center | stretch;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#justify-items" target="_blank" rel="noopener">justify-items 效果参考 张鑫旭大佬的博客</a><br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#align-items" target="_blank" rel="noopener">align-items 效果参考 张鑫旭大佬的博客</a></p>
<h4 id="palce-items"><a href="#palce-items" class="headerlink" title="palce-items"></a>palce-items</h4><p>place-items属性是align-items属性和justify-items属性的合并简写形式。<br><strong>语法</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-items</span>: &lt;<span class="selector-tag">align-items</span>&gt; &lt;<span class="selector-tag">justify-items</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果省略第二个值，则浏览器认为与第一个值相等。</p>
</blockquote>
<h3 id="justify-content、align-content、place-content"><a href="#justify-content、align-content、place-content" class="headerlink" title="justify-content、align-content、place-content"></a>justify-content、align-content、place-content</h3><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p>
<blockquote>
<p>justify-content指定了网格元素的水平分布方式。此属性仅在网格总宽度小于grid容器宽度时候有效果。</p>
</blockquote>
<p>语法如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">align-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>start - 对齐容器的起始边框。</li>
<li>end - 对齐容器的结束边框。</li>
<li>center - 容器内部居中。</li>
<li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li>
<li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li>
<li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li>
<li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li>
</ul>
<p>正式效果参考如下：<br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#justify-content" target="_blank" rel="noopener">justify-content 效果参考 张鑫旭大佬的博客</a><br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#align-content" target="_blank" rel="noopener">align-content 效果参考 张鑫旭大佬的博客</a></p>
<h4 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h4><p>place-content属性是align-content属性和justify-content属性的合并简写形式。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-content</span>: &lt;<span class="selector-tag">align-content</span>&gt; &lt;<span class="selector-tag">justify-content</span>&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p>
</blockquote>
<h3 id="grid-auto-columns、grid-auto-rows"><a href="#grid-auto-columns、grid-auto-rows" class="headerlink" title="grid-auto-columns、grid-auto-rows"></a>grid-auto-columns、grid-auto-rows</h3><p>指定任何自动生成的网格轨道（也称为隐式网格轨道）的大小。 当网格项目多于网格中的单元格或网格项目放置在显式网格之外时，将创建隐式轨道。<br><strong>语法</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-auto-columns</span>: &lt;<span class="selector-tag">track-size</span>&gt; ...;</span><br><span class="line"><span class="selector-tag">grid-auto-rows</span>: &lt;<span class="selector-tag">track-size</span>&gt; ...;</span><br></pre></td></tr></table></figure></p>
<p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<p>示例如划分好的网格是2行 x 2列，但是，3号项目指定在第3行，4号项目指定在第4行。<br>代码如下：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-columns</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: <span class="number">50px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="../../images/css/grid-1-8.png" alt="css grid"></p>
<h3 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h3><p>grid-auto-flow属性控制没有明确指定位置的grid子项的放置方式。比方说定义了一个5*2的10格子，共有5个元素，其中2个元素指定了放在哪个格子里，还有3个则自生自灭排列。此时，这3个元素如何排列就是由grid-auto-flow属性控制的。<br><strong>语法</strong><br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-auto-flow: row | column | row dense | column dense</span><br></pre></td></tr></table></figure></p>
<ul>
<li>row 默认值。没有指定位置的网格依次水平排列优先。</li>
<li>column 没有指定位置的网格依次垂直排列优先。</li>
<li>dense dense这个英文是稠密的意思。如果有设置，则表示自动排列启用“密集”打包算法。如果稍后出现的网格比较小，则尝试看看前面有没有合适的地方放置，使网格尽可能稠密紧凑。此属性值仅仅改变视觉顺序，会导致DOM属性和实际呈现顺序不符合，这对于可访问性是不友好的，建议谨慎使用。<br>示例请看<a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#grid-auto-flow" target="_blank" rel="noopener">grid-auto-flow 效果参考 张鑫旭大佬的博客</a></li>
</ul>
<h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>是下面所有这些CSS属性的缩写集合，grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns和grid-auto-flow。<br>语法：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid</span>: <span class="selector-tag">none</span></span><br></pre></td></tr></table></figure></p>
<p><code>none</code>表示设置所有的子属性为初始值。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid</span>: &lt;<span class="selector-tag">grid-template</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>和grid-template用法一致<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid: &lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;?</span><br></pre></td></tr></table></figure></p>
<p>上面就是grid容器上的属性，属性很多不好记，要多练习几遍才能熟练使用。</p>
<h2 id="作用在grid子项上的CSS属性"><a href="#作用在grid子项上的CSS属性" class="headerlink" title="作用在grid子项上的CSS属性"></a>作用在grid子项上的CSS属性</h2><ul>
<li>grid-column-start, grid-column-end, grid-row-start和grid-row-end</li>
<li>grid-column和grid-row</li>
<li>grid-area</li>
<li>justify-self、align-self、place-self</li>
</ul>
<h3 id="grid-column-start-grid-column-end-grid-row-start和grid-row-end"><a href="#grid-column-start-grid-column-end-grid-row-start和grid-row-end" class="headerlink" title="grid-column-start, grid-column-end, grid-row-start和grid-row-end"></a>grid-column-start, grid-column-end, grid-row-start和grid-row-end</h3><p>表示grid子项所占据的区域的起始和终止位置，包括水平方向和垂直方向。<br><strong>语法</strong><br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto</span><br><span class="line">grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto</span><br><span class="line">grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto</span><br><span class="line">grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto</span><br></pre></td></tr></table></figure></p>
<p>语法中的管道分隔符|表示“或者”的意思，所以别看上面好长，实际上就一个属性值，具体来讲：</p>
<ul>
<li><number><br>起止与第几条网格线。</number></li>
<li><name><br>自定义的网格线的名称。</name></li>
<li>span <number><br>表示当前网格会自动跨越指定的网格数量。</number></li>
<li>span <name><br>表示当前网格会自动扩展，直到命中指定的网格线名称。</name></li>
<li>auto<br>全自动，包括定位，跨度等。</li>
</ul>
<p><strong>普通数字</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="../../images/css/grid-1-10.png" alt="css grid"></p>
<p><strong>网格线的名字</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [第一列] <span class="number">100px</span> [第二列] <span class="number">100px</span>  [第三列] <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [第一行] <span class="number">100px</span> [第二行] <span class="number">100px</span> [第三行] <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: 第一列;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: 第一行;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与上面结果相同</p>
<p><strong>span关键字</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [第一列] <span class="number">100px</span> [第二列] <span class="number">100px</span>  [第三列] <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [第一行] <span class="number">100px</span> [第二行] <span class="number">100px</span> [第三行] <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: span <span class="number">2</span>;</span><br><span class="line">   <span class="attribute">grid-row-start</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="grid-column和grid-row"><a href="#grid-column和grid-row" class="headerlink" title="grid-column和grid-row"></a>grid-column和grid-row</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。<br><strong>语法</strong><br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-column: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</span><br><span class="line">grid-row: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</span><br></pre></td></tr></table></figure></p>
<p>改写上面的代码：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>:[第一列]/ span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: [第一行]/ span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与上面的实现一样。</p>
<h3 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h3><p><code>grid-area</code>表示当前网格所占用的区域。在介绍<code>grid-template-areas</code>属性的时候就演示过该属性，我们使用<code>grid-template-areas</code>属性自定义一些网格区域，然后使用<code>grid-area</code>属性让grid子项指定使用这些区域，就自动进行了区域分布。<br><code>grid-area</code>和<code>grid-column/grid-row</code>作用都是grid子项的分布，但<code>grid-area</code>语义要更好，识别度更佳，非常适合具有功能属性的布局区域（如头部，底部），同时，还支持非规则区域。</p>
<p><strong>语法</strong><br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-area: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><name> 区域名称。由grid-template-areas属性创建。</name></li>
<li><code>&lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;</code> 占据网格区域的纵横起始位置。</li>
</ul>
<p>改写上面代码：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="justify-self、align-self、place-self"><a href="#justify-self、align-self、place-self" class="headerlink" title="justify-self、align-self、place-self"></a>justify-self、align-self、place-self</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。<br><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p>
<p><strong>语法</strong><br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">justify-self: start | end | center | stretch;</span><br><span class="line">align-self: start | end | center | stretch;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
<p>示例代码请看<br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#justify-self" target="_blank" rel="noopener">justify-self 效果参考 张鑫旭大佬的博客</a><br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#align-self" target="_blank" rel="noopener">align-self 效果参考 张鑫旭大佬的博客</a></p>
<h4 id="place-self"><a href="#place-self" class="headerlink" title="place-self"></a>place-self</h4><p>place-items可以让align-self和justify-self属性写在单个声明中。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; / &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Grid布局则适用于更大规模的布局（二维布局），而Flexbox布局最适合应用程序的组件和小规模布局（一维布局）</li>
<li>命名虽然支持中文，但由于CSS文件中文存在乱码的风险</li>
<li>在Grid布局中，float，display:inline-block，display:table-cell，vertical-align以及column-*这些属性和声明对grid子项是没有任何作用的。这个可以说是Grid布局中的常识，面试经常会问的，一定要记得。</li>
<li>IE10-IE15虽然名义上支持Grid布局，但支持的是老版本语法（本文是介绍的全是2.0全新语法），<br>兼容性查询请看<a href="https://caniuse.com" target="_blank" rel="noopener">can i use</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/" target="_blank" rel="noopener">写给自己看的display: grid布局教程</a><br><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid 网格布局教程</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>react的生命周期</title>
    <url>/blog/react/react-lifecycle.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<font color="#ff502c">react</font> v16.x对生命周期有比较大的变化，可以通过下面的两张比较经典的图片来一览变化。<br><strong>react v15.x</strong><br><img src="../../images/react/react-lifecricle-1-2.png" alt="reac-lifecricle"><br><strong>react v16.x</strong><br><img src="../../images/react/react-lifecricle-1-3.jpg" alt="reac-lifecricle"></p>
<font color="#ff502c">react</font> v16.x的生命周期是在 react v15.x的生命周期基础上删减了一些生命周期，同时也新增了一些生命周期，删除的生命周期也可以通过hook来模拟实现。<br><br><strong>React 16.3 新增的生命周期方法</strong><br>- <strong>getDerivedStateFromProps()</strong><br>- <strong>getSnapshotBeforeUpdate()</strong><br><br><strong>逐渐废弃的生命周期方法</strong><br>- <strong>componentWillMount()</strong><br>- <strong>componentWillReceiveProps()</strong><br>- <strong>componentWillUpdate()</strong><br><br>&gt; 虽然废弃了这三个生命周期方法，但是为了向下兼容，将会做渐进式调整。（详情见#12028）<br>V16.3 并未删除这三个生命周期，同时还为它们新增以 UNSAFE_ 前缀为别名的三个函数 <font color="#ff502c">UNSAFE_componentWillMount()</font>、<font color="#ff502c">UNSAFE_componentWillReceiveProps()</font>、<font color="#ff502c">UNSAFE_componentWillUpdate()</font>。<br>在 16.4 版本给出警告将会弃用 <font color="#ff502c">componentWillMount()</font>、<font color="#ff502c">componentWillReceiveProps()</font>、<font color="#ff502c">componentWillUpdate()</font> 三个函数<br>然后在 17 版本将会删除 <font color="#ff502c">componentWillMount()</font>、<font color="#ff502c">componentWillReceiveProps()</font>、<font color="#ff502c">componentWillUpdate()</font> 这三个函数，会保留使用 <font color="#ff502c">UNSAFE_componentWillMount()</font>、<font color="#ff502c">UNSAFE_componentWillReceiveProps()</font>、<font color="#ff502c">UNSAFE_componentWillUpdate()</font>

<p>一般生命周期分为三个阶段：</p>
<ol>
<li>创建阶段（Mounting）</li>
<li>更新阶段（Updating）</li>
<li>卸载阶段（UnMounting）</li>
</ol>
<p>从 React v16.x 开始，还对生命周期加入了错误处理（Error Handling）。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>其实用下面的这个图更能展现v15.x的流程图三个阶段的生命周期，图如下：<br><img src="../../images/react/react-lifecricle-1-1.png" alt="reac-lifecricle"></p>
<h2 id="挂载-Mounting-阶段"><a href="#挂载-Mounting-阶段" class="headerlink" title="挂载(Mounting)阶段"></a>挂载(Mounting)阶段</h2><ul>
<li>constructor</li>
<li>static getDerivedStateFromProps()(<strong>新增</strong>)</li>
<li>componentWillMount()/UNSAFE_componentWillMount()(<strong>废弃</strong>)</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h3><p>对于每个组件实例这个方法只会调用<strong>一次</strong>。</p>
<p><font color="#ff502c">constructor参数接受两个参数<strong>props</strong>，<strong>context</strong>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props, context);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.props,<span class="keyword">this</span>.context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p>
<p>可以获取到父组件传下来的的<strong>props</strong>,<strong>context</strong>,如果你想在<font color="#ff502c">constructor</font>构造函数内部(注意是内部哦，在组件其他地方是可以直接接收的)使用<strong>props</strong>或<strong>context</strong>,则需要传入，并传入<font color="#ff502c">super</font>对象。</p>
<p>构造函数通常用于：</p>
<ul>
<li>使用 <strong>this.state</strong> 来初始化 <strong>state</strong></li>
<li>给事件处理函数绑定 <strong>this</strong></li>
</ul>
<blockquote>
<p>ES6 子类的构造函数必须执行一次 <font color="#ff502c">super</font>。React 如果构造函数中要使用 <strong>this.props</strong>，必须先执行 super(props)。</p>
</blockquote>
<h3 id="static-getDerivedStateFromProps-nextProps-prevState"><a href="#static-getDerivedStateFromProps-nextProps-prevState" class="headerlink" title="static getDerivedStateFromProps(nextProps, prevState)"></a>static getDerivedStateFromProps(nextProps, prevState)</h3><p><code>static getDerivedStateFromProps(nextProps, prevState)</code><br>首先，这是一个静态方法生命周期钩子。也就是说，定义的时候得在方法前加一个<code>static</code>关键字，或者直接挂载到<code>class</code>类上。</p>
<p>简要区分一下实例方法和静态方法：</p>
<ul>
<li>实例方法，挂载在this上或者挂载在prototype上，class类不能直接访问该方法，使用new关键字实例化之后，实例可以访问该方法。</li>
<li>静态方法，直接挂载在class类上，或者使用新的关键字static，实例无法直接访问该方法。</li>
</ul>
<p>当<font color="#ff502c">创建时</font>、<font color="#ff502c">接收新的 props 时</font>、<font color="#ff502c">setState 时</font>、<font color="#ff502c">forceUpdate 时</font>会执行这个方法。</p>
<blockquote>
<p>注意：v16.3 setState 时、forceUpdate 时不会执行这个方法，v16.4 修复了这个问题。</p>
</blockquote>
<p>这个生命周期钩子也经历了一些波折，原本它是被设计成<font color="#ff502c">初始化</font>、<font color="#ff502c">父组件更新</font>和<font color="#ff502c">接收到props</font>才会触发，现在只要渲染就会触发，也就是<font color="#ff502c">初始化</font>和<font color="#ff502c">更新阶段</font>都会触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize state in constructor,</span></span><br><span class="line">  <span class="comment">// Or with a property initializer.</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: <span class="literal">false</span>,</span><br><span class="line">    lastRow: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.currentRow !== state.lastRow) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        isScrollingDown: props.currentRow &gt; state.lastRow,</span><br><span class="line">        lastRow: props.currentRow,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return null to indicate no change to state.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在建议尽量少用，只在必要的场景中使用，一般使用场景如下：</p>
<ul>
<li>无条件的根据 <code>props</code> 更新 <code>state</code></li>
<li>当 <code>props</code> 和 <code>state</code> 的不匹配情况更新 <code>state</code></li>
</ul>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h3><ul>
<li>组件刚经历<font color="#ff502c">constructor</font>,初始完数据</li>
<li>组件还未进入<font color="#ff502c">render</font>，组件还未渲染完成，dom还<strong>未渲染</strong></li>
</ul>
<p>在组件<strong>挂载</strong>到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染（<strong>如果是异步的话，会触发重新渲染</strong>）。</p>
<blockquote>
<p>这是React不再推荐使用的API。</p>
</blockquote>
<h3 id="render（会多次执行）"><a href="#render（会多次执行）" class="headerlink" title="render（会多次执行）"></a>render（会多次执行）</h3><p>该方法会创建一个<strong>vnode</strong>，用来表示组件的输出。对于一个组件来讲，<font color="#ff502c">render</font>方法是唯一一个必需的方法。<font color="#ff502c">render</font>方法需要满足下面几点：</p>
<ol>
<li>只能通过 <strong>this.props</strong> 和 <strong>this.state</strong> 访问数据（不能修改）</li>
<li>可以返回 null,false 或者任何<font color="#ff502c">React</font>组件</li>
<li>只能出现一个顶级组件，不能返回一组元素</li>
<li>不能改变组件的状态(<strong>state</strong>)</li>
<li>不能修改DOM的输出</li>
</ol>
<p>可以返回下面几种类型：</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>组件挂载到DOM后调用，且只会被调用一次。<br>一般用于下面的场景：</p>
<ul>
<li>异步请求 ajax</li>
<li>添加事件绑定（注意在 <font color="#ff502c">componentWillUnmount</font> 中取消，以免造成内存泄漏）</li>
</ul>
<h2 id="更新-update-阶段"><a href="#更新-update-阶段" class="headerlink" title="更新(update)阶段"></a>更新(update)阶段</h2><ul>
<li>componentWillReceiveProps()/UNSAFE_componentWillReceiveProps()(<strong>废弃</strong>)</li>
<li>static getDerivedStateFromProps()(<strong>新增</strong>)</li>
<li>shouldComponentUpdate(nextProps,nextState)</li>
<li>componentWillUpdate(nextProps, nextState)/UNSAFE_componentWillUpdate(nextProps, nextState)(<strong>废弃</strong>)</li>
<li>render()</li>
<li>static getSnapshotBeforeUpdate()(<strong>新增</strong>)</li>
<li>componentDidUpdate()</li>
</ul>
<p>造成组件更新有两类(两种)：</p>
<ul>
<li><p><strong>调用setState</strong></p>
<ol>
<li>组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          someThings: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   shouldComponentUpdate(nextStates)&#123; <span class="comment">// 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染</span></span><br><span class="line">        <span class="keyword">if</span>(nextStates.someThings === <span class="keyword">this</span>.state.someThings)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 虽然调用了setState ，但state并无变化</span></span><br><span class="line">        <span class="keyword">const</span> preSomeThings = <span class="keyword">this</span>.state.someThings</span><br><span class="line">         <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            someThings: preSomeThings</span><br><span class="line">         &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span> = <span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.someThings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>父组件重新render</p>
<ol>
<li>直接使用,每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。</li>
</ol>
</li>
</ul>
<p>优化同上。</p>
<h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps (nextProps)"></a>componentWillReceiveProps (nextProps)</h3><p>componentWillReceiveProps在接受父组件改变后的<strong>props</strong>需要重新渲染组件。<br>它接受一个参数：</p>
<ul>
<li>nextProps <strong>通过对比nextProps和this.props，将nextProps setState为当前组件的state，从而重新渲染组件</strong></li>
</ul>
<p>该声明周期函数可能在两种情况下被触发：</p>
<ul>
<li>组件接收到了新的属性。</li>
<li>组件没有收到新的属性，但是由于父组件重新渲染导致当前组件也被重新渲染。<br>同样，因为Fiber机制的引入，这个生命周期钩子有可能会多次触发。</li>
</ul>
<h3 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps()"></a>static getDerivedStateFromProps()</h3><p>见上文<code>static getDerivedStateFromProps()</code></p>
<h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)"></a>shouldComponentUpdate(nextProps,nextState)</h3><p>在接收新的 props 或新的 state 时，在渲染前会触发该方法。该方法通过返回 true（触发重新渲染） 或者 false（不会触发重新渲染） 来确定是否需要触发新的渲染。<br>但是官方提倡我们使用PureComponent来减少重新渲染的次数而不是手工编写shouldComponentUpdate代码。因为未来版本shouldComponentUpdate返回false，仍然可能导致组件重新的渲染。</p>
<blockquote>
<p>Currently, if shouldComponentUpdate() returns false, then UNSAFE_componentWillUpdate(), render(), and componentDidUpdate() will not be invoked. In the future React may treat shouldComponentUpdate() as a hint rather than a strict directive, and returning false may still result in a re-rendering of the component.</p>
</blockquote>
<blockquote>
<p>PureComponent自动实现了一个shouldComponentUpdate生命周期钩子。(浅比较)</p>
</blockquote>
<h3 id="componentWillUpdate-nextProps-nextState-UNSAFE-componentWillUpdate-nextProps-nextState"><a href="#componentWillUpdate-nextProps-nextState-UNSAFE-componentWillUpdate-nextProps-nextState" class="headerlink" title="componentWillUpdate(nextProps, nextState)/UNSAFE_componentWillUpdate(nextProps, nextState)"></a>componentWillUpdate(nextProps, nextState)/UNSAFE_componentWillUpdate(nextProps, nextState)</h3><p>当接收到新的 <code>props</code> 或 <code>state</code> 时，在渲染前执行该方法。在这个方法中不能调用<code>setState</code>，因为这样会导致<code>整个</code>生命周期<code>混乱</code>。<br>因为在异步渲染中，可能会导致网络请求多次，引起一些性能问题，同事在这其中获取一些dom信息是不能保证准确性。</p>
<blockquote>
<p>因为Fiber机制的引入，这个生命周期钩子有可能会多次调用。</p>
</blockquote>
<h3 id="static-getSnapshotBeforeUpdate-prevProps-prevState"><a href="#static-getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="static getSnapshotBeforeUpdate(prevProps, prevState)"></a>static getSnapshotBeforeUpdate(prevProps, prevState)</h3><p>这个方法在 <font color="#ff502c">render()</font> 之后，<font color="#ff502c">componentDidUpdate()</font> 之前调用。<br>两个参数<font color="#ff502c"> prevProps</font> 表示更新前的 <font color="#ff502c">props</font>，<font color="#ff502c">prevState</font> 表示更新前的 <font color="#ff502c">state</font>返回值称为一个快照（snapshot），如果不需要 <font color="#ff502c">snapshot</font>，则必须显示的返回 <font color="#ff502c">null</font> —— 因为返回值将作为 <font color="#ff502c">componentDidUpdate()</font> 的第三个参数使用。所以这个函数必须要配合 <font color="#ff502c">componentDidUpdate()</font> 一起使用。<br>比如记录滚动的高度，代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">    <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// If we have a snapshot value, we've just added new items.</span></span><br><span class="line">    <span class="comment">// Adjust scroll so these new items don't push the old ones out of view.</span></span><br><span class="line">    <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h3><p>该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的，所有getSnapshotBeforeUpdate时，必须要有componentDidUpdate。</p>
<blockquote>
<p>可以使用 setState，会触发 render，所以要注意判断，避免导致死循环。</p>
</blockquote>
<h2 id="卸载阶段（Unmounting）"><a href="#卸载阶段（Unmounting）" class="headerlink" title="卸载阶段（Unmounting）"></a>卸载阶段（Unmounting）</h2><ul>
<li>componentWillUnmount</li>
</ul>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><p>在组件卸载或者销毁前调用。这个方法主要用来做一些清理工作，例如：</p>
<ul>
<li>取消事件绑定</li>
<li>订阅器</li>
<li>定时器</li>
</ul>
<blockquote>
<p>不能使用 setState</p>
</blockquote>
<h2 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理 Error Handling"></a>错误处理 Error Handling</h2><blockquote>
<p>这是React v16.3.0发布的API。</p>
<ul>
<li>componentDidCatch(err, info)</li>
</ul>
</blockquote>
<p>任何子组件在渲染期间，生命周期方法中或者构造函数 constructor 发生错误时调用。<br>它主要用来捕获错误并进行相应处理，所以它的用法也比较特殊。但是它不能捕获下面的错误：</p>
<ul>
<li>事件处理 (Event handlers) （因为事件处理不发生在 React 渲染时，报错不影响渲染）</li>
<li>异步代码 (Asynchronous code) (e.g. setTimeout or requestAnimationFrame callbacks)</li>
<li>服务端渲染 (Server side rendering)</li>
<li>错误边界本身(而不是子组件)抛出的错误</li>
</ul>
<h2 id="组件树生命周期调用顺序"><a href="#组件树生命周期调用顺序" class="headerlink" title="组件树生命周期调用顺序"></a>组件树生命周期调用顺序</h2><p>应用初次挂载时，我们以<font color="#ff502c">render</font>和<font color="#ff502c">componentDidMount</font>为例，React首先会调用根组件的<font color="#ff502c">render</font>钩子，如果有子组件的话，依次调用子组件的<font color="#ff502c">render</font>钩子，调用过程其实就是<font color="#ff502c">递归</font>的顺序。</p>
<p>等所有组件的render钩子都递归执行完毕，这时候执行权在最后一个子组件手里，于是开始触发下一轮生命周期钩子，调用最后一个子组件的componentDidMount钩子，然后调用栈依次往上递归。</p>
<p><img src="../../images/react/react-lifecricle-1-4.png" alt="reac-lifecricle"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.render();</span><br><span class="line">child.render();</span><br><span class="line">grandson.render();</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line">grandson.componentDidMount();</span><br><span class="line">child.componentDidMount();</span><br><span class="line">app.componentDidMount();</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line">app.render();</span><br><span class="line">child.render();</span><br><span class="line">grandson.render();</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line">grandson.componentDidUpdate();</span><br><span class="line">child.componentDidUpdate();</span><br><span class="line">app.componentDidUpdate();</span><br></pre></td></tr></table></figure>
<h2 id="V16-生命周期函数用法建议"><a href="#V16-生命周期函数用法建议" class="headerlink" title="V16 生命周期函数用法建议"></a>V16 生命周期函数用法建议</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用于初始化 state</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">// 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用</span></span><br><span class="line">  <span class="comment">// 因为该函数是静态函数，所以取不到 `this`</span></span><br><span class="line">  <span class="comment">// 如果需要对比 `prevProps` 需要单独在 `state` 中维护</span></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;&#125;</span><br><span class="line">  <span class="comment">// 判断是否需要更新组件，多用于组件性能优化</span></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;&#125;</span><br><span class="line">  <span class="comment">// 组件挂载后调用</span></span><br><span class="line">  <span class="comment">// 可以在该函数中进行请求或者订阅</span></span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line">  <span class="comment">// 用于获得最新的 DOM 数据</span></span><br><span class="line">  getSnapshotBeforeUpdate() &#123;&#125;</span><br><span class="line">  <span class="comment">// 组件即将销毁</span></span><br><span class="line">  <span class="comment">// 可以在此处移除订阅，定时器等等</span></span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line">  <span class="comment">// 组件销毁后调用</span></span><br><span class="line">  componentDidUnMount() &#123;&#125;</span><br><span class="line">  <span class="comment">// 组件更新后调用</span></span><br><span class="line">  componentDidUpdate() &#123;&#125;</span><br><span class="line">  <span class="comment">// 渲染组件函数</span></span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">  <span class="comment">// 以下函数不建议使用</span></span><br><span class="line">  UNSAFE_componentWillMount() &#123;&#125;</span><br><span class="line">  UNSAFE_componentWillUpdate(nextProps, nextState) &#123;&#125;</span><br><span class="line">  UNSAFE_componentWillReceiveProps(nextProps) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/post/5b7e0647e51d455d18400ef7#heading-10" target="_blank" rel="noopener">React专题：生命周期</a><br><a href="https://blog.hhking.cn/2018/09/18/react-lifecycle-change/" target="_blank" rel="noopener">重新认识 React 生命周期</a><br><a href="https://www.jianshu.com/p/514fe21b9914" target="_blank" rel="noopener">详解React生命周期(包括react16版)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>混合开发的JsBridge(-)</title>
    <url>/blog/moblie/JSBridege.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>JSBridge</strong><br>听其取名就是js和Native之前的桥梁，而实际上JSBridge确实是JS和Native之前的一种通信方式。混合开发，最重要的问题是：<strong>H5和Native的双向通信</strong>。</p>
<p><strong>JSBridge 的实现原理</strong><br><code>JavaScript</code> 是运行在一个单独的 <font color="#ff502c">JS Context</font> 中（例如，<font color="#ff502c">WebView</font> 的 <font color="#ff502c">Webkit</font> 引擎、<font color="#ff502c">JSCore</font>）。由于这些 <font color="#ff502c">Context </font>与原生运行环境的天然隔离，我们可以将这种情况与 <font color="#ff502c">RPC</font>（Remote Procedure Call，远程过程调用）通信进行类比，将 <font color="#ff502c">Native</font> 与 <font color="#ff502c">JavaScript</font> 的每次互相调用看做一次 <font color="#ff502c">RPC</font> 调用。<br>在 <font color="#ff502c">JSBridge </font>的设计中，可以把前端看做 <font color="#ff502c">RPC</font> 的客户端，把 <font color="#ff502c">Native</font> 端看做 <font color="#ff502c">RPC</font> 的服务器端，从而 <font color="#ff502c">JSBridge</font> 要实现的主要逻辑就出现了：通信调用（<font color="#ff502c">Native </font>与 <font color="#ff502c">JS</font> 通信） 和 句柄解析调用。（如果你是个前端，而且并不熟悉 <font color="#ff502c">RPC </font>的话，你也可以把这个流程类比成 JSONP 的流程）</p>
<p>流程如下图所示：<br><img src="../../images/moblie/JSBirgde.png" alt="JSBridege"><br><!-- ![JSBridege](../../images/moblie/JSBirgde-1-2.png) --></p>
<h2 id="H5和NA的双向通信通用方法"><a href="#H5和NA的双向通信通用方法" class="headerlink" title="H5和NA的双向通信通用方法"></a>H5和NA的双向通信通用方法</h2><p>H5通信方式和兼容性如下表所示。指的是借助Native的webview加载H5页面，H5和NA之间通过API、URL拦截、全局调用等形式，实现消息通信。</p>
<h3 id="H5调用NA方法"><a href="#H5调用NA方法" class="headerlink" title="H5调用NA方法"></a>H5调用NA方法</h3><table>
<thead>
<tr>
<th style="text-align:center">平台</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">shouldOverrideUrlLoading</td>
<td style="text-align:center">scheme拦截方法</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">addJavascriptInterface</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">onJsAlert()、onJsConfirm()、onJsPrompt（）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IOS</td>
<td style="text-align:center">拦截URL</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IOS(UIwebview)</td>
<td style="text-align:center">JavaScriptCore</td>
<td style="text-align:center">API方法，IOS7+ 支持</td>
</tr>
<tr>
<td style="text-align:center">IOS(WKwebview)</td>
<td style="text-align:center">window.webkit.messageHandlers</td>
<td style="text-align:center">API方法，IOS7+ 支持</td>
</tr>
</tbody>
</table>
<h3 id="NA调用H5方法"><a href="#NA调用H5方法" class="headerlink" title="NA调用H5方法"></a>NA调用H5方法</h3><table>
<thead>
<tr>
<th style="text-align:center">平台</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">loadurl()</td>
<td style="text-align:center">Android 4.4 +</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">evaluateJavascript()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IOS(UIwebview)</td>
<td style="text-align:center">stringByEvaluatingJavaScriptFromString</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IOS(UIwebview)</td>
<td style="text-align:center">JavaScriptCore</td>
<td style="text-align:center">IOS7.0+</td>
</tr>
<tr>
<td style="text-align:center">IOS(UIwebview)</td>
<td style="text-align:center">evaluateJavaScript:javaScriptString</td>
<td style="text-align:center">iOS8.0+</td>
</tr>
</tbody>
</table>
<h2 id="常用的JSBridge形式"><a href="#常用的JSBridge形式" class="headerlink" title="常用的JSBridge形式"></a>常用的JSBridge形式</h2><ul>
<li><font color="#ff502c">H5调Android</font>-原生通过<font color="#ff502c">addJavascriptInterface</font>注册，然后H5直接调用</li>
<li><font color="#ff502c">Android调H5</font>-原生通过<font color="#ff502c">loadUrl</font>来调用H5，<code>4.4</code>及以上还可以通过<font color="#ff502c">evaluateJavascript</font>调用</li>
<li><font color="#ff502c">H5调iOS</font>-原生通过<font color="#ff502c">JavaScriptCore</font>注册（需ios7以上），然后H5直接调用</li>
<li><font color="#ff502c">iOS调H5</font>-通过<font color="#ff502c">stringByEvaluatingJavaScriptFromString</font></li>
<li>改写浏览器原有对象</li>
<li><font color="#ff502c">url scheme</font>交互</li>
</ul>
<h3 id="H5调Android"><a href="#H5调Android" class="headerlink" title="H5调Android"></a>H5调Android</h3><p>JSInterface是安卓4.2-官方推荐的解决方案，JSInterface在4.2之前的版本都可以，但是存在严重的安全隐患，容易被利用提权。实现如下：<br>首先，原声webview需要先注册可供前端调用的JS函数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WebSettings webSettings = mWebView.getSettings();  </span><br><span class="line"><span class="comment">//Android容器允许JS脚本</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">private <span class="built_in">Object</span> getJSBridge()&#123;  </span><br><span class="line">    <span class="built_in">Object</span> insertObj = <span class="keyword">new</span> <span class="built_in">Object</span>()&#123;  </span><br><span class="line">        @JavascriptInterface</span><br><span class="line">        public <span class="built_in">String</span> foo()&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"foo"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        @JavascriptInterface</span><br><span class="line">        public <span class="built_in">String</span> foo2(final <span class="built_in">String</span> param)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"foo2:"</span> + param;  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">return</span> insertObj;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Android容器设置侨连对象</span></span><br><span class="line">mWebView.addJavascriptInterface(getJSBridge(), <span class="string">"JSBridge"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Native中通过addJavascriptInterface添加暴露出来的JS桥对象,然后再该对象内部声明对应的API方法。</p>
<p><strong>H5调用Native的方法</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用方法一</span></span><br><span class="line"><span class="built_in">window</span>.JSBridge.foo(); <span class="comment">//返回:'foo'</span></span><br><span class="line"><span class="comment">//调用方法二</span></span><br><span class="line"><span class="built_in">window</span>.JSBridge.foo2(<span class="string">'test'</span>);<span class="comment">//返回:'foo2:test'</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>在Android4.2以上(api17后),暴露的api要加上注解@JavascriptInterface，否则会找不到方法。<ul>
<li>在api17以前,addJavascriptInterface有风险,hacker可以通过反编译获取Native注册的Js对象， 然后在页面通过反射Java的内置静态类，获取一些敏感的信息和破坏</li>
<li>JS调用Native暴露的api,并且能得到相应返回值</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Android调H5"><a href="#Android调H5" class="headerlink" title="Android调H5"></a>Android调H5</h3><p>native调用js比较简单，只要遵循：”javascript: 方法名(‘参数,需要转为字符串’)”的规则即可。</p>
<p><strong>在<code>4.4</code>版本之前</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mWebView = new WebView(this);             </span></span><br><span class="line">mWebView.loadUrl(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>); </span><br><span class="line"><span class="comment">//ui线程中运行</span></span><br><span class="line">runOnUiThread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public <span class="keyword">void</span> run() &#123;  </span><br><span class="line">        mWebView.loadUrl(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>);  </span><br><span class="line">        Toast.makeText(Activity名.this, <span class="string">"调用方法..."</span>, Toast.LENGTH_SHORT).show();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>在4.4及以后（包括）</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步执行JS代码,并获取返回值    </span></span><br><span class="line">mWebView.evaluateJavascript(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>, <span class="keyword">new</span> ValueCallback&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> onReceiveValue(<span class="built_in">String</span> value) &#123;</span><br><span class="line">        <span class="comment">// 这里的value即为对应JS方法的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>4.4之前Native通过loadUrl来调用JS方法,只能让某个JS方法执行,但是无法获取该方法的返回值<ul>
<li>4.4及之后,通过evaluateJavascript异步调用JS方法,并且能在onReceiveValue中拿到返回值</li>
<li>mWebView.loadUrl(“javascript: 方法名(‘参数,需要转为字符串’)”); 函数需在UI线程运行，因为mWebView为UI控件(但是有一个坏处是会阻塞UI线程)</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="H5调iOS"><a href="#H5调iOS" class="headerlink" title="H5调iOS"></a>H5调iOS</h3><p>Native中通过引入官方提供的JavaScriptCore库(iOS7以上),然后可以将api绑定到JSContext上(然后Html中JS默认通过window.top.*可调用)。<br>以OC为例：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</span><br><span class="line">-(<span class="keyword">void</span>)webViewDidFinishLoad:(UIWebView *)webView&#123;</span><br><span class="line">    [self hideProgress];</span><br><span class="line">    [self setJSInterface];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setJSInterface&#123;</span><br><span class="line">    JSContext *context =[_wv valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="comment">// 注册名为foo的api方法</span></span><br><span class="line">    context[@<span class="string">"foo"</span>] = ^() &#123;</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        NSArray *args = [JSContext currentArguments];</span><br><span class="line">        NSString *title = [NSString stringWithFormat:@<span class="string">"%@"</span>,[args objectAtIndex:<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">//做一些自己的逻辑</span></span><br><span class="line">        <span class="comment">//返回一个值  'foo:'+title</span></span><br><span class="line">        <span class="keyword">return</span> [NSString stringWithFormat:@<span class="string">"foo:%@"</span>, title];</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>H5调用IOS方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.top.foo(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>iOS7之前，js无法直接调用Native,只能通过urlscheme方式间接调用<ul>
<li>JS能调用到已经暴露的api,并且能得到相应返回值</li>
<li>iOS原生本身是无法被JS调用的,但是通过引入官方提供的第三方”JavaScriptCore”,即可开放api给JS调用</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="iOS调H5"><a href="#iOS调H5" class="headerlink" title="iOS调H5"></a>iOS调H5</h3><p>Native调用js的方法比较简单，Native通过stringByEvaluatingJavaScriptFromString调用Html绑定在window上的函数。不过应注意Oc和Swift的写法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以取得JS函数执行的返回值</span></span><br><span class="line"><span class="comment">// 方法必须是Html页面绑定在最顶层的window上对象的</span></span><br><span class="line"><span class="comment">// 如window.top.foo</span></span><br><span class="line"><span class="comment">// Swift</span></span><br><span class="line">webview.stringByEvaluatingJavaScriptFromString(<span class="string">"方法名(参数)"</span>)</span><br><span class="line"><span class="comment">// OC</span></span><br><span class="line">[webView stringByEvaluatingJavaScriptFromString:@<span class="string">"方法名(参数);"</span>];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>Native调用JS方法时,能拿到JS方法的返回值<ul>
<li>不适合传输大量数据(大量数据建议用接口方式获取)</li>
<li>有iframe时，需要获取顶层窗口的引用</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="改写浏览器原有对象"><a href="#改写浏览器原有对象" class="headerlink" title="改写浏览器原有对象"></a>改写浏览器原有对象</h3><p>改写window上的四种方法，然后拦截固定规则的参数分发给Java对应的方法处理：</p>
<ul>
<li>alert，可以被webview的onJsAlert监听</li>
<li>confirm，可以被webview的onJsConfirm监听</li>
<li>console.log，可以被webview的onConsoleMessage监听</li>
<li>prompt，可以被webview的onJsPrompt监听<br>prompt简单举例说明，Web页面通过调用<code>prompt()</code>方法，安卓客户端通过监听<code>onJsPrompt</code>事件，拦截传入的参数，如果参数符合一定协议规范，那么就解析参数，扔给后续的Java去处理。这种协议规范，最好是跟iOS的协议规范一样，这样跨端调起协议是一致的，但具体实现不一样而已。比如：<code>hybrid://action?arg1=1</code> 这样的协议，而其他格式的<code>prompt</code>参数，是不会监听的，即除了<code>hybrid://action?arg1=1</code> 这样的规范协议，<code>prompt</code>还是原来的<code>prompt</code>。</li>
</ul>
<p>这四个方法也是各有利弊，比如:</p>
<ul>
<li><code>alert</code>/<code>console.log</code>是调试最常用的，如果你要看看协议是不是写错了，但是传入协议却被拦截了。</li>
<li><code>confirm</code>和<code>prompt</code>都带返回值，<code>prompt</code>是四个里面唯一可以自定义返回值，可以做同步的交互，要比写各种回调更「顺」，但是一旦串行调用了，就会比较坑。</li>
</ul>
<blockquote>
<p>prompt是目前安卓用的比较多的JSBridge解决方案。</p>
</blockquote>
<h3 id="url-scheme"><a href="#url-scheme" class="headerlink" title="url scheme"></a>url scheme</h3><p>这个叫法不是特别贴切，scheme是URI的一种格式，上文提到的hybrid://action?arg1=1 就是一个scheme协议，这里说的scheme（或者schema）泛指安卓和iOS的schema协议，因为它通用。</p>
<p>拦截 url scheme 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 url scheme 请求，之后 Native 拦截到请求并根据 url scheme（包括所带的参数）进行相关操作。<br>缺点：</p>
<ul>
<li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</li>
<li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li>
</ul>
<blockquote>
<ul>
<li>有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。<ul>
<li>为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="唤起APP技术"><a href="#唤起APP技术" class="headerlink" title="唤起APP技术"></a>唤起APP技术</h2><p>APP外（浏览器、微信等）调起APP自己，给APP进行导流。这时候就要用到APP的唤起技术。这里有一下几种方法：</p>
<ul>
<li>intent：安卓</li>
<li>localserver: 安卓</li>
<li>Universal links: IOS 9+</li>
<li>Deep link/Applink: 安卓</li>
<li>smart app banner: IOS</li>
</ul>
<h3 id="安卓intent"><a href="#安卓intent" class="headerlink" title="安卓intent"></a>安卓intent</h3><p>intent格式示例如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">intent:</span><br><span class="line">   HOST/URI-path <span class="comment">// Optional host </span></span><br><span class="line">   #Intent; </span><br><span class="line">      package=[string]; </span><br><span class="line">      action=[string]; </span><br><span class="line">      category=[string]; </span><br><span class="line">      component=[string]; </span><br><span class="line">      scheme=[string]; </span><br><span class="line">      S.xxx=xxx</span><br><span class="line">   end;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一部分：host和path是跟url无异</li>
<li>第二部分：#intent到end是完整的intent，包含了调起的app包名，action等是常用的配置项</li>
</ul>
<p>因为Intent不仅仅是调起APP，而是安卓客户端内部模块通信也会用，所以权限很大，一般浏览器都给封掉了。</p>
<h3 id="安卓localserver"><a href="#安卓localserver" class="headerlink" title="安卓localserver"></a>安卓localserver</h3><p>启动一个本地server，端口号是：8888，那么在手机上，网页就可以通过：<a href="http://127.0.0.1:8888" target="_blank" rel="noopener">http://127.0.0.1:8888</a> 访问这个server，server接收到请求就可以进行一些native的操作，对于需要回调数据的，就通过返回请求内容来执行，比如：</p>
<ul>
<li>获取个定位信息，js执行$.get(‘<a href="http://127.0.0.1:8888/getGeoLocation?callback=cbname&#39;" target="_blank" rel="noopener">http://127.0.0.1:8888/getGeoLocation?callback=cbname&#39;</a>)</li>
<li>server收到请求之后，调用native方法，获取GPS的定位信息，然后将数据通过response：window.cbname&amp;&amp;cbname({xxx})给页面返回定位数据</li>
</ul>
<blockquote>
<ul>
<li>如果控制不好权限，因为localserver是一直后台守候的，容易被利用，比如提权获取通讯录、甚至给通讯录发短信、容易造成蠕虫攻击<ul>
<li>另外安卓各种安全软件，都会清理内存和后台程序，很容易被干掉进程。浏览器也会封杀本地server调起，碰见127.0.0.1的请求就直接拦截。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Universal-links-Deep-link-Applink"><a href="#Universal-links-Deep-link-Applink" class="headerlink" title="Universal links / Deep link / Applink"></a>Universal links / Deep link / Applink</h3><p>这三个是官方推荐的调起方法，调起协议格式也是可以统一的，比如前文提到的hybrid://action?arg1=xxx这类scheme协议就是。这样可以统一安卓和iOS调起和JSBridge通信。</p>
<h4 id="Universal-Links"><a href="#Universal-Links" class="headerlink" title="Universal Links"></a>Universal Links</h4><p>iOS 9新出的一个功能，需要在App内声明一个https域名（ul.test.com），然后在该网站根目录放置apple-app-site-association文件，文件指明了转发规则，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"applinks"</span>: &#123;</span><br><span class="line">        <span class="string">"apps"</span>: [],</span><br><span class="line">        <span class="string">"details"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"appID"</span>: “xxx.com.baidu.SomeApp”,</span><br><span class="line">            <span class="string">"paths"</span>: [<span class="string">"*"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当APP安装成功之后，会下载这个文件，明确知道遇见ul.test.com的域名的URL时候，会把这个URL扔给你的APP，让你去解析，APP拿到这个URL就可以解析出来需要做什么事情。</p>
<p>Universal Link是iOS 9+的底层实现，所以在任何地方都可以直接调起APP，不受微信这类封闭APP的限制。</p>
<h4 id="Deep-link-Applink"><a href="#Deep-link-Applink" class="headerlink" title="Deep link / Applink"></a>Deep link / Applink</h4><p>Deep link 是安卓一开始推出的，主要用于搜索调起APP，后来推出 Applink，实际是Deep link的升级版。</p>
<p>这里需要提到微信的APPlink，毕竟微信作为SuperApp，是很大的分发资源，微信有自己的分发方法，安卓内可以申请微信的APPlink，跟Universal link一样，也是一个域名下面的URL，符合一定规则就由微信（ios是底层系统）扔个对应的域名APP进行解析。</p>
<h3 id="smart-app-banner"><a href="#smart-app-banner" class="headerlink" title="smart app banner"></a>smart app banner</h3><p>在页面的head中添加下面meta，在Safari浏览器中就会出现下面的banner<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"apple-itunes-app"</span> content=<span class="string">"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Hybrid是一种连接H5跟NA的思路，即可以快速迭代H5功能，又可以有NA的体验，是混合开发的典型开发模式。<br><strong>JSBridge的最佳实践</strong></p>
<ul>
<li>官方推荐的方法</li>
<li>跨平台通用</li>
<li>安全可靠</li>
<li>约定大于配置的原则</li>
<li>协议规范都使用：hybrid://action/method?arg1=xxx&amp;arg2=xxx</li>
<li>iOS使用Universal Link和UIWebview的delegate</li>
<li>安卓使用shouldOverrideUrlLoading和Applink</li>
</ul>
<p>以上就是Native和H5间的通信原理，在不同端的代码实现也有示例，下一篇是讲解怎么封装一个自己通用的JSBridge。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://yq.aliyun.com/articles/72774" target="_blank" rel="noopener">JSBridge深度剖析</a><br><a href="https://dailc.github.io/2017/12/24/quickhybrid_native2h5interaction.html" target="_blank" rel="noopener">H5和Native交互原理</a><br><a href="https://dailc.github.io/2017/12/24/quickhybrid_jsbridge.html" target="_blank" rel="noopener">JSBridge的实现</a><br><a href="https://juejin.im/post/5bda6f276fb9a0226d18931f#heading-11" target="_blank" rel="noopener">JSBridge实战</a><br><a href="https://juejin.im/post/5abca877f265da238155b6bc#heading-11" target="_blank" rel="noopener">JSBridge的原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>react简单的typeScript应用 (未完成)</title>
    <url>/blog/react/react-typescript.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的mixins、hoc、hooks三者对比</title>
    <url>/blog/react/react-mixins-hoc-hooks.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/react/react-hoc.html">react的高阶组件浅析</a><br><a href="/blog/react/react-hooks.html">react中Hooks浅析</a><br><a href="/blog/react/react-mixins-hoc-hooks.html">react的mixins、hoc、hooks对比</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><font color="#ff502c">Mixin（混入）</font>是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以<font color="#ff502c">拷贝任意多个对象的任意个方法</font>到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了<font color="#ff502c">解决代码复用问题</font>。<br>如下图所示：<br><img src="../../images/react/react-mixins-1-1.png" alt="reac-mixins"><br>Mixin是用来提取可复用的逻辑或者方法，并且它比继承要更令活，它的应用范围也是比较广的比如在<font color="#ff502c">JQuery</font>的<font color="#ff502c">extend</font>方法。</p>
<p>Mixin大致实现如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMixin</span>(<span class="params">target, mixin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        t   arget.prototype[<span class="built_in">arguments</span>[i]] = mixin.prototype[<span class="built_in">arguments</span>[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> methodName <span class="keyword">in</span> mixin.prototype) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Object</span>.hasOwnProperty(target.prototype, methodName)) &#123;</span><br><span class="line">                target.prototype[methodName] = mixin.prototype[methodName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setMixin(User,LogMixin,<span class="string">'actionLog'</span>);</span><br><span class="line">setMixin(Goods,LogMixin,<span class="string">'requestLog'</span>);</span><br></pre></td></tr></table></figure></p>
<p>您可以使用<font color="#ff502c">setMixin方法</font>将任意对象的任意方法扩展到目标对象上。</p>
<h2 id="React中的Mixin"><a href="#React中的Mixin" class="headerlink" title="React中的Mixin"></a>React中的Mixin</h2><p><font color="#ff502c">React</font>也提供了<font color="#ff502c">Mixin</font>的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用<font color="#ff502c">createClass</font>来创建<font color="#ff502c">React组件</font>时才可以使用，因为在<font color="#ff502c">React组件</font>的es6写法中它已经<font color="#ff502c">被废弃掉</font>了。</p>
<p>例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过<font color="#ff502c">Mixin</font>我们可以解决这一问题：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> LogMixin = &#123;</span><br><span class="line">    log: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'log'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentDidMount () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentWillUnmount () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'out'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> User = React.createClass(&#123;</span><br><span class="line">    mixins: [LogMixin],</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Goods = React.createClass(&#123;</span><br><span class="line">    mixins: [LogMixin],</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Mixin的缺陷"><a href="#Mixin的缺陷" class="headerlink" title="Mixin的缺陷"></a>Mixin的缺陷</h2><p><font color="#ff502c">React</font>官方文档在<a href="https://react.docschina.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a>一文中提到了Mixin带来了危害：</p>
<ul>
<li><strong>Mixin 可能会相互依赖，相互耦合，不利于代码维护</strong></li>
<li><strong>不同的Mixin中的方法可能会相互冲突</strong></li>
<li><strong>Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</strong></li>
</ul>
<p><font color="#ff502c">React</font>现在已经<font color="#ff502c">不再推荐使用Mixin</font>来解决代码复用问题，因为<font color="#ff502c">Mixin</font>带来的<font color="#ff502c">危害</font>比他产生的<font color="#ff502c">价值</font>还要巨大，并且React全面推荐使用<font color="#ff502c">高阶组件</font>来替代它。</p>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>React推荐高阶组件和代替Mixin来做逻辑、代码复用，这里就不多赘述Hoc的使用和作用，如果不太清楚的可以看另一篇博客来了解React中的HOC,<a href="/blog/react/react-hoc.html">react的高阶组件浅析</a>。</p>
<h3 id="HOC的作用"><a href="#HOC的作用" class="headerlink" title="HOC的作用"></a>HOC的作用</h3><p>HOC可以比Mixin做更多的事情，也没有Mixin产生那么大副作用，具体实现什么样的功能如下：</p>
<ul>
<li><strong>操作 props(属性)(通过属性代理实现、通过反向继承实现)</strong></li>
<li><strong>通过 Refs 访问到组件实例 （通过属性代理实现）</strong></li>
<li><strong>组件状态提升（通过属性代理实现）</strong></li>
<li><strong>操作state （通过反向继承实现）</strong></li>
<li><strong>渲染劫持（通过属性代理实现、通过反向继承实现）</strong></li>
<li><strong>用其他元素包裹 WrappedComponent （通过属性代理实现）</strong></li>
</ul>
<h2 id="HOC的缺陷"><a href="#HOC的缺陷" class="headerlink" title="HOC的缺陷"></a>HOC的缺陷</h2><ul>
<li><code>HOC</code>需要在原组件上进行包裹或者嵌套，如果大量使用<code>HOC</code>，将会产生非常多的嵌套，这让调试变得非常困难。</li>
<li><code>HOC</code>可以劫持<code>props</code>，在不遵守约定的情况下也可能造成冲突。</li>
</ul>
<p><strong>在新版的React中推行Hooks来替代HOC。它可以同时解决Mixin和HOC带来的问题</strong></p>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>在<font color="#ff502c">React v16.7.0-alpha</font>中加入了新的特性<font color="#ff502c">Hooks</font>，他可以让你在<font color="#ff502c">class</font>以外使用<font color="#ff502c">state</font>和其他<font color="#ff502c">React</font>特性。</p>
<p>使用<font color="#ff502c">Hooks</font>，你可以在将含有<font color="#ff502c">state的逻辑从组件中抽象出来</font>，这将可以让这些逻辑容易被测试。同时，<font color="#ff502c">Hooks</font>可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现<font color="#ff502c">状态逻辑复用的方案</font>。</p>
<p>可以看另一篇博客<a href="/blog/react/react-hooks.html">react中Hooks浅析</a></p>
<h2 id="hook使用事项"><a href="#hook使用事项" class="headerlink" title="hook使用事项"></a>hook使用事项</h2><p><strong>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。</strong></p>
<h3 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h3><p><font color="#ff502c">不要</font>在<font color="#ff502c">循环，条件或嵌套函数</font>中<font color="#ff502c">调用 Hook</font>， 确保总是在你的 <font color="#ff502c">React 函数的最顶层调用</font>他们。</p>
<h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p><font color="#ff502c">不要</font>在<font color="#ff502c">普通的 JavaScript 函数中</font>调用 Hook。只能在<font color="#ff502c"> React 的函数组件中调用 Hook</font>。不要在其他 JavaScript 函数中调用。<br><strong>Hook的提出主要就是为了解决class组件的一系列问题，所以我们能在class组件中使用它</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序的发展提出一个可以解决当前问题的方案，但随着时间的变化发现以前的方案有很大的副作用或者有更好的方案，就会更新一套更好的方案来解决问题，就像<font color="#ff502c">React中复用逻辑的变化从Mixin(已废弃)到HOC(用的比较多)再到现在的Hooks(新贵)</font>，可能以后Hooks也会落伍但是一定要保持学习。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-36" target="_blank" rel="noopener">【React深入】从Mixin到HOC再到Hook</a><br><a href="/blog/react/react-hoc.html">react的高阶组件浅析</a><br><a href="/blog/react/react-hooks.html">react中Hooks浅析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react中Hooks浅析</title>
    <url>/blog/react/react-hooks.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/react/react-hoc.html">react的高阶组件浅析</a><br><a href="/blog/react/react-hooks.html">react中Hooks浅析</a><br><a href="/blog/react/react-mixins-hoc-hooks.html">react的mixins、hoc、hooks对比</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
</blockquote>
<p>我们知道，functional component在使用的时候有一些限制，比如需要生命周期、state的时候就不能用functional component。而有了Hooks，你就可以在funtional component里，使用class component的功能:props，state，context，refs，和生命周期函数等等。<br><strong>虽然Hooks已经有要取代正宫class的趋势了，但是react目前没有计划抛弃class，所以不要慌，你还是可以跟往常一样使用class。</strong></p>
<h2 id="为什么引入hook"><a href="#为什么引入hook" class="headerlink" title="为什么引入hook"></a>为什么引入hook</h2><hr>
<h3 id="组件难以理解"><a href="#组件难以理解" class="headerlink" title="组件难以理解"></a>组件难以理解</h3><p>在使用class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个<font color="#ff502c">生命周期</font>中会调用越来越多的逻辑，越来越难以维护。<font color="#ff502c">Hook</font> <strong>将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</strong>。而并非强制按照生命周期划分。你还可以使用 <font color="#ff502c">reducer</font> 来管理组件的内部状态，使其更加可预测。使用<font color="#ff502c">Hook</font>，可以让你更大限度的将<font color="#ff502c">公用逻辑</font>抽离，将一个组件分割成<font color="#ff502c">更小</font>的函数，而不是<font color="#ff502c">强制</font>基于生命周期方法进行分割。</p>
<h3 id="组件嵌套问题"><a href="#组件嵌套问题" class="headerlink" title="组件嵌套问题"></a>组件嵌套问题</h3><p>如果我们需要抽离一些重复的逻辑，就会选择 <font color="#ff502c">HOC</font> 或者 <font color="#ff502c">render props</font> 的方式。这种方式首先提高了 debug 的难度，并且也很难实现共享状态。<br>但是通过 <font color="#ff502c">Hooks</font> 的方式去抽离重复逻辑的话，一是不会增加组件的嵌套，二是可以实现状态的共享。</p>
<h3 id="使用函数代替class"><a href="#使用函数代替class" class="headerlink" title="使用函数代替class"></a>使用函数代替class</h3><p>相比函数，编写一个<font color="#ff502c">class</font>可能需要掌握更多的知识，需要注意的点也越多，比如<font color="#ff502c">this</font>指向、绑定事件等等。另外，计算机理解一个函数比理解一个<font color="#ff502c">class</font>更快。<font color="#ff502c">Hooks</font>让你可以在<font color="#ff502c">class</font>之外使用更多React的新特性。</p>
<h3 id="减少状态逻辑复用的风险"><a href="#减少状态逻辑复用的风险" class="headerlink" title="减少状态逻辑复用的风险"></a>减少状态逻辑复用的风险</h3><p><font color="#ff502c">Hook</font>和<font color="#ff502c">Mixin</font>在用法上有一定的相似之处，但是<font color="#ff502c">Mixin</font>引入的<font color="#ff502c">逻辑</font>和<font color="#ff502c">状态</font>是可以<font color="#ff502c">相互覆盖</font>的，而多个<font color="#ff502c">Hook</font>之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。<br>在不遵守约定的情况下使用<font color="#ff502c">HOC</font>也有可能带来一定冲突，比如<font color="#ff502c">props覆盖</font>等等，使用Hook则可以避免这些问题。</p>
<h3 id="函数组件无-this-问题"><a href="#函数组件无-this-问题" class="headerlink" title="函数组件无 this 问题"></a>函数组件无 this 问题</h3><p>不需要通过<font color="#ff502c">bind</font>函数改变事件的<font color="#ff502c">this</font>指向问题。</p>
<h2 id="Hook-API-索引"><a href="#Hook-API-索引" class="headerlink" title="Hook API 索引"></a>Hook API 索引</h2><hr>

<p>大致所有的<font color="#ff502c">hook</font>都在下面的列表中，但是比较重要的<font color="#ff502c">hook</font>是<font color="#ff502c">State Hook</font>、<font color="#ff502c">Effect Hook</font>这两个hook。</p>
<ul>
<li>基础 Hook<ul>
<li>useState</li>
<li>useEffect</li>
<li>useContext</li>
</ul>
</li>
<li>额外的 Hook<ul>
<li><a href="https://react.docschina.org/docs/hooks-reference.html#usereducer" target="_blank" rel="noopener">useReducer</a></li>
<li>useCallback</li>
<li>useMemo</li>
<li>useRef</li>
<li><a href="https://react.docschina.org/docs/hooks-reference.html#useimperativehandle" target="_blank" rel="noopener">useImperativeHandle</a></li>
<li><a href="https://react.docschina.org/docs/hooks-reference.html#useLayoutEffect" target="_blank" rel="noopener">useLayoutEffect</a></li>
<li><a href="https://react.docschina.org/docs/hooks-reference.html#useDebugValue" target="_blank" rel="noopener">useDebugValue</a></li>
</ul>
</li>
</ul>
<h3 id="State-Hook、Effect-Hook"><a href="#State-Hook、Effect-Hook" class="headerlink" title="State Hook、Effect Hook"></a>State Hook、Effect Hook</h3><ul>
<li><code>State Hook</code>(<code>useState</code> 通过在函数组件里调用它来给组件添加一些内部 <code>state</code>。)</li>
<li><code>Effect Hook</code> (<code>useEffect</code> 就是一个 <code>Effect Hook</code>，给函数组件增加了操作副作用的能力。)</li>
</ul>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseStateHook</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>useState()</code>返回的状态 <code>(count)</code> 与传入的第一个参数 <code>(initialState)</code> 值相同。</p>
<blockquote>
<p><strong>注意</strong> <code>React</code> 会确保 <code>setState</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>setState</code>。</p>
</blockquote>
<p><strong>函数式更新</strong></p>
<p>同时也会返回更新<code>state</code>函数<code>setCount</code>,两种用法直接传要更新的值，也可以传<code>fucntion</code>但是要<code>return</code>出要更新的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; setCount(<span class="number">1</span>)&#125;&gt;</span><br><span class="line">    Click me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">    Click me</span></span><br><span class="line"><span class="regexp">&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 与 <code>class</code> 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code>结合展开运算符来达到合并更新对象的效果。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">    <span class="keyword">return</span> &#123;...prevState, ...updatedValues&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 <code>state</code> 对象。</p>
</blockquote>
<p><strong>惰性初始 state</strong></p>
<p><strong>initialState</strong> 参数只会在组件的<strong>初始渲染</strong>中起作用，后续渲染时会被<strong>忽略</strong>。也可以传入一个<strong>函数</strong>计算并返回初始的state。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count setCount] = useSate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; porps &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> initialState = porps + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><font color="#ff502c">useEffect</font> 就是一个 <font color="#ff502c">Effect Hook</font>，给函数组件增加了操作副作用的能力。它跟 <font color="#ff502c">class</font> 组件中的 <font color="#ff502c">componentDidMount</font>、<font color="#ff502c">componentDidUpdate</font> 和 <font color="#ff502c">componentWillUnmount</font> 具有相同的用途，只不过被合并成了一个 <font color="#ff502c">API</font>。（我们会在使用 <font color="#ff502c">Effect Hook</font> 里展示对比 <font color="#ff502c">useEffect</font> 和这些方法的例子。）</p>
<p><strong>语法</strong></p>
<p><font color="#ff502c">useEffect</font>方法接收传入两个参数：</p>
<ul>
<li>1.回调函数：在第组件一次<font color="#ff502c">render</font>和之后的每次<font color="#ff502c">update</font>后运行，<font color="#ff502c">React</font>保证在<font color="#ff502c">DOM已经更新完成</font>之后才会运行回调。</li>
<li>2.状态依赖(数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只要组件render后就会执行</span></span><br><span class="line">&#125;);</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有count改变时才会执行</span></span><br><span class="line">&#125;,[count]);</span><br></pre></td></tr></table></figure>
<p><strong>清除 effect</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清除订阅</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在<strong>执行下一个 effect 之前，上一个 effect 就已被清除</strong>。</p>
<p><strong>effect 的执行时机</strong></p>
<p>与 <font color="#ff502c">componentDidMount</font>、<font color="#ff502c">componentDidUpdate</font> 不同的是，在浏览器完成布局与绘制之后，传给 <font color="#ff502c">useEffect</font> 的函数会延迟调用。<br>虽然 <font color="#ff502c">useEffect</font> 会在浏览器绘制后延迟执行，但会保证在<font color="#ff502c">任何新</font>的<font color="#ff502c">渲染前</font>执行。<font color="#ff502c">React</font> 将在组件更新前刷新上一轮渲染的 effect。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseStateHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行...'</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'清理...'</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行上面的代码，并且点击几次按钮，执行顺序如下：</p>
<p>如果我们加上浏览器渲染，他会在页面渲染之执行，运行如下：</p>
<p><strong>模拟componentDidMount</strong></p>
<p><font color="#ff502c">componentDidMount</font>等价于<font color="#ff502c">useEffect</font>的回调仅在页面初始化完成后执行一次，当<font color="#ff502c">useEffect</font>的第二个参数传入一个空数组时可以实现这个效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDidMount</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    useEffect(callback, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方不推荐上面这种写法，因为这有可能导致一些错误。</p>
</blockquote>
<p><strong>模拟componentWillUnmount</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useUnMount</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> callback, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不像 <code>componentDidMount</code> 或者 <code>componentDidUpdate</code>，<code>useEffect</code> 中使用的 <code>effect</code> 并不会阻滞浏览器渲染页面。这让你的 <code>app</code> 看起来更加流畅。</p>
</blockquote>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>
<p>接收一个 <font color="#ff502c">context</font> 对象（<font color="#ff502c">React.createContext</font> 的返回值）并返回该 <font color="#ff502c">context</font> 的当前值。当前的 <font color="#ff502c">context</font> 值由上层组件中距离当前组件最近的 <font color="#ff502c">&lt;MyContext.Provider&gt;</font> 的 <font color="#ff502c">value prop</font> 决定。</p>
<p><a href="/blog/react/react-context.html">context的使用请看另一篇博客</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span></span><br><span class="line"><span class="comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line">        <span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">        <span class="comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;ThemeContext.Provider value=<span class="string">"drak"</span>&gt;</span><br><span class="line">                &lt;Toolbar /&gt;</span><br><span class="line">            &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 中间的组件再也不必指明往下传递 theme 了。</span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ThemedButton /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class ThemedButton extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 指定 contextType 读取当前的 theme context。</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 在这个例子中，当前的 theme 值为 “dark”。</span></span><br><span class="line"><span class="regexp">    static contextType = ThemeContext;</span></span><br><span class="line"><span class="regexp">    render () &#123;</span></span><br><span class="line"><span class="regexp">        return &lt;Button theme=&#123;this.context&#125;/</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写<code>ThemeButton</code>组件，用<code>useContext</code>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeButton</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Button theme=&#123;theme&#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别忘记 <font color="#ff502c">useContext</font> 的参数必须是 <font color="#ff502c">context</font> 对象本身：</p>
<ul>
<li>正确： <code>useContext(ThemeContext)</code></li>
<li>错误： <code>useContext(ThemeContext.Consumer)</code></li>
<li>错误： <code>useContext(ThemeContext.Provider)</code></li>
</ul>
<p>调用了 <font color="#ff502c">useContext</font> 的组件总会在 <font color="#ff502c">context</font> 值变化时重新渲染。如果重渲染组件的开销较大，你可以 <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693" target="_blank" rel="noopener">通过使用 memoization 来优化</a>。</p>
<blockquote>
<p>如果你在接触 <font color="#ff502c">Hook</font> 前已经对 <font color="#ff502c">context API</font> 比较熟悉，那应该可以理解，<strong>useContext(MyContext)</strong> 相当于 class 组件中的 <strong>static contextType = MyContext</strong> 或者 <strong>&lt;MyContext.Consumer&gt;</strong>。</p>
</blockquote>
<p>useContext(MyContext) 只是让你能够读取 <font color="#ff502c">context</font> 的值以及订阅 <font color="#ff502c">context</font> 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 c<font color="#ff502c">ontext</font>。</p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>如果你需要一个不会随着组件更新而重新创建的 <code>callback</code></p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><font color="#ff502c">useMemo</font> 可以用来优化函数组件重渲染的性能。函数组价有<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener">React.memo(高阶组件)</a>，它类似类组件的<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">React.PureComponent</a>；它们都是React的顶层API。</p>
<p><strong>useMemo 与 memo</strong></p>
<p><font color="#ff502c">React.memo</font>针对的是一个函数组件的渲染是否重复执行，而 <font color="#ff502c">useMemo</font> 定义的是一个函数逻辑是否重复执行。</p>
<p><strong>语法</strong></p>
<p>它的语法和<font color="#ff502c">useEffect</font>很像，把“创建”函数和依赖项数组作为参数传入 <font color="#ff502c">useMemo</font>。<br>参数：</p>
<ul>
<li>第一个参数是是需要执行的逻辑函数</li>
<li>第二个参数是这个逻辑依赖输入变量组成的数组，如果不传每次都会执行逻辑函数， 传入空数组只会执行一次。（非必传）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> renderCount = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'渲染次数：'</span> + count);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'渲染次数：'</span> + count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// eslint-disable-next-line react/react-in-jsx-scope</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; &#123;setCount(count + <span class="number">1</span>)&#125;&#125;&gt;</span><br><span class="line">        计数按钮</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;renderCount&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="../../images/react/react-hook-1-1.png" alt="reac-hook"><br>可以在依赖输入做判断优化渲染次数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderCount = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'渲染次数：'</span> + count);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'渲染次数：'</span> + count;</span><br><span class="line">&#125;, [count === <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="../../images/react/react-hook-1-2.png" alt="reac-hook"><br><strong>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。</strong></p>
<blockquote>
<p>注意 依赖项数组不会作为参数传给“创建”函数。然虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。<br>我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</p>
</blockquote>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，使用<code>useRef Hook</code>，你可以轻松的获取到<code>dom</code>的<code>ref</code>。<br><code>useRef</code> 主要有两个使用场景：</p>
<ul>
<li>获取子组件或者 <code>DOM</code> 节点的句柄</li>
<li>渲染周期之间的共享数据的存储</li>
</ul>
<p>大家可能会想到 <code>state</code> 也可跨越渲染周期保存，但是 <code>state</code> 的赋值会触发重渲染，但是 <code>ref</code> 不会，从这点看 <code>ref</code> 更像是类属性中的普通成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 <code>ref</code> 对象。</p>
<p><strong>模拟实现ComponentDidUpdate</strong></p>
<p><code>componentDidUpdate</code>就相当于除去第一次调用的<code>useEffect</code>，我们可以借助<code>useRef</code>生成一个标识，来记录是否为第一次执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">useDidUpdate</span>(<span class="params">callback, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> init = useRef(<span class="literal">true</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.current) &#123;</span><br><span class="line">      init.current = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请记住，当 <code>ref</code> 对象内容发生变化时，<code>useRef</code> 并不会通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 <code>DOM</code> 节点的 <code>ref</code> 时运行某些代码，则需要使用回调 <code>ref</code> 来实现。</p>
</blockquote>
<h2 id="hook使用事项"><a href="#hook使用事项" class="headerlink" title="hook使用事项"></a>hook使用事项</h2><p><strong>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。</strong></p>
<h3 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h3><p><font color="#ff502c">不要</font>在<font color="#ff502c">循环，条件或嵌套函数</font>中<font color="#ff502c">调用 Hook</font>， 确保总是在你的 <font color="#ff502c">React 函数的最顶层调用</font>他们。</p>
<h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p><font color="#ff502c">不要</font>在<font color="#ff502c">普通的 JavaScript 函数中</font>调用 Hook。只能在<font color="#ff502c"> React 的函数组件中调用 Hook</font>。不要在其他 JavaScript 函数中调用。<br><strong>Hook的提出主要就是为了解决class组件的一系列问题，所以我们能在class组件中使用它</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://react.docschina.org/docs/hooks-overview.html" target="_blank" rel="noopener">Hook 概览</a><br><a href="https://react.docschina.org/docs/hooks-reference.html" target="_blank" rel="noopener">Hook API 索引</a><br><a href="https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-40" target="_blank" rel="noopener">从Mixin到HOC再到Hook</a><br><a href="https://mp.weixin.qq.com/s/PmACWd4XvwXZXuTXggdhsw" target="_blank" rel="noopener">React 新特性 Hooks 讲解及实例(三)</a><br><a href="https://mp.weixin.qq.com/s/Tm7_JvMxSOvzsIXgx0rmYQ" target="_blank" rel="noopener">React 新特性 Hooks 讲解及实例(四)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的hash、chunkhash、contenthash分别是什么</title>
    <url>/blog/webpack/webpack-chunkhas-hash-contenthash.html</url>
    <content><![CDATA[<p><strong><em>知人者智，自知者明，胜人者有力，自胜者强。——老子</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<code>webpack</code>中有三种<code>hash</code>可以配置，分别是<code>hash</code>、<code>chunkhash</code>、<code>contenthash</code>他们是不对的可以针对不同的配置，首相要搞清楚这三种的<code>hash</code>的区别，什么场景下，适合用哪种。</p>
<p><strong>hash</strong><br>所有文件哈希值相同，只要改变内容跟之前的不一致，所有哈希值都改变，没有做到缓存意义</p>
<p><strong>chunkhash</strong><br>当有多个<code>chunk</code>，形成多个<code>bundle</code>时，如果只有一个<code>chunk</code>和一个<code>bundle</code>内容变了，其他的<code>bundle</code>的<code>hash</code>都会发生变化，因为大家都是公用的一个<code>hash</code>，这个时候<code>chunkhash</code>的作用就出来了。它根据不同的入口文件<code>(Entry)</code>进行依赖文件解析、构建对应的 <code>chunk</code>，生成对应的<strong>哈希值</strong>。</p>
<p><strong>contenthash</strong><br>在打包的时候我们会在<code>js</code>中导入<code>css</code>文件，因为他们是同一个入口文件，如果我只改了<code>js</code>得代码，但是他的<code>css</code>抽取生成<code>css</code>文件时候<code>hash</code>也会跟着变换。这个时候<code>contenthash</code>的作用就出来了。</p>
<p>下面直接用代码验证上面的猜想。</p>
<h2 id="一个简单的webpack配置"><a href="#一个简单的webpack配置" class="headerlink" title="一个简单的webpack配置"></a>一个简单的webpack配置</h2><p>我们现在就只创建一个能编译<code>js</code>的<code>webpack</code>配置，步骤如下：</p>
<ol>
<li>创建一个空文件加，并且在当文件夹中打开 <code>bash or cmd</code>。</li>
<li><code>npm init -y</code> 生成<code>package.json</code>。</li>
<li>如果你安装了<code>cnpm or yarn</code> 就执行 <code>cnpm i webpack webpack-cli -D</code>, 安装<code>webpack</code>的包。</li>
<li>创建<code>src</code>，在<code>src</code>内部创建<code>chunk0.js</code>、<code>chunk1.js</code>、<code>common.js</code>、<code>index.js</code>、<code>style.css</code>，并且编写内部代码</li>
<li>在项目根目录创建 <code>webpack.config.js</code></li>
<li>直接在<code>cmd</code>中运行 <code>webpack</code></li>
</ol>
<p>文件目录如下：<br><img src="../../images/webpack/webpack-1-3.png" alt="webpack contenthash hash chunkhash"></p>
<p>下面是代码<br><strong>chunk0.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>chunk1.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">flow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'flow'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>common.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">commonJs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'commonJs'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">'./chunk0.js'</span>;</span><br><span class="line"><span class="keyword">import</span> commonJs <span class="keyword">from</span> <span class="string">'./common'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(commonJs());</span><br></pre></td></tr></table></figure>
<p><strong>style.css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>, <span class="comment">// 如果不添加就会警告</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index.js"</span>, <span class="comment">// 一个入口文件</span></span><br><span class="line">    chunk1: <span class="string">"./src/chunk1.js"</span> <span class="comment">// 两一个入口文件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].[hash].js"</span> <span class="comment">// 出口文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>我们直接运行<code>webpack</code>，运行结果如下图所示：</p>
<p>只有一个hash，所有文件的hash都是相同：</p>
<p><img src="../../images/webpack/webpack-1-4.png" alt="webpack contenthash hash chunkhash"><br>如果我们改变修改<strong>chunk1.js</strong>中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">flow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'flow1'</span>; <span class="comment">// flow =&gt; folw1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再运行webpack发现所有的hash都<font color="#ff502c">变化</font>了，如下图所示：</p>
<p><img src="../../images/webpack/webpack-1-4.png" alt="webpack contenthash hash chunkhash"><br><img src="../../images/webpack/webpack-1-5.png" alt="webpack contenthash hash chunkhash"></p>
<p>对比发现他们的hash并不相同了，这个时候如果想修改了<strong>chunk1.js</strong>,index.js不产生变化，就要用到chunkhash。</p>
<h2 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h2><ul>
<li>第一步 我们先把<strong>webpack.config.js</strong>做一下修改</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    chunk1: <span class="string">"./src/chunk1.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].[chunkhash].js"</span> <span class="comment">// hash =&gt; chunkhash</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步 我们运行<code>webpack</code></li>
</ul>
<p><img src="../../images/webpack/webpack-1-6.png" alt="webpack contenthash hash chunkhash"><br>根据上面图片发下，两个<code>chunk</code>的<code>hash</code>并不相同了。</p>
<ul>
<li>第三部 我们修改 <code>chunk1.js</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">flow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'flow11111'</span>; <span class="comment">// flow1 =&gt; flow11111</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>再运行<code>webpack</code></li>
</ul>
<p><img src="../../images/webpack/webpack-1-6.png" alt="webpack contenthash hash chunkhash"><br><img src="../../images/webpack/webpack-1-7.png" alt="webpack contenthash hash chunkhash"></p>
<p>根据图片我们看到了<code>chunk1.js</code>的<code>hash</code>变化，而<code>index.js</code>的<code>hash</code>并没有变化，达到了我们预期的效果，对我们线上的缓存也是比较好的。</p>
<h2 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h2><p>但是当我们一个<code>js</code>文件里面引用了一个<code>css</code>文件，如果我么修改了<code>css</code>文件内的内容，我们<code>css</code>中的内容，会发发现这整个<code>bundle</code>的<code>hash</code>也会发生更新。<br>我们要引入<code>css</code>，并且要把<code>css</code>提出、压缩生成一个<code>css</code>文件，就要借助一个<code>webpack</code>的插件，叫做<code>MiniCssExtractPlugin</code>,他可以帮我提取css到css文件，并且压缩css。</p>
<ul>
<li>第一步先安装<code>css-loader</code>、<code>mini-css-extract-plugin</code>包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步修改<code>webpack.config.js</code> 如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>); <span class="comment">// 新增</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    chunk1: <span class="string">"./src/chunk1.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].[chunkhash].js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123; <span class="comment">// 新增</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, </span><br><span class="line">          <span class="string">"css-loader"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ <span class="comment">// 新增</span></span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">"[name].[chunkhash].css"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步运行webpack</li>
</ul>
<p><img src="../../images/webpack/webpack-1-8.png" alt="webpack contenthash hash chunkhash"></p>
<p>看代码可以看到<code>index.css</code>和<code>index.js</code>的<code>hash</code>是一样的。</p>
<ul>
<li>第四步修改style.css</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  font-size: <span class="number">13</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第五步运行webpack</li>
</ul>
<p><img src="../../images/webpack/webpack-1-8.png" alt="webpack contenthash hash chunkhash"><br><img src="../../images/webpack/webpack-1-9.png" alt="webpack contenthash hash chunkhash"></p>
<p>对比两次构建的<code>hash</code>，发现只修改了<code>style.css</code>的文件，引入他的<code>index.js</code>确也更新了<code>hash</code>，这个时候就需要<code>contenthash</code>来发挥作用了。</p>
<ul>
<li>第六步修改<code>webpack.config.js</code> 并且运行 webpack</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>); <span class="comment">// 新增</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    chunk1: <span class="string">"./src/chunk1.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].[chunkhash].js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123; <span class="comment">// 新增</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, </span><br><span class="line">          <span class="string">"css-loader"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ <span class="comment">// 新增</span></span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">"[name].[contenthash].css"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/webpack/webpack-1-10.png" alt="webpack contenthash hash chunkhash"></p>
<p>看到他们直接hash就是不同的。</p>
<ul>
<li>修改<code>common.js</code>，直接运行webpack</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">commonJs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'commonJs1'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/webpack/webpack-1-10.png" alt="webpack contenthash hash chunkhash"><br><img src="../../images/webpack/webpack-1-11.png" alt="webpack contenthash hash chunkhash"></p>
<p>看到修改js时我们的css文件的hash并没有变更。</p>
<blockquote>
<p>注意，当使用<code>contenthash</code>时，如果修改js文件，css文件的hash不会变化，但是修改js的文件，css文件的hash也会变化。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>hash 所有文件哈希值相同；</strong><br><strong>chunkhash 根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值；</strong><br><strong>contenthash 计算与文件内容本身相关，主要用在css抽取css文件时。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/post/5cede821f265da1bbd4b5630" target="_blank" rel="noopener">面试必备！webpack 中那些最易混淆的 5 个知识点</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的bundle、module、chunk分别是什么</title>
    <url>/blog/webpack/webpack-bundle-module-chunk.html</url>
    <content><![CDATA[<p><strong><em>祸兮福之所倚，福兮祸之所伏。——老子</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><code>bundle</code>、<code>module</code>、<code>chunk</code> 都是 webpack 中的术语，下面就一个一个介绍他们的定义是什么，怎么产生的。</p>
<h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p><strong>Bundle</strong>是由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。<br><strong>Bundle 分离（Bundle Splitting）:</strong>这个流程提供了一个优化 build 的方法，允许 webpack 为应用程序生成多个 bundle。最终效果是，当其他某些 bundle 的改动时，彼此独立的另一些 bundle 都可以不受到影响，减少需要重新发布的代码量，因此由客户端重新下载并利用浏览器缓存。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p><strong>模块（Module）</strong>提供比较完整程序接触面（surface area）更小的离散功能块。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。<br><strong>模块解析（Module Resolution）</strong>一个模块可以作为另一个模块的依赖模块，resolver 是一个库（libary）用于帮助找不到模块的绝对路径，模块将在<strong>resolve.modules</strong>中指定的所有目录内搜索。</p>
<h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p><strong>Chunk</strong>这是 webpack 特定的术语被用在内部来管理 building 过程。bundle 是由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk)和子 chunk(child chunk)）。通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系。<br><strong>代码分离（Code Splitting）</strong>指将代码分离到每个 bundles/chunks 里面，你可以按需加载，而不是加载一个包含全部的 bundle。<br><strong>配置（Configuration）</strong>webpack 的配置文件是一个普通的 JavaScript 文件，它导出为一个对象。然后由 webpack 根据这个对象定义的属性进行处理。</p>
<h2 id="Bundle-VS-Chunk-VS-Module"><a href="#Bundle-VS-Chunk-VS-Module" class="headerlink" title="Bundle VS Chunk VS Module"></a>Bundle VS Chunk VS Module</h2><p>我们从定义和时期来说：</p>
<ul>
<li>“模块”<code>(module)</code>的概念大家都比较熟悉，如 <code>CommonJS 模块</code>、<code>AMD</code>、<code>ES6 Modules</code> 模块</li>
<li><code>chunk</code> 表示打包的时候产生得模块，由他来组成 <code>bundle</code></li>
<li>打包完成的源代码</li>
</ul>
<p>我们现在就只创建一个能编译<code>js</code>的<code>webpack</code>配置，步骤如下：</p>
<ol>
<li>创建一个空文件加，并且在当文件夹中打开 <code>bash or cmd</code>。</li>
<li><code>npm init -y</code> 生成<code>package.json</code>。</li>
<li>如果你安装了<code>cnpm or yarn</code> 就执行 <code>cnpm i webpack webpack-cli -D</code>, 安装<code>webpack</code>的包。</li>
<li>创建<code>src</code>，在<code>src</code>内部创建<code>chunk0.js</code>、<code>chunk1.js</code>、<code>common.js</code>、<code>index.js</code>、<code>style.css</code>，并且编写内部代码</li>
<li>在项目根目录创建 <code>webpack.config.js</code></li>
<li>直接在<code>cmd</code>中运行 <code>webpack</code></li>
</ol>
<p>下面是代码<br><strong>chunk0.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>chunk1.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">flow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"flow"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>common.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">commonJs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"commonJs"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">"./chunk0.js"</span>;</span><br><span class="line"><span class="keyword">import</span> commonJs <span class="keyword">from</span> <span class="string">"./common"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(commonJs());</span><br></pre></td></tr></table></figure>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>, <span class="comment">// 如果不添加就会警告</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index.js"</span>, <span class="comment">// 一个入口文件</span></span><br><span class="line">    chunk1: <span class="string">"./src/chunk1.js"</span> <span class="comment">// 两一个入口文件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].bundle.js"</span> <span class="comment">// 出口文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行的效果如下<br><img src="../../images/webpack/webpack1-1.png" alt="webpack bundle module chunk"></p>
<p>通过上面的代码知道，<code>module</code> 就是没有被编译之前的代码，通过 <code>webpack</code> 的根据文件引用关系生成 <code>chunk</code> 文件，webpack 处理好 <code>chunk</code> 文件后，生成运行在浏览器中的代码 <code>bundle</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/post/5cede821f265da1bbd4b5630" target="_blank" rel="noopener">面试必备！webpack 中那些最易混淆的 5 个知识点</a><br><a href="http://qingbob.com/webpack-chunks-split-01/" target="_blank" rel="noopener">深入理解 Webpack 打包分块（上）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript实现flatten多种方法</title>
    <url>/blog/algorithm/algorithm-awaly-flatten.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>我们在网上看到很多的关于数组的面试题，比如说给如下一个数组，把它<strong>拍平、去重、升序</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>其实这个题有很多种解法，比如用 <code>Array.prototype.flat</code>,或者自己实现一个 <code>flatten</code> 函数，我们这里主要关注的时 <code>flat</code> 方法的实现。</p>
<h2 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h2><p>用最新的语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<p>1、就是先拍平一个多维数组 <code>arr.flat</code>(ES6 语法)<br>2、再通过 <code>Set</code> 集合做去重<br>3、再通过 <code>Array.from</code> 把 <code>Set</code> 集合转为数组<br>4、再通过 <code>sort</code> 排序</p>
<p>如果不了解 <code>flat</code> 的函数的话，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">mdn Array.prototype.flat()</a>，或者看<a href="http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-flat%EF%BC%8CflatMap" target="_blank" rel="noopener">阮一峰老师的 <code>flat</code> 介绍</a>。<br>Set 集合的讲解可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">mdn Set</a>，或者看<a href="http://es6.ruanyifeng.com/?search=Set&amp;x=0&amp;y=0#docs/set-map" target="_blank" rel="noopener">阮一峰老师的 Set 介绍</a>。<br>我们这里主要讨论 flat 的实现。</p>
<h2 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.toString().split(<span class="string">","</span>)))</span><br><span class="line">  .map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<p>1、我们调用 <code>Array</code> 上的 <code>toString</code> 方法把他转换为一个字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.toString();</span><br><span class="line"><span class="comment">// "8,5,9,4,1,3,7,5,10,3,4,6,2,4,3,2,4"</span></span><br></pre></td></tr></table></figure>
<p>这列我们就不讨论为什么返回的结果里面不包含<font color="#ff502c">‘[]’</font>这两个字符串，后面我在写一篇博客来说数组，的 <code>valueOf、toString</code> 方法。<br>2、再把字符串通过 <code>Array.prototype.split</code> 方法转换为数组<br>3、再通过 <code>Set</code> 集合做去重<br>4、再通过 <code>Array.from</code> 把 <code>Set</code> 集合转为数组<br>5、再通过 <code>sort</code> 排序</p>
<h2 id="第三种解法"><a href="#第三种解法" class="headerlink" title="第三种解法"></a>第三种解法</h2><p>自己通过封装一个 <code>flatten</code>，在不基于 <code>Array.prototype.flat</code> 方法上实现一个拍平函数</p>
<h3 id="ES6-实现"><a href="#ES6-实现" class="headerlink" title="ES6 实现"></a>ES6 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">arr</span> =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.isArray(arr) ? arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> [...a, ...flatten(b)], []) : [arr];</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(flatten(arr))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(arr)</span><br><span class="line">    ? arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, current</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [...prev, ...flatten(current)];</span><br><span class="line">      &#125;, [])</span><br><span class="line">    : [arr];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(flatten(arr))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>1、检测是否为数组<br>2、如果是数组，调用 <code>reduce</code> 函数实现合并函数<br>3、如果有嵌套数组，就递归调用该方法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现拍平数组大致有三种方法</p>
<ol>
<li><code>Array.prototype.flat</code> 方法</li>
<li><code>Array.prototype.toString</code> 方法转为字符串，再 <code>split</code></li>
<li>自己实现一个 <code>flatten</code> 函数</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理 （三）repaint(重绘)和reflow(回流)详解</title>
    <url>/blog/html/html-reload-reflow.html</url>
    <content><![CDATA[<p><strong><em>知足则不辱，知止则不殆。——老子</em></strong></p>
<blockquote>
<p><a href="/blog/html/html-browser-render.html">浏览器渲染原理 （一）在网址中输入一个网站后面都做了什么</a><br><a href="/blog/html/html-style-javascript.html">浏览器渲染原理 （二）css、javascript、dom 阻塞关系</a><br><a href="/blog/html/html-reload-reflow.html">浏览器渲染原理 （三） repaint(重绘)和 reflow(回流)详解</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>大多数设备的刷新频率是<strong>60Hz</strong>，也就说是浏览器对每一帧画面的渲染工作要在 <strong>16ms</strong> 内完成,超出这个时间，页面的渲染就会出现<strong>卡顿</strong>现象，影响用户体验。<br><strong>repaint(重绘)</strong>和 <strong>reflow(回流)</strong>发生在什么渲染的那个阶段，我们要了解什么叫做 <strong>repaint(重绘)</strong>和 <strong>reflow(回流)</strong>.</p>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="(重绘)"></a>(重绘)</h3><p>repaint 就是在<font color="#ff502c">不影响排版的情况下</font>对这个元素重新绘制的过程。例如改变一个元素的背景颜色、字体颜色等。</p>
<h3 id="reflow-回流、重排"><a href="#reflow-回流、重排" class="headerlink" title="reflow(回流、重排)"></a>reflow(回流、重排)</h3><p><font color="#ff502c">当 render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建</font>。这就称为回流（其实我觉得叫重新布局更简单明了些）。每个页面至少需要一次回流，就是在页面第一次加载的时候。<br><strong>回流必将引起重绘，而重绘不一定会引起回流</strong></p>
<h3 id="三种常见的渲染流程"><a href="#三种常见的渲染流程" class="headerlink" title="三种常见的渲染流程"></a>三种常见的渲染流程</h3><p><strong>1. JS/CSS&gt;计算样式&gt;布局&gt;绘制&gt;渲染层合并</strong><br><img src="../../images/html/images/reflow-repaint-1-1.png" alt="reflow"><br>这张图上渲染流程对应的是<strong>reflow</strong>渲染的过程，它会经过布局再绘制。<br><strong>2. JS/CSS&gt;计算样式&gt;绘制&gt;渲染层合并</strong><br><img src="../../images/html/images/reflow-repaint-1-2.png" alt="repaint"><br>这张图上渲染流程对应的是<strong>repaint</strong>渲染的过程，它不需要经过布局，只需要绘制当前的元素，不需要重新计算它的父元素。<br><strong>3. JS/CSS&gt;计算样式&gt;渲染层合并</strong><br><img src="../../images/html/images/reflow-repaint-1-3.png" alt="compositor"><br>这张图上渲染流程比较特殊，它不选经过布局、绘制，它只需要在<strong>合成层</strong>上修改。</p>
<!-- ### repaint、reflow和eventLoop关系 -->
<h2 id="repaint-重绘-和-reflow-回流"><a href="#repaint-重绘-和-reflow-回流" class="headerlink" title="repaint(重绘)和 reflow(回流)"></a>repaint(重绘)和 reflow(回流)</h2><hr>
<p>上面大致已经记录了 repaint、reflow 的流程和为什么要关注它，下面记录一下它们的触发条件、和 eventLoop 的关系。</p>
<h3 id="触发-repaint、reflow"><a href="#触发-repaint、reflow" class="headerlink" title="触发 repaint、reflow"></a>触发 repaint、reflow</h3><ol>
<li><strong>添加、删除元素</strong>（回流+重绘）</li>
<li>隐藏元素，<strong>display:none</strong>(回流+重绘)，<strong>visibility:hidden</strong>(只重绘，不回流)</li>
<li><strong>移动元素</strong>，比如改变 top、left（jquery 的 animate 方法就是改变 top、left 不一定会影响回流），或者移动元素到另外 1 个父元素中。(重绘+回流)</li>
<li>对 style 的操作（对不同的属性操作，影响不一样）（color、background-color）=&gt;(重绘) (padding、margin)=&gt;(回流)</li>
<li>浏览器大小改变<strong>resize</strong>、<strong>font-size</strong>（重绘+回流）</li>
<li><strong>transform/opacity</strong> （不会触发生重绘、回流）</li>
<li>最复杂的一种：<strong>获取某些属性</strong>，引发回流 很多浏览器会对回流做优化，他会等到足够数量的变化发生，在做一次批处理回流。 但是除了 render 树的直接变化。 当获取一些属性时，浏览器为了获得正确的值也会触发回流。<ol>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop/Left/Width/Height</li>
<li>clientTop/Left/Width/Height</li>
<li>width,height</li>
<li>调用了 getComputedStyle(), 或者 IE 的 currentStyle</li>
</ol>
</li>
</ol>
<p>上面大致就是触发<strong>repaint、reflow</strong>的操作，还有更多的后面还会补全。</p>
<h3 id="repaint、reflow-和-eventLoop-关系"><a href="#repaint、reflow-和-eventLoop-关系" class="headerlink" title="repaint、reflow 和 eventLoop 关系"></a>repaint、reflow 和 eventLoop 关系</h3><ol>
<li>当 <strong>Event loop</strong> 执行完 <strong>Microtasks</strong> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <strong>60Hz</strong> 的刷新率，每 <strong>16ms</strong> 才会更新一次。</li>
<li>然后判断是否有 <code>resize</code>或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <strong>16ms</strong> 才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了 <code>media query</code></li>
<li><strong>更新动画并且发送事件</strong></li>
<li><strong>判断是否有全屏操作事件</strong></li>
<li><strong>执行 requestAnimationFrame 回调</strong></li>
<li><strong>执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</strong></li>
<li><strong>更新界面</strong></li>
</ol>
<p>在这个里面记录了触发 <strong>repaing、reflow</strong>，还有和 <strong>eventloop</strong> 的关系，但是 <strong>eventloop</strong> 和 <strong>ui 渲染</strong>流程关系有点太复杂，所以大致记录了一下。</p>
<h2 id="优化渲染性能"><a href="#优化渲染性能" class="headerlink" title="优化渲染性能"></a>优化渲染性能</h2><hr>
<ul>
<li><strong><em>减少重绘和回流</em></strong></li>
<li><strong><em>优化 JavaScript 的执行效率</em></strong></li>
<li><strong><em>对用户输入事件的处理函数去抖动</em></strong></li>
<li><strong><em>优先使用渲染层合并属性、控制层数量</em></strong></li>
<li><strong><em>结合 chrome 工具分析性能</em></strong></li>
</ul>
<h3 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h3><ul>
<li><strong><em>避免逐项更改样式</em></strong>。最好一次性更改 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。</li>
<li><strong><em>避免循环操作 DOM</em></strong>。创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到 window.document。</li>
<li><strong><em>避免多次读取 offsetLeft 等属性</em></strong>。无法避免则将它们缓存到变量。</li>
<li><strong><em>将复杂的元素绝对定位或固定定位，使它脱离文档流</em></strong>。否则回流代价十分高</li>
<li><strong><em>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</em></strong></li>
<li><strong><em>动画实现的速度的选择</em></strong>，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li>
<li><strong><em>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</em></strong></li>
<li><strong><em>使用 visibility 替换 display: none</em></strong> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li><strong><em>使用 translate 替代 top</em></strong></li>
<li><strong><em>把 DOM 离线后修改</em></strong>，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li>
<li><strong><em>使用 flexbox 替代老的布局模型</em></strong><br>还有很多在这里就不一一列举了，主要思想就是减少 reflow、repaint 的次数。</li>
</ul>
<h3 id="优化-JavaScript-的执行效率"><a href="#优化-JavaScript-的执行效率" class="headerlink" title="优化 JavaScript 的执行效率"></a>优化 JavaScript 的执行效率</h3><p><strong>动画实现，避免使用 setTimeout 或 setInterval，尽量使用 requestAnimationFrame</strong><br><strong>把耗时长的 JavaScript 代码放到 Web Workers 中去做</strong></p>
<h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h4><p><strong>动画实现，避免使用 setTimeout 或 setInterval，尽量使用 requestAnimationFrame</strong><br>setTimeout(callback)和 setInterval(callback)无法保证 callback 函数的执行时机，很可能在帧结束的时候执行，从而导致丢帧，如下图：<br><img src="../../images/html/images/reflow-repaint-1-4.png" alt="setTimeout、和setInterval"><br>requestAnimationFrame(callback)可以保证 callback 函数在每帧动画开始的时候执行。</p>
<blockquote>
<p>注意：jQuery 的 animate 函数就是用 setTimeout 来实现动画，可以通过 jquery-requestAnimationFrame 这个补丁来用 requestAnimationFrame 替代 setTimeout</p>
</blockquote>
<h4 id="把耗时长的-JavaScript-代码放到-Web-Workers-中去做"><a href="#把耗时长的-JavaScript-代码放到-Web-Workers-中去做" class="headerlink" title="把耗时长的 JavaScript 代码放到 Web Workers 中去做"></a>把耗时长的 JavaScript 代码放到 Web Workers 中去做</h4><p>把耗时长的 <strong>JavaScript 代码放到 Web Workers</strong> 中去做 JavaScript 代码运行在浏览器的<strong>主线程</strong>上，与此同时，浏览器的主线程还负责<strong>样式计算、布局、绘制</strong>的工作，如果 JavaScript 代码运行时间过长，就会<strong>阻塞</strong>其他渲染工作，很可能会导致丢帧。<br>前面提到每帧的渲染应该在 16ms 内完成，但在动画过程中，由于已经被占用了不少时间，所以 JavaScript 代码运行耗时应该控制在<strong>3-4 毫秒</strong>。</p>
<h3 id="对用户输入事件的处理函数去抖动"><a href="#对用户输入事件的处理函数去抖动" class="headerlink" title="对用户输入事件的处理函数去抖动"></a>对用户输入事件的处理函数去抖动</h3><p>用户输入事件处理函数会在运行时<strong>阻塞帧的渲染</strong>，并且会导致<strong>额外的布局</strong>发生。<br>理想情况下，当用户和页面交互，页面的<strong>渲染层合并线程</strong>将接收到这个事件并移动元素。这个响应过程是不需要主线程参与，不会导致 <strong>JavaScript、布局和绘制</strong>过程发生。</p>
<p><img src="../../images/html/images/reflow-repaint-1-5.png" alt="去抖"></p>
<p>但是如果被触摸的元素绑定了输入事件处理函数，比如 <code>touchstart/touchmove/touchend</code>，那么渲染层合并线程必须等待这些被绑定的处理<strong>函数执行完毕</strong>才能执行，也就是用户的滚动页面操作<strong>被阻塞</strong>了，表现出的行为就是滚动出现<strong>延迟或者卡顿</strong>。<br>简而言之就是你必须确保用户输入事件绑定的任何处理函数都能够<strong>快速的执行完毕</strong>，以便腾出时间来让<strong>渲染层合并线程</strong>完成他的工作。</p>
<p><img src="../../images/html/images/reflow-repaint-1-6.png" alt="去抖"></p>
<h4 id="避免使用运行时间过长的输入事件处理函数"><a href="#避免使用运行时间过长的输入事件处理函数" class="headerlink" title="避免使用运行时间过长的输入事件处理函数"></a>避免使用运行时间过长的输入事件处理函数</h4><p>输入事件处理函数，比如 <code>scroll/touch 事件</code>的处理，都会在 <code>requestAnimationFrame</code> 之前被调用执行。<br>因此，如果你在上述输入事件的处理函数中做了<strong>修改样式属性</strong>的操作，那么这些操作就会被浏览器<strong>暂存</strong>起来，然后在调用 <code>requestAnimationFrame</code> 的时候，如果你在一开始就做了<strong>读取样式属性</strong>的操作，那么将会触发浏览器的强制同步布局操作。</p>
<p><img src="../../images/html/images/reflow-repaint-1-7.png" alt="去抖"></p>
<h4 id="对滚动事件处理函数去抖动"><a href="#对滚动事件处理函数去抖动" class="headerlink" title="对滚动事件处理函数去抖动"></a>对滚动事件处理函数去抖动</h4><p>通过 requestAnimationFrame 可以对样式修改操作去抖动，同时也可以使你的事件处理函数变得更轻</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Store the scroll value for laterz.</span></span><br><span class="line">  lastScrollY = <span class="built_in">window</span>.scrollY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent multiple rAF callbacks.</span></span><br><span class="line">  <span class="keyword">if</span> (scheduledAnimationFrame) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduledAnimationFrame = <span class="literal">true</span>;</span><br><span class="line">  requestAnimationFrame(readAndUpdatePage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, onScroll);</span><br></pre></td></tr></table></figure>
<h3 id="chrome-分析结合"><a href="#chrome-分析结合" class="headerlink" title="chrome 分析结合"></a>chrome 分析结合</h3><p>使用 Chrome DevTools 来了解页面的渲染层情况</p>
<h4 id="Chrome-DevTools-gt-Preformance"><a href="#Chrome-DevTools-gt-Preformance" class="headerlink" title="Chrome DevTools &gt; Preformance"></a>Chrome DevTools &gt; Preformance</h4><p>通过 Chrome DevTools 的 Preformance 来录制一段操作，并且开启 More tools 的 Layers、Rendering 功能，如果下图所示:<br><img src="../../images/html/images/reflow-repaint-1-8.png" alt="Chrome DevTools"><br><img src="../../images/html/images/reflow-repaint-1-9.png" alt="Chrome DevTools"></p>
<h4 id="借助-Chrome-暴露在-window-上的-preformance-对象"><a href="#借助-Chrome-暴露在-window-上的-preformance-对象" class="headerlink" title="借助 Chrome 暴露在 window 上的 preformance 对象"></a>借助 Chrome 暴露在 window 上的 preformance 对象</h4><p>可以用 preformance 对象来做一些前端的性能分析和统计，如下图所示：<br><img src="../../images/html/images/reflow-repaint-1-10.png" alt="Chrome DevTools"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个上面了解了 reflow、repaint 的流程和他的触发条件，再后面也有一部分怎么优化性能，结合前面的渲染流程大致知道优化的是那部分的流程。当然在优化性能的时候，一定要结合 chrome 的性能分析功能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.jianshu.com/p/a32b890c29b1" target="_blank" rel="noopener">深度剖析浏览器渲染性能原理，你到底知道多少？</a><br><a href="https://www.cnblogs.com/dll-ft/p/5810639.html" target="_blank" rel="noopener">回流(reflow)与重绘(repaint)</a><br><a href="https://www.cnblogs.com/goloving/p/7545954.html" target="_blank" rel="noopener">高性能 WEB 开发：深入理解页面呈现、重绘、回流</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理 （一）在网址中输入一个网站后面都做了什么</title>
    <url>/blog/html/html-browser-render.html</url>
    <content><![CDATA[<p><strong><em>人法地，地法天，天法道，道法自然。</em></strong></p>
<blockquote>
<p><a href="/blog/html/html-browser-render.html">浏览器渲染原理 （一）在网址中输入一个网站后面都做了什么</a><br><a href="/blog/html/html-style-javascript.html">浏览器渲染原理 （二）css、javascript、dom 阻塞关系</a><br><a href="/blog/html/html-reload-reflow.html">浏览器渲染原理 （三） repaint(重绘)和 reflow(回流)详解</a></p>
</blockquote>
<p>如果想看更深入的原理，可以看：</p>
<blockquote>
<p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Layout" target="_blank" rel="noopener">别人翻译的外国友人的渲染原理</a></p>
</blockquote>
<h2 id="浏览器是怎么渲染-html-的"><a href="#浏览器是怎么渲染-html-的" class="headerlink" title="浏览器是怎么渲染 html 的"></a>浏览器是怎么渲染 html 的</h2><hr>
<p><code>关键渲染路径（Critical Rendering Path）</code>是指与当前用户操作有关的内容。例如用户刚刚打开一个页面，首屏的显示就是当前用户操作相关的内容，具体就是浏览器收到<code>HTML、CSS 和 JavaScript</code> 等资源并对其进行处理从而渲染出 <code>Web</code> 页面。<br>如下图所示渲染流程：<br><img src="../../images/html/images/bowser-render.png" alt="bowser-render"><br>当我们在浏览器中输入一个网址的时候，他是怎么请求资源，并且把我们的页面绘制出来的，大概可以分为六步，其中又可以细分，下面我大概说一个 6 大步骤：</p>
<blockquote>
<ol>
<li>浏览器首先通过 <code>HTTP</code> 协议或者 <code>HTTPS</code> 协议，向服务器请求页面，当然这个其中也可能有缓存什么的；</li>
<li>把请求回来的<code>HTML</code> 代码经过解析，构建成 <code>DOM</code> 树；</li>
<li>计算 <code>DOM 树</code>上的 <code>CSS</code> 属性，生成 <code>CSSOM 树(CSS Object Model)</code>；</li>
<li>将 <code>DOM 树</code>和 <code>CSSOM 树</code>合并成一个<code>渲染树(rendering tree)</code>；</li>
<li>渲染树的每个元素包含的内容都是<code>计算</code>过的，它被称之为<code>布局 layout</code>。浏览器使用一种流式处理的方法，只需要一次 <code>pass 绘制</code>操作就可以布局所有的元素；</li>
<li>将渲染树的各个节点绘制到屏幕上，这一步被称为<code>绘制 painting</code>；</li>
<li>按照合理的顺序合并图层然后显示到屏幕上 <code>Composite（渲染层合并）</code></li>
</ol>
</blockquote>
<h3 id="第一步请求资源"><a href="#第一步请求资源" class="headerlink" title="第一步请求资源"></a>第一步请求资源</h3><p>在我们在浏览器中输入完网址的时候，浏览器其实会先做以下几小步：</p>
<blockquote>
<ol>
<li><code>DNS 查询</code>（就是把当前域名解析成为 ip 地址）</li>
<li><code>TCP 连接</code></li>
<li><code>HTTP 请求响应</code></li>
<li>服务器返回数据</li>
</ol>
</blockquote>
<h3 id="第二步构建-DOM-树"><a href="#第二步构建-DOM-树" class="headerlink" title="第二步构建 DOM 树"></a>第二步构建 DOM 树</h3><p>在构建 <code>DOM 树</code>的时候又可以分为几小步：</p>
<blockquote>
<ol>
<li>字符流通过状态机解析成为 <code>词 token</code></li>
<li>词 <code>token =&gt; prase =&gt; DOM 树</code></li>
</ol>
</blockquote>
<p>构建 <code>DOM</code> 的过程是：从父到子，从先到后，一个一个节点构造，<code>DOM 树</code>结构和 HTML 标签一一对应。</p>
<h3 id="第三步-CSSOM-模型构建"><a href="#第三步-CSSOM-模型构建" class="headerlink" title="第三步 CSSOM 模型构建"></a>第三步 CSSOM 模型构建</h3><p>在计算 <code>css 规则</code>的时候，我们会在已经构建好的元素上，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。并且 <code>CSSOM</code> 主要是<code>DOM 结构</code>上的盒的描述，他基本上是依附于 <code>DOM 树</code>的。<br><code>CSS 计算</code>是把 <code>CSS 规则</code>应用到 <code>DOM 树</code>上，为 <code>DOM 结构</code>添加显示相关属性过程。<br><code>CSSOM</code> 是有 <code>rule</code> 部分和 <code>view</code> 部分的，<code>rule 部分</code>是在 <code>dom</code> 开始之前就构件完成的，而 <code>view</code> 部分是跟着 <code>dom</code> 同步构建的。</p>
<h3 id="第四步构建渲染树（Rendr-tree-construction）"><a href="#第四步构建渲染树（Rendr-tree-construction）" class="headerlink" title="第四步构建渲染树（Rendr tree construction）"></a>第四步构建渲染树（Rendr tree construction）</h3><p>通过 <code>DOM 树</code>和 <code>CSS 规则树</code>，浏览器就可以通过它两构建<code>渲染树</code>了。<br><code>渲染树</code>和 <code>DOM 元素</code>相对应的，但并非一一对应。非可视化的 <code>DOM 元素</code>不会插入呈现树中，例如<code>“head”元素</code>。如果元素的 <code>display</code> 属性值为<code>“none”</code>，那么也不会显示在呈现树中（但是 <code>visibility</code> 属性值为<code>“hidden”</code>的元素仍会显示）。</p>
<h3 id="第五步渲染树布局-layout-of-the-render-tree"><a href="#第五步渲染树布局-layout-of-the-render-tree" class="headerlink" title="第五步渲染树布局(layout of the render tree)"></a>第五步渲染树布局(layout of the render tree)</h3><p><strong>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息</strong>。计算这些值的过程称为<code>布局</code>或<code>重排</code>。<br>布局阶段会从<code>渲染树</code>更新节点开始遍历，由于渲染树的每个节点都是一个 <code>Render Object</code> 对象，包含宽高，位置，背景色等样式信息。浏览器中渲染这个过程，就是把每一个元素对应的盒变成<code>位图</code>，再把位图合成一个大的<code>位图</code>。<br>布局又分为全局布局和增量布局，<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Layout" target="_blank" rel="noopener">详情请看</a></p>
<h3 id="第六步渲染树绘制（Painting-the-render-tree）"><a href="#第六步渲染树绘制（Painting-the-render-tree）" class="headerlink" title="第六步渲染树绘制（Painting the render tree）"></a>第六步渲染树绘制（Painting the render tree）</h3><p>在绘制阶段，系统会遍历<code>呈现树</code>，并调用呈现器的<code>“paint”方法</code>，将<code>呈现器</code>的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。<br>绘制又分为<code>全局绘制</code>和<code>增量绘制</code>，并且绘制的属性也会有前后之分，<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">详情请看</a></p>
<h3 id="compositor-layer-合成渲染层"><a href="#compositor-layer-合成渲染层" class="headerlink" title="compositor layer 合成渲染层"></a>compositor layer 合成渲染层</h3><p>渲染过程把<code>元素变成位图</code>，合成把一部分<code>位图变成合成层</code>，最终的绘制过程把<code>合成层</code>显示到屏幕上。<br>对于 <code>transform/opacity</code> 这两种变换，浏览器不会用 <code>repaint/reflow</code> 处理，而是在已经渲染的元素基础上进行附加工作。<br>他的渲染流程为下图所示：<br><img src="../../images/html/images/reflow-repaint-1-1.png" alt="只执行 compositor"><br>js 改变样式，样式只触发合成属性，不触发 repaint/reflow.附原文链接<br><a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count" target="_blank" rel="noopener">stick-to-compositor-only-properties-and-manage-layer-count</a></p>
<h2 id="阻塞渲染：CSS、JavaScript、DOM"><a href="#阻塞渲染：CSS、JavaScript、DOM" class="headerlink" title="阻塞渲染：CSS、JavaScript、DOM"></a>阻塞渲染：CSS、JavaScript、DOM</h2><p>谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 <code>HTML 解析器（HTML Parser）</code>被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。<br>同时，由于下面两点：</p>
<blockquote>
<ol>
<li>默认情况下，<code>CSS 被视为阻塞渲染的资源</code>，这意味着浏览器将不会渲染任何已处理的内容，直至<code>CSSOM 构建完毕</code>。</li>
<li><code>JavaScrip</code>t 不仅可以读取和<code>修改 DOM 属性</code>，还可以<code>读取和修改 CSSOM</code> 属性，因此 <code>CSS 解析</code>与 <code>script 的执行</code>互斥。</li>
<li>存在<code>阻塞的 CSS 资源</code>时，浏览器会<code>延迟 JavaScript 的执行和 DOM 构建</code>。</li>
</ol>
</blockquote>
<p>正是由于以上这些原因，<code>script 标签</code>的位置很重要我们在实际开发中应该尽量坚持以下两个原则：<br><strong><em>在引入顺序上，CSS 资源先于 JavaScript 资源。</em></strong><br><strong><em>JavaScript 应尽量少的去影响 DOM 的构建。</em></strong><br>想理清楚 <code>CSS、JavaScript、DOM</code> 之间的相互<a href="http://asyncnode/blog/html/html-browser-render.html" target="_blank" rel="noopener">阻塞关系</a></p>
<h2 id="改变阻塞模式"><a href="#改变阻塞模式" class="headerlink" title="改变阻塞模式"></a>改变阻塞模式</h2><p>我们熟知的<code>javascript</code>标签上<code>defer</code>和<code>async</code>属性，还有可能不太熟知的<code>link</code>标签上的<code>preload</code>属性。</p>
<p>在介绍 async 和 defer 之前我们要先看了解两个概念，<code>load</code>和<code>DOMContentLoaded</code>的执行时机</p>
<h3 id="load-和-DOMContentLoaded"><a href="#load-和-DOMContentLoaded" class="headerlink" title="load 和 DOMContentLoaded"></a>load 和 DOMContentLoaded</h3><p><strong>load</strong><br>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。<br><strong>DOMContentLoaded</strong><br>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</p>
<h3 id="首先是-async-和-defer"><a href="#首先是-async-和-defer" class="headerlink" title="首先是 async 和 defer"></a>首先是 async 和 defer</h3><p>async 和 defer 他们对于内联脚本无作用（即没有 src 属性的脚本）<br><strong>async</strong><br>该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。async 与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发<code>之前或之后</code>执行，但一定在 load 触发<code>之前</code>执行。并且多个 async-script 的执行顺序是<code>不确定</code>的。</p>
<p><strong>defer</strong><br>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并<code>未停止</code>解析，这两个过程是<code>并行</code>的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后<code>触发</code> DOMContentLoaded 事件。</p>
<p>defer 与相比普通 script，有两点区别：载入 JavaScript 文件时<code>不阻塞</code> HTML 的解析，执行阶段被放到 HTML 标签<code>解析完成</code>之后。</p>
<h3 id="preload-和-prerender"><a href="#preload-和-prerender" class="headerlink" title="preload 和 prerender"></a>preload 和 prerender</h3><p><strong>preload</strong></p>
<p><code>&lt;link&gt;</code> 元素的 <code>rel 属性</code>的属性<code>值preload</code>能够让你在你的<code>HTML页面</code>中 <code>&lt;head&gt;元素</code>内部书写一些声明式的资源获取请求，可以指明哪些资源是在<code>页面加载完成后即刻需要的</code>。对于这种即刻需要的资源，你可能希望在页面加载的生命周期的早期阶段就开始获取，在浏览器的主渲染机制介入前就<code>进行预加载</code>。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。<br>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好.</p>
<p><strong>prerender</strong><br>可以通过预渲染将下载的文件<code>预先在后台渲染</code>，可以使用以下代码<code>开启预渲染</code><br>预渲染虽然可以提高页面的<code>加载速度</code>，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个里面基本上了解了浏览器的渲染过程，但是有很多细节没有套路比如说我们都知道浏览器是单线程的，<code>ui 线程</code>和 <code>javascript 线程</code>是怎么协调的，还有一个比较重要的是<code>重绘和回流（重排）</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">浏览器的渲染：过程与原理</a><br><a href="https://www.imooc.com/article/40004" target="_blank" rel="noopener">浏览器渲染原理与过程</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener">HTML <script> 元素用于嵌入或引用可执行脚本。</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Layout">浏览器的工作原理：新式网络浏览器幕后揭秘</a><br><a href="https://zhuanlan.zhihu.com/p/23428399">重绘，回流和合成，了解基本浏览器绘制帮你优化页面性能</a></p>
</blockquote>
</script></a></p></blockquote>]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中实现一个自己的new</title>
    <url>/blog/javascript/javascript-extends.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><hr>
<p>传统的 javascript 中只有对象，没有类的概念。它是基于原型的面向对象语言。原型对象特点就是将自身的属性共享给新对象。<br>先看一下 new 关键字是他都做了什么，让我们通过 new 实现继承的。<br>下面请看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name, year, model</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.getV = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">"--"</span> + <span class="keyword">this</span>.year + <span class="string">"--"</span> + <span class="keyword">this</span>.model;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> carOne = <span class="keyword">new</span> Car(<span class="string">"jeep"</span>, <span class="string">"2018"</span>, <span class="string">"Wrangler"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(carOne.getV());</span><br><span class="line"><span class="built_in">console</span>.log(carOne);</span><br><span class="line">&lt;font color=<span class="string">"#ff502c"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>new 关键字进行如下的操作：</p>
<blockquote>
<ol>
<li>创建一个空的 JavaScript 对象；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象；</li>
<li>将步骤 1 新创建的对象作为 this 的上下文；</li>
<li>如果该函数没有返回对象，则返回 this。</li>
</ol>
</blockquote>
<p>同时，我们自己写的这个函数接收的<font color="#ff502c">第一个参数</font>就是我们要<font color="#ff502c">继承</font>的对象。<br>下面我们就一步一步实现一个自己的 new 关键字</p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>第一步比较简单我们要首先定义一个 create 方法在方法内创建一个<font color="#ff502c">空对象</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象会在后面用到，经过后面的处理，如果<font color="#ff502c">没有</font>返回值，就会<font color="#ff502c">返回</font>我们创建的这个<font color="#ff502c">空对象</font>。</p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>第二步比较关键，用到了我们基于 prototype 继承的知识。就是把我们新创建的这个<font color="#ff502c">空对象</font>的<font color="#ff502c"><strong>proto</strong></font>，指向我们要<font color="#ff502c">继承对象</font>的<font color="#ff502c">prototype</font>。<br>下面我们就在第一步代码的基础上实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shfit.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一步我们就是通过<font color="#ff502c"><strong>proto</strong></font>关联了我们创建的空对象的 prototype 到我们要继承的<font color="#ff502c">另一个</font>对象。</p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>第三步，将步骤 1 新创建的对象作为<font color="#ff502c">this 的上下文</font>，我们通过<font color="#ff502c">apply 执行构造函数</font>并且改变 this 指向。<br>下面我们在第二步的基础上实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shfit.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">  <span class="comment">// 绑定this指向，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Preson.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>判断是否有返回值，如果该函数没有返回对象，则<font color="#ff502c">返回 this</font>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shfit.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">  <span class="comment">// 绑定this指向，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Preson.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">"object"</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">  <span class="comment">// 绑定this指向，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Preson.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">"object"</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name, year, model</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> carOne = create(Car, <span class="string">"jeep"</span>, <span class="string">"2018"</span>, <span class="string">"Wrangler"</span>);</span><br><span class="line"><span class="keyword">var</span> carTwo = <span class="keyword">new</span> Car(<span class="string">"jeep"</span>, <span class="string">"2018"</span>, <span class="string">"Wrangler"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(carOne);</span><br><span class="line"><span class="built_in">console</span>.log(carTwo);</span><br><span class="line"><span class="built_in">console</span>.log(carOne.__proto__ === Car.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(carTwo.__proto__ === Car.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>一道面试题</strong><br>一道有关 new 的面试题，其实一部还是考察运算符优先级。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Foo.getName();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></table></figure>
<p>其实这个是考察运算优先级和 new 的面试题，通过 mdn 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算优先级</a><br>new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (Foo.getName())();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></table></figure>
<p>对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">mdn new 运算符</a> &gt; <a href="https://yuchengkai.cn/docs/frontend/#new" target="_blank" rel="noopener">大佬 new 的实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-router整体的流程和源码解析（一） (未完成)</title>
    <url>/blog/vue/vue-router-flow.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中有三种wathcer (未完成)</title>
    <url>/blog/vue/vue-three-wathcer.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 Vue中的派发更新</title>
    <url>/blog/vue/vue-notify.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/vue/vue-definedProperty.html">深入Vue系列 Vue中的响应式对象</a><br><a href="/blog/vue/vue-dep.html">深入Vue系列 Vue中的依赖收集</a><br><a href="/blog/vue/vue-notify.html">深入Vue系列 Vue中的派发更新</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过在<code>defineReactive</code>观测的<code>data</code>子项中的<code>getter</code>函数中完成<a href="/blog/vue/vue-dep.html">依赖收集</a>，在<code>defineReactive</code>观测的<code>data</code>子项中的<code>setter</code>函数中完成依赖派发。<br>首先看一下 defineReactive 中的 setter：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 子对象递归调用 observe</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123; ... &#125;, <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="comment">// 先getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="comment">// 如果跟原来值一样则不管</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有setter方法则执行</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">/*新的值需要重新进行observe，保证数据响应式*/</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">       <span class="comment">/*dep对象通知所有的订阅者*/</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做了两个步：</p>
<ul>
<li>一个是 <code>childOb = !shallow &amp;&amp; observe(newVal)</code>，如果 <code>shallow</code> 为 <code>false</code> 的情况，会对新设置的值变成一个响应式对象；</li>
<li><code>dep.notify()</code> <code>dep</code> 对象通知所有的订阅者</li>
</ul>
<h2 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h2><ul>
<li>执行 <code>dep.notify()</code></li>
<li>执行 <code>watcher.update()</code></li>
<li>执行 <code>queueWatcher(this)</code></li>
<li>执行 <code>nextTick(flushSchedulerQueue)</code></li>
<li>执行 <code>watcher.run()</code></li>
<li>执行 <code>watcher.get()</code></li>
</ul>
<h3 id="1-执行-dep-notify"><a href="#1-执行-dep-notify" class="headerlink" title="1. 执行 dep.notify()"></a>1. <strong>执行 dep.notify()</strong></h3><p>当我们对响应式数据做了修改，就会触发 <code>setter</code> 的逻辑，最后调用<code>dep.notify()</code>方法，它是<code>Dep</code>的一个实例方法。代码在<code>scr/core/observer.js</code>中:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 循环调用watcher.update()方法</span></span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做的事情是：</p>
<ul>
<li>遍历所有的 <code>subs</code>，也就是 <code>Watcher</code> 的实例数组，然后调用每一个 <code>watcher</code>的 <code>update</code> 方法。</li>
</ul>
<h3 id="2-执行-watcher-update"><a href="#2-执行-watcher-update" class="headerlink" title="2. 执行 watcher.update()"></a>2. <strong>执行 watcher.update()</strong></h3><p>watcher 类定义在<code>src/core/observer/watcher.js</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="comment">// 判断是否为computed watcher</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="comment">// A computed property watcher has two modes: lazy and activated.</span></span><br><span class="line">      <span class="comment">// It initializes as lazy by default, and only becomes activated when</span></span><br><span class="line">      <span class="comment">// it is depended on by at least one subscriber, which is typically</span></span><br><span class="line">      <span class="comment">// another computed property or a component's render function.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.dep.subs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// In lazy mode, we don't want to perform computations until necessary,</span></span><br><span class="line">        <span class="comment">// so we simply mark the watcher as dirty. The actual computation is</span></span><br><span class="line">        <span class="comment">// performed just-in-time in this.evaluate() when the computed property</span></span><br><span class="line">        <span class="comment">// is accessed.</span></span><br><span class="line">        <span class="keyword">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// In activated mode, we want to proactively perform the computation</span></span><br><span class="line">        <span class="comment">// but only notify our subscribers when the value has indeed changed.</span></span><br><span class="line">        <span class="keyword">this</span>.getAndInvoke(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.dep.notify();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否有sync 修饰符</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 执行queueWatcher</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的创建时渲染<code>watcher</code>所以会走 <code>queueWatcher(this)</code>的逻辑。这里主要做了：</p>
<ul>
<li>判断是否为<code>computed Watcher</code>、是否有<code>sync</code> 修饰符，如果都不满足执行<code>queueWatcher</code></li>
</ul>
<h3 id="3-执行-queueWatcher-this"><a href="#3-执行-queueWatcher-this" class="headerlink" title="3. 执行 queueWatcher(this)"></a>3. <strong>执行 queueWatcher(this)</strong></h3><p><code>queueWatcher</code> 的定义在 <code>src/core/observer/scheduler.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watcher队列</span></span><br><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = [];</span><br><span class="line"><span class="comment">// has 对象保证同一个 Watcher 只添加一次</span></span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id;</span><br><span class="line">  <span class="comment">// 保证watcher只添加一次</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//  保证对 nextTick(flushSchedulerQueue) 的调用逻辑只有一次</span></span><br><span class="line">      nextTick(flushSchedulerQueue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要做了如下：</p>
<ul>
<li>把<code>watcher</code>添加到一个队列里</li>
<li>在 <code>nextTick</code> 后执行 <code>flushSchedulerQueue</code></li>
</ul>
<blockquote>
<p>has 对象保证同一个 <code>Watcher</code> 只添加一次<br>判断是否为渲染<code>watcher</code><br>通过 <code>waiting</code> 保证对 <code>nextTick(flushSchedulerQueue)</code> 的调用逻辑只有一次</p>
</blockquote>
<h3 id="4-执行-nextTick-flushSchedulerQueue"><a href="#4-执行-nextTick-flushSchedulerQueue" class="headerlink" title="4. 执行 nextTick(flushSchedulerQueue)"></a>4. <strong>执行 nextTick(flushSchedulerQueue)</strong></h3><p><a href="/blog/vue/vue-next-tick.html">nextTick</a>这里单独记录，主要看<code>flushSchedulerQueue</code>，代码在<code>src/core/observer/scheduler.js</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  flushing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> watcher, id;</span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  <span class="comment">// 对watcher 根据id进行排序，保证从父到子执行</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="comment">// 遍历queue队列 并且执行 watcher的 run方法</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = <span class="literal">null</span>;</span><br><span class="line">    watcher.run();</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="comment">// 防止死循环</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">"You may have an infinite update loop "</span> +</span><br><span class="line">            (watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span>),</span><br><span class="line">          watcher.vm</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice();</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice();</span><br><span class="line">  <span class="comment">// 把这些控制流程状态的一些变量恢复到初始值，把 watcher 队列清空。</span></span><br><span class="line">  resetSchedulerState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">  callActivatedHooks(activatedQueue);</span><br><span class="line">  callUpdatedHooks(updatedQueue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">"flush"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要做了以下几步：</p>
<ul>
<li>队列排序<ol>
<li>.组件的更新<strong>由父到子</strong>；因为父组件的创建过程是先于子的，所以 <code>watcher</code> 的创建也是<strong>先父后子</strong>，执行顺序也应该保持<strong>先父后子</strong>。</li>
<li>用户的<strong>自定义</strong> <code>watcher</code> 要<strong>优先</strong>于<strong>渲染</strong> <code>watcher</code> 执行；因为用户自定义 <code>watcher</code> 是在渲染 <code>watcher</code> 之前创建的。</li>
<li>如果一个组件在父组件的 <code>watcher</code> 执行期间被销毁，那么它对应的 <code>watcher</code> 执行都可以被跳过，所以父组件的 <code>watcher</code> 应该先执行。</li>
</ol>
</li>
<li>队列遍历<br>在对 <code>queue</code> 排序后，接着就是要对它做遍历，拿到对应的 <code>watcher</code>，执行 <code>watcher.run()</code>。这里需要注意一个细节，在遍历的时候每次都会对 <code>queue.length</code> 求值，因为在 <code>watcher.run()</code> 的时候，很可能用户会再次添加新的 <code>watcher</code>，这样会再次执行到 <code>queueWatcher</code>，如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id;</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这时候 <code>flushing</code> 为 <code>true</code>，就会执行到 <code>else</code> 的逻辑，然后就会从后往前找，找到第一个待插入 <code>watcher</code> 的 <code>id</code> 比当前队列中 <code>watcher</code> 的 <code>id</code> 大的位置。把 <code>watcher</code> 按照 <code>id</code>的插入到队列中，因此 <code>queue</code> 的长度发生了变化。</p>
<ul>
<li>状态恢复<br>这个过程就是执行 <code>resetSchedulerState</code> 函数，它的定义在 <code>src/core/observer/scheduler.js</code> 中:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = [];</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset the scheduler's state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  index = queue.length = activatedChildren.length = <span class="number">0</span>;</span><br><span class="line">  has = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    circular = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑非常简单，就是把这些控制流程状态的一些<strong>变量恢复到初始值</strong>，把 <code>watcher</code> 队列清空。</p>
<h3 id="5-执行-watcher-run"><a href="#5-执行-watcher-run" class="headerlink" title="5. 执行 watcher.run()"></a>5. <strong>执行 watcher.run()</strong></h3><p>接下来我们继续分析 <code>watcher.run()</code> 的逻辑，它的定义在 <code>src/core/observer/watcher.js</code> 中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getAndInvoke(<span class="keyword">this</span>.cb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAndInvoke(cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行watcher.run()函数</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get();</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.call(<span class="keyword">this</span>.vm, value, oldValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行watcher 的回调函数</span></span><br><span class="line">        cb.call(<span class="keyword">this</span>.vm, value, oldValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做了如下：</p>
<ul>
<li>执行 <code>this.getAndInvoke</code> 方法，并传入 <code>watcher</code> 的回调函数</li>
<li><code>getAndInvoke</code> 函数先 通过 <code>this.get()</code> 得到它当前的值，然后做判断，如果满足<strong>新旧值不等</strong>、<strong>新值是对象类型</strong>、<strong>deep</strong> 模式任何一个条件，则执行 <code>watcher</code> 的回调<blockquote>
<p>注意回调函数执行的时候会把<strong>第一个</strong>和<strong>第二个</strong>参数传入新值 <code>value</code> 和旧值 <code>oldValue</code>，这就是当我们添加自定义 <code>watcher</code> 的时候能在<strong>回调函数</strong>的参数中拿到<strong>新旧值</strong>的原因。</p>
</blockquote>
</li>
</ul>
<h3 id="6-执行-watcher-get"><a href="#6-执行-watcher-get" class="headerlink" title="6. 执行 watcher.get()"></a>6. <strong>执行 watcher.get()</strong></h3><p>那么对于渲染 watcher 而言，它在执行 this.get() 方法求值的时候，会执行 getter 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以这就是当我们去修改组件相关的<strong>响应式数据</strong>的时候，会触发组件<strong>重新渲染</strong>的原因，接着就会重新执行 <code>patch</code> 的过程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>派发更新的过程是：修改数据触发观测数据的<code>setter</code>方法=&gt;调用<code>dep.notify()</code> 通知所有的订阅者=&gt;循环调用<strong>订阅者</strong><code>watcher.update()</code>=&gt;循环调用<code>watcher.update()</code>=&gt;调用<code>queueWatcher()</code>,添加<code>watcher</code>到一个<code>queue</code>队列中=&gt;调用<code>nextTick(flushSchedulerQueue)</code> ，对<code>queue</code>根据<code>id</code>排序 =&gt; 调用<code>watcher.run()</code>方法 =&gt; 触发<code>watcher.get()</code>方法=&gt;调用<code>vm._update(vm._render(), hydrating)</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/setters.html#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">派发更新</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 Vue中的依赖收集</title>
    <url>/blog/vue/vue-dep.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/vue/vue-definedProperty.html">深入Vue系列 Vue中的响应式对象</a><br><a href="/blog/vue/vue-dep.html">深入Vue系列 Vue中的依赖收集</a><br><a href="/blog/vue/vue-notify.html">深入Vue系列 Vue中的派发更新</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过响应式对象知道，每一个 <code>data</code> 的属相都会实例化一个 <code>Dep</code>，并且它的 <code>get</code> 函数中通过 <code>dep.depend</code>做依赖收集。通过下面这张图比较直观的看出依赖收集的过程：<br><img src="../../images/vue/vue-Dep-1-1.jpg" alt="vue-Dep"><br><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 <code>getter</code> 和 <code>setter</code>，它的定义在 <code>src/core/observer/index.js</code>，在 <code>getter</code> 中会做依赖收集，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*在闭包中定义一个dep对象*/</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了getter/setter则将其缓存，新定义的getter/setter中会将其执行</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子对象递归调用 observe</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有getter方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">// 如果当前有watcher在读取当前值</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 那么进行依赖收集，dep.addSub</span></span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">/*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span></span><br><span class="line">          childOb.dep.depend();</span><br><span class="line">          <span class="comment">// 这里是对数组进行劫持</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">/*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span></span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="comment">// 先getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="comment">// 如果跟原来值一样则不管</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有setter方法则执行</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新的值需要重新进行observe，保证数据响应式*/</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      <span class="comment">/*dep对象通知所有的观察者*/</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getter</code> 的时候进行依赖的收集，注意这里，只有在 <code>Dep.target</code> 中有值的时候才会进行依赖收集，这个 <code>Dep.target</code> 是在<code>Watcher</code>实例的 <code>get</code> 方法调用的时候 <code>pushTarget</code> 会把当前取值的<code>watcher</code>推入 <code>Dep.target</code>，原先的<code>watcher</code>压栈到 <code>targetStack</code> 栈中，当前取值的<code>watcher</code>取值结束后出栈并把原先的<code>watcher</code>值赋给 <code>Dep.target</code>，<code>cleanupDeps</code> 最后把新的 <code>newDeps</code> 里已经没有的<code>watcher</code>清空，以防止视图上已经不需要的无用<code>watcher</code>触发<code>setter</code> 的时候首先 <code>getter</code>，并且比对旧值没有变化则<code>return</code>，如果发生变更，则<code>dep</code>通知所有<code>subs</code>中存放的依赖本数据的<code>Watcher</code>实例 <code>update</code> 进行更新，这里 <code>update</code> 中会 <code>queueWatcher( )</code> 异步推送到调度者观察者队列 <code>queue</code> 中，在<code>nextTick</code>时 <code>flushSchedulerQueue</code>( ) 把队列中的<code>watcher</code>取出来执行 <code>watcher.run</code> 且执行相关钩子函数。</p>
<h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p><code>Dep</code> 是整个 <code>getter</code> 依赖收集的核心，它的定义在 <code>src/core/observer/dep.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> type Watcher <span class="keyword">from</span> <span class="string">"./watcher"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">"../util/index"</span>;</span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++;</span><br><span class="line">    <span class="comment">// 订阅者的列表</span></span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*添加一个观察者对象*/</span></span><br><span class="line">  addSub(sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*移除一个观察者对象*/</span></span><br><span class="line">  removeSub(sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//给watcher收集依赖</span></span><br><span class="line">  <span class="comment">//这里是一个关键步骤，Dep.target是一个watcher实例</span></span><br><span class="line">  <span class="comment">//先将这个Dep实例添加到Watcher的依赖中</span></span><br><span class="line">  <span class="comment">//然后在watcher中调用dep.addSub将watcher添加到dep的订阅者中</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*通知所有订阅者*/</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="comment">//遍历这个依赖的所有订阅者watcher</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">//update()的最终目的就是要执行Watcher的getter</span></span><br><span class="line">      <span class="comment">//执行这个Watcher的getter的时候就会触发这个Watcher的依赖们的get()</span></span><br><span class="line">      <span class="comment">//然后重新收集依赖</span></span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// this is globally unique because there could be only one</span></span><br><span class="line"><span class="comment">// watcher being evaluated at any time.</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// watcher栈</span></span><br><span class="line"><span class="keyword">const</span> targetStack = [];</span><br><span class="line"><span class="comment">/* 将watcher观察者实例设置给Dep.target，用以依赖收集。同时将该实例存入target栈中 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">_target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target);</span><br><span class="line">  <span class="comment">// 改变目标指向</span></span><br><span class="line">  Dep.target = _target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将观察者实例从target栈中取出并设置给Dep.target */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = targetStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Dep.target</code> 是一个静态属性，这是一个全局唯一 <code>Watcher</code>，这是一个非常巧妙的设计，因为在同一时间只能有一个全局的 <code>Watcher</code> 被计算。</li>
<li>定义一些 <code>Dep</code> 上得方法，添加依赖方法、移除方法、调用 <code>watcher.update()</code>的方法</li>
<li>实例属性 <code>subs</code> 保存 <code>watcher</code> 订阅者的列表</li>
</ul>
<h2 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h2><p><code>src/core/observer/watcher.js</code> 代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn) <span class="comment">//  // 在get方法中执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// 调用get方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">/*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="comment">/*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        <span class="comment">/*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span></span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*将观察者实例从target栈中取出并设置给Dep.target*/</span></span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addDep (dep: Dep) &#123;...  &#125;<span class="comment">/* 添加一个依赖关系到Deps集合中 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;  ...&#125;<span class="comment">/* 清理newDeps里没有的无用watcher依赖 */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Watcher</code>是一个观察者对象。依赖收集以后<code>Watcher</code>对象会被保存在<code>Dep</code>的<code>subs</code>中，数据变动的时候<code>Dep</code>会通知<code>Watcher</code>实例，然后由<code>Watcher</code>实例回调<code>cb</code>进行视图的更新。</p>
<h2 id="触发流程"><a href="#触发流程" class="headerlink" title="触发流程"></a>触发流程</h2><p>大致流程如下：</p>
<ol>
<li>Vue 的 <code>mount</code> 过程是通过 <code>mountComponent</code> 函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化渲染 watcher</span></span><br><span class="line"><span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent,</span><br><span class="line">  noop,</span><br><span class="line">  &#123;</span><br><span class="line">    before() &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">"beforeUpdate"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>初始化渲染<code>watcher</code>的时候，会执行<code>watcher</code>的构造函数，再会执行<code>this.get()</code>方法，进入 get 函数，首先执行：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pushTarget(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// pushTarget方法实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果存在Dep.target 就把 Dep.target 压入targetStack 栈，为了后面恢复使用</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target);</span><br><span class="line">  <span class="comment">// 把 Dep.target 赋值为当前的渲染 watcher</span></span><br><span class="line">  Dep.target = _target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上就是把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code> 并压栈（为了恢复用）。</p>
<ol start="3">
<li>接着会执行：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this.getter 对应就是 updateComponent 函数</span></span><br><span class="line">value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line"><span class="comment">// 所以就会执行</span></span><br><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 其实执行的就是个</span></span><br><span class="line">  vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// vm._update(vm._render(), hydrating)</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>执行<code>vm._render()</code> 这个方法会生成 渲染 <code>VNode</code>，并且在这个过程中会对 <code>vm</code> 上的<strong>数据访问</strong>，这个时候就触发了数据对象的 <code>getter</code>。每个对象属性的<code>getter</code>都持有一个<code>Dep</code>实例，在触发 getter 的时候就会调用<code>dep.depend()</code>方法，也就会执行<code>Dep.target.addDep(this)</code>。</p>
</li>
<li><p>执行<code>Dep.target.addDep(this)</code> 这个时候<code>Dep.target</code>已经被赋值为渲染<code>watcher</code>，因为在上面执行了<code>pushTarget(this)</code>。执行 addDep 方法代码如下：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line"><span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">        <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">            dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，那么就会执行 <code>this.subs.push(sub)</code>，也就是说把当前的 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>subs</code> 中，这个目的是为后续数据变化时候能通知到哪些 <code>subs</code> 做准备。</p>
<ol start="6">
<li>接着执行 <code>watcher</code> 中 <code>get()</code>方法中的 <code>traverse(value)</code>、<code>popTarget()</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">  <span class="comment">/*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span></span><br><span class="line">  traverse(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将观察者实例从target栈中取出并设置给Dep.target*/</span></span><br><span class="line">popTarget();</span><br><span class="line"></span><br><span class="line"><span class="comment">// popTarget 实现 在Dep类中</span></span><br><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line"><span class="comment">/* 将观察者实例从target栈中取出并设置给Dep.target */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = targetStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>traverse(value)</code>递归触发子项的<code>getter</code>完成依赖收集。再执行<code>popTarget()</code>实际上就是把 <code>Dep.target</code> 恢复成上一个状态，因为当前 <code>vm</code> 的数据依赖收集已经完成，那么对应的渲染<code>Dep.target</code> 也需要改变。</p>
<ol start="7">
<li>接着执行<code>watcher</code> 中 <code>get()</code>方法中的 <code>this.cleanupDeps()</code>, <code>cleanupDeps()</code>函数定义在<code>watcher</code>类中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cleanupDeps 函数</span></span><br><span class="line">cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">            dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先理解四个变量<code>depIds</code>、<code>newDepIds</code> 、<code>deps</code>、 <code>newDeps</code>。</p>
<ul>
<li><code>depIds Hash</code>表，用于快速查找（<code>dep</code>）</li>
<li><code>newDepIds Hash</code>表，用于快速查找（<code>newDeps</code>）</li>
<li><code>deps</code> 缓存上一轮执行观察者函数用到的<code>dep</code>实例</li>
<li><code>newDeps</code> 存储本轮执行观察者函数用到的<code>dep</code>实例</li>
</ul>
<p>在执行 <code>cleanupDeps</code> 函数的时候，会首先遍历 <code>deps</code>，移除对 <code>dep.subs</code> 数组中 <code>Wathcer</code> 的订阅，然后把 <code>newDepIds</code> 和 <code>depIds</code> 交换，<code>newDeps</code> 和 <code>deps</code> 交换，并把 <code>newDepIds</code> 和 <code>newDeps</code> 清空。</p>
<p><strong>为什么清除 Deps</strong><br>因此<code>Vue</code>设计了在每次<strong>添加完新的</strong>订阅，会<strong>移除掉旧的</strong>订阅，这样就保证了在我们刚才的场景中，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除了，所以不会有任何浪费。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在 <code>Vue</code> 中初始化渲染时，视图上绑定的数据就会实例化一个 <code>Watcher</code>，<strong>依赖收集</strong>就是是通过属性的 <code>getter</code> 函数完成的，<code>Observer</code> 、<code>Watcher</code> 、<code>Dep</code> 都与依赖收集相关。其中 <code>Observer</code> 与 <code>Dep</code> 是<strong>一对一</strong>的关系， <code>Dep</code> 与 <code>Watcher</code> 是<strong>多对多</strong>的关系，Dep 则是 <code>Observer</code> 和 <code>Watcher</code> 之间的<strong>纽带</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/getters.html#dep" target="_blank" rel="noopener">依赖收集</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a><br><a href="https://zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/#more" target="_blank" rel="noopener">Vue2.0 源码阅读：响应式原理</a>&gt; <a href="https://juejin.im/post/5b40c8495188251af3632dfa" target="_blank" rel="noopener">Vue 源码阅读-依赖收集原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 Vue中的响应式对象</title>
    <url>/blog/vue/vue-definedProperty.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/vue/vue-definedProperty.html">深入Vue系列 Vue中的响应式对象</a><br><a href="/blog/vue/vue-dep.html">深入Vue系列 Vue中的依赖收集</a><br><a href="/blog/vue/vue-notify.html">深入Vue系列 Vue中的派发更新</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vue 的<strong>核心响应式</strong>是通过<code>Obeject.defineProperty</code>方法来实现的。 而<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a>是 ES5 中无法<strong>shim</strong>的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p><strong>Object.defineProperty</strong><br>Object.defineProperty 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor);</span><br></pre></td></tr></table></figure>
<p>obj 是要在其上定义属性的对象；prop 是要定义或修改的属性的名称；descriptor 是将被定义或修改的属性描述符。</p>
<p>由于 Vue 会在初始化实例时对属性执行 <strong>getter/setter</strong> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的。<br>响应式原理大致流程如下图所示：<br><img src="../../images/vue/vue-defineProperty-1-1.png" alt="vue-defineProperty"><br>Vue 数据响应式变化主要涉及<strong>Observer、Watcher、Dep</strong>这三个主要的类。这里主要是响应式对象，后面分别会记录它的依赖收集、派发更新、三种 Watcher。<br>把普通对象改造为<strong>响应式对象</strong>在 Vue 中的大致流程为：</p>
<ul>
<li><code>initState</code>(初始化数据)</li>
<li><code>Observer(</code>劫持数据)</li>
<li><code>defineReactive</code>(依赖收集、派发更新)</li>
</ul>
<p>在 getter 对象中又会依赖收集，在 setter 中派发更新。</p>
<blockquote>
<p>Vue-version(2.6.10)</p>
</blockquote>
<h2 id="initState-初始化数据"><a href="#initState-初始化数据" class="headerlink" title="initState(初始化数据)"></a>initState(初始化数据)</h2><p>那么我们从一个简单的 Vue 实例的代码来分析 Vue 的响应式原理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'App'</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        msg: <span class="string">'initState'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<strong>Vue</strong>的初始化阶段，<code>_init</code> 方法执行的时候，会执行 <code>initState(vm)</code> 方法，它的定义在 <strong>src/core/instance/state.js</strong>中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options;</span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props);</span><br><span class="line">  <span class="comment">// 初始化methods</span></span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods);</span><br><span class="line">  <span class="comment">// 初始化data</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*该组件没有data的时候绑定一个空对象*/</span></span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化computed</span></span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed);</span><br><span class="line">  <span class="comment">// 初始化手写的watcher</span></span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initState</code> 方法主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>wathcer</code> 等属性做了初始化操作。主要看<code>initData</code>。</p>
<h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><p><code>initData</code>方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data;</span><br><span class="line">  <span class="comment">// 判断data是否为function 如果是直接执行，如果不是获取data</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">"function"</span> ? getData(data, vm) : data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">"data functions should return an object:\n"</span> +</span><br><span class="line">          <span class="string">"https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function"</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props;</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods;</span><br><span class="line">  <span class="keyword">let</span> i = keys.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">            <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      <span class="comment">// 通过 proxy 把每一个值 vm._data.xxx 都代理到 vm.xxx 上</span></span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 另一个是调用 observe 方法观测整个 data 的变化，把 data 也变成响应式</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 initData 过程中主要做了两件事：</p>
<ul>
<li>通过 <code>proxy</code> 把每一个值 vm._data.[key] 都代理到 vm.[key] 上；</li>
<li>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式（可观察），可以通过 <code>vm._data.[key]</code> 访问到定义 <code>data</code> 返回函数中对应的属性。</li>
</ul>
<h2 id="Observer-劫持数据"><a href="#Observer-劫持数据" class="headerlink" title="Observer(劫持数据)"></a>Observer(劫持数据)</h2><p>observe 的功能就是用来监测数据的变化，它的定义在 src/core/observer/index.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为VNode 如果是直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 如果存在__ob__ 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">"__ob__"</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果不存在 实例化一个 Observer</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回 Observer实例</span></span><br><span class="line">  <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>observe</code> 方法的作用就是给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例。接下来我们来看一下 <code>Observer</code> 的作用。</p>
<p><strong>Observer</strong><br>observe 的功能就是用来监测数据的变化，它的定义在 src/core/observer/index.js 中：<br><code>Observer</code> 是一个类，它的作用是给对象的属性添加 <code>getter</code> 和 <code>setter</code>，用于<strong>依赖收集</strong>和<strong>派发更新</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 给对象的属性添加 getter 和 setter， 用于依赖收集、派发更新</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="comment">// 实例化 Dep 对象</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把自身实例添加到数据对象 value 的 __ob__ 属性上</span></span><br><span class="line">    def(value, <span class="string">"__ob__"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 判断value 是否为Array 做不同的调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//  遍历对象属性 并且每个属性添加 getter、setter</span></span><br><span class="line">  walk(obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray(items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法做的事情如下：</p>
<ul>
<li>实例化 <code>Dep</code> 对象</li>
<li>通过执行 <code>def</code> 函数把自身实例添加到数据对象 <code>value</code>的 <strong>ob</strong> 属性上</li>
<li>对 <code>value</code> 做判断，对于数组会调用 <code>observeArray</code> 方法，否则对纯对象调用 <code>walk</code>方法。</li>
</ul>
<blockquote>
<p>可以看到 <code>observeArray</code> 是遍历数组再次调用 <code>observe</code> 方法，而 <code>walk</code> 方法是遍历对象的 <code>key</code> 调用 <code>defineReactive</code> 方法，那么我们来看一下这个方法是做什么的。</p>
</blockquote>
<p><strong>def 方法</strong><br>def 的定义在 src/core/util/lang.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">obj: Object, key: string, val: any, enumerable?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自身实例添加到数据对象 value 的 __ob__ 属性上</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发中输出 <code>data</code> 上对象类型的数据，会发现该对象多了一个 <code>__ob__</code> 的属性。</p>
<h2 id="defineReactive-依赖收集、派发更新"><a href="#defineReactive-依赖收集、派发更新" class="headerlink" title="defineReactive(依赖收集、派发更新)"></a>defineReactive(依赖收集、派发更新)</h2><p><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 <code>getter</code> 和 <code>setter</code>，它的定义在 <code>src/core/observer/index.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*在闭包中定义一个dep对象*/</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了getter/setter则将其缓存，新定义的getter/setter中会将其执行</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子对象递归调用 observe</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有getter方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">// 如果当前有watcher在读取当前值</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 那么进行依赖收集，dep.addSub</span></span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">/*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span></span><br><span class="line">          childOb.dep.depend();</span><br><span class="line">          <span class="comment">// 这里是对数组进行劫持</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">/*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span></span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="comment">// 先getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="comment">// 如果跟原来值一样则不管</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有setter方法则执行</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新的值需要重新进行observe，保证数据响应式*/</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      <span class="comment">/*dep对象通知所有的订阅者*/</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暂时不对<strong>依赖收集</strong>、<strong>派发更新</strong>、<strong>Dep</strong>讲述只记录<strong>数据劫持</strong>的过程记录，后面文章记录具体的<strong>依赖收集</strong>、<strong>派发更新</strong>、<strong>watcher</strong>、<strong>Dep</strong>、记录。<br><code>defineReactive</code> 函数最开始初始化 <code>Dep</code> 对象的实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，这样就保证了无论 <code>obj</code> 的结构多复杂，它的所有<strong>子属性</strong>也能变成响应式的对象，这样我们访问或修改 <code>obj</code> 中一个嵌套较深的属性，也能触发 <code>getter</code> 和 <code>setter</code>。最后利用 <code>Object.defineProperty</code> 去给 obj 的属性 key 添加 getter 和 setter。</p>
<h2 id="数据观测的特殊处理"><a href="#数据观测的特殊处理" class="headerlink" title="数据观测的特殊处理"></a>数据观测的特殊处理</h2><p>访问对象属性，其取值与赋值操作，都能被<code>Object.defineProperty()</code>成功拦截，但是<code>Object.defineProperty()</code>在处理数组上却存在一些问题。通过调用数据原型上的<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、 <code>reverse</code>等方法不能被观测到<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Cross-browser_concerns" target="_blank" rel="noopener">兼容性问题</a>。</p>
<p>在<strong>Vue</strong>中是对数组的原型上述方法做了一些增强操作。即<strong>保留</strong>原来操作的基础上，植入<strong>Vue</strong>的特定的操作代码。<br>代码在 src/core/observer/index.js 中定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">"push"</span>,</span><br><span class="line">  <span class="string">"pop"</span>,</span><br><span class="line">  <span class="string">"shift"</span>,</span><br><span class="line">  <span class="string">"unshift"</span>,</span><br><span class="line">  <span class="string">"splice"</span>,</span><br><span class="line">  <span class="string">"sort"</span>,</span><br><span class="line">  <span class="string">"reverse"</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"unshift"</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"splice"</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// observeArray方法进行一遍观测处理</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    <span class="comment">/*dep对象通知所有的订阅者*/</span></span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>保留数组原来的操作 <code>push</code>、<code>unshift</code>、<code>splice</code>这些方法，会带来<strong>新的数据元素</strong>，而新带来的数据元素，我们是有办法得知的（即为传入的参数）那么新增的元素也是需要被配置为<strong>可观测数据</strong>的，这样子后续数据的变更才能得以处理。所以要对新增的元素调用<code>observer</code>实例上的<code>observeArray</code>方法进行一遍观测处理由于数组变更了，那么就需要通知观察者，所以通过<code>ob.dep.notify()</code>对数组的观察者<code>watchers</code>进行通知。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从初始化<code>initData</code>，到核心就是利用 <code>Object.defineProperty</code> 给数据添加了 <code>getter</code> 和 <code>setter</code>，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：<code>getter</code> 做的事情是<strong>依赖收集</strong>，<code>setter</code> 做的事情是<strong>派发更新</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/vuejs/vue/tree/dev/src" target="_blank" rel="noopener">Vue 源码</a><br><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/reactive-object.html#object-defineproperty" target="_blank" rel="noopener">响应式对象</a><br><a href="https://mp.weixin.qq.com/s/-pZnJWxrRlz-rOGhdshe7g" target="_blank" rel="noopener">Vue 响应式原理其实很好懂</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a><br><a href="https://juejin.im/entry/5bdab35d6fb9a0224e0e5794" target="_blank" rel="noopener">深入解析 Vue 依赖收集原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中render源码解析 (未完成)</title>
    <url>/blog/vue/vue-update-render-createelement-patch.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码中new vue都做了什么 (未完成)</title>
    <url>/blog/vue/vue-new-vue.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack实现热加载的两种方式 和 实现原理 (未完成)</title>
    <url>/blog/webpack/webpack-hot-twofuntions.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>编写一个自己的webpack插件plugin</title>
    <url>/blog/webpack/webpack-self-plugins.html</url>
    <content><![CDATA[<p><strong><em>非彼无我，非我无所取。——庄子</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>插件是 webpack 的支柱功能。<code>webpack</code> 自身也是构建于，你在 <code>webpack</code> 配置中用到的相同的插件系统之上！插件目的在于解决 <code>loader</code> 无法实现的其他事。<br>要想写好插件就要知道<code>Webpack</code>中的两个比较核心的概念<code>compiler</code>、<code>compilation</code>、<code>tapable</code>。在<a href="/blog/webpack/webpack-process.html">webpack 编译流程</a>已经都要记录。<br><code>Webpack</code> 通过 <code>Plugin</code> 机制让其更加灵活，以适应各种应用场景。 在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。</p>
<h2 id="实现一个-plugin"><a href="#实现一个-plugin" class="headerlink" title="实现一个 plugin"></a>实现一个 plugin</h2><hr>
<p>一个 webpack plugin 基本包含以下几步：</p>
<ol>
<li>一个 JavaScript 函数或者类</li>
<li>在函数原型（prototype）中定义一个注入<code>compiler</code>对象的<code>apply</code>方法。</li>
<li><code>apply</code>函数中通过<code>compiler</code>插入指定的事件钩子，在钩子回调中拿到<code>compilation</code>对象</li>
<li>使用<code>compilation</code>操纵修改<code>webapack</code>内部实例数据。</li>
<li>异步插件，数据处理完后使用<code>callback</code>回调</li>
</ol>
<p>最后会实现一个简单的<code>clean-webpack-plugin</code>。</p>
<h3 id="一个简单的插件"><a href="#一个简单的插件" class="headerlink" title="一个简单的插件"></a>一个简单的插件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackCleanupPlugin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"WebpackCleanupPlugin"</span>, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 应用函数</span></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(compiler);</span><br><span class="line">    <span class="comment">// 绑定钩子事件</span></span><br><span class="line">    compiler.plugin(<span class="string">"done"</span>, compilation =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(compilation);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何使用在 webpack.config.js 中引入并且使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"><span class="comment">// 引入自己的插件</span></span><br><span class="line"><span class="keyword">const</span> WebpackCleanupPlugin = <span class="built_in">require</span>(<span class="string">"./WebpackCleanupPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">"source-map"</span>,</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    chunk1: <span class="string">"./src/chunk1.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].[chunkhash].js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">"css-loader"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">"[name].[contenthash].css"</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 使用自己的插件</span></span><br><span class="line">    <span class="keyword">new</span> WebpackCleanupPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>自己写的插件如下执行：</p>
<ul>
<li><code>webpack</code> 启动后，在读取配置的过程中会先执行 <code>new WebpackCleanupPlugin()</code> 初始化一个 WebpackCleanupPlugin 获得其实例。</li>
<li>在初始化 <code>compiler</code> 对象后，再调用 <code>WebpackCleanupPlugin.apply(compiler)</code> 给插件实例传入 <code>compiler</code> 对象。</li>
<li>插件实例在获取到 <code>compiler</code> 对象后，就可以通过 <code>compiler.plugin</code>(事件名称, 回调函数) 监听到 <code>Webpack</code> 广播出来的事件。</li>
<li>并且可以通过 <code>compiler</code> 对象去操作 <code>webpack</code>。</li>
</ul>
<p><strong>Compiler、Compilation</strong></p>
<ul>
<li><strong>Compiler 对象包含了 Webpack 环境所有的的配置信息</strong>，包含 <code>options</code>，<code>hook</code>，<code>loaders</code>，<code>plugins</code> 这些信息，这个对象在 <code>Webpack</code> 启动时候被实例化，它是<strong>全局唯一</strong>的，可以简单地把它理解为 <code>Webpack</code> 实例；<code>Compiler</code>中包含的东西如下所示：</li>
</ul>
<p><img src="../../images/webpack/webpack-3-5.png" style="height: 300px"></p>
<ul>
<li><strong>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等</strong>。当 <code>Webpack</code> 以开发模式运行时，每当检测到一个文件变化，一次新的 <code>Compilation</code> 将被创建。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。通过 <code>Compilation</code> 也能读取到 <code>Compiler</code> 对象。</li>
</ul>
<p><code>Compilation</code>中包含的东西如下所示：</p>
<p><img src="../../images/webpack/webpack-3-6.png" style="height: 300px"></p>
<blockquote>
<p><strong>Compiler 和 Compilation 的区别在于</strong>：<code>Compiler</code> 代表了整个 <code>Webpack</code> 从启动到关闭的生命周期，而 <code>Compilation</code> 只是代表了一次新的编译。</p>
</blockquote>
<p><a href="https://www.webpackjs.com/api/compiler-hooks/" target="_blank" rel="noopener">Compiler 钩子</a>和<a href="https://www.webpackjs.com/api/compilation-hooks/" target="_blank" rel="noopener">compilation 钩子</a></p>
<h2 id="一个简单的清除文件插件"><a href="#一个简单的清除文件插件" class="headerlink" title="一个简单的清除文件插件"></a>一个简单的清除文件插件</h2><hr>
<p>每次打包如果文件有修改会生成新的文件，文件的<strong>hash</strong>也会跟着变化，那么这个改变了的文件，他以前的文件就是无效的了，要把以前的文件清除掉，我们使用比较多的就是<code>clean-webpack-plugin</code>，这里自己实现一个简单的文件清除。如果不知道<a href="/blog/webpack/webpack-chunkhas-hash-contenthash.html">hash、contenthash、chunkhash</a>的区别可以看这一片文章。</p>
<p>大致分为以下几步：</p>
<ul>
<li>获取<code>output</code>路径，也就是出口路径一般为<code>dist</code></li>
<li>绑定钩子事件 <code>compiler.plugin(&#39;done&#39;, (stats) =&gt; {})</code></li>
<li>编译文件，与原来文件对比，删除未匹配文件 （同时可以 options 设置要忽略的文件）</li>
</ul>
<p>代码实现如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> recursiveReadSync = <span class="built_in">require</span>(<span class="string">"recursive-readdir-sync"</span>);</span><br><span class="line"><span class="keyword">const</span> minimatch = <span class="built_in">require</span>(<span class="string">"minimatch"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> union = <span class="built_in">require</span>(<span class="string">"lodash.union"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles</span>(<span class="params">fromPath, exclude = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = recursiveReadSync(fromPath).filter(<span class="function"><span class="params">file</span> =&gt;</span></span><br><span class="line">    exclude.every(</span><br><span class="line">      excluded =&gt;</span><br><span class="line">        !minimatch(path.relative(fromPath, file), path.join(excluded), &#123;</span><br><span class="line">          dot: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// console.log(files);</span></span><br><span class="line">  <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackCleanupPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 配置文件</span></span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 获取output路径</span></span><br><span class="line">    <span class="keyword">const</span> outputPath = compiler.options.output.path;</span><br><span class="line">    <span class="comment">// 绑定钩子事件</span></span><br><span class="line">    compiler.plugin(<span class="string">"done"</span>, stats =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        compiler.outputFileSystem.constructor.name !== <span class="string">"NodeOutputFileSystem"</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取编译完成 文件名</span></span><br><span class="line">      <span class="keyword">const</span> assets = stats.toJson().assets.map(<span class="function"><span class="params">asset</span> =&gt;</span> asset.name);</span><br><span class="line">      <span class="built_in">console</span>.log(assets);</span><br><span class="line">      <span class="comment">// 多数组合并并且去重</span></span><br><span class="line">      <span class="keyword">const</span> exclude = union(<span class="keyword">this</span>.options.exclude, assets);</span><br><span class="line">      <span class="built_in">console</span>.log(exclude);</span><br><span class="line">      <span class="comment">// console.log('outputPath', outputPath);</span></span><br><span class="line">      <span class="comment">// 获取未匹配文件</span></span><br><span class="line">      <span class="keyword">const</span> files = getFiles(outputPath, exclude);</span><br><span class="line">      <span class="comment">// const files = [];</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"files"</span>, files);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.options.preview) &#123;</span><br><span class="line">        <span class="comment">// console.log('%s file(s) would be deleted:', files.length);</span></span><br><span class="line">        <span class="comment">// 输出文件</span></span><br><span class="line">        files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"    %s"</span>, file));</span><br><span class="line">        <span class="comment">// console.log();</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 删除未匹配文件</span></span><br><span class="line">        files.forEach(fs.unlinkSync);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.options.quiet) &#123;</span><br><span class="line">        <span class="comment">// console.log('\nWebpackCleanupPlugin: %s file(s) deleted.', files.length);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = WebpackCleanupPlugin;</span><br></pre></td></tr></table></figure>
<p>上面的这个插件实现了一个清除编译文件的效果。在这里就不做实验了，如果有兴趣可以自己把代码 copy 到本地，运行一下看一下结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上面大致知道怎么写一个简单的清除文件的<code>webpack</code>的<strong>插件</strong>，其实还可以做更多的事情如下：</p>
<ul>
<li>读取输出资源、代码块、模块及其依赖（在 <code>emit</code> 事件发生）</li>
<li>监听文件变化 <code>watch-run</code></li>
<li>修改输出资源 <code>compilation.assets</code></li>
</ul>
<p>具体实现可以看一下一下<a href="http://webpack.wuhaolin.cn/5%E5%8E%9F%E7%90%86/5-4%E7%BC%96%E5%86%99Plugin.html" target="_blank" rel="noopener">webpack 深入浅出</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/post/5beb8875e51d455e5c4dd83f" target="_blank" rel="noopener">干货！撸一个 webpack 插件(内含 tapable 详解+webpack 流程)</a><br><a href="https://zoumiaojiang.com/article/what-is-real-webpack-plugin/" target="_blank" rel="noopener">看清楚真正的 Webpack 插件</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack编译流程</title>
    <url>/blog/webpack/webpack-process.html</url>
    <content><![CDATA[<p><strong><em>中无主而不止，外无正而不行。——庄子</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>现在前端开发基本上都会用到<code>react</code>、<code>vue</code>，用到了前端<code>mvc</code>、<code>mvvm</code>框架，基本上都会涉及到打包发布，打包常用的工具就是<code>webpack</code>、<code>gulp</code>等等。经常使用自然也要了解一些他大致的流程也会方便使用。<br>首先要理解webpack中比较核心的概念：</p>
<ul>
<li><strong>Entry</strong>: 指定webpack开始构建的入口模块，从该模块开始构建并计算出直接或间接依赖的模块或者库。</li>
<li><strong>Output</strong>：告诉webpack如何命名输出的文件以及输出的目录</li>
<li><strong>Module</strong>: 模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li>
<li><strong>Chunk</strong>：<code>coding split</code>的产物，我们可以对一些代码打包成一个单独的<code>chunk</code>，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。在<code>webpack3</code>及以前我们都利用<code>CommonsChunkPlugin</code>将一些公共代码分割成一个<code>chunk</code>，实现单独加载。在<code>webpack4</code> 中<code>CommonsChunkPlugin</code>被废弃，使用<code>SplitChunksPlugin</code></li>
<li><strong>Loader</strong>：模块转换器，用于把模块原内容按照需求转换成新内容。</li>
<li><strong>Plugin</strong>：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。</li>
</ul>
<p>webpack 执行流程和事件流如下图所示：</p>
<p><img src="../../images/webpack/webpack2.svg" style="height: 400px"><br>webpack编译过程中一个比较重要的概念<strong>compiler</strong>、<strong>compilation</strong>，如下：</p>
<ul>
<li><strong>Compiler 对象</strong>：负责文件监听和启动编译。<code>Compiler</code> 实例中包含了完整的 <code>webpack</code> 配置，全局只有一个 <code>Compiler</code> 实例。</li>
<li><strong>Compilation 对象</strong>：当 <code>webpack</code> 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。<!-- ![webpack-flow](../../images/webpack/webpack-3-1.png) -->
</li>
</ul>
<h2 id="webpack流程"><a href="#webpack流程" class="headerlink" title="webpack流程"></a>webpack流程</h2><hr>
<p>Webpack的运行流程是一个串行的过程，从启动到结束依次执行以下流程：</p>
<ol>
<li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。</li>
<li>编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。</li>
<li>输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。</li>
</ol>
<p>如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：<br><img src="../../images/webpack/webpack-3-2.png" alt="webpack-flow"><br>下面具体介绍一下 <code>webpack</code>的三个大阶段具体的小步。</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>初始化阶段大致分为：</p>
<ul>
<li>合并<code>shell</code>和<strong>配置文件文件</strong>的参数并且<strong>实例化Complier对象</strong>。</li>
<li><strong>加载插件</strong></li>
<li><strong>处理入口</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始化参数</td>
<td style="text-align:center">从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 new Plugin()。</td>
</tr>
<tr>
<td style="text-align:center">实例化 Compiler</td>
<td style="text-align:center">用上一步得到的参数初始化 <code>Compiler</code> 实例，<code>Compiler</code> 负责文件监听和启动编译。<code>Compiler</code> 实例中包含了完整的 <code>Webpack</code> 配置，全局只有一个 <code>Compiler</code> 实例。</td>
</tr>
<tr>
<td style="text-align:center">加载插件</td>
<td style="text-align:center">依次调用插件的 <code>apply</code> 方法，让插件可以监听后续的所有事件节点。同时给插件传入 <code>compiler</code> 实例的引用，以方便插件通过 <code>compiler</code> 调用 <code>Webpack</code> 提供的 <code>API</code>。</td>
</tr>
<tr>
<td style="text-align:center">environment</td>
<td style="text-align:center">开始应用 <code>Node.js</code> 风格的文件系统到 <code>compiler</code> 对象，以方便后续的文件寻找和读取。</td>
</tr>
<tr>
<td style="text-align:center">entry-option</td>
<td style="text-align:center">读取配置的 <code>Entrys</code>，为每个 <code>Entry</code> 实例化一个对应的 <code>EntryPlugin</code>，为后面该 <code>Entry</code> 的递归解析工作做准备。</td>
</tr>
<tr>
<td style="text-align:center">after-plugins</td>
<td style="text-align:center">调用完所有内置的和配置的插件的 <code>apply</code> 方法。</td>
</tr>
<tr>
<td style="text-align:center">after-resolvers</td>
<td style="text-align:center">根据配置初始化完 <code>resolver</code>，<code>resolver</code> 负责在文件系统中寻找指定路径的文件。</td>
</tr>
</tbody>
</table>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">before-run</td>
<td style="text-align:center">清除缓存</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">启动一次新的编译。</td>
</tr>
<tr>
<td style="text-align:center">watch-run</td>
<td style="text-align:center">和 <code>run</code> 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致<strong>重新启动</strong>一次新的编译。</td>
</tr>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">该事件是为了告诉插件一次<strong>新的</strong>编译将要启动，同时会给插件带上 <code>compiler</code> 对象。</td>
</tr>
<tr>
<td style="text-align:center">compilation</td>
<td style="text-align:center">当 <code>Webpack</code> 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。</td>
</tr>
<tr>
<td style="text-align:center">make</td>
<td style="text-align:center">一个新的 <code>Compilation</code> 创建完毕，即将从 <code>Entry</code> 开始读取文件，根据文件类型和配置的 <code>Loader</code> 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。</td>
</tr>
<tr>
<td style="text-align:center">after-compile</td>
<td style="text-align:center">一次 <code>Compilation</code> 执行完成。这里会根据编译结果 合并出我们最终生成的文件名和文件内容。</td>
</tr>
<tr>
<td style="text-align:center">invalid</td>
<td style="text-align:center">当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 <code>Webpack</code> 退出。</td>
</tr>
</tbody>
</table>
<p>这里主要最重要的就是<code>compilation</code>过程，<code>compilation</code> 实际上就是调用相应的 <code>loader</code> 处理文件生成 <code>chunks</code>并对这些 <code>chunks</code> 做优化的过程。几个关键的事件（<code>Compilation</code>对象<code>this.hooks</code>中）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">build-module</td>
<td style="text-align:center">使用对应的 <code>Loader</code> 去转换一个模块。</td>
</tr>
<tr>
<td style="text-align:center">normal-module-loader</td>
<td style="text-align:center">在用 <code>Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack</code> 后面对代码的分析。</td>
</tr>
<tr>
<td style="text-align:center">program</td>
<td style="text-align:center">从配置的入口模块开始，分析其 <code>AST</code>，当遇到 <code>require</code> 等导入其它模块语句时，便将其加入到<strong>依赖的模块列表</strong>，同时对新找出的<strong>依赖模块递归分析</strong>，最终搞清所有模块的<strong>依赖关系</strong>。</td>
</tr>
<tr>
<td style="text-align:center">seal</td>
<td style="text-align:center">所有模块及其<strong>依赖</strong>的模块都通过 <code>Loader</code> 转换完成后，根据依赖关系开始生成 <code>Chunk</code>。</td>
</tr>
</tbody>
</table>
<h3 id="输出阶段"><a href="#输出阶段" class="headerlink" title="输出阶段"></a>输出阶段</h3><table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">should-emit</td>
<td style="text-align:center">所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td>
</tr>
<tr>
<td style="text-align:center">emit</td>
<td style="text-align:center">确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td>
</tr>
<tr>
<td style="text-align:center">after-emit</td>
<td style="text-align:center">文件输出完毕。</td>
</tr>
<tr>
<td style="text-align:center">done</td>
<td style="text-align:center">成功完成一次完成的编译和输出流程。</td>
</tr>
<tr>
<td style="text-align:center">failed</td>
<td style="text-align:center">如果在编译和输出流程中遇到异常导致 <code>Webpack</code> 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</td>
</tr>
</tbody>
</table>
<h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><hr>
<p><code>Webpack</code>可以将其理解是一种基于<strong>事件流</strong>的编程范例，一个插件<strong>合集</strong>。而将这些插件控制在<code>webapck</code>事件流上的运行的就是<code>webpack</code>自己写的基础类<code>Tapable</code>。<code>Webpack</code> 的<strong>事件流</strong>机制应用了<strong>观察者模式</strong>，和 <code>Node.js</code> 中的 <code>EventEmitter</code>非常相似。<br><strong>Tapable 有四组成员函数</strong>：</p>
<ul>
<li><strong>plugin(name:string, handler:function)</strong>：允许将一个自定义插件注册到 <code>Tapable</code> 实例 的事件中。它的行为和 <code>EventEmitter</code> 的 <code>on()</code> 方法相似，用来注册一个<strong>处理函数/监听器</strong>，来在<strong>信号/事件</strong>发生时做一些事情。</li>
<li><strong>apply(…pluginInstances</strong>: <code>(AnyPlugin|function)[])：AnyPlugin</code> 应该是一个拥有 <code>apply</code> 方法的类（也可以是一个对象，但是不常见），或者只是一个包含注册代码的函数。这个方法只调用插件的定义，从而将真正的事件监听器可以注册到 <code>Tapable</code> 实例的注册列表中。</li>
<li><strong>applyPlugins*(name:string, …)</strong>：<code>Tapable</code> 实例可以通过使用这些函数，在指定的 <code>hash</code> 下应用所有的插件。这一组方法的行为和 <code>EventEmitter</code> 的 <code>emit()</code> 方法相似，使用多种策略细致地控制事件的触发。</li>
<li><strong>mixin(pt: Object)</strong>：一个简单地方法，使用混入而不是继承的方式扩展 <code>Tapable</code> 的原型。</li>
</ul>
<p>上面核心的对象 <code>Compiler</code>、<code>Compilation</code>等都是继承于<code>Tabable</code>类。可以直接在 <code>Compiler</code> 和 <code>Compilation</code> 对象上广播和监听器，方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 广播出事件</span></span><br><span class="line"><span class="comment">* event-name 为事件名称，注意不要和现有的事件重名</span></span><br><span class="line"><span class="comment">* params 为附带的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.apply(<span class="string">'event-name'</span>,params);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。</span></span><br><span class="line"><span class="comment">* 同时函数中的 params 参数为广播事件时附带的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.plugin(<span class="string">'event-name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  doSomeThing();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同理，<code>compilation.apply</code> 和 <code>compilation.plugin</code> 使用方法和上面一致。</p>
<p><a href="https://github.com/webpack/tapable" target="_blank" rel="noopener">tapable</a>库暴露了很多Hook（钩子）类，为插件提供挂载的钩子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> &#123;</span><br><span class="line">   SyncHook,</span><br><span class="line">   SyncBailHook,</span><br><span class="line">   SyncWaterfallHook,</span><br><span class="line">   SyncLoopHook,</span><br><span class="line">   AsyncParallelHook,</span><br><span class="line">   AsyncParallelBailHook,</span><br><span class="line">   AsyncSeriesHook,</span><br><span class="line">   AsyncSeriesBailHook,</span><br><span class="line">   AsyncSeriesWaterfallHook</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br></pre></td></tr></table></figure>
<p>如下图所示tapable上的钩子：<br><img src="../../images/webpack/webpack-3-4.png" alt="webpack-flow"></p>
<p>tabable的提供了两类绑定钩子的方式：</p>
<ul>
<li><strong>AsyncHook(异步钩子)</strong>： <strong>绑定</strong>可以通过<code>tapAsync</code> 或 <code>tapPromise</code>（以及 <code>tap</code>），<strong>执行</strong>通过 <code>callAsync</code>、<code>promise</code>；</li>
<li><strong>syncHook(钩子)</strong>： <strong>绑定</strong>可以通过<code>tap</code>，<strong>执行</strong>通过 <code>call</code>；</li>
</ul>
<p>具体的用法请看<a href="https://github.com/webpack/tapable#tapable" target="_blank" rel="noopener">Tapable</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ol>
<li><strong>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</strong>；</li>
<li><strong>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</strong>；</li>
<li><strong>确定入口：根据配置中的 entry 找出所有的入口文件</strong>；</li>
<li><strong>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</strong>；</li>
<li><strong>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</strong>；</li>
<li><strong>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</strong>；</li>
<li><strong>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</strong>。</li>
</ol>
<p>同时我们也了解了webpack中比较核心的几个概念<code>compiler</code>、<code>compilation</code>、<code>tapable</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MjUxNjA4Mw==&amp;mid=2247484465&amp;idx=1&amp;sn=13e809bbad1aded06089f9f90f54280f&amp;chksm=ec017daddb76f4bb998db48b7b60ef61ce69f18a389b5d371f5abdec6af6e1e3819eaceb2194&amp;mpshare=1&amp;scene=1&amp;srcid=0724xrEwBfryLPOe61Ki51Oi&amp;sharer_sharetime=1563935222192&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b&amp;key=4a20f31792598319b088ea3b82b6daf06773b3d7ffa59c0bb5d9ec0f7388ff5fed13910f4aacc420e4591fbc921b91b777b3904d18b7e88b4a3fee042e9d5df41b3746bc994433035daadda223075e98&amp;ascene=1&amp;uin=MTY4MzM5MzY2Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=4jkq%2FusyjX7RQyhKNRuqJ4ao5EVltuqP5Geyej5jy%2BYFRnQMWIS09yOSU9wir8dM" target="_blank" rel="noopener">webpack学习笔记（原理，实现loader和插件）</a><br><a href="https://github.com/lihongxun945/diving-into-webpack/blob/master/6-process-pipe-line.md" target="_blank" rel="noopener">webpack 源码分析六：webpack 处理流程分析</a><br><a href="https://juejin.im/post/5be9297351882516f5786404" target="_blank" rel="noopener">Webpack原理与实践（一）：打包流程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的依赖分析、依赖加载 (未完成)</title>
    <url>/blog/webpack/webpack-rely-load.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-router (未完成)</title>
    <url>/blog/vue/vue-router.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中的events源码分析 (未完成)</title>
    <url>/blog/vue/vue-click-eventbus.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型（六）多种数据类型判断方法</title>
    <url>/blog/javascript/javascript-bool-type.html</url>
    <content><![CDATA[<p><strong><em>日极则仄，月满则亏。物极则反，命曰环流。——《管子·白心》</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript数据类型（一） 常见数据类型</a><br><a href="/blog/javascript/javascript-type-one-question.html">JavaScript数据类型（二） 类型转换</a><br><a href="/blog/javascript/javascript-type-one-questionone.html">JavaScript数据类型（三）常见的面试题</a><br><a href="/blog/javascript/javascript-IF-False-options.html">JavaScript数据类型（四）IF 转换规则</a><br><a href="/blog/javascript/javascript-false-true.html">JavaScript数据类型（五）== 混乱的转换规则</a><br><a href="/blog/javascript/javascript-bool-type.html">JavaScript数据类型（六）多种数据类型判断方法</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>在ECMAScript规范中，共定义了7种数据类型，分为基本数据类型和引用类型两大类，如下所示：</p>
<blockquote>
<p>基本类型： <strong>Null、Undefined、Symbol（ES6）、Number、Boolean、String</strong><br>引用类型： <strong>Obeject、Array、Date</strong>等等</p>
</blockquote>
<ul>
<li><p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在<font color="#ff502c">栈</font>中，即按值访问。</p>
</li>
<li><p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在<font color="#ff502c">堆(heap)</font>中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。</p>
</li>
</ul>
<h3 id="原始值-primitive-values"><a href="#原始值-primitive-values" class="headerlink" title="原始值( primitive values )"></a>原始值( primitive values )</h3><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。</p>
<p>注: <strong>想看Java​Script 数据类型和数据结构 可以在： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">mdn</a>中查看</strong></p>
<p>有四种方法可以判断Java​Script中的类型如：</p>
<ul>
<li><strong>typeof运算符</strong></li>
<li><strong>instanceof运算符</strong></li>
<li><strong>constructor(原型对象的构造函数)</strong></li>
<li><strong>toString(内置[[Class]]属性)、Array.isArray()</strong><br>下面就分别来讲一下他们能判断什么类型，判断不了什么类型，因为什么还有一些注意事项。</li>
</ul>
<h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><hr>
<h3 id="typeof语法"><a href="#typeof语法" class="headerlink" title="typeof语法"></a>typeof语法</h3><p>typeof运算符后跟操作数：</p>
<blockquote>
<p>typeof operand<br>or<br>typeof (operand)</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>operand 是一个表达式，表示对象或<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive" target="_blank" rel="noopener">原始值</a>，其类型将被返回。</p>
<p>下面表格总结了typeof可能返回的值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">“undefined”</td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center">“object”</td>
</tr>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">“boolean”</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">“number”</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">“string”</td>
</tr>
<tr>
<td style="text-align:center">Symbol （ECMAScript 6 新增）</td>
<td style="text-align:center">“symbol”</td>
</tr>
<tr>
<td style="text-align:center">宿主对象（由JS环境提供）</td>
<td style="text-align:center">Implementation-dependent</td>
</tr>
<tr>
<td style="text-align:center">函数对象（[[Call]] 在ECMA-262条款中实现了）</td>
<td style="text-align:center">“function”</td>
</tr>
<tr>
<td style="text-align:center">任何其他对象</td>
<td style="text-align:center">“object”</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'foo'</span>); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>在这其中要注意的是：</p>
<ul>
<li>其中<code>null</code>返回了<code>object</code>是因为<code>JavaScript</code>语言设计遗留的问题。</li>
<li>对于引用类型，除 <code>function</code> 以外，一律返回 <code>object</code> 类型</li>
<li>对于 <code>function</code> 返回 <code>function</code></li>
</ul>
<h3 id="typeof-null"><a href="#typeof-null" class="headerlink" title="typeof null"></a>typeof null</h3><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。由于 <code>null</code> 代表的是机器代码的<strong>空指针</strong>，一个对象类型的引用，值是零（大多数平台下值为 0x00）。<strong>自然前三位也是0</strong>，所以执行<code>typeof</code>时会返回<code>&quot;object&quot;</code>.</p>
<p>这个bug是第一版Javascript留下来的。在这个版本，数值是以<strong>32字节存储的</strong>，由标志位（1~3个字节）和数值组成。标志位存储的是低位的数据。这里有五种标志位：</p>
<ul>
<li><strong>000：对象，数据是对象的应用。</strong></li>
<li><strong>1：整型，数据是31位带符号整数。</strong></li>
<li><strong>010：双精度类型，数据是双精度数字。</strong></li>
<li><strong>100：字符串，数据是字符串。</strong></li>
<li><strong>110：布尔类型，数据是布尔值。</strong><br>最低位有一位，那么标志位只有一个1字节长度；或者是零位，标志位有3个字节长度，多出两个了字节，一共多出四种类型。</li>
</ul>
<p><strong>原文地址<a href="http://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">英文</a></strong><br><strong>翻译地址<a href="http://www.cnblogs.com/xiaoheimiaoer/p/4572558.html" target="_blank" rel="noopener">中文</a></strong></p>
<blockquote>
<p><strong>判断null类型也很简单，就用null === null来判断</strong><br><strong>看typeof所有的类型细节请看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">mdn-typeof</a></strong></p>
</blockquote>
<h2 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h2><hr>
<p><strong>instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</strong>.<br>原始值使用<code>instanceof</code>都会返回<code>false</code>，如果使用<code>new</code> 声明 是可以检测出来。对于是使用<code>new</code>声明的类型，它还可以检测出多层继承关系。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p>object instanceof constructor</p>
</blockquote>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>object 要检测的对象<br>constructor 某个构造函数</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 object 的原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'123'</span>;</span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C(); </span><br><span class="line">c1 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(c1) === C.prototype</span></span><br><span class="line"></span><br><span class="line">C.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">c1 <span class="keyword">instanceof</span> C; <span class="comment">// false, C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c2 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(c2) === C.prototype</span></span><br><span class="line"></span><br><span class="line">c2.__proto__ = &#123;&#125;; <span class="comment">// 借助于非标准的__proto__伪属性</span></span><br><span class="line"></span><br><span class="line">c2 <span class="keyword">instanceof</span> C; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>注：<strong>需要注意的是，如果表达式 obj instanceof Foo 返回true，则并不意味着该表达式会永远返回true，因为Foo.prototype属性的值有可能会改变，改变之后的值很有可能不存在于obj的原型链上，这时原表达式的值就会成为false。另外一种情况下，原表达式的值也会改变，就是改变对象obj的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的<strong>proto</strong>伪属性，是可以实现的。比如执行obj.<strong>proto</strong> = {}之后，obj instanceof Foo就会返回false了。</strong></p>
<h3 id="、Array、Object-三者之间的关系"><a href="#、Array、Object-三者之间的关系" class="headerlink" title="[]、Array、Object 三者之间的关系"></a>[]、Array、Object 三者之间的关系</h3><p>从 <code>instanceof</code> 能够判断出 <code>[ ].__proto__</code> 指向 <code>Array.prototype</code>，而 <code>Array.prototype.__proto__</code> 又指向了<code>Object.prototype</code>，最终 <code>Object.prototype.__proto__</code> 指向了<code>null</code>，标志着原型链的结束。因此，<code>[]、Array、Object</code> 就在内部形成了一条原型链：</p>
<p><img src="../../images/javascript/javascript1.png" alt="[]-Array-Object" width="60%" style="margin: 0 auto;"></p>
<p>从原型链可以看出，<code>[]</code> 的 <code>__proto__</code> 直接指向<code>Array.prototype</code>，间接指向 <code>Object.prototype</code>，所以按照 <code>instanceof</code> 的判断规则，<code>[]</code> 就是<code>Object</code>的实例。依次类推，类似的 <code>new Date()、new Person()</code> 也会形成一条对应的原型链 。<strong>因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p>
<h3 id="instanceof和多全局对象-多个frame或多个window之间的交互"><a href="#instanceof和多全局对象-多个frame或多个window之间的交互" class="headerlink" title="instanceof和多全局对象(多个frame或多个window之间的交互)"></a>instanceof和多全局对象(多个frame或多个window之间的交互)</h3><p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 <code>[] instanceof window.frames[0].Array</code> 会返回<code>false</code>，因为 <code>Array.prototype !== window.frames[0].Array.prototype</code>，并且数组从前者继承。</p>
<p>实际上你可以通过使用 <code>Array.isArray(myObj)</code> 或者<code>Object.prototype.toString.call(myObj) === &quot;[object Array]&quot;</code>来安全的检测传过来的对象是否是一个数组。</p>
<h3 id="实现一个简单的instanceof"><a href="#实现一个简单的instanceof" class="headerlink" title="实现一个简单的instanceof"></a>实现一个简单的instanceof</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// L instanceof R</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123; <span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line">  <span class="keyword">var</span> O = R.prototype; <span class="comment">// 取的R的显式原型</span></span><br><span class="line">  L = L.__proto__; <span class="comment">// 取的L的隐式原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L === <span class="literal">null</span>) &#123; <span class="comment">// 已找到顶层</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (O === L) &#123; <span class="comment">// 当 O严格等于L时，返回true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L = L.__proto__; <span class="comment">// 继续向上一层原型链查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">instance_of([], <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line">instance_of([], <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="constructor-原型对象的构造函数"><a href="#constructor-原型对象的构造函数" class="headerlink" title="constructor(原型对象的构造函数)"></a>constructor(原型对象的构造函数)</h2><p>当一个函数 F被定义时，JS引擎会为F添加 <code>prototype</code> 原型，然后再在 <code>prototype</code>上添加一个 <code>constructor</code> 属性，并让其指向 F 的引用。如下所示：</p>
<p><img src="../../images/javascript/javascript2.png" alt="constructor" style="margin: 0 auto;"></p>
<p>当执行 <code>var f = new F()</code> 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 <code>constructor</code> 传递到了 f 上，因此 <code>f.constructor === F</code>.</p>
<p>可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p>
<p>实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span>.constructor === <span class="built_in">String</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="keyword">new</span> Data().constructor === <span class="built_in">Date</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>nul</code>l 和 <code>undefined</code> 是无效的对象，因此是不会有 <code>constructor</code> 存在的，这两种类型的数据需要通过其他方式来判断</li>
<li>函数的 <code>constructor</code> 是不稳定的，这个主要体现在自定义对象上，当开发者重写 <code>prototype</code> 后，原有的 <code>constructor</code> 引用会丢失，constructor 会默认为 Object</li>
</ul>
<p>总结： <strong>手动设置或更新构造函数可能会导致不同且有时令人困惑的后果。为了防止它，只需在每个特定情况下定义构造函数的角色。在大多数情况下，不使用构造函数，并且不需要重新分配构造函数。</strong></p>
<h2 id="toString-内置-Class-属性"><a href="#toString-内置-Class-属性" class="headerlink" title="toString(内置[[Class]]属性)"></a>toString(内置[[Class]]属性)</h2><hr>
<p>原型上的<code>toString()</code> 方法返回一个表示该对象的字符串。<br>调用该方法，默认返回当前对象的 <code>[[Class]]</code> 。这是一个内部属性，其格式为 <code>[object Xxx]</code> ，其中 Xxx 就是对象的类型。<br>对于 Object 对象，直接调用 <code>toString()</code>  就能返回 <code>[object Object]</code> 。而对于其他对象，则需要通过 <code>call / apply</code> 来调用才能返回正确的类型信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure>
<p>注：<strong>但是它不能检测非原生构造函数的构造函数名。</strong></p>
<blockquote>
<p><code>jquery</code>中的<code>$.type</code>原理就是通过<code>Object.prototype.toString.call()</code>;<br><code>Array.isArray</code>其实也是通过<code>[[Class]]</code>来判定当前是否维数组.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>以上就是已知的4中检测类型的方法，那个方法都不识最完美的，就看你要检测的是那个对应的类型，就用对应的检测方法。</strong></p>
<p>我们可以通过四种方式获取数据类型：</p>
<ul>
<li><font color="#ff502c">typeof运算符，用来区分对象和原始值</font></li>
<li><font color="#ff502c">instanceof运算符，用来分类对象</font></li>
<li><font color="#ff502c">constructor，用来创建实例对象的 Object 构造函数的引用</font></li>
<li><font color="#ff502c">[[Class]]是一个内部属性字符串，用来给对象分类</font>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/onepixel/p/5126046.html" target="_blank" rel="noopener">判断JS数据类型的四种方法</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">MDN 中的constructor</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener">MDN 中的toString</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">MDN 中的typeof</a><br><a href="https://segmentfault.com/a/1190000015264821" target="_blank" rel="noopener">js判断数据类型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue渲染父子组件中生命周期执行顺序</title>
    <url>/blog/vue/vue-list-two.html</url>
    <content><![CDATA[<h2 id="vue-生命周期"><a href="#vue-生命周期" class="headerlink" title="vue 生命周期"></a>vue 生命周期</h2><hr>
<p>在另一片博客中我已经有详细讲过<a href="/blog/vue/vue-list-one.html">vue 生命周期</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"setParentMessage"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">"parentMsgOne"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">"parentMsgTwo"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> mixins = &#123;</span></span><br><span class="line"><span class="javascript">            props: [<span class="string">'msg'</span>],</span></span><br><span class="line"><span class="xml">            template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>from child: &#123;&#123;childMsg&#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">            data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    childMsg: <span class="keyword">this</span>.msg</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            beforeCreate() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---beforeCreate'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            created() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---created'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            beforeMount() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---beforeMount'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            mounted() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---mounted'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---beforeUpdate'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            updated() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---updated'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---beforeDestroy'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            destroyed() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---destroyed'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'child'</span>, &#123;</span></span><br><span class="line">            mixins: [mixins]</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">            data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    parentMsgOne: <span class="string">'childrenOne'</span>,</span></span><br><span class="line"><span class="javascript">                    parentMsgTwo: <span class="string">'childrenTwo'</span>,</span></span><br><span class="line"><span class="javascript">                    message: <span class="string">'parent'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                setParentMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.message = <span class="string">'parent--message--更新'</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            beforeCreate() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'parent---beforeCreate'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            created() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'parent---created'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            beforeMount() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'parent---beforeMount'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            mounted() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'parent---mounted'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'parent---beforeUpdate'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            updated() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'parent---updated'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'parent---beforeDestroy'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            destroyed() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">'parent---destroyed'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码执行结果如下：</p>
<p><img src="../../images/vue/vue-hook4.png" alt="vue-hook" width="100%" style="margin: 0 auto;"></p>
<h3 id="beforeCreate-到-mounted"><a href="#beforeCreate-到-mounted" class="headerlink" title=" beforeCreate 到 mounted "></a><strong> beforeCreate 到 mounted </strong></h3><ol>
<li>先创建父组件<br><code>beforeCreate</code><br><code>created</code><br><code>beforeMount</code></li>
<li>按顺序创建子组件<br><code>beforeCreate</code><br><code>created</code><br><code>beforeMount</code></li>
<li>先挂载子组件<br><code>mounted</code></li>
<li>在挂载父组件<br><code>mounted</code></li>
</ol>
<p>总结：<font color="#ff502c">从创建到挂载，是从外到内，再由内到外</font></p>
<h3 id="beforeUpdate-到-updated"><a href="#beforeUpdate-到-updated" class="headerlink" title=" beforeUpdate 到 updated "></a><strong> beforeUpdate 到 updated </strong></h3><blockquote>
<p>注： <font color="#ff502c">只有在标签上绑定了 data 时，data 发生改变，才会触发 updated 钩子函数。如果只是在控制台改变 data，而没有反馈到视图上，则无法触发。</font></p>
</blockquote>
<ol>
<li>父组件点击事件更新 <code>data</code> 中的数据<br><img src="../../images/vue/vue-hook5.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>他不会重新渲染子组件</li>
</ol>
<blockquote>
<p>注：<font color="#ff502c">react 中如果父组件状态更新，子组件也会跟着更新。稍后的文章会讲怎么解决这种问题。</font></p>
</blockquote>
<ol start="2">
<li>子组件点击事件更新 <code>data</code> 中的数据</li>
</ol>
<p><img src="../../images/vue/vue-hook6.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>这个他也不会重新选然父组件</p>
<blockquote>
<p>注： <font color="#ff502c">如果是 mixins 的话当 data 中的数据改变时，不会触发子组件中的 updated 函数。触发的顺序仍然是 mixins 先于组件</font></p>
</blockquote>
<blockquote>
<p>总结：<font color="#ff502c">父子组件 update 互相不影响</font></p>
</blockquote>
<h3 id="beforeDestroy-到-destroy"><a href="#beforeDestroy-到-destroy" class="headerlink" title=" beforeDestroy 到 destroy "></a><strong> beforeDestroy 到 destroy </strong></h3><p>在浏览器中执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.$destroy();</span><br></pre></td></tr></table></figure>
<p><img src="../../images/vue/vue-hook7.png" alt="vue-hook" width="50%" style="margin: 0 auto;"></p>
<ol>
<li>父组件先<code>beforeDestroy</code></li>
<li>子组件<code>beforeDestroy</code></li>
<li>子组件<code>destroyed</code></li>
<li>父组件<code>destroyed</code></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体来说<strong>vue父子组件</strong>生命周期执行顺序为<font color="#ff502c">从外到内，再从内到外</font>,</p>
<font color="#ff502c"><strong>总结：生命周期遵从“从外到内，再从内到外，mixins先于组件”的原则。</strong></font>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期详解。</title>
    <url>/blog/vue/vue-list-one.html</url>
    <content><![CDATA[<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><hr>
<p><a href="/blog/vue/vue-list-two.html">vue父子组件渲染生命周期执行循序</a></p>
<h3 id="Vue声明周期表格"><a href="#Vue声明周期表格" class="headerlink" title="Vue声明周期表格"></a>Vue声明周期表格</h3><p>一说到Vue的生命周期，大家都能说上来一点.我自己会随着自己对Vue的深入了解，不断的完善自己对Vue的整体认识。<br>本文Vue的版本 <font color="#ff502c">Vue 2.x</font> 官方生命周期图解：<br><!-- ![vue-hook]( 200x800) --><br><img src="../../images/vue/vue-hook.png" alt="vue-hook" width="60%" style="margin: 0 auto;"></p>
<table>
<thead>
<tr>
<th style="text-align:center">生命周期钩子</th>
<th style="text-align:center">详细</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">beforeCreate</td>
<td style="text-align:center">在实例初始化之后，数据观测(data observer) 和 event/watcher事件配置之前被调用。</td>
</tr>
<tr>
<td style="text-align:center">created</td>
<td style="text-align:center">在实例创建完成后被立即调用。在这一步,实例已经完成以下配置：数据观测（data observer），属性和方法的运算，watch/event事件回调。然而，挂载阶段还没有开始，<font color="#ff502c">$el</font>属性目前不可见。</td>
</tr>
<tr>
<td style="text-align:center">beforeMount</td>
<td style="text-align:center">在挂载开始之前被调用：相关的 <font color="#ff502c">render</font> 函数首次被调用。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td style="text-align:center">mounted</td>
<td style="text-align:center"><font color="#ff502c">el</font>被新创建的<font color="#ff502c">vm.$el</font>替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 <br> 注意 mounted <strong>不会</strong> 承诺所有的子组件也一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td style="text-align:center">beforeUpdate</td>
<td style="text-align:center">数据更新时调用，发生在虚拟DOM打补丁之前。这里适合在更新之前访问现在的DOM，比如手动移除已添加的事件监听器。<strong>该钩子在服务器渲染期间不被调用，因为只有初次渲染会在服务器端运行</strong></td>
</tr>
<tr>
<td style="text-align:center">updated</td>
<td style="text-align:center">由于数据更改导致的虚拟dom重新渲染和打补丁，在这之后会调用该钩子。<br> 当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然后在大多数情况下，你应该避免在此期间更改状态。如果要相应的状态改变，通常最好使用 <a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener"><font color="#ff502c">计算属性</font></a>或<a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener"><font color="#ff502c">watcher</font></a>取而代之。 <br> 注意 <font color="#ff502c">updated</font> 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 <font color="#ff502c">updated</font>。</td>
</tr>
<tr>
<td style="text-align:center">beforeDestory</td>
<td style="text-align:center">实例销毁之前调用。在这一步，实例仍然完全可用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td style="text-align:center">destoryed</td>
<td style="text-align:center">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
</tbody>
</table>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"setMessage"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        message: <span class="string">'Vue的生命周期'</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line"><span class="javascript">        setMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.message = <span class="string">'updateMessage'</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.group(<span class="string">'------beforeCreate创建前状态------'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// undefined</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      created() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.group(<span class="string">'------created创建完毕状态------'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data); <span class="comment">// Object ** 已经初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message); <span class="comment">// Vue的生命周期 ** 已经初始化</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">// 当不存在el的时候只会执行到前面两个生命周期</span></span></span><br><span class="line">      beforeMount() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.group(<span class="string">'------beforeMount挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// 已经初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// 已经初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// 已经初始化</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      mounted() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.group(<span class="string">'------mounted挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el); <span class="comment">// 已经初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data); <span class="comment">// 已经初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message); <span class="comment">// 已经初始化</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.group(<span class="string">'------beforeUpdate挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      updated() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.group(<span class="string">'------updated挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.group(<span class="string">'------beforeDestroy挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      destroyed() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.group(<span class="string">'------destroyed挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>1、beforeMount生命周期之前</strong></p>
<p><img src="../../images/vue/vue-hook1.png" alt="vue-hook" width="60%" style="margin: 0 auto;"><br>在这个调用<font color="#ff502c">beforeMount</font>判断vm.$options是否存在<font color="#ff502c">el</font>，如果没有的话则会<font color="#ff502c">停止编译</font>，也就意味着<font color="#ff502c">停止了生命周期</font>，直到在改vue实例上调用<font color="#ff502c">vm.$mount(el)</font>。</p>
<p>vue的实现代码：如果存在<code>el</code>时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原型上的<code>$mount</code>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm,</span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  vm.$el = el;</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们注释掉上面<code>el</code>属性的代码,并且不再后续调用<code>vm.$mount(el)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// el: '#app'</span></span><br></pre></td></tr></table></figure>
<p>如果没有<code>el</code>他只会执行前两个生命周期<font color="#ff502c">beforeCreate、created</font>，如果我们在后续调用了<font color="#ff502c">vm.$mount(el)</font>，可以发现代码继续向下执行了</p>
<p>在浏览器上调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>
<p>他就会接着执行下去</p>
<p><strong>2、template属性、outer html、render函数三个优先级</strong></p>
<ol>
<li>如果直接调用<code>render</code>函数，那么他的优先级最高。</li>
<li>如果<code>vue</code>实例对象中有<code>template</code>参数选项，则将其作为模板编译成<code>render</code>函数。</li>
<li>如果没有<code>template</code>选项，则将外部<code>HTML</code>作为模板编译。</li>
<li>可以看到<code>template</code>中的模板优先级要高于<code>outer HTML</code>的优先级。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    // 如果render、template都不存在 会显示这个</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message + '这是在outer HTML中的'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    // 如果三个都存在 最终会显示 <span class="tag">&lt;<span class="name">h1</span>&gt;</span>this is createElement<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">      template: <span class="string">"&lt;h1&gt;&#123;&#123;message +'这是在template中的'&#125;&#125;&lt;/h1&gt;"</span>, <span class="comment">// 如果render不存在 只有 template 会显示这个</span></span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        message: <span class="string">'Vue的生命周期'</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> createElement(<span class="string">'h1'</span>, <span class="string">'this is createElement'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3、mounted</strong><br>可以看到此时是给<code>vue</code>实例对象添加<code>$el</code>成员，并且替换掉挂在的<code>DOM</code>元素。因为在之前<code>console</code>中打印的结果可以看到<code>beforeMount</code>之前<code>el</code>上还是<code>undefined</code></p>
<p><strong>4、mounted</strong><br>在<code>mounted</code>之前<code>h1</code>中还是通过<code></code>进行占位的，因为此时还有挂在到页面上，还是<code>JavaScript</code>中的虚拟<code>DOM</code>形式存在的。在<code>mounted</code>之后可以看到<code>h1</code>中的内容发生了变化。</p>
<p><strong>5、beforeUpdate和updated</strong><br>当<code>vue</code>发现<code>data</code>中的数据发生了改变，会触发对应组件的重新渲染，先后调用<code>beforeUpdate</code>和<code>updated</code>钩子函数。我们点击当前的<code>p</code>标签就会触发<code>data</code>中的<code>message</code>更新</p>
<p><strong>6、beforeDestroy和destroyed</strong><br><code>beforeDestroy</code> 钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。<br><code>destroyed</code> 钩子函数在<code>Vue</code> 实例销毁后调用。调用后，<code>Vue</code> 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://segmentfault.com/a/1190000011381906?utm_source=tag-newest" target="_blank" rel="noopener">详解vue生命周期</a><br><a href="https://juejin.im/post/5c6d48e36fb9a049eb3c84ff" target="_blank" rel="noopener">详解 Vue 生命周期实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>css3中flex的所有属性详解</title>
    <url>/blog/css/css3-flex.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<strong>H5</strong>页面或者移动端书写<code>css</code>时，都会推荐你使用<code>flex</code>布局来实现，因为<code>flex</code>在移动端兼容性还是比较好的，最主要的是实现布局比较简单。</p>
<p>但是在真正的实战中很多人在不完全了解<strong>flex</strong>中的属性导致滥用，所以有了这篇文章，加深自己对<strong>flex</strong>的记忆。</p>
<h2 id="什么是FC"><a href="#什么是FC" class="headerlink" title="什么是FC?"></a>什么是FC?</h2><p><strong>FC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念</strong>。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。<br>常见的<strong>FC</strong>有什么比如<strong>BFC</strong>、<strong>IFC</strong>、<strong>FFC</strong>、<strong>GFC</strong>，在以前的博客里面有记录过<strong>BFC</strong>，这里就不多做赘述只记录<strong>FFC</strong>。</p>
<h3 id="FFC是什么？"><a href="#FFC是什么？" class="headerlink" title="FFC是什么？"></a>FFC是什么？</h3><p><strong>Flex</strong>遵循的是<strong>FFC</strong>的规则，<strong>FFC</strong>又是什么呢？<br><code>FFC(Flex Formatting Contexts)</code>直译为”自适应格式化上下文”，<code>display</code>值为<code>flex</code>或者<code>inline-flex</code>的元素将会生成自适应容器（<code>flex container</code>）。</p>
<p><strong>布局规则</strong></p>
<ul>
<li>设置为 <code>flex</code> 的容器被渲染为一个块级元素</li>
<li>设置为 <code>inline-flex</code> 的容器则渲染为一个行内元素</li>
<li><strong>弹性容器中的每一个子元素都是一个弹性项目</strong>。弹性项目可以是任意数量的。弹性容器外和弹性项目内的一切元素都不受影响。简单地说，Flexbox 定义了弹性容器内弹性项目该如何布局</li>
</ul>
<p>基本上<strong>FFC</strong>和<a href="/blog/css/css-bfc.html"><strong>BFC</strong></a>是比较类似的这里只记录它们之前的区别，区别如下：</p>
<ul>
<li><strong>FlexBox</strong>不支持<code>::first-line</code>和<code>::first-letter</code>这两种伪元素</li>
<li><code>vertical-align</code>对<code>FlexBox</code>中的子元素是没有效果的</li>
<li><code>float</code>和<code>clear</code>属性对<code>FlexBox</code>中的子元素是没有效果的，对<code>FlexBox</code>是有作用的</li>
<li>多烂布局<code>Cloumn-*</code>在<code>FlexBox</code>中也是无效的</li>
<li><code>FlexBox</code>下的子元素不会继承父级容器的宽</li>
</ul>
<h2 id="Flex中的概念"><a href="#Flex中的概念" class="headerlink" title="Flex中的概念"></a>Flex中的概念</h2><p>给<code>div</code>元素设置<code>display</code>值为<code>flex</code>或者<code>inline-flex</code>的元素将会生成自适应容器（<code>flex container</code>）。<br><strong>Flex</strong>有很多属性，大致可以分为两类一类作用在<strong>flex容器上</strong>、一类作用在<strong>flex子项上</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">作用在flex容器上</th>
<th style="text-align:center">作用在flex子项上</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flex-direction (设置主轴方向)</td>
<td style="text-align:center">order (在父容器中的排序)</td>
</tr>
<tr>
<td style="text-align:center">flex-wrap (主轴是否换行)</td>
<td style="text-align:center">flex-grow (当有空白区域，是否站空白区域，是否扩展)</td>
</tr>
<tr>
<td style="text-align:center">flex-flow (flex-direction flex-wrap)</td>
<td style="text-align:center">flex-shrink (当空间过小时，是否收缩自身，是否收缩)</td>
</tr>
<tr>
<td style="text-align:center">justify-content (水平方向子项对齐和分布方式)</td>
<td style="text-align:center">flex-basis (在分配剩余空间之前元素的默认大小)</td>
</tr>
<tr>
<td style="text-align:center">align-items (垂直方向子项对齐和分布方式)</td>
<td style="text-align:center">flex (flex-grow flex-shrink flex-basis)</td>
</tr>
<tr>
<td style="text-align:center">align-content (水平方向flex子项的对齐和分布方式，于justify-content类似且对立)</td>
<td style="text-align:center">align-self (自己本身的垂直对齐方式)</td>
</tr>
</tbody>
</table>
<p><img src="../../images/css/flex-1-1.png" alt="flex-main"></p>
<p>采用Flex布局的元素，称为Flex容器（flex container）,简称“容器”。它的所有子元素自动成为容器成员，成为Flex项目（flex item）,简称“项目”。</p>
<p>容器默认存在两根轴：<strong>水平的主轴（main axis）和垂直的交叉轴（cross axis）</strong>。<br>主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；<br>交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<p>项目默认沿<strong>主轴排列</strong>。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<p>本文上所用到的<code>html</code>结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox-item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox-item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox-item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>css</code>基础结构如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox-item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: cadetblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: coral;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作用在flex容器上的CSS属性"><a href="#作用在flex容器上的CSS属性" class="headerlink" title="作用在flex容器上的CSS属性"></a>作用在flex容器上的CSS属性</h2><hr>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><code>flex-direction</code>用来控制子项整体布局方向，是从左往右还是从右往左，是从上往下还是从下往上。<br>语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个值</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。<br><img src="../../images/css/flex-1-2.png" alt="flex-main"></li>
<li>row-reverse：主轴为水平方向，起点在右端。<br><img src="../../images/css/flex-1-3.png" alt="flex-main"></li>
<li>column：主轴为垂直方向，起点在上沿。<br><img src="../../images/css/flex-1-4.png" alt="flex-main"></li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code>用来控制子项整体单行显示还是换行显示，如果换行，则下面一行是否反方向显示。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有三个值如下：</p>
<p><strong>nowrap</strong><br>默认值，表示单行显示，不换行。于是很容易出现宽度溢出的场景，其渲染表现比较复杂，需要对CSS3宽度有一定了解，可以阅读“理解CSS3 max/min-content及fit-content等width值”这篇文章。具体表现如下（以水平布局举例）：</p>
<ul>
<li>flex子项最小内容宽度min-content之和大于flex容器宽度，则内容溢出，表现和white-space:nowrap类似。</li>
<li>如果flex子项最小内容宽度min-content之和小于flex容器宽度，则：<ul>
<li>flex子项默认的fit-content宽度之和大于flex容器宽度，则flex子项宽度收缩，正好填满flex容器，内容不溢出。</li>
<li>flex子项默认的fit-content宽度之和小于flex容器宽度，则flex子项以fit-content宽度正常显示，内容不溢出。</li>
</ul>
</li>
</ul>
<p><strong>wrap</strong><br>宽度不足换行显示。<br><img src="../../images/css/flex-1-5.png" alt="flex-main"><br><strong>wrap-reverse</strong><br>宽度不足换行显示，但是是<strong>从下往上开始</strong>，也就是原本换行在<strong>下面</strong>的子项现在跑到<strong>上面</strong>。<br><img src="../../images/css/flex-1-6.png" alt="flex-main"></p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>的缩写，表示<strong>flex布局</strong>的<strong>flow流动</strong>特性，语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;<span class="string">'flex-direction'</span>&gt; || &lt;<span class="string">'flex-wrap'</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例说明如果设置代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row-reverse wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="../../images/css/flex-1-7.png" alt="flex-main"></p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>属性决定了<strong>水平方向子项的对齐和分布方式</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li><code>flex-start</code>: <strong>默认值。逻辑CSS属性值，与文档流方向相关。默认表现为左对齐</strong>。</li>
<li><code>flex-end</code>: <strong>逻辑CSS属性值，与文档流方向相关。默认表现为右对齐</strong>。</li>
<li><code>center</code>: <strong>表现为居中对齐</strong>。<br><img src="../../images/css/flex-1-8.png" alt="flex-main"></li>
<li><code>space-between</code>: <strong>表现为两端对齐。between是中间的意思，意思是多余的空白间距只在元素中间区域分配</strong>。<br><img src="../../images/css/flex-1-9.png" alt="flex-main"></li>
<li><code>space-around</code>: <strong>around是环绕的意思，意思是每个flex子项两侧都环绕互不干扰的等宽的空白间距，最终视觉上边缘两侧的空白只有中间空白宽度一半</strong>。<br><img src="../../images/css/flex-1-10.png" alt="flex-main"></li>
<li><code>space-evenly</code>: <strong>evenly是匀称、平等的意思。也就是视觉上，每个flex子项两侧空白间距完全相等</strong>。<br><img src="../../images/css/flex-1-11.png" alt="flex-main"></li>
</ul>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<p><img src="../../images/css/flex-1-12.png" alt="flex-main"></p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><code>align-content</code>可以看成和<code>justify-content</code>是相似且对立的属性，<code>justify-content</code>指明水平方向flex子项的对齐和分布方式，而<code>align-content</code>则是指明垂直方向每一行<code>flex</code>元素的<strong>对齐和分布方式</strong>。如果所有<code>flex</code>子项只有一行，则<code>align-content</code>属性是没有任何效果的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: stretch | flex-start | flex-end | center | space-between | space-around | space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有7个值，每个值是不同作用如下面所示:</p>
<ul>
<li><code>stretch</code>: 默认值。每一行flex子元素都等比例拉伸。例如，如果共两行flex子元素，则每一行拉伸高度是50%。</li>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：表现为整体垂直居中对齐。</li>
<li><code>space-between</code>：表现为上下两行两端对齐。剩下每一行元素等分剩余空间。</li>
<li><code>space-around</code>：每一行元素上下都享有独立不重叠的空白空间。</li>
<li><code>space-evenly</code>： 每一行元素都完全上下等分。</li>
</ul>
<p><img src="../../images/css/flex-1-13.png" alt="flex-main"></p>
<h2 id="作用在flex子项上的CSS属性"><a href="#作用在flex子项上的CSS属性" class="headerlink" title="作用在flex子项上的CSS属性"></a>作用在flex子项上的CSS属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>可以通过设置<strong>order</strong>改变某一个<strong>flex</strong>子项的排序位置。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth(1)</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* 整数值，默认值是 0 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth(2)</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth(3)</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="../../images/css/flex-1-14.png" alt="flex-main"></p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code>属性中的<code>grow</code>是扩展的意思，扩展的就是<code>flex</code>子项所占据的宽度，扩展所侵占的空间就是除去元素外的剩余的空白间隙。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-grow</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* 数值，可以是小数，默认值是 0 */</span></span><br></pre></td></tr></table></figure>
<p><code>flex-grow</code>不支持负值，默认值是<code>0</code>，表示不占用剩余的空白间隙扩展自己的宽度。如果<code>flex-grow</code>大于<code>0</code>，则<code>flex</code>容器剩余空间的分配就会发生，具体规则如下：</p>
<ul>
<li><p>所有剩余空间总量是<code>1</code>。</p>
</li>
<li><p>如果只有一个<code>flex</code>子项设置了<code>flex-grow</code>属性值：</p>
<ul>
<li>如果<code>flex-grow</code>值小于<code>1</code>，则扩展的空间就总剩余空间和这个比例的计算值。</li>
<li>如果<code>flex-grow</code>值大于<code>1</code>，则独享所有剩余空间。</li>
</ul>
</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-grow" target="_blank" rel="noopener">张鑫旭大佬：具体可参见下面“grow案例1”。</a></p>
<ul>
<li>如果有多个<code>flex</code>子项设置了<code>flex-grow</code>属性值：</li>
<li>如果<code>flex-grow</code>值总和小于<code>1</code>，则每个子项扩展的空间就总剩余空间和当前元素设置的<code>flex-grow</code>比例的计算值。</li>
<li>如果<code>flex-grow</code>值总和大于<code>1</code>，则所有剩余空间被利用，分配比例就是<code>flex-grow</code>属性值的比例。例如所有的<code>flex</code>子项都设置<code>flex-grow:1</code>，则表示剩余空白间隙大家等分，如果设置的<code>flex-grow</code>比例是1:2:1，则中间的flex子项占据一半的空白间隙，剩下的前后两个元素等分。</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-grow" target="_blank" rel="noopener">张鑫旭大佬：具体可参见下面“grow案例2”。</a></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><code>shrink</code>是“收缩”的意思，<code>flex-shrink</code>主要处理当<code>flex</code>容器空间不足时候，单个元素的收缩比例。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* 数值，默认值是 1 */</span></span><br></pre></td></tr></table></figure>
<p><code>flex-shrink</code>不支持负值，默认值是<code>1</code>，也就是默认所有的<code>flex</code>子项都会收缩。如果设置为<code>0</code>，则表示不收缩，保持原始的<code>fit-content</code>宽度。</p>
<p><code>flex-shrink</code>的内核跟<code>flex-grow</code>很神似，<code>flex-grow</code>是空间足够时候如何利用空间，<code>flex-shrink</code>则是空间不足时候如何收缩腾出空间。</p>
<p>两者的规则也是类似。已知flex子项不换行，且容器空间不足，不足的空间就是“完全收缩的尺寸”：</p>
<ul>
<li>如果只有一个<strong>flex子项</strong>设置了<code>flex-shrink</code>：<ul>
<li><code>flex-shrink</code>值小于<code>1</code>，则收缩的尺寸不完全，会有一部分内容<strong>溢出flex容器</strong>。</li>
<li><code>flex-shrink</code>值大于等于<code>1</code>，则收缩完全，正好<strong>填满flex容器</strong>。</li>
</ul>
</li>
<li>如果多个<strong>flex子项</strong>设置了<code>flex-shrink</code>：<ul>
<li><code>flex-shrink</code>值的总和小于<code>1</code>，则收缩的尺寸不完全，每个元素收缩尺寸占“完全收缩的尺寸”的比例就是设置的<code>flex-shrink</code>的值。</li>
<li><code>flex-shrink</code>值的总和大于<code>1</code>，则收缩完全，每个元素收缩尺寸的比例和<code>flex-shrink</code>值的比例一样。下面案例演示的就是此场景。</li>
</ul>
</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-shrink" target="_blank" rel="noopener">张鑫旭大佬：案例显示代码</a></p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code>定义了<strong>在分配剩余空间之前元素的默认大小</strong>。相当于对浏览器提前告知：浏览器兄，我要占据这么大的空间，提前帮我预留好。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto; /* 默认值是 auto */</span><br></pre></td></tr></table></figure>
<p>默认值是<code>auto</code>，就是自动。有设置<code>width</code>则占据空间就是<code>width</code>，没有设置就按内容宽度来。</p>
<p>如果同时设置<code>width</code>和<code>flex-basis</code>，就渲染表现来看，会忽略<code>width</code>。<strong>flex顾名思义就是弹性的意思，因此，实际上不建议对flex子项使用width属性，因为不够弹性</strong>。</p>
<p>当剩余空间不足的时候，<code>flex</code>子项的实际宽度并通常不是设置的<code>flex-basis</code>尺寸，因为flex布局剩余空间不足的时候默认会收缩。</p>
<p>当剩余空间不足的时候，flex子项的实际宽度并通常不是设置的<code>flex-basis</code>尺寸，因为flex布局剩余空间不足的时候默认会收缩。</p>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-basis" target="_blank" rel="noopener">张鑫旭大佬：案例显示代码</a></p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的缩写。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex: none | auto | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</span><br></pre></td></tr></table></figure>
<p>其中第2和第3个参数<strong>（flex-shrink和flex-basis）</strong>是可选的。默认值为<code>0 1 auto</code>。</p>
<p>flex为<code>none</code>和<code>auto</code>简写实际效果如下：</p>
<ul>
<li><strong>flex默认值等同于flex:0 1 auto</strong>；</li>
<li><strong>flex:none等同于flex:0 0 auto</strong>；</li>
<li><strong>flex:auto等同于flex:1 1 auto</strong>；</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-flex" target="_blank" rel="noopener">张鑫旭大佬：案例显示代码</a></p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><code>align-self</code>指控制单独某一个<strong>flex子项的垂直对齐方式</strong>.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure>
<p><strong>唯一区别就是align-self多了个auto（默认值），表示继承自flex容器的align-items属性值</strong>。</p>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#align-self" target="_blank" rel="noopener">张鑫旭大佬：案例显示代码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/" target="_blank" rel="noopener">写给自己看的display: flex布局教程</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a><br><a href="https://zhuanlan.zhihu.com/p/25303493" target="_blank" rel="noopener">30 分钟学会 Flex 布局</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的高阶组件(hoc)浅析</title>
    <url>/blog/react/react-hoc.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/react/react-hoc.html">react 的高阶组件浅析</a> &gt; <a href="/blog/react/react-hooks.html">react 中 Hooks 浅析</a> &gt; <a href="/blog/react/react-mixins-hoc-hooks.html">react 的 mixins、hoc、hooks 对比</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
</blockquote>
<p>高阶组件可以看作 React 对装饰模式的一种实现，<strong>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件</strong>。</p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>
<p>可以从下面几个方面探索 HOC。<br><img src="../../images/react/react-hoc-1-1.png" alt="reac-hoc"></p>
<p><strong>HOC 的实现方式</strong></p>
<ul>
<li>属性代理</li>
<li>反向继承</li>
</ul>
<p><strong>高阶组件的使用场景</strong></p>
<ul>
<li>操作 props(属性)</li>
<li>通过 Refs 访问到组件实例</li>
<li>组件状态提升</li>
<li>操作 state</li>
<li>渲染劫持</li>
<li>用其他元素包裹 WrappedComponent</li>
</ul>
<h2 id="HOC-的实现方式"><a href="#HOC-的实现方式" class="headerlink" title="HOC 的实现方式"></a>HOC 的实现方式</h2><p><font color="#ff502c"></font><br><code>React</code> 中实现 <code>HOC</code> 的两种主要方式：<code>Props Proxy</code>(属性代理)（PP）和 <code>Inheritance Inversion</code>(反向继承)(II) 。 两者都支持不同的方式来操作 <strong>WrappedComponent</strong> 。</p>
<p>这里不会详细介绍生命周期方法来做什么，因为它不是 <code>HOC</code> 的特性，而是 <code>React</code> 的特性。 但请注意，使用 <code>Inheritance Inversion(反向继承)</code>，您可以为 <code>WrappedComponent</code> 创建新的生命周期方法。 记得总是这样调用 <code>super[lifecycleHook]</code> ，这样就不会破坏 <code>WrappedComponent</code> 。</p>
<h3 id="属性代理-Props-Proxy"><a href="#属性代理-Props-Proxy" class="headerlink" title="属性代理 Props Proxy"></a>属性代理 Props Proxy</h3><p>Props Proxy(属性代理)(PP) 以下列方式实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里的重要部分是 HOC 得 render 方法<strong>返回</strong>WrappedComponent 类型的 React 元素。我们还通过 HOC 接收到得<code>props</code>(属性)，这就是名字<code>Props Proxy</code>的由来。</p>
<p>对比原生组件增强的项：</p>
<ul>
<li>操作 props</li>
<li>可操作组件的生命周期</li>
<li>通过 Refs 访问到组件实例</li>
<li>用其他元素包裹 WrappedComponent</li>
<li>提取 state(状态)</li>
</ul>
<h3 id="Inheritance-Inversion-反向继承"><a href="#Inheritance-Inversion-反向继承" class="headerlink" title="Inheritance Inversion(反向继承)"></a>Inheritance Inversion(反向继承)</h3><p>Inheritance Inversion(反向继承)(II) 通过以下方式实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的 HOC 类<font color="#ff502c">Enhancer</font> <strong>继承（extends）了</strong>WrappedComponent。它被成为<font color="#ff502c">Inheritance Inversion(反向继承)</font>，因为它不是用 WrappedComponent 来继承某些<font color="#ff502c">Enhancer</font>类。而是被<font color="#ff502c">Enhancer</font>被动继承。通过这种方式，他们之间的关系似乎是<strong>反向（inverse）</strong>。</p>
<p><font color="#ff502c">反向继承</font>允许 <font color="#ff502c">HOC</font> 通过 <font color="#ff502c">this</font> 访问 <font color="#ff502c">WrappedComponent</font> 实例，这意味着它可以访问 <font color="#ff502c">state(状态)</font>，<font color="#ff502c">props(属性)</font>，<font color="#ff502c">组件生命周期方法</font>和 <font color="#ff502c">render</font> 方法。<br>对比原生组件增强的项：</p>
<ul>
<li>可操作所有传入的 props</li>
<li>可操作组件的生命周期</li>
<li>获取 refs</li>
<li>可操作 state</li>
<li>可以渲染劫持</li>
</ul>
<h2 id="高阶组件的使用场景"><a href="#高阶组件的使用场景" class="headerlink" title="高阶组件的使用场景"></a>高阶组件的使用场景</h2><hr>

<h3 id="操作-props-属性"><a href="#操作-props-属性" class="headerlink" title="操作 props(属性)"></a>操作 props(属性)</h3><blockquote>
<p>通过属性代理实现</p>
</blockquote>
<p>你可以<code>读取、添加、编辑、删除</code>传给 <code>WrappedComponent</code> 的 <code>props(属性)</code>。在<code>删除或编辑</code>重要的 <code>props(属性)</code> 时要小心，你应该通过命名空间确保高阶组件的 <code>props</code> 不会破坏 <code>WrappedComponent</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        ...this.props,</span><br><span class="line">        userName: <span class="string">"asyncnode"</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="通过-Refs-访问到组件实例"><a href="#通过-Refs-访问到组件实例" class="headerlink" title="通过 Refs 访问到组件实例"></a>通过 Refs 访问到组件实例</h3><p><code>高阶组件</code>中可获取原组件的<code>ref</code>，通过<code>ref</code>获取组件<code>实例</code>，如下面的代码，当程序初始化完成后调用原组件的 log 方法。</p>
<blockquote>
<p>通过属性代理实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">RefsHoC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrapperRef.log();</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          ref=&#123;ref =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.wrapperRef = ref;</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用高阶组件的时候并不能获取到原组件的真实 ref，需要手动进行传递，<a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components" target="_blank" rel="noopener">详情请看</a></p>
<h3 id="组件状态提升"><a href="#组件状态提升" class="headerlink" title="组件状态提升"></a>组件状态提升</h3><p>将原组件的状态提取到<code>HOC</code>中进行管理，如下面的代码，我们将<code>Input</code>的<code>value</code>提取到<code>HOC</code>中进行管理，使它变成受控组件，同时不影响它使用<code>onChange</code>方法进行一些其他操作。基于这种方式，我们可以实现一个简单的<code>双向绑定</code>。</p>
<blockquote>
<p>通过属性代理实现</p>
</blockquote>
<p>示例：在以下提取 state(状态)示例中，我们非常规的提取 name 输入字段的值和 onChange 处理程序。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        value: <span class="string">""</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    onChange(event) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onChange &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">this</span>.setState(</span><br><span class="line">        &#123;</span><br><span class="line">          name: event.target.value</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onChange === <span class="string">"function"</span>) &#123;</span><br><span class="line">            onChange(event);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        value: name,</span><br><span class="line">        onChange: <span class="keyword">this</span>.onChange</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以像这样使用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@ppHOC <span class="comment">//装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作-state"><a href="#操作-state" class="headerlink" title="操作 state"></a>操作 state</h3><p><code>HOC</code>可以读取，编辑和删除 <code>WrappedComponent</code> 实例的状态，如果需要，还可以添加更多的 <code>state(状态)</code>。 请记住，您正在弄乱 <code>WrappedComponent</code> 的 <code>state(状态)</code>，这会导致您破坏一些东西。 大多数情况下，<code>HOC</code> 应限于读取或添加 <code>state(状态)</code> ，而添加 <code>state(状态)</code> 时应该被命名为不会弄乱 <code>WrappedComponent</code> 的 <code>state(状态)</code>。</p>
<blockquote>
<p>通过反向继承实现</p>
</blockquote>
<p>示例：通过访问 <code>WrappedComponent</code> 的 <code>props(属性)</code> 和 <code>state(状态)</code> 进行调试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">IIHOCDEBUGGER</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">II</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;HOC Debugger Component&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;Props&lt;/</span>p&gt; <span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;JSON.stringify(this.props, null, 2)&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line">          &lt;p&gt;State&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/</span>pre&gt;</span><br><span class="line">          &#123;<span class="keyword">super</span>.render()&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>HOC</code> 用其他元素包裹着 <code>WrappedComponent</code> ，并且还显示了 <code>WrappedComponent</code> 的实例 <code>props(属性)</code> 和 <code>state(状态)</code> 。</p>
<h3 id="渲染劫持-Render-Highjacking"><a href="#渲染劫持-Render-Highjacking" class="headerlink" title="渲染劫持(Render Highjacking)"></a>渲染劫持(Render Highjacking)</h3><blockquote>
<p>通过反向继承实现</p>
</blockquote>
<p>它被称为 渲染劫持(Render Highjacking)，因为 HOC 控制了 WrappedComponent 的渲染输出，并且可以用它做各种各样的事情。<br>在渲染劫持中，您可以：state(状态)，props(属性)</p>
<ul>
<li>读取，添加，编辑，删除渲染输出的任何 React 元素中的 props(属性)</li>
<li>读取并修改 render 输出的 React 元素树</li>
<li>有条件地渲染元素树</li>
<li>把样式包裹进元素树（就像在 Props Proxy(属性代理) 中的那样）<br>注：render 是指 WrappedComponent.render 方法<br>通过<strong>渲染劫持</strong>可以做到<strong>组合渲染</strong>和<strong>条件渲染</strong>.<br>示例 1：<strong>条件渲染</strong>。除非 <code>this.props.loggedIn</code> 不为 <code>true</code> ，否则此 <code>HOC</code> 将准确渲染 <code>WrappedComponent</code> 将渲染的内容。（假设 HOC 将收到 loggedIn props(属性)）.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反向继承实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过属性代理实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        return null;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例 2：<strong>组合渲染</strong>。 新增一个 title。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反向继承实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;div className=<span class="string">"title"</span>&gt;&#123;<span class="keyword">this</span>.props.title&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;super.render()&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>React.Fragment&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过属性代理实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;div className=<span class="string">"title"</span>&gt;&#123;<span class="keyword">this</span>.props.title&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;WrappedComponent &#123;...this.props&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在 <code>Props Proxy</code>(属性代理) 类型的高阶函数中做不到渲染劫持。</p>
</blockquote>
<p>虽然可以通过 <code>WrappedComponent.prototype.render</code> 访问 <code>render</code> 方法，但是您需要模拟 <code>WrappedComponent</code> 实例及其 <code>props</code>(属性)，并且可能需要自己处理组件生命周期，而不是依赖 <code>React</code> 执行它。 在我的实验中不值得这么做，如果你想做渲染劫持(<code>Render Highjacking</code>)，你应该使用 <code>Inheritance Inversion</code>(反向继承) 而不是 <code>Props Proxy</code>(属性代理)。 请记住，React 在内部处理组件实例，而处理实例的唯一方法是通过 this 或 refs 。</p>
<h3 id="用其他元素包裹-WrappedComponent"><a href="#用其他元素包裹-WrappedComponent" class="headerlink" title="用其他元素包裹 WrappedComponent"></a>用其他元素包裹 WrappedComponent</h3><blockquote>
<p>通过属性代理实现</p>
</blockquote>
<p>可以将 WrappedComponent 与其他组件和元素包装在一起，以用于样式，布局或其他目的。 一些基本用法可以通过常规父组件来完成.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123; <span class="attr">display</span>: <span class="string">"block"</span> &#125;&#125;&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>使用 <code>HOC</code> 包裹组件时，会丢失原始 <code>WrappedComponent</code> 的名称，这可能会在开发和调试时影响到您。人们通常做的是通过获取 <code>WrappedComponent</code> 的名称并预先添加某些内容来自定义 <code>HOC</code> 的名称。 以下内容摘自 <code>React-Redux</code> 。用 <code>HOC</code> 包裹了一个组件会使它失去原本 <code>WrappedComponent</code> 的名字，可能会影响开发和调试。通常会用 <code>WrappedComponent</code> 的名字加上一些 前缀作为 HOC 的名字。下面的代码来自 React-Redux:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span>;</span><br><span class="line">&#125;</span><br><span class="line">HOC.displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何使用-HOC"><a href="#如何使用-HOC" class="headerlink" title="如何使用 HOC"></a>如何使用 HOC</h2><p>上面的示例代码都写的是如何声明一个<code>HOC</code>，<code>HOC</code>实际上是一个函数，所以我们将要增强的组件作为参数调用<code>HOC</code>函数，得到增强后的组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>原组件<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> inheritHOC(myComponent);</span><br></pre></td></tr></table></figure>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>假设现在我们有 logger，visible，style 等多个 HOC，现在要同时增强一个 Input 组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">logger(visible(style(Input)));</span><br></pre></td></tr></table></figure>
<p>这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> g(f(...args)));</span><br><span class="line">compose(</span><br><span class="line">  logger,</span><br><span class="line">  visible,</span><br><span class="line">  style</span><br><span class="line">)(Input);</span><br></pre></td></tr></table></figure>
<p><code>compose</code>函数返回一个所有函数组合后的函数，<code>compose(f, g, h)</code> 和 <code>(...args) =&gt; f(g(h(...args)))</code>是一样的。<br>很多第三方库都提供了类似<code>compose</code>的函数，例如<code>lodash.flowRight</code>，<code>Redux</code>提供的<code>combineReducers</code>函数等。</p>
<h3 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h3><p>我们还可以借助 ES7 为我们提供的 Decorators 来让我们的写法变的更加优雅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@logger</span><br><span class="line">@visible</span><br><span class="line">@style</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Decorators</code>是<code>ES7</code>的一个提案，还没有被标准化，但目前<code>Babel</code>转码器已经支持，我们需要提前配置<code>babel-plugin-transform-decorators-legacy</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="HOC-的实际应用"><a href="#HOC-的实际应用" class="headerlink" title="HOC 的实际应用"></a>HOC 的实际应用</h2><p>多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用， 官方文档中<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">CommentList</a>的示例也是解决了代码复用问题。</p>
<h3 id="日志打点"><a href="#日志打点" class="headerlink" title="日志打点"></a>日志打点</h3><p>某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.start = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.end = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;WrappedComponent.dispalyName&#125;</span> 渲染时间：<span class="subst">$&#123;<span class="keyword">this</span>.end - <span class="keyword">this</span>.start&#125;</span> ms`</span></span><br><span class="line">      );</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user&#125;</span>进入<span class="subst">$&#123;WrappedComponent.dispalyName&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user&#125;</span>退出<span class="subst">$&#123;WrappedComponent.dispalyName&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="可用、权限控制"><a href="#可用、权限控制" class="headerlink" title="可用、权限控制"></a>可用、权限控制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; visible, auth, display = <span class="literal">null</span>, ...props &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span> || (auth &amp;&amp; authList.indexOf(auth) === <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> display;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>authList</code>是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的 visible 是 false，我们将其显示为传入的组件样式，或者<code>null</code>。我们可以将任何需要进行权限校验的组件应用<code>HOC</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@auth</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  ...  &#125;</span><br><span class="line">@auth</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  ...  &#125;</span><br><span class="line"></span><br><span class="line">&lt;Button auth=<span class="string">"user/addUser"</span>&gt;添加用户&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">&lt;Input auth="user/</span>search<span class="string">" visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>在<code>vue</code>中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而<code>React</code>中没有做这样的处理，在默认情况下，表单元素都是非受控组件。给表单元素绑定一个状态后，往往需要手动书写<code>onChange</code>方法来将其改写为<strong>受控组件</strong>，在表单元素非常多的情况下这些重复操作是非常痛苦的。<br>我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。<br><img src="../../images/react/react-hoc-1-2.png" alt="reac-hoc"><br>…代码未完成（后续补上）</p>
<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息：<br>…代码未完成（后续补上）</p>
<h2 id="使用-HOC-的注意事项"><a href="#使用-HOC-的注意事项" class="headerlink" title="使用 HOC 的注意事项"></a>使用 HOC 的注意事项</h2><hr>

<h3 id="静态属性拷贝"><a href="#静态属性拷贝" class="headerlink" title="静态属性拷贝"></a>静态属性拷贝</h3><p>当我们应用<code>HOC</code>去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在<code>HOC</code>的结尾手动拷贝他们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOCComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  HOCComponent.staticMethod = WrappedComponent.staticMethod;</span></span><br><span class="line"><span class="xml">  // ...</span></span><br><span class="line"><span class="xml">  return HOCComponent;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用<code>hoist-non-react-statics</code>来帮助我们解决这个问题，它可以自动帮我们拷贝所有非 React 的静态方法，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">"hoist-non-react-statics"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOCComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  hoistNonReactStatic(HOCComponent, WrappedComponent);</span></span><br><span class="line"><span class="xml">  return HOCComponent;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="传递-refs"><a href="#传递-refs" class="headerlink" title="传递 refs"></a>传递 refs</h3><p>使用高阶组件后，获取到的<code>ref</code>实际上是<code>最外层</code>的<code>容器组件</code>，而非<code>原组件</code>，但是很多情况下我们需要用到<code>原组件的ref</code>。<br>高阶组件并不能像透传 props 那样将 refs 透传，我们可以用一个回调函数来完成 ref 的传递：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    getWrappedRef = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.wrappedRef;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          ref=&#123;ref =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.wrappedRef = ref;</span><br><span class="line">          &#125;&#125;</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@hoc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Input</span><br><span class="line">        ref=&#123;ref =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.inpitRef = ref.getWrappedRef();</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React 16.3</code>版本提供了一个<code>forwardRef API</code>来帮助我们进行<code>refs</code>传递，这样我们在高阶组件上获取的<code>ref</code>就是原组件的 ref 了，而不需要再手动传递，如果你的<code>React</code>版本大于<code>16.3</code>，可以使用下面的方式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; forwardedRef, ...props &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return React.forwardRef((props, ref) =&gt; &#123;</span></span><br><span class="line">    return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不要在-render-方法中使用-HOC"><a href="#不要在-render-方法中使用-HOC" class="headerlink" title="不要在 render 方法中使用 HOC"></a>不要在 render 方法中使用 HOC</h3><p>React Diff 算法的原则是：</p>
<ul>
<li>使用组件标识确定是卸载还是更新组件</li>
<li>如果组件的和前一次渲染时标识是相同的，递归更新子组件</li>
<li>如果标识不同卸载组件重新挂载新组件</li>
</ul>
<p>每次调用<strong>高阶组件</strong>生成的都是是一个<strong>全新</strong>的组件，组件的<strong>唯一标识</strong>响应的也会改变，如果在 render 方法调用了高阶组件，这会导致组件每次都会被<strong>卸载后重新挂载</strong>。</p>
<h3 id="不要改变原始组件"><a href="#不要改变原始组件" class="headerlink" title="不要改变原始组件"></a>不要改变原始组件</h3><p>官方文档对高阶组件的说明：</p>
<blockquote>
<p>高阶组件就是一个没有副作用的纯函数。</p>
</blockquote>
<p>我们再来看看纯函数的定义：</p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。 该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。</p>
</blockquote>
<p><strong>我们使用高阶组件是为了增强而非改变原组件</strong>。</p>
<h3 id="透传不相关的-props"><a href="#透传不相关的-props" class="headerlink" title="透传不相关的 props"></a>透传不相关的 props</h3><p>使用高阶组件，我们可以代理所有的<code>props</code>，但往往特定的 HOC 只会用到其中的一个或几个<code>props</code>。我们需要把其他不相关的<code>props</code>透传给原组件，如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visible</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; visible, ...props &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们只使用<code>visible</code>属性来控制组件的显示可隐藏，把其他<code>props</code>。</p>
<h2 id="HOC-的缺陷"><a href="#HOC-的缺陷" class="headerlink" title="HOC 的缺陷"></a>HOC 的缺陷</h2><ul>
<li><code>HOC</code>需要在原组件上进行包裹或者嵌套，如果大量使用<code>HOC</code>，将会产生非常多的嵌套，这让调试变得非常困难。</li>
<li><code>HOC</code>可以劫持<code>props</code>，在不遵守约定的情况下也可能造成冲突。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>HOC 相对于 Mixins 的好处</strong>：</p>
<ul>
<li><strong>高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合</strong></li>
<li><strong>高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为</strong></li>
<li><strong>高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担</strong></li>
</ul>
<p><strong>HOC 实现方式有两种</strong>：</p>
<ul>
<li><strong>通过属性代理实现</strong></li>
<li><strong>通过反向继承实现</strong></li>
</ul>
<p><strong>高阶组件的使用场景</strong>:</p>
<ul>
<li><strong>操作 props(属性)(通过属性代理实现、通过反向继承实现)</strong></li>
<li><strong>通过 Refs 访问到组件实例 （通过属性代理实现）</strong></li>
<li><strong>组件状态提升（通过属性代理实现）</strong></li>
<li><strong>操作 state （通过反向继承实现）</strong></li>
<li><strong>渲染劫持（通过属性代理实现、通过反向继承实现）</strong></li>
<li><strong>用其他元素包裹 WrappedComponent （通过属性代理实现）</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a> &gt; <a href="https://www.html.cn/archives/9462" target="_blank" rel="noopener">深入理解 React 高阶组件（Higher Order Component，简称：HOC）</a> &gt; <a href="https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-13" target="_blank" rel="noopener">【React 深入】从 Mixin 到 HOC 再到 Hook</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript类型转换（三）常见的面试题</title>
    <url>/blog/javascript/javascript-type-one-questionone.html</url>
    <content><![CDATA[<p><strong><em>多言多败，多事多害。——《训蒙增广》</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript数据类型（一） 常见数据类型</a><br><a href="/blog/javascript/javascript-type-one-question.html">JavaScript数据类型（二） 类型转换</a><br><a href="/blog/javascript/javascript-type-one-questionone.html">JavaScript数据类型（三）常见的面试题</a><br><a href="/blog/javascript/javascript-IF-False-options.html">JavaScript数据类型（四）IF 转换规则</a><br><a href="/blog/javascript/javascript-false-true.html">JavaScript数据类型（五）== 混乱的转换规则</a><br><a href="/blog/javascript/javascript-bool-type.html">JavaScript数据类型（六）多种数据类型判断方法</a></p>
</blockquote>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><hr>
<p>在另一篇文章中有表述大致显示转化规则，隐式转换规则，着篇文章中会收集一些前端比较经典的关于类型转换的问题。下面就开始比较经典的面试题。</p>
<h2 id><a href="#" class="headerlink" title="![] == []"></a>![] == []</h2><p>这个题在另一篇面试中有记录过，<a href="/blog/javascript/javascript-false-true.html">![] == []</a>.</p>
<h2 id="a-1-amp-amp-a-2-amp-amp-a-3"><a href="#a-1-amp-amp-a-2-amp-amp-a-3" class="headerlink" title="(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)"></a>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)</h2><p>这个真的有很多种办法，这里只记录我知道的方法，如果有好的方法，请在下方留言，大家一起进步。<br>首先要知道==和===的区别。</p>
<p><strong>==</strong><br>宽松匹配 ==会先将左右两两边的值转化成相同的原始类型，然后再去比较他们是否相等。<br><strong>===</strong><br>他是不转化直接比较，如果类型不同直接就是<code>false</code>，如果类型相同，原始值相同就为<code>true</code>。</p>
<p>这里主要讲解<code>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)</code>相等的多种解法，如下：</p>
<ol>
<li>重写<code>Object</code>的<code>valueOf</code></li>
<li>重写<code>Object</code>的<code>toString</code></li>
<li>重写<code>ToPrimitive</code>，<code>es6 smybol(&#39;&#39;)</code></li>
<li>通过劫持 obj 的<code>getter</code>方法</li>
<li>数组<code>join、shift</code></li>
<li>字符串骚操作</li>
</ol>
<h3 id="重写-Object-的-valueOf、重写-Object-的-toString"><a href="#重写-Object-的-valueOf、重写-Object-的-toString" class="headerlink" title="重写 Object 的 valueOf、重写 Object 的 toString"></a>重写 Object 的 valueOf、重写 Object 的 toString</h3><p><strong>重写代码的 valueOf 方法、和 toString 方法</strong>，如果不知道 ToPrimitive(obj, type)规则，请看<a href="/blog/javascript/javascript-type-one-question.html">ToPrimitive 规则</a>我的另一篇博客。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">a.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">a1.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">a1.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a1 == <span class="number">1</span> &amp;&amp; a1 == <span class="number">2</span> &amp;&amp; a1 == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="重写-ToPrimitive，es6-smybol-‘’"><a href="#重写-ToPrimitive，es6-smybol-‘’" class="headerlink" title="重写 ToPrimitive，es6 smybol(‘’)"></a>重写 ToPrimitive，es6 smybol(‘’)</h3><p><strong>在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为，得到我们想要的结果</strong>。看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">a[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Obj-defineProperty"><a href="#Obj-defineProperty" class="headerlink" title="Obj.defineProperty"></a>Obj.defineProperty</h3><p><strong>通过劫持对象的属性值的 getter 操作</strong>，让他累加来做到我们想要的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"a"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="通过数组的方式实现"><a href="#通过数组的方式实现" class="headerlink" title="通过数组的方式实现"></a>通过数组的方式实现</h3><p><strong>通过改变数组的 join 方法实现</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的骚操作"><a href="#字符串的骚操作" class="headerlink" title="字符串的骚操作"></a>字符串的骚操作</h3><p><strong>通过定义变量是包含空格</strong>，实现视觉上的相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aﾠ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> ﾠa = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aﾠ == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; ﾠa == <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面就是知道的可以让(aﾠ == 1 &amp;&amp; a == 2 &amp;&amp; ﾠa== 3 )的六种方法，如果还有后面会接着补充，下面来说一下(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3)。</p>
<h2 id="a-1-amp-amp-a-2-amp-amp-a-3-1"><a href="#a-1-amp-amp-a-2-amp-amp-a-3-1" class="headerlink" title="(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3)"></a>(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3)</h2><p>在上面介绍过==与===的区别， ===是不会进行类型转换的，所以==的很多规则并不适用，那只有<strong>劫持方法</strong>和<strong>字符串</strong>的操作可以实现，其他方法都不能实现。</p>
<h3 id="Obj-defineProperty-1"><a href="#Obj-defineProperty-1" class="headerlink" title="Obj.defineProperty"></a>Obj.defineProperty</h3><p><strong>通过劫持对象的属性值的 getter 操作</strong>，让他累加来做到我们想要的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">"a"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的骚操作-1"><a href="#字符串的骚操作-1" class="headerlink" title="字符串的骚操作"></a>字符串的骚操作</h3><p><strong>通过定义变量是包含空格</strong>，实现视觉上的相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aﾠ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> ﾠa = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aﾠ === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; ﾠa === <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>未完待续。。。。如有经典试题可评论</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码中parse生成AST (未完成)</title>
    <url>/blog/vue/vue-parse.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码中complier整体流程 (未完成)</title>
    <url>/blog/vue/vue-complier.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript类型转换（二） 类型转换</title>
    <url>/blog/javascript/javascript-type-one-question.html</url>
    <content><![CDATA[<p><strong><em>天下难事必作于易，天下大事必作于细。——《道德经》</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript数据类型（一） 常见数据类型</a><br><a href="/blog/javascript/javascript-type-one-question.html">JavaScript数据类型（二） 类型转换</a><br><a href="/blog/javascript/javascript-type-one-questionone.html">JavaScript数据类型（三）常见的面试题</a><br><a href="/blog/javascript/javascript-IF-False-options.html">JavaScript数据类型（四）IF 转换规则</a><br><a href="/blog/javascript/javascript-false-true.html">JavaScript数据类型（五）== 混乱的转换规则</a><br><a href="/blog/javascript/javascript-bool-type.html">JavaScript数据类型（六）多种数据类型判断方法</a></p>
</blockquote>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><hr>
<p>在JavaScript中关于类型转换的规则是非常混乱的，有<strong>强制转换（显示转换）</strong>、<strong>隐式转换</strong>，并且转换的规则没有完整可参考的文档，只有当时的提议书。并且在<strong>隐式转换</strong>的时候会出现很多不可思议的bug.</p>
<blockquote>
<p>类型转换发生在静态类型的语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）；</p>
</blockquote>
<p>我们先来解释显示转换再来隐式转换。<br>如果想了解<a href="/blog/javascript/javascript-Type-conversion.html">javaScript中的类型</a>，或者<a href="/blog/javascript/javascript-IF-False-options.html">if运算符转换规则</a>的知识可以看看我其他的博客。</p>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><ol>
<li>ToString</li>
<li>ToNumber</li>
<li>ToBoolean</li>
</ol>
<p>首先介绍显示转换中的基本类型互转，字符串、数字、布尔值、null、undefined之间的转换。</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><ol>
<li>ToPrimitive(转换为原始值)</li>
<li>valueOf(返回指定对象的原始值)</li>
<li>运算符中的转换（+、-、*、/）</li>
<li>==</li>
</ol>
<p>再来看一下ToPrimitive把对象转为原始值，当然也有Object.prototype.toString()的介绍，再试valueOf返回对象的原始值，再最后就是运算符在基本类型和object之间的运算，其中最坑的应该是==的隐士转换，因为他的左右规则不同，左右类型不同执行的又不同。</p>
<h3 id="ToPrimitive的规则"><a href="#ToPrimitive的规则" class="headerlink" title="ToPrimitive的规则"></a>ToPrimitive的规则</h3><p>我们要用到的<code>ToPrimitive</code>的规则，因为显示转换也会用到<code>ToPrimitive</code>的规则，如果还想所有的转换规则请看.<a href="http://www.ecma-international.org/" target="_blank" rel="noopener">ecma规则</a><br><strong>ToPrimitive</strong>(转换为原始值)<br><code>ToPrimitive</code> 运算符接受一个值，和一个可选的 期望类型作参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @params obj 要转换的对象 ，required</span></span><br><span class="line"><span class="comment">* @params type 期望转换为的原始数据类型， </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ToPrimitive(obj, type);</span><br></pre></td></tr></table></figure>
<p>根据<font color="#ff502c">type</font><font color="#ff502c"></font>的不同会他后面的步骤也不相同，如下所示</p>
<p><strong>type为string</strong></p>
<ol>
<li>先调用obj的<font color="#ff502c">toString</font>方法，如果返回<font color="#ff502c">原始值</font>，则不往下执行，如果返回不是原始值，则执行<font color="#ff502c">第二步</font>。</li>
<li>调用obj的<font color="#ff502c">valueOf</font>方法，如果为<font color="#ff502c">原始值</font>，则不往下执行，如果返回不是原值值，则执行<font color="#ff502c">第三步</font>。</li>
<li>抛出<font color="#ff502c">TypeError</font>异常</li>
</ol>
<p><strong>type为Number</strong></p>
<ol>
<li>先调用obj的<font color="#ff502c">valueOf</font>方法，如果返回<font color="#ff502c">原始值</font>，则不往下执行，如果返回不是原始值，则执行<font color="#ff502c">第二步</font>。</li>
<li>调用obj的<font color="#ff502c">toString</font>方法，如果为<font color="#ff502c">原始值</font>，则不往下执行，如果返回不是原值值，则执行<font color="#ff502c">第三步</font>。</li>
<li>抛出<font color="#ff502c">TypeError</font>异常</li>
</ol>
<p><strong>type参数为空</strong></p>
<ol>
<li>该对象为<code>Date</code>，则type被设置为<font color="#ff502c">String</font></li>
<li>否则，type被设置为<font color="#ff502c">Number</font></li>
</ol>
<p>这基本上就是object常用的转换的一些规则，在下面会验证ToPrimitive规则是否正确。</p>
<h2 id="显示转换-1"><a href="#显示转换-1" class="headerlink" title="显示转换"></a>显示转换</h2><hr>
<p>我们先看一下基本类型之间的转换的图标如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Null</th>
<th style="text-align:center">Undefined</th>
<th style="text-align:center">Boolean(true)</th>
<th style="text-align:center">Boolean(false)</th>
<th style="text-align:center">Number</th>
<th style="text-align:center">String</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">(0/NAN)=&gt;false OR true</td>
<td style="text-align:center">(‘’)=&gt;false OR true</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-</td>
<td style="text-align:center">(‘’)=&gt;false OR true</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">‘null’</td>
<td style="text-align:center">‘undefined’</td>
<td style="text-align:center">‘true’</td>
<td style="text-align:center">‘false’</td>
<td style="text-align:center">‘Number’</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>我们下面一个一个说明<code>ToString</code>、<code>ToNumber</code>、<code>ToBoolean</code>的大致规则。</p>
<h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h3><p>抽象操作<code>ToString</code>负责处理非字符串到字符串的强制类型转换。<br>验证一下上面表格中的转换规则，验证的时候加上object的转换验证，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">null</span>)); <span class="comment">// 'null'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">undefined</span>)); <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">true</span>)); <span class="comment">// 'true'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">false</span>)); <span class="comment">// 'false'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">1</span>)); <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">0</span>)); <span class="comment">// '0'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">NaN</span>)); <span class="comment">// 'NaN'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// '1,2,3' or [].toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// 'Sat Apr 20 2019 00:00:00 GMT+0800 (中国标准时间)'</span></span><br></pre></td></tr></table></figure>
<p>上面的代码证明了我们上面table中的基本类型的·String·转换规则。</p>
<blockquote>
<p>注意：对象这里要先转换为原始值，调用<code>ToPrimitive</code>转换，<code>type</code>就指定为<code>string</code>了，继续回到<code>ToPrimitive</code>进行转换（看ToPrimitive）。</p>
</blockquote>
<h3 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h3><p>抽象操作<code>ToNumber</code>负责处理非<code>Number</code>到<code>Number</code>的强制类型转换。<br>验证一下上面表格中的转换规则，验证的时候加上object的转换验证，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'1'</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'0'</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'abcd'</span>)); <span class="comment">// 'NaN'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(&#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// 1555689600000</span></span><br></pre></td></tr></table></figure>
<p>上面的代码证明了我们上面table中的基本类型的<code>Number</code>转换规则。</p>
<blockquote>
<p>注意：对象这里要先转换为原始值，调用<code>ToPrimitive</code>转换，type就指定为<code>number</code>了，继续回到<code>ToPrimitive</code>进行转换（看ToPrimitive）。</p>
</blockquote>
<h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><p>抽象操作<code>ToBoolean</code>负责处理非<code>Boolean</code>到<code>Boolean</code>的强制类型转换。<br>验证一下上面表格中的转换规则，验证的时候加上object的转换验证，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'true'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'false'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">''</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'abcd'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123;&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// 1555689600000</span></span><br></pre></td></tr></table></figure>
<p>在表格上只有基本类型的转换为Boolean的规则，具体的转换规则为：</p>
<ul>
<li><font color="#ff502c">false</font></li>
<li><font color="#ff502c">null</font></li>
<li><font color="#ff502c">undefined</font></li>
<li><font color="#ff502c">空字符串’ ‘</font></li>
<li><font color="#ff502c">数字零 0</font></li>
<li><font color="#ff502c">NaN</font>

</li>
</ul>
<p>只有上面的会转为<code>false</code>,其他的都会转为<code>true</code>.<br>他和if()条件运算符转换的规则基本上一至，请看<a href="/blog/javascript/javascript-IF-False-options.html">if运算符转换</a>。</p>
<h2 id="隐士转换"><a href="#隐士转换" class="headerlink" title="隐士转换"></a>隐士转换</h2><hr>
<p>在上面已经列出了<code>ToPrimitive</code>的常用的转换规则，在下面会验证上面的规则是否正确。最坑的也是规则对多的就是运算符的转换，可能现在只知道一部分，后面会慢慢补全。</p>
<h3 id="ToPrimitive验证"><a href="#ToPrimitive验证" class="headerlink" title="ToPrimitive验证"></a>ToPrimitive验证</h3><p><strong>Object转String规则验证</strong><br>首先验证Obejct转换为String的规则，直接上代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'toString'</span>); <span class="keyword">return</span> &#123;&#125;; &#125;,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>); <span class="keyword">return</span> &#123;&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">String</span>(obj);</span><br><span class="line"><span class="comment">// 1. toString </span></span><br><span class="line"><span class="comment">// 2. valueOf</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>根据上面的输出结果，证明上面的String()，走了<font color="#ff502c">ToPrimitive(obj, string)</font>的<font color="#ff502c">type</font>为<font color="#ff502c">string</font>的规则。详情见上面。</p>
<p><strong>Object转Number规则验证</strong><br>再验证Obejct转换为Number的规则，直接上代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'toString'</span>); <span class="keyword">return</span> &#123;&#125;; &#125;,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>); <span class="keyword">return</span> &#123;&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Number</span>(obj);</span><br><span class="line"><span class="comment">// 1. valueOf</span></span><br><span class="line"><span class="comment">// 2. toString</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>根据上面的输出结果，证明上面的Number()，走了<font color="#ff502c">ToPrimitive(obj, number)</font>的<font color="#ff502c">type</font>为<font color="#ff502c">number</font>的规则。详情见上面。</p>
<p><strong>其他转变如数组转String或者Number</strong><br>再验证Obejct转换为Number的规则，直接上代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'toString'</span>); <span class="keyword">return</span> &#123;&#125;; &#125;,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>); <span class="keyword">return</span> &#123;&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Number</span>(obj);</span><br><span class="line"><span class="comment">// 1. valueOf</span></span><br><span class="line"><span class="comment">// 2. toString</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>根据上面的输出结果，证明上面的Number()，走了<font color="#ff502c">ToPrimitive(obj, number)</font>的<font color="#ff502c">type</font>为<font color="#ff502c">number</font>的规则。详情见上面。</p>
<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><p>JavaScript 调用 <code>valueOf()</code> 方法用来把对象转换成原始类型的值（数值、字符串和布尔值）。但是我们很少需要自己调用此函数，<code>valueOf</code> 方法一般都会被 JavaScript 自动调用。</p>
<ul>
<li><code>String</code> =&gt; 返回字符串值</li>
<li><code>Number</code> =&gt; 返回数字值</li>
<li><code>Boolean</code> =&gt; 返回<code>Boolean</code>的this值</li>
<li><code>Object</code> =&gt; 返回this</li>
<li><code>Date</code> =&gt; 返回一个数字，即时间值,字符串中内容是依赖于具体实现的</li>
</ul>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span>.valueOf()); <span class="comment">// 'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="number">123</span>).valueOf()); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">true</span>).valueOf()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>: <span class="number">123</span>&#125;.valueOf()) <span class="comment">// &#123;a: 123&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// Sat Apr 20 2019 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<h3 id="运算符中的转换（-、-、-、"><a href="#运算符中的转换（-、-、-、" class="headerlink" title="运算符中的转换（+、-、*、/)"></a>运算符中的转换（+、-、*、/)</h3><p>在运算符中的转换又分为两种，自动转换为<code>string</code>类型、自动转换为<code>number</code>类型。</p>
<h4 id="自动转换为string类型"><a href="#自动转换为string类型" class="headerlink" title="自动转换为string类型"></a>自动转换为string类型</h4><p>在基础类型中，当一个值为字符串，另一个值非字符串，则后者转为字符串，当有一个是对象时，会走<code>ToPrimitive(obj, number)</code>，<code>ToPrimitive</code>转换请看上面，下面看代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="number">1</span>); <span class="comment">// 'a1'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="literal">true</span>); <span class="comment">// 'atrue'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="literal">false</span>); <span class="comment">// 'afalse'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="literal">undefined</span>); <span class="comment">// 'aundefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="literal">null</span>); <span class="comment">// 'anull'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + []); <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + &#123;<span class="attr">toString</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'1'</span> &#125;&#125;); <span class="comment">// 'a1'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + &#123;<span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;&#125;); <span class="comment">// 'a1'</span></span><br></pre></td></tr></table></figure>
<h4 id="自动转换为number类型"><a href="#自动转换为number类型" class="headerlink" title="自动转换为number类型"></a>自动转换为number类型</h4><p>加法运算符，如果没有一个为<code>string</code>类型的时候，都会优先转换为<code>Number</code>类型，如果有一个为object时，会走<code>ToPrimitive(obj, number)</code>，<code>ToPrimitive</code>转换请看上面。一元运算符，也是需要注意。下面看代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">false</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">null</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + []); <span class="comment">// ‘true’</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">null</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> - <span class="literal">false</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> - <span class="literal">true</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> - <span class="string">'0'</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> * <span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span> * <span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> - <span class="string">'0'</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span> - <span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span> - <span class="string">'0'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> - <span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> - <span class="number">0</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> - &#123;<span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;&#125;); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> - &#123;<span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123;&#125; &#125;, <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;&#125;); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 一元运算符</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'abc'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="string">'abc'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'1'</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="string">'1'</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="literal">false</span>); <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：null转为数值时为0，而undefined转为数值时为NaN</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title="=="></a>==</h3><p>== 抽象相等比较与+运算符不同，不再是String优先，而是Nuber优先。假设左面为x、y为右面，大概的规则如下。</p>
<ol>
<li>如果x,y都为number,直接比较</li>
<li>如果x为string，y为number，x转换为number比较，反则相反。</li>
<li>如果存在对象，通过ToPrimitive(obj, number)type为number进行转换，再进行比较。</li>
<li>如果x，y有一方存在boolean,按照ToNumber将boolean转换为1或0，再进行比较。</li>
</ol>
<p>验证代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x,y 都number 比较</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一方为string一方为number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> == <span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="string">'1'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一方为 对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 因为对象的规则比较繁杂，如果普通对象[] 和 ![] 规则不同请看下面文章</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在 booelan</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="string">'0'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="string">'0'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在这里就不多赘述了，看我另一篇文章 <a href="/blog/javascript/javascript-false-true.html">![] == []</a>，通过一道面试题。来讲解基本的转换规则，因为这个规则其实挺复杂的，一两句话讲不清楚。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript中的类型转换基本上分为<strong>显示转换、隐式转换</strong>。</p>
<p><strong>显示转换</strong></p>
<ol>
<li><code>ToString</code></li>
<li><code>ToNumber</code></li>
<li><code>ToBoolean</code></li>
</ol>
<p><strong>隐式转换</strong></p>
<ol>
<li><code>ToPrimitive(转换为原始值)</code></li>
<li><code>valueOf(返回指定对象的原始值)</code></li>
<li><code>运算符中的转换（+、-、*、/）</code></li>
<li><code>==</code></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s/_THIZY4KTa1IlVb4k9qbJg" target="_blank" rel="noopener">经常被面试官考的JavaScript数据类型知识你真的懂吗？</a><br><a href="https://javascript.ruanyifeng.com/grammar/conversion.html" target="_blank" rel="noopener">数据类型转换</a><br><a href="https://github.com/amandakelake/blog/issues/34" target="_blank" rel="noopener">深入理解JS的类型、值、类型转换 #34</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单mvvm双向绑定基础框架 (未完成)</title>
    <url>/blog/vue/vue-simple-mvvm.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>eventloop图解 (未完成)</title>
    <url>/blog/javascript/evenloop.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>arrow-functions（箭头函数）和普通的函数的区别 this（二）</title>
    <url>/blog/es6/es6-arrow-functions.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在用vue框架、或者react框架中我们会用到很多es6中的新特性，比较多的就是<font color="#ff502c">箭头函数</font>.都会知道一点普通函数和箭头函数的区别,这里总结一下<strong>箭头函数和普通函数的区别</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对比</th>
<th style="text-align:center">普通函数</th>
<th style="text-align:center">箭头函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">this指向规则</td>
<td style="text-align:center">this总是指向调用它的那个对象</td>
<td style="text-align:center">1.所有箭头函数本身没有this <br>2.箭头函数的this在定义的时候捕获自外层第一个普通函数的this <br> 3.如果箭头函数外层没有普通函数,严格模式和非严格模式下它的this都会指向window(全局对象)</td>
</tr>
<tr>
<td style="text-align:center">有无prototype</td>
<td style="text-align:center">有</td>
<td style="text-align:center">箭头函数没有<font color="#ff502c">prototype</font>(原型)</td>
</tr>
<tr>
<td style="text-align:center">可否new</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">箭头函数作为匿名函数,是不能作为构造函数的(因为箭头函数没有constructor),不能使用new,不然会报错</td>
</tr>
<tr>
<td style="text-align:center">有无arguments</td>
<td style="text-align:center">有</td>
<td style="text-align:center">1.箭头函数的this指向全局,使用会报未声明的错误 <br> 2.箭头函数的this指向普通函数时,它的<font color="#ff502c">argumens</font>继承于改普通函数</td>
</tr>
<tr>
<td style="text-align:center">可否new</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">箭头函数作为匿名函数,是不能作为构造函数的(因为箭头函数没有constructor),不能使用new,不然会报错</td>
</tr>
<tr>
<td style="text-align:center">可否改变this指向</td>
<td style="text-align:center">可以通过call、apply、bind改变this的指向</td>
<td style="text-align:center">箭头函数本身的this指向不能改变,但是可以修改它要捕获的对象的this</td>
</tr>
</tbody>
</table>
<h2 id="箭头函数this指向的规则"><a href="#箭头函数this指向的规则" class="headerlink" title="箭头函数this指向的规则"></a>箭头函数this指向的规则</h2><h3 id="1-箭头函数的this在定义的时候捕获自外层第一个普通函数的this"><a href="#1-箭头函数的this在定义的时候捕获自外层第一个普通函数的this" class="headerlink" title="1.箭头函数的this在定义的时候捕获自外层第一个普通函数的this"></a>1.箭头函数的this在定义的时候捕获自外层第一个普通函数的this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    c: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b(); </span><br><span class="line">obj.c();</span><br></pre></td></tr></table></figure>
<p><strong>箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window(全局对象)</strong><br><strong>this对象的指向是可变的，但是在箭头函数中，它是固定的。</strong></p>
<h3 id="2-不能直接修改箭头函数的this指向-但是可以通过修改外层函数的this"><a href="#2-不能直接修改箭头函数的this指向-但是可以通过修改外层函数的this" class="headerlink" title="2.不能直接修改箭头函数的this指向,但是可以通过修改外层函数的this"></a>2.不能直接修改箭头函数的this指向,但是可以通过修改外层函数的this</h3><p><strong>不能通过call、apply、bind改变this</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); </span><br><span class="line">    &#125;,</span><br><span class="line">    c: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b.call(&#123;<span class="attr">a</span>: <span class="number">30</span>&#125;); <span class="comment">// 30</span></span><br><span class="line">obj.c.call(&#123;<span class="attr">a</span>: <span class="number">40</span>&#125;); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>由于箭头函数<strong>没有</strong>自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。<br><strong>但是可以改变它外部普通函数的this指向，箭头函数也会跟着改变。</strong></p>
<font color="#ff502c">函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</font>

<h3 id="3-箭头函数没有prototype-原型-，所以箭头函数本身没有this"><a href="#3-箭头函数没有prototype-原型-，所以箭头函数本身没有this" class="headerlink" title="3.箭头函数没有prototype(原型)，所以箭头函数本身没有this"></a>3.箭头函数没有<font color="#ff502c">prototype</font>(原型)，所以箭头函数本身没有this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bb = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bb.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="4-箭头函数是匿名函数，不能作为构造函数，不能使用new"><a href="#4-箭头函数是匿名函数，不能作为构造函数，不能使用new" class="headerlink" title="4.箭头函数是匿名函数，不能作为构造函数，不能使用new"></a>4.箭头函数是匿名函数，不能作为构造函数，不能使用new</h3><p>如果<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bb = <span class="keyword">new</span> aa(); <span class="comment">// Uncaught TypeError: aa is not a constructor</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-箭头函数的arguments"><a href="#5-箭头函数的arguments" class="headerlink" title="5.箭头函数的arguments"></a>5.箭头函数的arguments</h3><ul>
<li>箭头函数的this指向全局，使用arguments会报未声明的错误</li>
<li>箭头函数的this指向普通函数时,它的argumens继承于该普通函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bb = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> aa = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">    &#125;</span><br><span class="line">    cc();</span><br><span class="line">&#125;</span><br><span class="line">aa.call(&#123;<span class="attr">name</span>: <span class="string">'aa'</span>&#125;);</span><br><span class="line">bb();</span><br></pre></td></tr></table></figure>
<p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<h3 id="箭头函数不能当做Generator函数-不能使用yield关键字"><a href="#箭头函数不能当做Generator函数-不能使用yield关键字" class="headerlink" title="箭头函数不能当做Generator函数,不能使用yield关键字"></a>箭头函数不能当做Generator函数,不能使用yield关键字</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>箭头函数注意事项</strong></p>
<ul>
<li><strong>箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名</strong></li>
<li><strong>箭头函数一条语句返回对象字面量，需要加括号</strong></li>
<li><strong>箭头函数在参数和箭头之间不能换行！</strong></li>
<li><strong>箭头函数不支持new.target</strong></li>
<li><strong>箭头函数的this意外指向和代码的可读性。</strong></li>
</ul>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么在vue中推荐使用Mixins (未完成)</title>
    <url>/blog/vue/vue-Mixins-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Vue中双向绑定的原理（mvvm）(未完成)</title>
    <url>/blog/vue/vue-mvvm.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Http系列(二) Http2中的多路复用</title>
    <url>/blog/http/http-http2-1.html</url>
    <content><![CDATA[<p><strong><em>重为轻根，静为躁君。——老子</em></strong></p>
<blockquote>
<p><a href="/blog/http/http-http2.html">Http 系列(-) Http 发展历史</a><br><a href="/blog/http/http-http2-1.html">Http 系列(二) Http2 中的多路复用</a><br><a href="/blog/http/http-tcp.html">Http 系列(三) Http/Tcp 三次握手和四次挥手</a><br><a href="/blog/http/http-get-post.html">Http 系列(四) Http 中 Get/Post 的区别</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><font color="#ff502c">多路复用</font>代替原来的<font color="#ff502c">序列和阻塞机制</font>，所有就是请求的都是通过<font color="#ff502c">一个 TCP 连接并发</font>完成。同时也很好的解决了<font color="#ff502c">浏览器限制同一个域名下</font>的<font color="#ff502c">请求数量</font>的问题。</p>
<p>在 HTTP/2 中，有了二进制分帧之后，HTTP/2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2 中：</p>
<ul>
<li><strong>同域名下所有通信都在单个连接上完成，同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应</strong>。</li>
<li><strong>单个连接可以承载任意数量的双向数据流，单个连接上可以并行交错的请求和响应，之间互不干扰</strong>。</li>
<li><strong>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低</strong>。</li>
</ul>
<h2 id="帧（frame）和流（stream）"><a href="#帧（frame）和流（stream）" class="headerlink" title="帧（frame）和流（stream）"></a>帧（frame）和流（stream）</h2><hr>
<p>在 HTTP/2 中，有两个非常重要的概念：帧（frame）和流（stream）。</p>
<h3 id="帧（frame）"><a href="#帧（frame）" class="headerlink" title="帧（frame）"></a>帧（frame）</h3><p>HTTP/2 中<strong>数据传输的最小单位</strong>，因此帧不仅要细分表达 HTTP/1.x 中的各个部份，也优化了 HTTP/1.x 表达得不好的地方，同时还增加了 HTTP/1.x 表达不了的方式。<br>每一帧都包含几个字段，有<strong>length、type、flags、stream identifier、frame playload</strong>等，其中<font color="#ff502c">type 代表帧的类型</font>，在 HTTP/2 的标准中定义了 10 种不同的类型，包括上面所说的 HEADERS frame 和 DATA frame。此外还有：<br><code>PRIORITY</code>（设置流的优先级）<br><code>RST_STREAM</code>（终止流）<br><code>SETTINGS</code>（设置此连接的参数）<br><code>PUSH_PROMISE</code>（服务器推送）<br><code>PING</code>（测量 RTT）<br><code>GOAWAY</code>（终止连接）<br><code>WINDOW_UPDATE</code>（流量控制）<br><code>CONTINUATION</code>（继续传输头部数据）</p>
<p>在 HTTP 2.0 中，它把数据报的两大部分分成了 <font color="#ff502c">header frame</font> 和 <font color="#ff502c">data frame</font>。也就是头部帧和数据体帧。</p>
<h3 id="流（stream）"><a href="#流（stream）" class="headerlink" title="流（stream）"></a>流（stream）</h3><p>流： 存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。<br>HTTP/2 长连接中的数据包是不按请求-响应顺序发送的，一个完整的请求或响应(称一个数据流 stream，每个数据流都有一个独一无二的编号)可能会分成非连续多次发送。它具有如下几个特点：</p>
<ul>
<li><strong>双向性：同一个流内，可同时发送和接受数据</strong>。</li>
<li><strong>有序性：流中被传输的数据就是二进制帧 。帧在流上的被发送与被接收都是按照顺序进行的</strong>。</li>
<li><strong>并行性：流中的 二进制帧 都是被并行传输的，无需按顺序等待</strong>。</li>
<li><strong>流的创建：流可以被客户端或服务器单方面建立, 使用或共享</strong>。</li>
<li><strong>流的关闭：流也可以被任意一方关闭</strong>。</li>
<li><strong>HEADERS 帧在 DATA 帧前面</strong>。</li>
<li><strong>流的 ID 都是奇数，说明是由客户端发起的，这是标准规定的，那么服务端发起的就是偶数了</strong>。</li>
</ul>
<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><hr>
<p>从 Http/0.9 到 Http/2 要发送多个请求，从<strong>多个 Tcp 连接=&gt;keep-alive=&gt;管道化=&gt;多路复用</strong>不断的减少多次创建 Tcp 等等带来的性能损耗。</p>
<h3 id="多个-Tcp-连接"><a href="#多个-Tcp-连接" class="headerlink" title="多个 Tcp 连接"></a>多个 Tcp 连接</h3><p>在最早的时候没有<code>keep-alive</code>只能创建多个<code>Tcp</code>连接来做多次请求。多次 http 请求效果如下图所示：<br><img src="../../images/http/http2.0-1-6.png" alt="http2.0" width="50%"><br>一次请求完成就会关闭本次的 Tcp 连接，下个请求又要从新建立 Tcp 连接传输完成数据再关闭，造成很大的性能损耗。</p>
<h3 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h3><p><code>Keep-Alive</code>解决的核心问题是： 一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是<strong>可以配置</strong>的，不管你用的是<code>Apache</code>还是<code>nginx</code>。<br>以往，浏览器判断响应数据是否接收完毕，是看连接是否关闭。在使用持久连接后，就不能这样了，这就要求服务器对持久连接的响应头部一定要返回<code>content-length</code>标识<code>body的</code>长度，供浏览器判断界限。有时，<code>content-length</code>的方法并不是太准确，也可以使用 <code>Transfer-Encoding: chunked</code> 头部发送一串一串的数据，最后由长度为 0 的<code>chunked</code>标识结束。<br>多次 http 请求效果如下图所示：<br><img src="../../images/http/http2.0-1-7.png" alt="http2.0" width="50%"><br>上图：设置 Connection:Keep-Alive，保持连接在一段时间内不断开。</p>
<p><code>Keep-Alive</code>还是存在如下问题：</p>
<ul>
<li>串行的文件传输。</li>
<li>同域并行请求限制带来的阻塞（6~8）个</li>
</ul>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p><font color="#ff502c">HTTP 管线化</font>可以<font color="#ff502c">克服同域并行请求限制带来的阻塞</font>，它是建立在<strong>持久连接</strong>之上，是把所有请求一并发给服务器，但是服务器需要按照<strong>顺序一个一个响应</strong>，而不是等到一个响应回来才能发下一个请求，这样就节省了很多请求到服务器的时间。不过，HTTP 管线化<strong>仍旧</strong>有阻塞的问题，若上一响应迟迟不回，<strong>后面的响应</strong>都会被阻塞到。<br><img src="../../images/http/http2.0-1-8.png" alt="http2.0" width="50%"><br>上图：HTTPpipelining：建立多个连接</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>多路复用代替原来的<font color="#ff502c">序列和阻塞机制</font>。所有就是请求的都是通过<font color="#ff502c">一个 TCP 连接并发</font>完成。因为在多路复用之前所有的传输是基于<font color="#ff502c">基础文本的</font>，在多路复用中是基于<font color="#ff502c">二进制数据帧</font>的传输、<font color="#ff502c">消息</font>、<font color="#ff502c">流</font>，所以可以做到乱序的传输。<font color="#ff502c">多路复用</font>对同一域名下所有请求都是基于<font color="#ff502c">流</font>，所以<font color="#ff502c">不存在</font>同域并行的阻塞。多次请求如下图：<br><img src="../../images/http/http2.0-1-9.png" alt="http2.0" width="50%"><br>上图：多路复用</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）</strong>。</p>
<p><strong>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流</strong>。</p>
<p><strong>HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效</strong>。</p>
<p>多路复用代替了 HTTP1.x 的<strong>序列和阻塞机制</strong>，所有的相同域名请求都通过<strong>同一个 TCP 连接并发</strong>完成。<strong>同一 Tcp 中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.kancloud.cn/digest/web-performance-http2/74825" target="_blank" rel="noopener">多路复用</a><br><a href="https://segmentfault.com/a/1190000018401534" target="_blank" rel="noopener">一文读懂 HTTP/2 及 HTTP/3 特性</a><br><a href="https://zhuanlan.zhihu.com/p/26559480" target="_blank" rel="noopener">一文读懂 HTTP/2 特性</a><br><a href="https://segmentfault.com/a/1190000011172823" target="_blank" rel="noopener">浅析 HTTP/2 的多路复用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Http2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的变量提升</title>
    <url>/blog/javascript/hoisting.html</url>
    <content><![CDATA[<h2 id="产生变量提升的原因"><a href="#产生变量提升的原因" class="headerlink" title="产生变量提升的原因"></a>产生变量提升的原因</h2><p>在 ES6 之前，JavaScript <strong>没有块级作用域(一对花括号{}即为一个块级作用域)</strong>，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。<br>在 JavaScript 代码运行之前其实是有一个编译阶段的。编译之后才是从上到下，一行一行解释执行。变量提升就发生在编译阶段，它把变量和函数的声明提升至作用域的顶端。（编译阶段的工作之一就是将变量与其作用域进行关联）。<br>我先分开介绍变量提升和函数提升到后面再放到一起比较。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>我们直接从代码从最基础的开始</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>相信这个大家知道，上面代码其实就是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>他会提前声明 a,但是不会给 a 赋值。<br>但是如下代码会怎么执行呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果没有通过 var 声明值类型的就不会存在变量提升，而是会报错。</p>
<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>和变量提升一样存在函数提升，但是他们还有点不同。如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他会提前声明并且赋值，还有一种函数声明方式，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法就和变量提升相同了。<br>还有一种我感觉要说一下，其实不仔细思考也很容易犯错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会输出如下：</span></span><br><span class="line"><span class="comment">// 1 这个 a function 输出的</span></span><br><span class="line"><span class="comment">// undefined 因为 a function没有 return出来任何值，默认return  undefined。</span></span><br></pre></td></tr></table></figure>
<p>为什么会输出 一个 <font color="#ff502c">1</font> 和一个<font color="#ff502c">undefined</font>,我来解释一下,首先 console.log(a())，他会<font color="#ff502c">先执行 a()</font>方法，<font color="#ff502c">输出 1</font>,但是 a 方法没有返回值，默认返回<font color="#ff502c">undefined</font>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a()); <span class="comment">// Uncaught TypeError: a is not a function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个看一下就行。</p>
<h3 id="结合变量提升和函数提升"><a href="#结合变量提升和函数提升" class="headerlink" title="结合变量提升和函数提升"></a>结合变量提升和函数提升</h3><p>如果变量提升遇到函数提升，那个优先级更高呢，看下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>看上面的代码知道<font color="#ff502c">函数提升</font>是<font color="#ff502c">高于变量提升</font>的，因为在 javascript 中函数是一等公民，<font color="#ff502c">并且不会被变量声明覆盖</font>，但是会被<font color="#ff502c">变量赋值覆盖</font>。其实代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>我们再来一个稍微复杂一点的，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(2);&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<p>在多次函数提升的会后一个覆盖前一个，然后才是变量提升，其实代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(2);&#125;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<p>基本上这个上面基本上包含了 javascript 的变量提升和函数提升。其实还有一个作用域的我在这边就不介绍了，我会开篇再好好说一下作用域。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webSocket(二) 短轮询、长轮询、Websocket、sse</title>
    <url>/blog/http/http-web-socket2.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/http/http-web-socket1.html">webSocket(一) 浅析</a><br><a href="/blog/http/http-web-socket2.html">webSocket(二) 短轮询、长轮询、Websocket、sse</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Web Sockets定义了一种在通过一个单一的 socket 在网络上进行<strong>全双工通讯的通道</strong>。仅仅是传统的 HTTP 通讯的一个增量的提高，尤其对于<strong>实时、事件驱动</strong>的应用来说是一个飞跃。<br>通过<font color="#ff502c">Polling(轮询)</font>、<font color="#ff502c">Long-Polling(长轮询)</font>、<font color="#ff502c">Websocket</font>、<font color="#ff502c">sse</font>的对比。四种Web即时通信技术比较它们的<strong>实现方式</strong>和<strong>各自的优缺点</strong>。<br>对比优缺点如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">轮询(Polling)</th>
<th style="text-align:center">长轮询(Long-Polling)</th>
<th style="text-align:center">Websocket</th>
<th style="text-align:center">sse</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通信协议</td>
<td style="text-align:center">http</td>
<td style="text-align:center">http</td>
<td style="text-align:center">tcp</td>
<td style="text-align:center">http</td>
</tr>
<tr>
<td style="text-align:center">触发方式</td>
<td style="text-align:center">client(客户端)</td>
<td style="text-align:center">client(客户端)</td>
<td style="text-align:center">client、server(客户端、服务端)</td>
<td style="text-align:center">client、server(客户端、服务端)</td>
</tr>
<tr>
<td style="text-align:center">优点</td>
<td style="text-align:center">兼容性好容错性强，实现简单</td>
<td style="text-align:center">比短轮询节约资源</td>
<td style="text-align:center">全双工通讯协议，性能开销小、安全性高，可扩展性强</td>
<td style="text-align:center">实现简便，开发成本低</td>
</tr>
<tr>
<td style="text-align:center">缺点</td>
<td style="text-align:center">安全性差，占较多的内存资源与请求数</td>
<td style="text-align:center">安全性差，占较多的内存资源与请求数</td>
<td style="text-align:center">传输数据需要进行二次解析，增加开发成本及难度</td>
<td style="text-align:center">只适用高级浏览器</td>
</tr>
<tr>
<td style="text-align:center">延迟</td>
<td style="text-align:center">非实时，延迟取决于请求间隔</td>
<td style="text-align:center">同短轮询</td>
<td style="text-align:center">实时</td>
<td style="text-align:center">非实时，默认3秒延迟，延迟可自定义</td>
</tr>
</tbody>
</table>
<p>上面基本上包含了各个实现方式的<strong>优点</strong>和<strong>缺点</strong>，它们基于什么<strong>协议</strong>、由那端<strong>主动</strong>发送数据。</p>
<h2 id="轮询-Polling"><a href="#轮询-Polling" class="headerlink" title="轮询(Polling)"></a>轮询(Polling)</h2><p><strong>短轮询(Polling)</strong>的实现思路就是<strong>浏览器端</strong>每隔几秒钟向<strong>服务器端</strong>发送<font color="#ff502c">http</font>请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。<strong>在服务端响应完成，就会关闭这个Tcp连接</strong>，如下图所示：<br><img src="../../images/http/websocket-1-1.jpg" alt="webSocket"><br>示例代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Polling</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fetch(url).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// somthing</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setInterval(polling, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>优点：可以看到实现非常简单，它的<strong>兼容性</strong>也比较好的只要<strong>支持http协议</strong>就可以用这种方式实现。</li>
<li>缺点：但是它的缺点也很明显就是非常的消耗资源，因为建立<code>Tcp</code>连接是非常消耗资源的，服务端响应完成就会关闭这个<code>Tcp</code>连接，下一次请求再次建立<code>Tcp</code>连接。</li>
</ul>
<h2 id="COMET"><a href="#COMET" class="headerlink" title="COMET"></a>COMET</h2><p><strong>Alex Russell（Dojo Toolkit 的项目 Lead）</strong>称这种基于<code>HTTP长连接</code>、无须在浏览器端安装插件的“服务器推”技术为<code>“Comet”</code>。<br>常用的COMET分为两种：<strong>基于HTTP的长轮询（long-polling）技术，以及基于iframe的长连接流（stream）模式</strong>。</p>
<h3 id="长轮询（Long-Polling）"><a href="#长轮询（Long-Polling）" class="headerlink" title="长轮询（Long-Polling）"></a>长轮询（Long-Polling）</h3><p>客户端发送请求后服务器端<strong>不会立即</strong>返回数据，服务器端会<strong>阻塞请求</strong>连接不会<strong>立即断开</strong>，直到服务器端<strong>有数据更新或者是连接超时</strong>才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据。大致效果如下：<br><img src="../../images/http/websocket-1-2.jpg" alt="webSocket"><br>客户端的代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LongPolling</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fetch(url).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        LongPolling();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        LongPolling();</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">LongPolling();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>优点： 长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。</li>
<li>缺点：连接挂起也会导致资源的浪费。</li>
</ul>
<h3 id="基于iframe的长连接流（stream）模式"><a href="#基于iframe的长连接流（stream）模式" class="headerlink" title="基于iframe的长连接流（stream）模式"></a>基于iframe的长连接流（stream）模式</h3><p>当我们在页面中嵌入一个<font color="#ff502c">iframe</font>并设置其src时，服务端就可以通过长连接<font color="#ff502c">“源源不断”</font>地向客户端输出内容。<br>例如，我们可以向客户端返回一段<code>script</code>标签包裹的<code>javascript</code>代码，该代码就<font color="#ff502c">会在iframe中执行</font>。因此，如果我们预先在<code>iframe</code>的父页面中定义一个<font color="#ff502c">处理函数process()</font>，而在每次有新数据需要<font color="#ff502c">推送时</font>，在该连接响应中写入<font color="#ff502c"><script>parent.process(${your_data})</script></font>。那么iframe中的这段代码就会调用父页面中预先定义的<font color="#ff502c">process()函数</font>。（是不是有点像JSONP传输数据的方式？）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在父页面中定义的数据处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不可见的iframe</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.style = <span class="string">'display: none'</span>;</span><br><span class="line"><span class="comment">// src指向后端接口</span></span><br><span class="line">iframe.src = <span class="string">'/long_iframe'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure></p>
<p>后端还是以node为例<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回数据的方法，将数据拼装成script脚本返回给iframe</span></span><br><span class="line">    <span class="keyword">const</span> iframeSend = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="string">`&lt;script type="text/javascript"&gt;</span></span><br><span class="line"><span class="string">                        parent.process(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)</span></span><br><span class="line"><span class="string">                    &lt;/script&gt;`</span>;</span><br><span class="line">        res.write(script);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    res.setHeader(<span class="string">'connection'</span>, <span class="string">'keep-alive'</span>);</span><br><span class="line">    <span class="comment">// 注意设置相应头的content-type</span></span><br><span class="line">    res.setHeader(<span class="string">'content-type'</span>, <span class="string">'text/html; charset=utf-8'</span>);        </span><br><span class="line">    <span class="comment">// 当有数据更新时，服务端“推送”数据给客户端</span></span><br><span class="line">    EVENT.addListener(MSG_POST, iframeSend);</span><br><span class="line"></span><br><span class="line">    req.socket.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'iframe socket close'</span>);</span><br><span class="line">        <span class="comment">// 注意在连接关闭时移除监听，避免内存泄露</span></span><br><span class="line">        EVENT.removeListener(MSG_POST, iframeSend);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="../../images/http/websocket-1-3.gif" alt="webSocket"></p>
<blockquote>
<p>不过使用iframe有个小瑕疵，因此这个iframe相当于永远也不会加载完成，所以浏览器上会一直有一个loading标志。</p>
</blockquote>
<p>他的优缺点和上面的长轮询一样。</p>
<h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><p>WebSocket的一些特性和基础使用方法在这里就不多赘述了，请看另一篇博客<a href="/blog/http/http-web-socket1.html">webSocket(一) 浅析</a>;<br>大致代码如下：<br><strong>服务端</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>: <span class="number">8080</span>&#125;);</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: receive connection'</span>);</span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: recevied: %s'</span>, message);</span><br><span class="line">    &#125;);</span><br><span class="line">    ws.send(<span class="string">'world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>客户端</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">    ws.send(<span class="string">'from client:hello'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'from server:'</span> + e.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行效果如下：<br><img src="../../images/http/web-socket-1-2.png" alt="webSocket"></p>
<ul>
<li>优点：不会造成性能的浪费</li>
<li>缺点：学习一套新的请求库</li>
</ul>
<h2 id="SSE-Server-Sent-Events"><a href="#SSE-Server-Sent-Events" class="headerlink" title="SSE (Server-Sent Events)"></a>SSE (Server-Sent Events)</h2><p><code>Server-Sent</code>是<code>HTML5</code>提出一个标准。由客户端发起与服务器之间创建<code>TCP</code>连接，然后<strong>并维持这个连接</strong>，直到客户端或服务器中的任何一方断开，<code>ServerSent</code>使用的是”问”+”答”的机制，连接创建后浏览器会周期性地发送消息至服务器询问，是否有自己的消息。其实现原理类似于我们在上一节中提到的<strong>基于iframe的长连接模式</strong>。<br>HTTP响应内容有一种特殊的<code>content-type —— text/event-stream</code>，该响应头标识了响应内容为<strong>事件流</strong>，客户端<strong>不会关闭连接</strong>，而是等待服务端不断得发送响应结果。<br>SSE规范比较简单，主要分为两个部分：浏览器中的<font color="#ff502c">EventSource</font>对象，以及服务器端与浏览器端之间的<strong>通讯协议</strong>。</p>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>在浏览器中可以通过<font color="#ff502c">EventSource</font>构造函数来创建该对象<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">'/sse'</span>);</span><br></pre></td></tr></table></figure></p>
<p>而<code>SSE</code>的响应内容可以看成是一个<strong>事件流</strong>，由不同的事件所组成。这些事件会触发前端<code>EventSource</code>对象上的方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的事件</span></span><br><span class="line">source.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的事件名</span></span><br><span class="line">source.addEventListener(<span class="string">'my_msg'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    process(e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接打开</span></span><br><span class="line">source.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'open sse'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误</span></span><br><span class="line">source.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<font color="#ff502c">EventSource</font>通过事件监听的方式来工作。注意上面的代码监听了<font color="#ff502c">y_msg</font>事件，SSE支持自定义事件，默认事件通过监听message来获取数据。实现代码如下:<br><br><strong>客户端</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示聊天信息</span></span><br><span class="line"><span class="keyword">let</span> chat = <span class="keyword">new</span> EventSource(<span class="string">"/chat-room"</span>);</span><br><span class="line">chat.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = event.data;</span><br><span class="line">    $(<span class="string">".list-group"</span>).append(<span class="string">"&lt;li class='list-group-item'&gt;"</span> + msg + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">    <span class="comment">// chat.close(); 关闭server-sent event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义事件</span></span><br><span class="line">chat.addEventListener(<span class="string">"myChatEvent"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = event.data;</span><br><span class="line">    $(<span class="string">".list-group"</span>).append(<span class="string">"&lt;li class='list-group-item'&gt;"</span> + msg + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><strong>服务端 nodejs</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line">router.get(<span class="string">'/chat-room'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当res.white的数据data 以\n\n结束时 就默认该次消息发送完成，触发onmessage方法，以\r\n不会触发onmessage方法</span></span><br><span class="line">    res.header(&#123;</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"text/event-stream"</span>,</span><br><span class="line">        <span class="string">"Cache-Control"</span>: <span class="string">"no-cache"</span>,</span><br><span class="line">        <span class="string">"Connection"</span>: <span class="string">"keep-alive"</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.white("event: myChatEvent\r\n"); 自定义事件</span></span><br><span class="line">    res.write(<span class="string">"retry: 10000\r\n"</span>); <span class="comment">// 指定通信的最大间隔时间</span></span><br><span class="line">    res.write(<span class="string">"data: start~~\n\n"</span>);</span><br><span class="line">    res.end(); <span class="comment">// 不加end不会认为本次数据传输结束 会导致不会有下一次请求</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br>- 优点： 客户端只需连接一次，Server就定时推送，除非其中一端断开连接。并且SSE会在连接意外断开时自动重连。<br>- 缺点： 要学习新的语法<br><br>## 总结<br>上面四种Web即时通信技术比较，可以从不同的角度考虑，它们的优先级是不同的，基本上可以分为两大类基于<code>http</code>和<code>tcp</code>两种通信中的一种。<br><strong>兼容性考虑</strong><br><font color="#ff502c">短轮询&gt;长轮询&gt;长连接SSE&gt;WebSocket</font><br><strong>从性能方面考虑</strong><br><font color="#ff502c">WebSocket&gt;长连接SSE&gt;长轮询&gt;短轮询</font><br><strong>服务端推送</strong><br><font color="#ff502c">WebSocket&gt;长连接SSE&gt;长轮询</font>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/post/5b135b78f265da6e420eab7d#heading-7" target="_blank" rel="noopener">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a><br><a href="https://mp.weixin.qq.com/s/7KtvnY4zSfjORtxv30YaKQ" target="_blank" rel="noopener">JavaScript 服务器推送技术之 WebSocket</a><br><a href="https://www.cnblogs.com/huchong/p/8595644.html" target="_blank" rel="noopener">轮询、长轮询、长连接、websocket</a><br><a href="https://www.jianshu.com/p/ef054d3d1b62" target="_blank" rel="noopener">消息推送机制-轮询、长轮询、SSE(Server Sent Event)和WS(WebSocket)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Http系列(三) Http/Tcp三次握手和四次挥手</title>
    <url>/blog/http/http-tcp.html</url>
    <content><![CDATA[<p><strong><em>见素抱朴、少私寡欢。——老子</em></strong></p>
<blockquote>
<p><a href="/blog/http/http-http2.html">Http 系列(-) Http 发展历史</a><br><a href="/blog/http/http-http2-1.html">Http 系列(二) Http2 中的多路复用</a><br><a href="/blog/http/http-tcp.html">Http 系列(三) Http/Tcp 三次握手和四次挥手</a><br><a href="/blog/http/http-get-post.html">Http 系列(四) Http 中 Get/Post 的区别</a></p>
</blockquote>
<h2 id="TCP-概念"><a href="#TCP-概念" class="headerlink" title="TCP 概念"></a>TCP 概念</h2><hr>
<p><code>TCP(Transmission Control Protocol 传输控制协议)</code>是一种<font color="#ff502c">面向连接(连接导向)</font>的、<font color="#ff502c">可靠</font>的、 <font color="#ff502c">基于 IP 的传输层</font>协议。<br>首先来看看 OSI 的七层模型<br><img src="../../images/http/1.jpg" alt="OSI"><br>我们需要知道<code>TCP</code>工作在网络 OSI 的七层模型中的第四层——<font color="#ff502c">传输层，IP 在第三层——网络层，ARP 在第二层——数据链路层</font>;同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上<strong>头部信息</strong>，进行 封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封 装的过程。在 OSI 七层模型中，每一层的作用和对应的协议如下：<br><img src="../../images/http/http-1-1.jpg" alt="OSI"></p>
<p><strong>标志位</strong><br>要理解三次握手四次挥手，首先要理解几个比较重要的标示如 SYN、ACK，如下面的表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SYN</td>
<td style="text-align:center">请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为 1</td>
</tr>
<tr>
<td style="text-align:center">ACK</td>
<td style="text-align:center">确认号是否有效，一般置为 1。</td>
</tr>
<tr>
<td style="text-align:center">FIN</td>
<td style="text-align:center">释放一个连接。</td>
</tr>
<tr>
<td style="text-align:center">PSH</td>
<td style="text-align:center">提示接收端应用程序立即从 TCP 缓冲区把数据读走。</td>
</tr>
<tr>
<td style="text-align:center">RST</td>
<td style="text-align:center">对方要求重新建立连接，复位。</td>
</tr>
<tr>
<td style="text-align:center">URG</td>
<td style="text-align:center">紧急指针（urgent pointer）有效。</td>
</tr>
</tbody>
</table>
<p><strong>序号</strong></p>
<ul>
<li>序号：Seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li>
<li>确认序号：Ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。</li>
</ul>
<p>三次握手四次挥手整体的流程如下图所示：<br><img src="../../images/http/http-1-3.jpg" width="50%"></p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>三次握手的过程大致如下图所示：<br><img src="../../images/http/http-1-2.png" alt="OSI"><br>大致步骤如下：</p>
<h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p><strong>客户端向服务器发出连接请求报文</strong>，这时报文首部中的同部位<font color="#ff502c">SYN=1</font>，同时随机生成<font color="#ff502c">初始序列号 seq=x</font>，此时，TCP 客户端进程进入了 <font color="#ff502c">SYN-SENT（同步已发送状态）状态</font>。TCP 规定，<font color="#ff502c">SYN 报文段（SYN=1 的报文段）</font>不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。</p>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p><strong><code>TCP</code>服务器收到请求报文后</strong>，如果同意连接，则发出确认报文。确认报文中应该 <font color="#ff502c">ACK=1，SYN=1</font>，确认号是<font color="#ff502c">ack=x+1</font>，同时也要为自己随机初始化一个<font color="#ff502c">序列号 seq=y</font>，此时，TCP 服务器进程进入了<font color="#ff502c">SYN-RCVD（同步收到）状态</font>。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有<font color="#ff502c">SYN(建立连接)</font>和<font color="#ff502c">ACK(确认)标志</font>，询问客户端是否准备好。</p>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p><strong><code>TCP</code>客户进程收到确认后，还要向服务器给出确认</strong>。<font color="#ff502c">确认报文的 ACK=1，ack=y+1</font>，此时，TCP 连接建立，客户端进入<font color="#ff502c">ESTABLISHED（已建立连接）状态</font>。TCP 规定，<font color="#ff502c">ACK 报文段</font>可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。</p>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><blockquote>
<p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。</p>
</blockquote>
<p><strong>样例</strong><br>在谢希仁著《计算机网络》书中同时举了一个例子，如下：</p>
<blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p>
</blockquote>
<p>总结一下就是为了<strong>防止服务端的等待浪费资源</strong>。</p>
<h2 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h2><p>建立连接后，两台主机就可以相互传输数据了。如下图所示：<br><img src="../../images/http/http-1-4.png" width="50%"></p>
<ul>
<li><strong>主机 A 初始 seq 为 1200,滑动窗体为 100,向主机 B 传递数据的过程</strong>。</li>
<li>假设主机 B 在完全成功接收数据的基础上,那么主机 B 为了确认这一点，向主机 A 发送 ACK 包，并将 Ack 号设置为 1301。因此按如下的公式确认 Ack 号：Ack 号 = Seq 号 + 传递的字节数 + 1 （这是在完全接受成功的情况下）</li>
<li>主机 A 获得 B 传来的 ack(1301)后,开始发送 seq 为 1301,滑动窗体为 100 的数据。</li>
</ul>
<p>与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。上面说了，主机 B 完全成功接收 A 发来的数据才是这样的,如果存在丢包该如何。下面分析传输过程中数据包丢失的情况，如下图所示：<br><img src="../../images/http/http-1-5.png" width="50%"></p>
<p>上图表示通过 Seq 1301 数据包向主机 B 传递 100 字节的数据，但中间发生了错误，主机 B 未收到。经过一段时间后，主机 A 仍未收到对于 Seq 1301 的 ACK 确认，因此尝试重传数据。为了完成数据包的重传，TCP 套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>四次挥手流程大致如下图所示：<br><img src="../../images/http/http-1-6.png" alt="OSI"></p>
<h3 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h3><p><font color="#ff502c">客户端发送一个 FIN(结束)，用来关闭客户到服务端的连接</font>。<br>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<font color="#ff502c">FIN=1</font>，其<font color="#ff502c">序列号为 seq=u</font>（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</p>
<h3 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h3><p><font color="#ff502c">服务端收到这个 FIN，他发回一个 ACK(确认)，确认收到序号为收到序号+1，和 SYN 一样，一个 FIN 将占用一个序号</font>。<br>服务器收到连接释放报文，发出确认报文，<font color="#ff502c">ACK=1，ack=u+1</font>，并且带上自己的<font color="#ff502c">序列号 seq=v</font>，此时，服务端就进入了<font color="#ff502c">CLOSE-WAIT（关闭等待）状态</font>。TCP 服务器<br>通知高层的应用进程，客户端向服务器的方向就释放了，<font color="#ff502c">这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受</font>。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p>
<blockquote>
<p>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
</blockquote>
<h3 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h3><p><font color="#ff502c">服务端发送一个 FIN(结束)到客户端，服务端关闭客户端的连接</font>。</p>
<p><font color="#ff502c">服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1</font>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的<font color="#ff502c">序列号为 seq=w</font>，此时，服务器就进入了<font color="#ff502c">LAST-ACK（最后确认）状态</font>，等待客户端的确认。</p>
<h3 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h3><p><font color="#ff502c">客户端发送 ACK(确认)报文确认，并将确认的序号+1，这样关闭完成</font>。<br><strong>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态</strong>。</p>
<blockquote>
<p>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p>
</blockquote>
<h2 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h2><ul>
<li><strong>为什么要三次握手</strong></li>
<li><strong>为什么是 4 次挥手</strong></li>
<li><strong>TCP 和 UDP 的区别</strong></li>
<li><strong>客户端突然挂掉了怎么办</strong></li>
<li><strong>为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态</strong></li>
<li><strong>浏览器同时可以开启多少个 http 链接</strong></li>
</ul>
<h3 id="为什么要三次握手（两次握手可以吗？）"><a href="#为什么要三次握手（两次握手可以吗？）" class="headerlink" title="为什么要三次握手（两次握手可以吗？）"></a>为什么要三次握手（两次握手可以吗？）</h3><p>client 发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达 server，本来这已经是一个失效的报文，但是 server 端接收到这个请求报文后，还是会想 client 发出确认的报文，表示同意连接。假如不采用三次握手，那么只要 server 发出确认，新的建立就连接了，但其实这个请求是失效的请求，client 是不会理睬 server 的确认信息，也不会向服务端发送确认的请求，但是 server 认为新的连接已经建立起来了，并一直等待 client 发来数据，这样，server 的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server 会因为收不到确认的报文，就知道 client 并没有建立连接。这就是三次握手的作用。</p>
<p>简单来说，就是为了<strong>防止服务端的等待浪费资源</strong></p>
<h3 id="为什么是-4-次挥手"><a href="#为什么是-4-次挥手" class="headerlink" title="为什么是 4 次挥手"></a>为什么是 4 次挥手</h3><p>握手的时候，A 和 B 打个招呼，B 可以直接把自己的 SYN 信息和对 A 的回应 ACK 信息一起带上，但是挥手的时候，A 说我要断开了，B 还没发完最后的数据，因此需要先回应一下 A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了 2 步：<br>（1）回应 A；<br>（2）发送自己的最后一个数据</p>
<p><strong>为了确保数据能够完成传输。</strong></p>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul>
<li>TCP 是<font color="#ff502c">面向连接</font>的，udp 是<font color="#ff502c">无连接</font>的即发送数据前不需要先建立链接。</li>
<li><font color="#ff502c">TCP 保证数据正确性，UDP 可能丢包，TCP 保证数据顺序，UDP 不保证</font>。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付 Tcp 通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li><strong>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多</strong>。</li>
<li><strong>TCP 是面向字节流，UDP 面向报文，UDP 具有较好的实时性，工作效率比 TCP 高</strong>.并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</li>
<li><strong>TCP 对系统资源要求较多，UDP 对系统资源要求较少</strong>。</li>
<li><strong>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节</strong>。</li>
</ul>
<h3 id="客户端突然挂掉了怎么办"><a href="#客户端突然挂掉了怎么办" class="headerlink" title="客户端突然挂掉了怎么办"></a>客户端突然挂掉了怎么办</h3><p>正常连接时，客户端突然挂掉了，如果没有措施处理这种情况，那么就会出现客户端和服务器端出现<strong>长时期的空闲</strong>。解决办法是在<strong>服务器端设置保活计时器</strong>，每当服务器收到客户端的消息，就将计时器复位。<strong>超时时间通常设置为 2 小时</strong>。若服务器超过 2 小时没收到客户的信息，他就发送<strong>探测报文段</strong>。若发送了 10 个探测报文段，每一个相隔 75 秒，还没有响应就认为客户端出了故障，因而终止该连接。<br><strong>设置保活计时器</strong></p>
<h3 id="为什么-TIME-WAIT-状态需要经过-2MSL-最大报文段生存时间-才能返回到-CLOSE-状态"><a href="#为什么-TIME-WAIT-状态需要经过-2MSL-最大报文段生存时间-才能返回到-CLOSE-状态" class="headerlink" title="为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态"></a>为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态</h3><p><strong>TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文</strong><br>原因是，担心网络不可靠而导致的丢包，最后一个回应 B 的 ACK 万一丢了怎么办，在这个时间内，A 是可以重新发包的，但是超过了最大等待时间的话，就算收不到也没用了，所以就可以关闭了。</p>
<h3 id="浏览器同时可以开启多少个-http-链接"><a href="#浏览器同时可以开启多少个-http-链接" class="headerlink" title="浏览器同时可以开启多少个 http 链接"></a>浏览器同时可以开启多少个 http 链接</h3><p>浏览器对于同一个域名，一般 PC 端浏览器会针对<font color="#ff502c">单个域名的 server</font>同时<font color="#ff502c">建立 6 ～ 8 个连接</font>，<font color="#ff502c">手机端</font>的连接数则一般控制在<font color="#ff502c">4 ～ 6 个</font>（这个根据浏览器内核不同可能会有所差异），超过浏览器<font color="#ff502c">最大连接数</font>限制，后续请求就会<font color="#ff502c">被阻塞</font>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/qdhxhz/p/8470997.html" target="_blank" rel="noopener">TCP 三次握手和四次挥手</a><br><a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">TCP 的三次握手与四次挥手理解及面试题（很全面）</a>&gt; <a href="https://mp.weixin.qq.com/s/efON3efZoDmHJg1os_3nqA" target="_blank" rel="noopener">通俗大白话来理解 TCP 协议的三次握手和四次分手</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>webSocket(一) 浅析</title>
    <url>/blog/http/http-web-socket1.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/http/http-web-socket1.html">webSocket(一) 浅析</a><br><a href="/blog/http/http-web-socket2.html">webSocket(二) Http 中的轮询、长轮询、Websocket、sse</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>WebSocket 由多个标准构成: WebSocket API 是 W3C 定义的，而 WebSocket 协议(RFC 6455)及其扩展则由 HyBi Working Group(IETF)定义。</p>
</blockquote>
<p>HTML5 开始提供的一种浏览器与服务器进行<font color="#ff502c">全双工通讯的网络技术</font>，属于<font color="#ff502c">应用层协议</font>。它基于<font color="#ff502c">TCP 传输协议</font>，并<font color="#ff502c">复用 HTTP 的握手通道</font>。<br><code>WebSocket</code> 可以实现<strong>客户端与服务器间双向</strong>、<strong>基于消息的文本或二进制数据传输</strong>。<code>WebSocket</code> 连接远远不是一个<strong>网络套接字</strong>，因为浏览器在这个简单的 API 之后隐藏了所有的复杂性，而且还提供了更多服务:</p>
<ul>
<li>连接协商和同源策略;</li>
<li>与既有 HTTP 基础设施的互操作;</li>
<li>基于消息的通信和高效消息分帧;</li>
<li>子协议协商及可扩展能力。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>为什么已经有了轮询还要 WebSocket 呢，是因为短轮询和长轮询有个缺陷：通信只能由客户端发起。<br>WebSocket 提供了一个文明优雅的全双工通信方案。一般适合于对数据的实时性要求比较强的场景，如通信、股票、直播、共享桌面，特别适合于客户端与服务频繁交互的情况下，如聊天室、实时共享、多人协作等平台。<br>他的主要特点如下：</p>
<ul>
<li><strong>建立在 TCP 协议之上，服务器端的实现比较容易。</strong></li>
<li><strong>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</strong></li>
<li><strong>数据格式比较轻量，性能开销小，通信高效。服务器与客户端之间交换的标头信息大概只有 2 字节;</strong></li>
<li><strong>可以发送文本，也可以发送二进制数据。</strong></li>
<li><strong>没有同源限制，客户端可以与任意服务器通信。</strong></li>
<li><strong>协议标识符是 <code>ws</code>（如果加密，则为 wss），服务器网址就是 URL。ex：<code>ws://example.com:80/some/path</code></strong></li>
<li><strong>不用频繁创建及销毁 TCP 请求，减少网络带宽资源的占用，同时也节省服务器资源;</strong></li>
<li><strong>WebSocket 是纯事件驱动的，一旦连接建立，通过监听事件可以处理到来的数据和改变的连接状态，数据都以帧序列的形式传输。服务端发送数据后，消息和事件会异步到达。</strong></li>
<li><strong>无超时处理。</strong></li>
</ul>
<h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p>
<ul>
<li>CONNECTING：值为 0，表示正在连接。</li>
<li>OPEN：值为 1，表示连接成功，可以通信了。</li>
<li>CLOSING：值为 2，表示连接正在关闭。</li>
<li>CLOSED：值为 3，表示连接已经关闭，或者打开连接失败。</li>
</ul>
<h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">"Hello Server!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果要指定多个回调函数，可以使用addEventListener方法。</span></span><br><span class="line">ws.addEventListener(<span class="string">"open"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">"Hello Server!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="webSocket-onmessage-webSocket-send"><a href="#webSocket-onmessage-webSocket-send" class="headerlink" title="webSocket.onmessage()\webSocket.send()"></a>webSocket.onmessage()\webSocket.send()</h3><p><strong>webSocket.onmessage()</strong><br>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。也可以处理二进制数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，服务器数据可能是文本，也可能是二进制数据（`blob对象或Arraybuffer对象`）。</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>webSocket.send()</strong><br>实例对象的<code>send()</code>方法用于向服务器发送数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发送 Blob 对象的例子。</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.querySelector(<span class="string">'input[type="file"]'</span>).files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 ArrayBuffer 对象的例子。</span></span><br><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure>
<h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="webSocket-学习"><a href="#webSocket-学习" class="headerlink" title="webSocket 学习"></a>webSocket 学习</h2><p>对网络应用层协议的学习来说，最重要的往往就是<strong>连接建立过程、数据交换教程</strong>。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。<br>大致可以通过下面的几个方面来学习:</p>
<ul>
<li><strong>如何建立连接</strong></li>
<li><strong>数据帧格式</strong></li>
<li><strong>数据传递</strong></li>
<li><strong>连接保持+心跳</strong></li>
<li><strong>Sec-WebSocket-Key/Accept 的作用</strong></li>
<li><strong>数据掩码的作用</strong></li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了<strong>WebSocket 服务端、WebSocket 客户端（网页端）</strong>。完整代码可以在 这里 找到。这里服务端用了<code>ws</code>这个库。相比大家熟悉的<code>socket.io</code>，ws 实现更<strong>轻量</strong>，更适合学习的目的。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>代码如下，监听<code>8080</code>端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">"http"</span>).Server(app);</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">"ws"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line">wss.on(<span class="string">"connection"</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"server: receive connection"</span>);</span><br><span class="line">  ws.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"server: recevied: %s"</span>, message);</span><br><span class="line">  &#125;);</span><br><span class="line">  ws.send(<span class="string">"world"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">"/index.html"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>服务端运行结果如下图所示：<br><img src="../../images/http/web-socket-1-1.png" alt="webSocket"></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>代码如下，向 8080 端口发起 WebSocket 连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8080"</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"ws onopen"</span>);</span><br><span class="line">  ws.send(<span class="string">"from client:hello"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"ws onmessage"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"from server:"</span> + e.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端运行结果如下图所示：<br><img src="../../images/http/web-socket-1-2.png" alt="webSocket"></p>
<h2 id="如何建立连接"><a href="#如何建立连接" class="headerlink" title="如何建立连接"></a>如何建立连接</h2><p>前面提到，WebSocket 复用了<font color="#ff502c">HTTP 的握手通道</font>。具体指的是，客户端通过 HTTP 请求与 WebSocket<font color="#ff502c">服务端协商升级协议</font>。协议升级完成后，后续的数据交换则遵照<font color="#ff502c">WebSocket 的协议</font>。</p>
<h3 id="客户端：申请协议升级"><a href="#客户端：申请协议升级" class="headerlink" title="客户端：申请协议升级"></a>客户端：申请协议升级</h3><p>首先，客户端发起协议升级请求。可以看到，采用的是标准的 HTTP 报文格式，且只支持<font color="#ff502c">GET 方法</font>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: localhost:<span class="number">8080</span></span><br><span class="line">Origin: http:<span class="comment">//127.0.0.1:3000</span></span><br><span class="line">Connection: Upgrade <span class="comment">// 表示要升级协议</span></span><br><span class="line">Upgrade: websocket <span class="comment">// 表示要升级到websocket协议。</span></span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span> <span class="comment">// 表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</span></span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw== <span class="comment">// 与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</span></span><br></pre></td></tr></table></figure>
<p>重点请求首部意义如下：</p>
<ul>
<li><code>Connection</code>: Upgrade：表示要升级协议</li>
<li><code>Upgrade: websocket</code>：表示要升级到 websocket 协议。</li>
<li><code>Sec-WebSocket-Version</code>: 13：表示 websocket 的版本。如果服务端不支持该版本，需要返回一个 Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li>
<li><code>Sec-WebSocket-Key</code>：与后面服务端响应首部的 Sec-WebSocket-Accept 是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</li>
</ul>
<blockquote>
<p>注意，上面请求省略了部分非重点请求首部。由于是标准的 HTTP 请求，类似 Host、Origin、Cookie 等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。</p>
</blockquote>
<h3 id="服务端：响应协议升级"><a href="#服务端：响应协议升级" class="headerlink" title="服务端：响应协议升级"></a>服务端：响应协议升级</h3><p>服务端返回内容如下，状态代码<code>101</code>表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="../../images/http/web-socket-1-2.png" alt="webSocket"></p>
<blockquote>
<p>备注：每个 header 都以\r\n 结尾，并且最后一行加上一个额外的空行\r\n。此外，服务端回应的 HTTP 状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。</p>
</blockquote>
<h3 id="Sec-WebSocket-Accept-的计算"><a href="#Sec-WebSocket-Accept-的计算" class="headerlink" title="Sec-WebSocket-Accept 的计算"></a>Sec-WebSocket-Accept 的计算</h3><p><code>Sec-WebSocket-Accept</code>根据客户端请求首部的<code>Sec-WebSocket-Key</code>计算出来。<br>计算公式为：</p>
<ul>
<li>将<code>Sec-WebSocket-Key</code>跟<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>拼接。</li>
<li>通过<code>SHA1</code>计算出摘要，并转成<code>base64</code>字符串。</li>
</ul>
<p>伪代码如下：<br><code>&gt;toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ) )</code></p>
<p>验证下前面的返回结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">"crypto"</span>);</span><br><span class="line"><span class="keyword">const</span> magic = <span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>;</span><br><span class="line"><span class="keyword">const</span> secWebSocketKey = <span class="string">"w4v7O6xFTi36lq3RNcgctw=="</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> secWebSocketAccept = crypto</span><br><span class="line">  .createHash(<span class="string">"sha1"</span>)</span><br><span class="line">  .update(secWebSocketKey + magic)</span><br><span class="line">  .digest(<span class="string">"base64"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(secWebSocketAccept);</span><br><span class="line"><span class="comment">// Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span></span><br></pre></td></tr></table></figure>
<h2 id="数据帧格式"><a href="#数据帧格式" class="headerlink" title="数据帧格式"></a>数据帧格式</h2><p><strong>客户端、服务端数据的交换</strong>，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下 WebSocket 的数据帧格式。<br>WebSocket 客户端、服务端通信的最小单位是帧（frame），由 1 个或多个帧组成一条完整的消息（message）。</p>
<ul>
<li>发送端：将消息切割成多个帧，并发送给服务端；</li>
<li>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；</li>
</ul>
<p><strong>数据帧的格式</strong>。详细定义可参考 <a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="noopener">RFC6455 5.2 节</a> 。</p>
<h3 id="数据帧格式概览"><a href="#数据帧格式概览" class="headerlink" title="数据帧格式概览"></a>数据帧格式概览</h3><p>下面给出了 WebSocket 数据帧的统一格式。熟悉 TCP/IP 协议的同学对这样的图应该不陌生。</p>
<ul>
<li>从左到右，单位是比特。比如<code>FIN</code>、<code>RSV1</code>各占据 1 比特，<code>opcode</code>占据 4 比特。</li>
<li>内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (<span class="number">4</span>)  |A|     (<span class="number">7</span>)     |             (<span class="number">16</span>/<span class="number">64</span>)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (<span class="keyword">if</span> payload len==<span class="number">126</span>/<span class="number">127</span>)   |</span><br><span class="line">| |<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, <span class="keyword">if</span> payload len == <span class="number">127</span>  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, <span class="keyword">if</span> MASK <span class="keyword">set</span> to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="数据帧格式详解"><a href="#数据帧格式详解" class="headerlink" title="数据帧格式详解"></a>数据帧格式详解</h3><p><strong>FIN</strong>：1 个比特。<br>如果是<strong>1</strong>，表示这是消息（message）的<strong>最后一个分片（fragment）</strong>，如果是<strong>0</strong>，表示不是是消息（message）的<strong>最后一个分片（fragment）</strong>。</p>
<p><strong>RSV1, RSV2, RSV3</strong>：各占 1 个比特。<br>一般情况下全为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非 0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用 WebSocket 扩展，连接出错。</p>
<p><strong>Opcode: 4 个比特。</strong><br>操作代码，Opcode 的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p>
<ul>
<li>%x0：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li>
<li>%x1：表示这是一个文本帧（frame）</li>
<li>%x2：表示这是一个二进制帧（frame）</li>
<li>%x3-7：保留的操作代码，用于后续定义的非控制帧。</li>
<li>%x8：表示连接断开。</li>
<li>%x9：表示这是一个 ping 操作。</li>
<li>%xA：表示这是一个 pong 操作。</li>
<li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li>
</ul>
<p><strong>Mask: 1 个比特。</strong><br>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。<br>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。<br>如果 Mask 是 1，那么在 Masking-key 中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask 都是 1。</p>
<p><strong>Payload length：</strong>数据载荷的长度，单位是字节。为 7 位，或 7+16 位，或 1+64 位。<br>假设数 Payload length === x，如果</p>
<ul>
<li>x 为 0~126：数据的长度为 x 字节。</li>
<li>x 为 126：后续 2 个字节代表一个 16 位的无符号整数，该无符号整数的值为数据的长度。</li>
<li>x 为 127：后续 8 个字节代表一个 64 位的无符号整数（最高位为 0），该无符号整数的值为数据的长度。<br>此外，如果 payload length 占用了多个字节的话，payload length 的二进制表达采用网络序（big endian，重要的位在前）。</li>
</ul>
<p><strong>Masking-key：</strong>或 4 字节（32 位）<br>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为 1，且携带了 4 字节的 Masking-key。如果 Mask 为 0，则没有 Masking-key。</p>
<blockquote>
<p>备注：载荷数据的长度，不包括 mask key 的长度。</p>
</blockquote>
<p><strong>Payload data：</strong>(x+y) 字节<br>载荷数据：包括了扩展数据、应用数据。其中，扩展数据 x 字节，应用数据 y 字节。</p>
<p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为 0 字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p>
<p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p>
<h3 id="掩码算法"><a href="#掩码算法" class="headerlink" title="掩码算法"></a>掩码算法</h3><p>掩码键（Masking-key）是由客户端挑选出来的 32 位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p>
<p>首先，假设：</p>
<ul>
<li>original-octet-i：为原始数据的第 i 字节。</li>
<li>transformed-octet-i：为转换后的数据的第 i 字节。</li>
<li>j：为 i mod 4 的结果。</li>
<li>masking-key-octet-j：为 mask key 第 j 字节。</li>
</ul>
<p>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>
<blockquote>
<p>j = i MOD 4<br>transformed-octet-i = original-octet-i XOR masking-key-octet-j</p>
</blockquote>
<h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>一旦 WebSocket 客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>
<p>WebSocket 根据<font color="#ff502c">opcode</font>来区分操作的类型。比如<font color="#ff502c">0x8 表示断开连接</font>，<font color="#ff502c">0x0-0x2 表示数据交互</font>。</p>
<h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>WebSocket 的每条消息可能被切分成多个数据帧。当 WebSocket 的接收方收到一个数据帧时，会根据<font color="#ff502c">FIN 的值</font>来判断，是否已经收到消息的最后一个数据帧。</p>
<p><font color="#ff502c">FIN=1</font>表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>
<p>此外，<font color="#ff502c">opcode</font>在数据交换的场景下，表示的是数据的类型。<font color="#ff502c">0x01 表示文本</font>，<font color="#ff502c">0x02 表示二进制</font>。<font color="#ff502c">而 0x00</font>比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>
<h3 id="数据分片例子"><a href="#数据分片例子" class="headerlink" title="数据分片例子"></a>数据分片例子</h3><p>直接看例子更形象些。下面例子来自<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" target="_blank" rel="noopener">MDN</a>，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>
<p><strong>第一条消息</strong><br>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>
<p><strong>第二条消息</strong></p>
<ul>
<li>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。</li>
<li>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。</li>
<li>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Client: FIN=<span class="number">1</span>, opcode=<span class="number">0x1</span>, msg=<span class="string">"hello"</span></span><br><span class="line">Server: (process complete message immediately) Hi.</span><br><span class="line">Client: FIN=<span class="number">0</span>, opcode=<span class="number">0x1</span>, msg=<span class="string">"and a"</span></span><br><span class="line">Server: (listening, <span class="keyword">new</span> message containing text started)</span><br><span class="line">Client: FIN=<span class="number">0</span>, opcode=<span class="number">0x0</span>, msg=<span class="string">"happy new"</span></span><br><span class="line">Server: (listening, payload concatenated to previous message)</span><br><span class="line">Client: FIN=<span class="number">1</span>, opcode=<span class="number">0x0</span>, msg=<span class="string">"year!"</span></span><br><span class="line">Server: (process complete message) Happy <span class="keyword">new</span> year to you too!</span><br></pre></td></tr></table></figure>
<h2 id="连接保持-心跳"><a href="#连接保持-心跳" class="headerlink" title="连接保持+心跳"></a>连接保持+心跳</h2><p>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。<br>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<ul>
<li>发送方-&gt;接收方：ping</li>
<li>接收方-&gt;发送方：pong</li>
</ul>
<p>ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode 分别是 0x9、0xA。</p>
<p>举例，WebSocket 服务端向客户端发送 ping，只需要如下代码（采用 ws 模块）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.ping(<span class="string">""</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Sec-WebSocket-Key-Accept-的作用"><a href="#Sec-WebSocket-Key-Accept-的作用" class="headerlink" title="Sec-WebSocket-Key/Accept 的作用"></a>Sec-WebSocket-Key/Accept 的作用</h2><p>前面提到了，<code>Sec-WebSocket-Key/Sec-WebSocket-Accept</code>在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p>
<p>作用大致归纳如下：</p>
<ul>
<li>避免服务端收到非法的 websocket 连接（比如 http 客户端不小心请求连接 websocket 服务，此时服务端可以直接拒绝连接）</li>
<li>确保服务端理解 websocket 连接。因为 ws 握手阶段采用的是 http 协议，因此可能 ws 连接是被一个 http 服务器处理并返回的，此时客户端可以通过 Sec-WebSocket-Key 来确保服务端认识 ws 协议。（并非百分百保险，比如总是存在那么些无聊的 http 服务器，光处理 Sec-WebSocket-Key，但并没有实现 ws 协议。。。）</li>
<li>用浏览器里发起 ajax 请求，设置 header 时，Sec-WebSocket-Key 以及其他相关的 header 是被禁止的。这样可以避免客户端发送 ajax 请求时，意外请求协议升级（websocket upgrade）</li>
<li>可以防止反向代理（不理解 ws 协议）返回错误的数据。比如反向代理前后收到两次 ws 连接的升级请求，反向代理把第一次请求的返回给 cache 住，然后第二次请求到来时直接把 cache 住的请求给返回（无意义的返回）。</li>
<li>Sec-WebSocket-Key 主要目的并不是确保数据的安全性，因为 Sec-WebSocket-Key、Sec-WebSocket-Accept 的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。</li>
</ul>
<blockquote>
<p>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws 客户端、ws 服务端，其实并没有实际性的保证。</p>
</blockquote>
<h2 id="数据掩码的作用"><a href="#数据掩码的作用" class="headerlink" title="数据掩码的作用"></a>数据掩码的作用</h2><p>WebSocket 协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p>
<ul>
<li>1、代理缓存污染攻击</li>
<li>2、 最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000012709475" target="_blank" rel="noopener">WebSocket：5 分钟从入门到精通</a><br><a href="https://mp.weixin.qq.com/s/sXde-0h7jjGlt4hdwi_Ngw" target="_blank" rel="noopener">WebSocket 通信过程与实现</a></p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流（throttle）与函数去抖（debounce）</title>
    <url>/blog/javascript/javascript-debounce-throttle.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以下场景往往由于事件频繁被触发，因而频繁执行 DOM 操作、资源加载等重行为，导致 UI 停顿甚至浏览器崩溃。</p>
<ol>
<li><p>window 对象的 resize、scroll 事件</p>
</li>
<li><p>拖拽时的 mousemove 事件</p>
</li>
<li><p>射击游戏中的 mousedown、keydown 事件</p>
</li>
<li><p>文字输入、自动完成的 keyup 事件</p>
</li>
</ol>
<p>实际上对于 window 的 resize 事件，实际需求大多为停止改变大小 n 毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了 debounce 和 throttle 两种解决办法。</p>
<h2 id="与函数去抖（debounce）"><a href="#与函数去抖（debounce）" class="headerlink" title="与函数去抖（debounce）"></a>与函数去抖（debounce）</h2><p>当<font color="#ff502c">调用动作 n 毫秒</font>后，才会执行该动作，若在这<font color="#ff502c">n 毫秒</font>内又调用此动作则将<font color="#ff502c">重新</font>计算执行时间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timer为第二次要调用间隔的时间，只有大于间隔时间的调用会立即执func，不然要等到timer之后再执行</span></span><br><span class="line"><span class="comment"> * @param timer &#123;Number&#125; 间隔时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * @param func &#123;Function&#125; 要执行的函数</span></span><br><span class="line"><span class="comment"> * @param * &#123;Function&#125; 返回匿名函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">timer, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextAction;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(nextAction);</span><br><span class="line">    nextAction = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(content, args);</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>调用 onresize 函数，我们不需要触发频率这么快，要让函数执行延迟 500 毫秒再执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.onresize = debounce(<span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考-v1-9-1-的-Underscore-js-debounce"><a href="#参考-v1-9-1-的-Underscore-js-debounce" class="headerlink" title="参考 v1.9.1 的 Underscore.js debounce"></a>参考 v1.9.1 的 Underscore.js debounce</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class="line"><span class="comment">// be triggered. The function will be called after it stops being called for</span></span><br><span class="line"><span class="comment">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class="line"><span class="comment">// leading edge, instead of the trailing.</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//immediate 不传为 undefind, 默认不立即执行，传true 立即执行一次</span></span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (args) result = func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// restArguments Underscore.js 的restArguments方法 https://underscorejs.org/#restArguments</span></span><br><span class="line">  <span class="comment">// 格式化 参数为数组</span></span><br><span class="line">  <span class="keyword">var</span> debounced = restArguments(<span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// _.delay Underscore.js _.delay https://underscorejs.org/#delay</span></span><br><span class="line">      timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><p>预先设定一个<font color="#ff502c">执行周期</font>，当再次调用动作的<font color="#ff502c">时刻</font>大于等于<font color="#ff502c">执行周期</font>则执行该动作，然后进入下一个新周期。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timer为第二次要调用间隔的时间，只有大于间隔时间的调用会立即执func，不然要等到timer之后再执行</span></span><br><span class="line"><span class="comment"> * @param delay &#123;Number&#125; 间隔时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * @param func &#123;Function&#125; 要执行的函数</span></span><br><span class="line"><span class="comment"> * @param * &#123;Function&#125; 返回匿名函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">delay, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextAction = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (currTime - nextAction &gt; delay) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      nextAction = currTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>和防抖一样调用 onresize 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考-v1-9-1-的-Underscore-js-throttle"><a href="#参考-v1-9-1-的-Underscore-js-throttle" class="headerlink" title="参考 v1.9.1 的 Underscore.js throttle"></a>参考 v1.9.1 的 Underscore.js throttle</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class="line"><span class="comment">// during a given window of time. Normally, the throttled function will run</span></span><br><span class="line"><span class="comment">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class="line"><span class="comment">// but if you'd like to disable the execution on the leading edge, pass</span></span><br><span class="line"><span class="comment">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = _.now();</span><br><span class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    previous = <span class="number">0</span>;</span><br><span class="line">    timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>require和import的区别</title>
    <url>/blog/javascript/javascript-module.html</url>
    <content><![CDATA[<h2 id="简单比较"><a href="#简单比较" class="headerlink" title="简单比较"></a>简单比较</h2><p>对比表格如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">对比类型</th>
<th style="text-align:center">import</th>
<th style="text-align:center">require</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">何时加载</td>
<td style="text-align:center">编译时加载</td>
<td style="text-align:center">运行时加载</td>
</tr>
<tr>
<td style="text-align:center">静态化</td>
<td style="text-align:center">ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</td>
<td style="text-align:center">只有运行时才能得到这个对象，不能在编译时做到静态化</td>
</tr>
<tr>
<td style="text-align:center">调用时间</td>
<td style="text-align:center">import是编译时调用，所以严格模式必须放在文件开头</td>
<td style="text-align:center">require是运行时调用，所以require理论上可以运用在代码的任何地方</td>
</tr>
<tr>
<td style="text-align:center">模块输出</td>
<td style="text-align:center">模块输出的是值的引用，不会缓存，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块</td>
<td style="text-align:center">模块输出的是一个值的拷贝，并且在第一次加载是缓存，后面加载都会读取缓存</td>
</tr>
<tr>
<td style="text-align:center">模块加载</td>
<td style="text-align:center">按引入加载</td>
<td style="text-align:center">整体加载</td>
</tr>
<tr>
<td style="text-align:center">循环加载</td>
<td style="text-align:center">ES6 模块是动态引用，如果使用import从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值</td>
<td style="text-align:center">CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出</td>
</tr>
</tbody>
</table>
<p>下面我们一项一项具体解释：</p>
<h3 id="何时加载-静态化"><a href="#何时加载-静态化" class="headerlink" title="何时加载/静态化"></a>何时加载/静态化</h3><p>require / exports ：<br>遵循 <font color="#ff502c">CommonJS/AMD</font>，只能在<font color="#ff502c">运行时</font>确定模块的依赖关系及输入/输出的变量，<font color="#ff502c">无法</font>进行<font color="#ff502c">静态优化</font>。</p>
<p>import / export：<br>遵循 <font color="#ff502c">ES6</font> 规范，支持<font color="#ff502c">编译时静态分析</font>，便于JS引入宏和类型检验。<font color="#ff502c">动态绑定</font>。</p>
<h3 id="调用时间"><a href="#调用时间" class="headerlink" title="调用时间"></a>调用时间</h3><p>import / export：<br>import命令具有<font color="#ff502c">提升效果</font>，会<font color="#ff502c">提升</font>到整个模块的头部，<font color="#ff502c">首先执行</font>。（是在编译阶段执行的）<br>因为import是静态执行的，不能使用表达式和变量，即在运行时才能拿到结果的语法结构.</p>
<p>require / exports ：<br>require是<font color="#ff502c">运行时</font>调用，所以require理论上可以运用在代码的<font color="#ff502c">任何地方</font></p>
<h3 id="模块输出-模块加载"><a href="#模块输出-模块加载" class="headerlink" title="模块输出/模块加载"></a>模块输出/模块加载</h3><p>require / exports ：<br>CommonJS 模块输出的是<font color="#ff502c">值的拷贝</font>，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值，并且会在第一次加载是<font color="#ff502c">缓存</font>这个值的拷贝，他是<font color="#ff502c">完全</font>输出这个值的拷贝。</p>
<p>import / export：<br>模块输出的是值的<font color="#ff502c">引用</font>，<font color="#ff502c">不会</font>缓存，而是<font color="#ff502c">动态</font>地去被加载的模块取值，并且变量总是绑定其所在的模块，并且只会<font color="#ff502c">加载</font>引入的值，不去全部加载。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型（五）== 混乱的转换规则</title>
    <url>/blog/javascript/javascript-false-true.html</url>
    <content><![CDATA[<p><strong><em>察见渊鱼者不详，智料隐匿者有殃。——《列子·说符》</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript数据类型（一） 常见数据类型</a><br><a href="/blog/javascript/javascript-type-one-question.html">JavaScript数据类型（二） 类型转换</a><br><a href="/blog/javascript/javascript-type-one-questionone.html">JavaScript数据类型（三）常见的面试题</a><br><a href="/blog/javascript/javascript-IF-False-options.html">JavaScript数据类型（四）IF 转换规则</a><br><a href="/blog/javascript/javascript-false-true.html">JavaScript数据类型（五）== 混乱的转换规则</a><br><a href="/blog/javascript/javascript-bool-type.html">JavaScript数据类型（六）多种数据类型判断方法</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>JavaScript 有两种比较方式：<strong>严格比较运算符</strong>和<strong>转换类型比较运算符</strong>。对于严格比较运算符（===）来说，仅当两个操作数的<strong>类型相同且值相等</strong>为 <code>true</code>，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数<strong>转换成相同的类型</strong>。</p>
<p>比较的特点:</p>
<ul>
<li><strong>对于两个拥有相同字符顺序，相同长度，并且每个字符的位置都匹配的字符串，应该使用严格比较运算符。</strong></li>
<li><strong>对于两个数值相同的数字应该使用严格比较运算符，NaN和任何值不相等，包括其自身，正数零等于负数零。</strong></li>
<li><strong>对于两个同为true或同为false的布尔操作数，应使用严格比较运算符。</strong></li>
<li><strong>不要使用严格比较运算符或比较运算符来比较两个不相等的对象。</strong></li>
<li><strong>当比较一个表达式和一个对象时，仅当两个操作数引用相同的对象（指针指向相同对象）。</strong></li>
<li><strong>对于Null 和 Undefined 类型而言，应使用严格比较运算符比较其自身，使用比较运算符进行互相比较。</strong></li>
</ul>
<p><a href="https://www.h5jun.com/post/why-false-why-true.html" target="_blank" rel="noopener"></a></p>
<h3 id="一致-严格相等"><a href="#一致-严格相等" class="headerlink" title="一致/严格相等 (===)"></a>一致/严格相等 (===)</h3><p>一致运算符不会进行类型转换，仅当操作数<strong>严格相等</strong>时返回<code>true</code></p>
<h3 id="相等"><a href="#相等" class="headerlink" title="相等(==)"></a>相等(==)</h3><p>比较操作符会为两个不同类型的操作数<strong>转换类型</strong>，然后进行<strong>严格比较</strong>。当两个操作数都是对象时，JavaScript会比较其<strong>内部引用</strong>，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的<strong>引用地址相同</strong>。</p>
<p>非严格比较操作符 == 是会做强制类型转换的，那么根据 ECMA 262 它的规则是：</p>
<p><strong>图1-1</strong><br><img src="../../images/false-true/1.png" alt="! =="><br><strong><font color="#ff502c">ToPrimitive：</font></strong></p>
<p><strong>图1-2</strong><br><img src="../../images/false-true/2.png" alt="! =="></p>
<p><strong>图1-3</strong><br><img src="../../images/false-true/3.png" alt="! =="></p>
<p><strong>图1-4</strong><br><img src="../../images/false-true/4.png" alt="! =="><br><strong><font color="#ff502c">ToBoolean: </font></strong></p>
<p><strong>图1-5</strong></p>
<p><img src="../../images/false-true/5.png" alt="! =="><br><strong>图1-6</strong><br><img src="../../images/false-true/6.png" alt="! =="></p>
<p><a href="http://www.ecma-international.org" target="_blank" rel="noopener">ecma规则</a></p>
<h2 id="false-or-or-false-为true"><a href="#false-or-or-false-为true" class="headerlink" title="[] == false or ![] == [] or ![] == false 为true"></a>[] == false or ![] == [] or ![] == false 为true</h2><p>mdn运算符优先级参考表<br><img src="../../images/false-true/false-true-1.png" alt="! =="><br><img src="../../images/false-true/false-true-2.png" alt="! =="></p>
<p><font color="#ff502c">==</font>的优先级16</p>
<p><font color="#ff502c">!</font>的优先级10</p>
<h3 id="false-结果为-true"><a href="#false-结果为-true" class="headerlink" title="[] == false 结果为 true"></a>[] == false 结果为 true</h3><p>根据图1-1可知</p>
<ul>
<li>第 7 条：<strong>If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).</strong></li>
<li>第 9 条：<strong>If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.</strong></li>
</ul>
<p>所以 <code>[] == false</code> 的比较是对 x 执行 <code>ToPrimitive(x)</code>，然后和 <code>ToNumber(false)</code> （为 0）进行比较。</p>
<p><strong>看一下 ToPrimitive：</strong><br>根据上图1-2、1-3、1-4的规则对于<code>ToPrimitive([])</code>，先执行<code>[].valueOf()</code>，返回result的是’[]’，因为Type(result)是Object，所以继续执行<code>[].toString()</code>，返回””。<br>因此实际上最终是比较<code>&quot;&quot; == 0</code>，结果为<code>true</code>。</p>
<h3 id="结果为-true"><a href="#结果为-true" class="headerlink" title="![] == [] 结果为 true"></a>![] == [] 结果为 true</h3><p>按照优先级，先执行 ![]，根据规范，实际上是 <code>!(ToBoolean([]))</code>：<br>根据上图1-5、1-6可看出，实际上 <code>ToBoolean([])</code> 会<code>return</code>出<code>true</code>, <code>![]</code> 就是 <code>false</code>.<br>[] 上文已经讲过了 是 “”。<br>所以对比就是 <code>false == &quot;&quot;</code>，结果为<code>true</code>。</p>
<h3 id="false-结果为-true-1"><a href="#false-结果为-true-1" class="headerlink" title="![] == false 结果为 true"></a>![] == false 结果为 true</h3><p>按照优先级，先执行 <code>![]</code>，根据规范，实际上是 <code>!(ToBoolean([]))</code>：<br>根据上图可看出，实际上 <code>ToBoolean([])</code> 会return出true, ![] 就是 false.<br><code>false == false</code> ，结果为<code>true</code>。</p>
<h3 id="false-结果为-false"><a href="#false-结果为-false" class="headerlink" title="!![] == false 结果为 false"></a>!![] == false 结果为 false</h3><p>按照优先级，先执行 !![]，根据规范，实际上是 <code>!!(ToBoolean([]))</code>：<br>根据上图可看出，实际上 <code>ToBoolean([])</code>会return出true, !![] 就是 true.<br><code>true == false</code> ，结果为 <code>false</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上一个<strong>对象转为原始值</strong>的大致过程再进行对比，如果不太清楚可以看另一篇博客<a href="/blog/javascript/javascript-type-one-question.html">JavaScript数据类型（二） 类型转换</a>，但是在本篇博客中最重要的时<code>ToBoolean([])</code>的转换比较不容易理解。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Http系列(四) Http中Get/Post的区别</title>
    <url>/blog/http/http-get-post.html</url>
    <content><![CDATA[<p><strong><em>为无为，事无事，味无味。——老子</em></strong></p>
<blockquote>
<p><a href="/blog/http/http-http2.html">Http系列(-) Http发展历史</a><br><a href="/blog/http/http-http2-1.html">Http系列(二) Http2中的多路复用</a><br><a href="/blog/http/http-tcp.html">Http系列(三) Http/Tcp三次握手和四次挥手</a><br><a href="/blog/http/http-get-post.html">Http系列(四) Http中Get/Post的区别</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：<code>GET</code> 和 <code>POST</code>。</p>
<ul>
<li><strong>GET - 从指定的资源请求数据。</strong></li>
<li><strong>POST - 向指定的资源提交要被处理的数据</strong></li>
</ul>
<p>最直观的区别就是<code>GET</code>把参数包含在<code>URL</code>中，<code>POST</code>通过<code>request body</code>传递参数。<code>POST</code>和<code>GET</code>大致区别如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">GET</th>
<th style="text-align:center">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">后退按钮/刷新</td>
<td style="text-align:center">无害</td>
<td style="text-align:center">数据会被重新提交（浏览器应该告知用户数据会被重新提交）</td>
</tr>
<tr>
<td style="text-align:center">书签</td>
<td style="text-align:center">可收藏为书签</td>
<td style="text-align:center">不可收藏为书签</td>
</tr>
<tr>
<td style="text-align:center">缓存</td>
<td style="text-align:center">能被缓存</td>
<td style="text-align:center">不能缓存</td>
</tr>
<tr>
<td style="text-align:center">编码类型</td>
<td style="text-align:center">application/x-www-form-urlencoded</td>
<td style="text-align:center">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码</td>
</tr>
<tr>
<td style="text-align:center">历史</td>
<td style="text-align:center">参数保留在浏览器历史中</td>
<td style="text-align:center">参数不会保存在浏览器历史中</td>
</tr>
<tr>
<td style="text-align:center">对数据长度的限制</td>
<td style="text-align:center">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）</td>
<td style="text-align:center">无限制</td>
</tr>
<tr>
<td style="text-align:center">对数据类型的限制</td>
<td style="text-align:center">只允许 ASCII 字符</td>
<td style="text-align:center">没有限制。也允许二进制数据</td>
</tr>
<tr>
<td style="text-align:center">安全性</td>
<td style="text-align:center">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分 在发送密码或其他敏感信息时绝不要使用 GET ！</td>
<td style="text-align:center">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中</td>
</tr>
<tr>
<td style="text-align:center">可见性</td>
<td style="text-align:center">数据在 URL 中对所有人都是可见的</td>
<td style="text-align:center">数据不会显示在 URL 中</td>
</tr>
</tbody>
</table>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><hr>
<p><strong>其实<code>GET</code>和<code>POST</code>都是<code>http协议中</code>的两种发送请求的方法。</strong></p>
<ul>
<li><strong>GET在浏览器回退时是无害的，而POST会再次提交请求。</strong></li>
<li><strong>GET产生的URL地址可以被Bookmark，而POST不可以。</strong></li>
<li><strong>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</strong></li>
<li><strong>GET请求只能进行url编码，而POST支持多种编码方式。</strong></li>
<li><strong>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</strong></li>
<li><strong>GET请求在URL中传送的参数是有长度限制的，而POST么有。</strong></li>
<li><strong>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</strong></li>
<li><strong>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</strong></li>
<li><strong>GET参数通过URL传递，POST放在Request body中。</strong></li>
<li><strong>http协议并未规定get和post的长度限制</strong></li>
<li><strong>get的最大长度限制是因为浏览器和web服务器限制了URL的长度</strong></li>
<li><strong>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</strong></li>
</ul>
<h3 id="其实很多人说get请求比post请求快，主要是底下两条"><a href="#其实很多人说get请求比post请求快，主要是底下两条" class="headerlink" title="其实很多人说get请求比post请求快，主要是底下两条"></a>其实很多人说get请求比post请求快，主要是底下两条</h3><ol>
<li><strong>get请求比post请求少一步</strong></li>
<li><strong>get请求可以缓存</strong></li>
</ol>
<p><strong>get请求过程</strong>：</p>
<ol>
<li><strong>浏览器请求tcp连接（第一次握手）</strong></li>
<li><strong>服务器答应进行tcp连接（第二次握手）</strong></li>
<li>浏览器确认，<strong>并发送get请求头和数据</strong>（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li>服务器返回200 OK响应</li>
</ol>
<p><strong>post请求过程</strong>：</p>
<ol>
<li><strong>浏览器请求tcp连接（第一次握手）</strong></li>
<li><strong>服务器答应进行tcp连接（第二次握手）</strong></li>
<li><strong>浏览器确认，并发送post请求头</strong>（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li><strong>服务器返回100 Continue响应</strong></li>
<li><strong>浏览器发送数据</strong></li>
<li>服务器返回200 OK响应</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>GET</code>在浏览器回退时是<strong>无害</strong>的，而<code>POST</code>会<strong>再次</strong>提交请求。</li>
<li><code>GET</code>产生的URL地址可以被<code>Bookmark</code>，而<code>POST</code>不可以。</li>
<li><code>GET</code>请求会被浏览器主动<code>cache</code>，而<code>POST</code>不会，除非手动设置。</li>
<li><code>GET</code>请求只能进行<code>url</code>编码，而<code>POST</code>支持多种编码方式。</li>
<li><code>GET</code>请求参数会被完整保留在浏览器历史记录里，而<code>POST</code>中的参数不会被保留。</li>
<li><code>GET</code>请求在<code>URL</code>中传送的参数是有长度限制的，而<code>POST</code>么有。</li>
<li>对参数的数据类型，<code>GET</code>只接受<code>ASCII</code>字符，而<code>POST</code>没有限制。</li>
<li><code>GET</code>比<code>POST</code>更不安全，因为参数直接暴露在<code>URL</code>上，所以不能用来传递敏感信息。</li>
<li><code>GE</code>T参数通过<code>URL</code>传递，<code>POST</code>放在<code>Request body</code>中。</li>
<li><code>http</code>协议并未规定<code>get</code>和<code>post</code>的长度限制</li>
<li><code>get</code>的最大长度限制是因为浏览器和<code>web</code>服务器限制了<code>URL</code>的长度</li>
<li>对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应<code>200</code>（返回数据）；而对于POST，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a><br><a href="https://www.cnblogs.com/logsharing/p/8448446.html#!comments" target="_blank" rel="noopener">GET和POST两种基本请求方法的区别</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise系列（三） 实现一个自己的Promise</title>
    <url>/blog/es6/es6-promise-two.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>接上文的<code>Promsie</code>文章，在这篇文章中实现<code>Promsie</code>常用的方法，并且是实现<code>PromsieA+</code>的规范等等。</p>
<h2 id="实现-Promise-方法-catch、resolve、reject、all、race-等方法"><a href="#实现-Promise-方法-catch、resolve、reject、all、race-等方法" class="headerlink" title="实现 Promise 方法 catch、resolve、reject、all、race 等方法"></a>实现 Promise 方法 catch、resolve、reject、all、race 等方法</h2><p><code>catch</code>方法：</p>
<blockquote>
<p>相当于调用 <code>then</code> 方法, 但只传入 <code>Rejected</code> 状态的回调函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加catch方法</span></span><br><span class="line">PromiseA.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">111</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 111</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>resolve</code>方法：</p>
<blockquote>
<p>静态 <code>resolve</code> 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果参数是MyPromise实例或thenable对象，直接返回value</span></span><br><span class="line">PromiseA.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value <span class="keyword">instanceof</span> PromiseA || (value &amp;&amp; isFunction(value.then))</span><br><span class="line">    ? value</span><br><span class="line">    : <span class="keyword">new</span> PromiseA(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PromiseA.resolve(<span class="number">111</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// 111</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>reject</code>方法：</p>
<blockquote>
<p>静态 <code>reject</code> 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加静态reject方法</span></span><br><span class="line">PromiseA.reject = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(value));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PromiseA.reject(<span class="number">111</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// 111</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>all</code> 方法:</p>
<blockquote>
<p>静态 <code>all</code> 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加静态all方法</span></span><br><span class="line">PromiseA.all = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> values = [],</span><br><span class="line">      count = list.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">      <span class="comment">// 数组参数如果不是PromiseA实例，先调用PromiseA.resolve</span></span><br><span class="line">      <span class="keyword">this</span>.resolve(list[i]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        values[i] = res;</span><br><span class="line">        <span class="comment">// 所有状态都变成fulfilled时返回的PromiseA状态就变成fulfilled</span></span><br><span class="line">        --count &lt; <span class="number">1</span> &amp;&amp; resolve(values);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PromiseA.all([</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">222</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">333</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [111, 222, 333]</span></span><br></pre></td></tr></table></figure>
<p><code>race</code> 方法：</p>
<blockquote>
<p>静态 <code>race</code> 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加静态race方法</span></span><br><span class="line">PromiseA.race = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">      <span class="comment">// 只要有一个实例率先改变状态，新的PromiseA的状态就跟着改变</span></span><br><span class="line">      <span class="keyword">this</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PromiseA.race([</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">222</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">333</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 111</span></span><br></pre></td></tr></table></figure>
<h2 id="实现-promiseify-方法"><a href="#实现-promiseify-方法" class="headerlink" title="实现 promiseify 方法"></a>实现 promiseify 方法</h2><p><code>promiseify</code>是将异步回调函数<code>api</code>转换为<code>promise</code>形式。代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态promisify</span></span><br><span class="line">PromiseA.promisify = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">          fn.apply(<span class="literal">null</span>, args.concat(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">              err ? reject(err) : resolve(<span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">          &#125;));</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是把不同异步函数转为<code>Promise</code>的实现。</p>
<h2 id="达到PromiseA-规范标准"><a href="#达到PromiseA-规范标准" class="headerlink" title="达到PromiseA+规范标准"></a>达到PromiseA+规范标准</h2>]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise系列（二） 实现一个自己的Promise</title>
    <url>/blog/es6/es6-promise.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/es6/es6-promise.html">Promise系列（二） 实现一个自己的Promise</a><br><a href="/blog/es6/es6-promise-two.html">Promise系列（三） 实现一个自己的Promise</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个 <code>Promise</code> 就是一个对象，它代表了一个异步操作的最终完成或者失败。大多数人仅仅是使用已创建的<code>Promise</code>实例对象，因此本教程将首先说明怎样使用 <code>Promise</code>，之后说明如何创建<code>Promise</code>。<br>本质上，<code>Promise</code> 是一个绑定了回调的对象，而不是将回调传进函数内部。<br>原生提供了<code>Promise</code>对象。本篇不注重讲解<code>promise</code>的用法，关于用法，可以看阮一峰老师的<code>ECMAScript 6</code>系列里面的<code>Promise</code>部分：<br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ECMAScript 6 : Promise 对象</a><br>我们在最后实现一个<code>es2015</code>版本的<code>PromiseA</code>.<br>注：在本代码中有很多不完善的地方，最后会给出一个<code>es2015</code>的版本，那个版本是比较完善的。<br>本篇博客逐步实现，最终使其符合<code>Promises/A+</code>规范</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>逐步实现：</p>
<ol>
<li><strong>基础版本</strong></li>
<li><strong>支持同步任务</strong></li>
<li><strong>支持状态</strong></li>
<li><strong>支持链式操作</strong></li>
<li><strong>支持串行异步任务</strong></li>
<li><strong>实现 Promise 方法 all、resolve、reject、race 等方法</strong></li>
<li><strong>实现 promiseify 方法</strong></li>
<li><strong>达到 PromiseA+规范</strong></li>
</ol>
<blockquote>
<p>注意事项：这边建议不要使用 <code>setTimeout</code>作为 <code>Promise</code> 的实现。因为 <code>setTimeout</code> 属于 宏任务， 而 <code>Promise</code> 属于 微任务。</p>
</blockquote>
<!-- 不理知道宏任务和微任务请看量一篇博客：[evenloop](http://asyncnode.com/blog/evenloop.html) -->
<p>显示代码请看</p>
<h2 id="基础版本-异步回调"><a href="#基础版本-异步回调" class="headerlink" title="基础版本(异步回调)"></a>基础版本(异步回调)</h2><p>目标</p>
<ul>
<li>可以通过<code>new</code> 关键字创建一个 <code>Promise</code>实例。</li>
<li><code>Promise</code>实例传入的异步方法执行成功就执行注册的成功回调函数，失败就执行注册的失败回调函数。</li>
</ul>
<p>首先实现两个判断函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">"function"</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">"object"</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">  executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">"function"</span>) &#123;</span><br><span class="line">  executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  executeAsync = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装我们要调用的callAsync函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callAsync</span>(<span class="params">fn, arg, callback, onError</span>) </span>&#123;</span><br><span class="line">  executeAsync(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback ? callback(fn(arg)) : fn(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      onError(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：判断传入参数是否为<code>function</code>, 根据当前环境降级实现<strong>微任务或宏任务</strong></p>
<p><strong>代码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">"function"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Promise resolver handle is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">null</span>; <span class="comment">// 成功时的值</span></span><br><span class="line">  self.error = <span class="literal">null</span>; <span class="comment">// 失败时的原因</span></span><br><span class="line">  self.onFulfilled = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;; <span class="comment">// 成功的回调函数</span></span><br><span class="line">  self.onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;; <span class="comment">// 失败的回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    self.value = value;</span><br><span class="line">    self.onFulfilled(self.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    self.error = error;</span><br><span class="line">    self.onRejected(self.error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//捕获callback是否报错</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    handle(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//在这里给promise实例注册成功和失败回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.onFulfilled);</span><br><span class="line">  <span class="built_in">console</span>.log(onFulfilled);</span><br><span class="line">  <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">  <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br><span class="line"><span class="keyword">new</span> PromiseA([]);</span><br></pre></td></tr></table></figure>
<p>判断实例传入的参数是否为<code>function</code>，在<code>then</code>中注册了这个<code>promise</code>实例的成功回调和失败回调，当<code>promise resolve</code>时，当<code>promise resolve</code>时，就把异步执行结果赋值给<code>promise</code>实例的<code>value</code>，并把这个值传入成功回调中执行，失败就把异步执行失败原因赋值给<code>promise</code>实例的<code>error</code>，并把这个值传入失败回调并执行。</p>
<h2 id="支持同步代码"><a href="#支持同步代码" class="headerlink" title="支持同步代码"></a>支持同步代码</h2><p>我们执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在如果我们同步执行<code>resolve(111)</code>的话，我们的<code>then</code>函数还没有被执行，所以后续的<code>then</code>中得回调函数也不会被执行，简单来说就是<code>then</code>函数在<code>resolve(111)</code>的函数之后执行，所以<code>then</code>中得回调也不会被执行。</p>
<p><strong>目标</strong></p>
<ul>
<li><strong>使<code>promise</code>支持同步方法</strong></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">"function"</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">"object"</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">  executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">"function"</span>) &#123;</span><br><span class="line">  executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  executeAsync = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Promise resolver handle is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">null</span>; <span class="comment">// 成功时的值</span></span><br><span class="line">  self.error = <span class="literal">null</span>; <span class="comment">// 失败时的原因</span></span><br><span class="line">  self.onFulfilled = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;; <span class="comment">// 成功的回调函数</span></span><br><span class="line">  self.onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;; <span class="comment">// 失败的回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.value = value;</span><br><span class="line">      <span class="built_in">console</span>.log(self.onFulfilled(self.value));</span><br><span class="line">      self.onFulfilled(self.value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.error = error;</span><br><span class="line">      self.onRejected(self.error);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handle(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//在这里给promise实例注册成功和失败回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.onFulfilled);</span><br><span class="line">  <span class="built_in">console</span>.log(onFulfilled);</span><br><span class="line">  <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">  <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br></pre></td></tr></table></figure>
<p>就是在<code>resolve</code>和<code>reject</code>里面用<code>setTimeout</code>进行包裹，使其到<code>then</code>方法执行之后再去执行，这样我们就让<code>Promise</code>支持传入同步方法。</p>
<blockquote>
<p>注：<code>setTimeout</code>其实是最后一种方法，要看环境, 要是支持的话，优先使用<code>MutationObserver</code>(微任务),再是<code>MessageChannel</code>（优先级比定时器高的宏任务）,再是<code>setImmediate</code>（这个兼容性太差，不建议用）再不行就降级为<code>setTimeout</code>了</p>
</blockquote>
<h2 id="支持三种状态"><a href="#支持三种状态" class="headerlink" title="支持三种状态"></a>支持三种状态</h2><p>我们知道在使用<code>Ppromise</code>时，<code>Promise</code>有三种状态：<code>pending(进行中)</code>、<code>fulfilled(已成功)</code>、<code>rejected(已失效)</code>。</p>
<ol>
<li>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，</li>
</ol>
<p>只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就<strong>凝固</strong>了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved（已定型）</code>。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。</p>
<p><strong>目标</strong></p>
<ul>
<li>实现<code>promise</code>的三种状态</li>
<li>实现<code>promise</code>对象的状态改变，改变只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</li>
<li>实现一旦<code>promise</code>状态改变，再对<code>promise</code>对象添加回调函数，也会立即得到这个结果。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">"function"</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">"object"</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">  executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">"function"</span>) &#123;</span><br><span class="line">  executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  executeAsync = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Promise resolver handle is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.error = <span class="literal">undefined</span>;</span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  self.onFulfilled = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;;</span><br><span class="line">  self.onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        self.status = FULFILLED;</span><br><span class="line">        self.value = value;</span><br><span class="line">        self.onFulfilled(self.value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        self.status = REJECTED;</span><br><span class="line">        self.error = value;</span><br><span class="line">        self.onRejected(self.error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handle(resolve, reject);</span><br><span class="line">  <span class="comment">//捕获callback是否报错</span></span><br><span class="line">  <span class="comment">// try &#123;</span></span><br><span class="line">  <span class="comment">// &#125; catch (error) &#123;</span></span><br><span class="line">  <span class="comment">//     reject(error);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">    <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data, error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br></pre></td></tr></table></figure>
<p>为了实现上面的目标我们建立了三种状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>，如果是<code>peding</code>状态，我们才会改变<code>promise</code>的状态，并且执行相关状态的操作，并且现在的<code>promise</code>的状态是不可改变的。在<code>then</code>那种我们判断<code>promise</code>的状态已经从<code>pending</code>转换为<code>fulfilled</code>或者<code>rejected</code>就会立刻执行他的状态的回调，并且把结果传入。</p>
<h2 id="支持链式调用（同步）"><a href="#支持链式调用（同步）" class="headerlink" title="支持链式调用（同步）"></a>支持链式调用（同步）</h2><p>大家都知道<code>jquery</code>的链式调用，<code>promise</code>也是支持链式调用。<br>我们首先在这一步实现同步的链式调用。</p>
<p><strong>目标</strong></p>
<ul>
<li><strong>使<code>promise</code>支持链式调用</strong></li>
</ul>
<blockquote>
<p>注：我们把<code>then</code>中的回调存入数组中</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.onFulfilledCallbacks = [];</span><br><span class="line">self.onRejectedCallbacks = [];</span><br></pre></td></tr></table></figure>
<p>当我们执行回调时，也要改成遍历回调数组执行回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(self.value));</span><br><span class="line">self.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(self.value));</span><br></pre></td></tr></table></figure>
<p>最后，<code>then</code>方法也要改一下,只需要在最后一行加一个<code>return this</code>即可，这其实和<code>jQuery</code>链式操作的原理一致，每次调用完方法都返回自身实例，后面的方法也是实例的方法，所以可以继续执行。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">"function"</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">"object"</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">  executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">"function"</span>) &#123;</span><br><span class="line">  executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  executeAsync = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Promise resolver handle is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.error = <span class="literal">undefined</span>;</span><br><span class="line">  self.onFulfilledCallbacks = [];</span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  <span class="comment">// self.onFulfilled = function (value) &#123; (value) &#125;;</span></span><br><span class="line">  <span class="comment">// self.onRejected = function (value) &#123; (value) &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        self.status = FULFILLED;</span><br><span class="line">        self.value = value;</span><br><span class="line">        <span class="comment">// self.onFulfilled(self.value);</span></span><br><span class="line">        self.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(self.value));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        self.status = REJECTED;</span><br><span class="line">        self.value = error;</span><br><span class="line">        <span class="comment">// self.onRejected(self.value);</span></span><br><span class="line">        self.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(self.error));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handle(resolve, reject);</span><br><span class="line">  <span class="comment">//捕获callback是否报错</span></span><br><span class="line">  <span class="comment">// try &#123;</span></span><br><span class="line">  <span class="comment">// &#125; catch (error) &#123;</span></span><br><span class="line">  <span class="comment">//     reject(error);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型上的then方法</span></span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="comment">// this.onFulfilled = onFulfilled;</span></span><br><span class="line">    <span class="comment">// this.onRejected = onRejected;</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reslove(<span class="number">111</span>);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一"</span> + data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第二"</span> + data);</span><br><span class="line">  &#125;); <span class="comment">// 第一 第二</span></span><br></pre></td></tr></table></figure>
<p>总结： 这个就是最简单的同步<code>then</code>的回调用一个内部数组来储存，最后循环调用。</p>
<h2 id="支持串行异步任务"><a href="#支持串行异步任务" class="headerlink" title="支持串行异步任务"></a>支持串行异步任务</h2><p>我们一般都是用<code>promise.then</code>来写异步任务，在下面完善一下代码</p>
<p><strong>目标</strong></p>
<ul>
<li><strong>使<code>PromiseA</code>支持串行异步操作</strong></li>
<li><strong>支持传入<code>PromiseA</code>对象</strong></li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在上一步已经实现可以链式调用，但是只支持<strong>同步</strong>的链式调用，现在要实现支持一步串行调用。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个promise实例</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"first------"</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">first</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="comment">// 第二个promise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">"second------"</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">second</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">    <span class="comment">// 第三个promise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">"third------"</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 异步串行</span></span><br><span class="line"><span class="comment">// "first------" + new Date()</span></span><br><span class="line"><span class="comment">// "first------" + new Date()</span></span><br><span class="line"><span class="comment">// "first------" + new Date()</span></span><br></pre></td></tr></table></figure>
<p>想要的结果是在<strong>1s</strong>之后输出<code>&#39;first------&#39; + new Date()</code>结果，再经过<strong>2s</strong>之后执行<code>&#39;second------&#39; + new Date()</code>，再等<strong>3s</strong>之后才会执行<code>&#39;third------&#39; + new Date()</code>，但是结果和预想的结果不相同。<br>实际结果是<strong>1s</strong>之后直接就会输出三次<code>first------ + new Date()</code>，因为所有的回调函数都注册在了<code>PromiseA</code>中的<code>onFulfilledCallbacks</code>队列里，在后面<code>resolve</code>后会全部执行，这个并不能满足<strong>异步串行</strong>。<br>需要将每个回调函数注册在对应<code>promise</code>实例的<code>onFulfilledCallbacks</code>里面，然后再返回一下新的<code>promise</code>以做到异步串行效果。</p>
<p>改写代码如下：</p>
<ul>
<li>改写<code>prototype</code>上的<code>then</code>方法</li>
<li>改写<code>resolve</code>、<code>reject</code>上的代码</li>
</ul>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改原型上的then方法</span></span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个新的PromiseA对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFunction(onFulfilled)) &#123;</span><br><span class="line">        callAsync(</span><br><span class="line">          onFulfilled,</span><br><span class="line">          value,</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> PromiseA) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回PromiseA对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejectedNext</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          onFulfilledNext(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的PromiseA对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFunction(onRejected)) &#123;</span><br><span class="line">        callAsync(</span><br><span class="line">          onRejected,</span><br><span class="line">          error,</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> PromiseA) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回PromiseA对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejectedNext</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          onRejectedNext(error);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的PromiseA对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">      <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">      <span class="keyword">case</span> PENDING:</span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.push(fulfilled);</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(rejected);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">      <span class="keyword">case</span> FULFILLED:</span><br><span class="line">        fulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> REJECTED:</span><br><span class="line">        rejected(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着修改 <code>resolve</code> 和 <code>reject</code> ：依次执行队列中的函数</p>
<p>当 <code>resolve</code> 或 <code>reject</code> 方法执行时，依次提取成功或失败<strong>任务队列</strong>当中的函数开始执行，并<strong>清空队列</strong>，从而实现 <code>then</code> 方法的多次调用，实现的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callAsync</span>(<span class="params">fn, arg, callback, onError</span>) </span>&#123;</span><br><span class="line">  executeAsync(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback ? callback(fn(arg)) : fn(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      onError(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// resolve方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 状态一旦定型不可改变</span></span><br><span class="line">  <span class="keyword">if</span> (self.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 改变当前实例状态</span></span><br><span class="line">  self.status = FULFILLED;</span><br><span class="line">  <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">  <span class="keyword">const</span> runFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cb;</span><br><span class="line">    <span class="comment">// 循环执行</span></span><br><span class="line">    <span class="keyword">while</span> ((cb = self.onFulfilledCallbacks.shift())) &#123;</span><br><span class="line">      cb(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">  <span class="keyword">const</span> runRejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cb;</span><br><span class="line">    <span class="keyword">while</span> ((cb = self.onRejectedCallbacks.shift())) &#123;</span><br><span class="line">      cb(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/* 如果resolve的参数为PromiseA对象，则必须等待（参数PromiseA）对象状态改变后,</span></span><br><span class="line"><span class="comment">    当前PromsieA的状态才会改变，且状态取决于参数PromsieA对象的状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">if</span> (val <span class="keyword">instanceof</span> PromiseA) &#123;</span><br><span class="line">    <span class="comment">// 如果为参数为PromiseA对象，在参数PromiseA对象的then方法中执行后续runFulfilled or runRejected操作</span></span><br><span class="line">    val.then(</span><br><span class="line">      value =&gt; &#123;</span><br><span class="line">        self.value = value;</span><br><span class="line">        runFulfilled(value);</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        self.value = err;</span><br><span class="line">        runRejected(err);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果参数是普通类型，直接执行runFulfilled</span></span><br><span class="line">    self.value = val;</span><br><span class="line">    runFulfilled(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加reject时执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (self.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">  self.status = REJECTED;</span><br><span class="line">  self.value = err;</span><br><span class="line">  <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">  <span class="keyword">let</span> cb;</span><br><span class="line">  <span class="keyword">while</span> ((cb = self.onRejectedCallbacks.shift())) &#123;</span><br><span class="line">    cb(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  handle(resolve.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  reject(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里面最关键的就是回调函数返回<strong>异步PromiseA对象</strong>时，要等<strong>异步PromiseA对象</strong>有结果时，当前的实例才能根据前面的异步结果改变自己的状态。</p>
<p>测试一下代码，在第一<code>PromiseA</code>实例的<code>then</code>的回调函数中，返回一个新的<code>PromiseA</code>实例并且在<code>2s</code>之后直接执行当前实例的<code>resolve</code>方法，在下一个<code>then</code>回调函数中再返回一个<code>PromiseA</code>实例，在<code>3s</code>后执行当前实例的<code>resolve</code>，最后一个<code>then</code>传入的回调函数中输出<code>resolve</code>中储存的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">"first------"</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// t1</span></span><br><span class="line">.then(<span class="function"><span class="params">first</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="comment">// 第二个promise实例</span></span><br><span class="line">    <span class="comment">// p2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">"second------"</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// t2</span></span><br><span class="line">.then(<span class="function"><span class="params">second</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">    <span class="comment">// 第三个promise实例</span></span><br><span class="line">    <span class="comment">// p3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">"third------"</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// t3</span></span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1s之后执行</span></span><br><span class="line"><span class="comment">// "first------" + new Date()</span></span><br><span class="line"><span class="comment">// 在上面的基础上等待2s之后执行</span></span><br><span class="line"><span class="comment">// "second------" + new Date()</span></span><br><span class="line"><span class="comment">// 在上面的基础上等待3s之后执行</span></span><br><span class="line"><span class="comment">// "third------" + new Date()</span></span><br></pre></td></tr></table></figure>
<p>整理一下内部的执行过程：</p>
<ol>
<li>当实例化<code>p1</code>时，在它<code>1s</code>后调用<code>resolve</code>函数，在它的<code>t1</code>中传入一个函数，这个函数返回一个<code>p2</code>实例。</li>
<li><code>t2</code>的执行，要等到<code>p2</code>的状态改变才执行。当执行<code>t2</code>时，又会产生一个<code>p3</code>实例。</li>
<li>等到<code>p3</code>的状态改变时，才会触发后续的<code>t3</code>执行。</li>
</ol>
<p>请看下文<a href="/blog/es6/es6-promise.html">Promise系列（二） 实现一个自己的Promise</a></p>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise系列（一） Promise的使用 (未完成)</title>
    <url>/blog/es6/es6-promise-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中source-map、WebpackPreload、WebpackPrefetch、WebpackChunkName</title>
    <url>/blog/webpack/webpack-source-map.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在webpack中的比如在调试vue代码或者react代码中，调试打包后的代码时候，我们都会用到一个叫做soruce-map，我们都是通过devtool来配置。比如说在vue-cli或者create-react-app中都有用到，source-map有很多种，我们在这里记录一下他们对应的解释。<br>在编写vue、react的时候，我们想做懒加载是，有非常适合chunk splitting的模块，比如说vue-router、react-router，在做懒加载切割的时候有三个要注意的不如说WebpackChunkName、WebpackPreload、WebpackPrefetch三个配置，他们分别对应chunk的name，和chunk代码何时被加载。</p>
<blockquote>
<p><a href="/blog/webpack/webpack-chunkhas-hash-contenthash.html">chunkhas-hash-contenthash</a></p>
</blockquote>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><p>当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。source-map就是帮忙<strong>追踪rror(错误) 和 warning(警告)的</strong>。<br>通过下面官方提供的表格一览devtool对应source-map的配置和速度影响：<br><img src="../../images/webpack/webpack-1-2.png" alt="webpack source-map"><br>在这个上面那种适合prod那种适合dev环境，还有构建速度和重新构建速度等等。我们可以在上面的基础上再把所有的配置分为四类，<strong>cheap、inline、eval、module</strong>四种，再在这种基础上看一下他们的区别，当然官方提供了devtool各种配置下得具体区别，有兴趣的可以看一下<a href="https://github.com/webpack/webpack/tree/master/examples/source-map" target="_blank" rel="noopener">devtool各种打包区别</a>。</p>
<p><strong>heap、inline、eval、module四种解释如下图标所示</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">带有参数</th>
<th style="text-align:center">不同的表现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cheap</td>
<td style="text-align:center">带有cheap参数的表示，在追踪error、warning时，只显示当前文件的行数，不显示当前在行数中的列数</td>
</tr>
<tr>
<td style="text-align:center">inline</td>
<td style="text-align:center">source map 转换为 DataUrl（base64） 后添加到 bundle 中，不产生source-map文件</td>
</tr>
<tr>
<td style="text-align:center">eval</td>
<td style="text-align:center">打包后的模块都使用 eval() 执行，行映射可能不准；不产生独立的 map 文件， 四中带有eval的对比请看<a href="https://webpack.docschina.org/configuration/devtool#%E5%AF%B9%E4%BA%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">四中eval对比</a></td>
</tr>
<tr>
<td style="text-align:center">module</td>
<td style="text-align:center">增加第三方库的error、warning追踪</td>
</tr>
</tbody>
</table>
<p>在下面对比source-map、eval-source-map、cheap-source-map、cheap-module-source-map、inline-souce-map来验证我们上面的总结<br>基础代码是在<a href="/blog/webpack/webpack-chunkhas-hash-contenthash.html">另一篇博客</a>中</p>
<h3 id="source-map-1"><a href="#source-map-1" class="headerlink" title="source-map"></a>source-map</h3><p>webpack中用使用devtool，修改webpack.config.js文件代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>); <span class="comment">// 新增</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    chunk1: <span class="string">"./src/chunk1.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].[chunkhash].js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123; <span class="comment">// 新增</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, </span><br><span class="line">          <span class="string">"css-loader"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ <span class="comment">// 新增</span></span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">"[name].[contenthash].css"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>运行webpack结果如下：<br><img src="../../images/webpack/webpack-2-1.png" alt="webpack contenthash hash chunkhash"><br>可以看到多了三个文件，就是对应我们业务代码bundle的map映射。</p>
<h3 id="eval-source-map"><a href="#eval-source-map" class="headerlink" title="eval-source-map"></a>eval-source-map</h3><p>修改devtool，修改webpack.config.js文件代码如下：</p>
<pre><code class="javascript">
</code></pre>
<h3 id="cheap-source-map"><a href="#cheap-source-map" class="headerlink" title="cheap-source-map"></a>cheap-source-map</h3><h3 id="cheap-module-source-map"><a href="#cheap-module-source-map" class="headerlink" title="cheap-module-source-map"></a>cheap-module-source-map</h3><h3 id="inline-souce-map"><a href="#inline-souce-map" class="headerlink" title="inline-souce-map"></a>inline-souce-map</h3><h2 id="WebpackPreload、WebpackPrefetch、WebpackChunkName"><a href="#WebpackPreload、WebpackPrefetch、WebpackChunkName" class="headerlink" title="WebpackPreload、WebpackPrefetch、WebpackChunkName"></a>WebpackPreload、WebpackPrefetch、WebpackChunkName</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>devtool</strong></p>
<ul>
<li>在dev环境中推荐使用 cheap-module-eval-source-map</li>
<li>在生产环境不推荐使用devtool一般都是使用false、‘none’，如果线上有错误日志收集的话推荐使用 source-map。</li>
</ul>
<blockquote>
<p>注意：如果生产环境上使用了source-map，你应该将你的服务器配置为，不允许普通用户访问 source map 文件！</p>
</blockquote>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>http中的jwt的实现 (未完成)</title>
    <url>/blog/http/http-jwt.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Http中的缓存（三） PWA中的serviceworker (未完成)</title>
    <url>/blog/http/http-cache-serviceworker.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/http/http-cache.html">Http中的缓存（一） 强缓存、协商缓存</a><br><a href="/blog/http/http-etag-cache.html">Http中的缓存（二） ETag和If-None-Match字段验证</a><br><a href="/blog/http/http-cache-serviceworker.html">Http中的缓存（三） PWA中的serviceworker</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git flow (未完成)</title>
    <url>/blog/git/git-flow.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git hooks (未完成)</title>
    <url>/blog/git/git-hooks.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git precommit or husky (未完成)</title>
    <url>/blog/git/git-precommit.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git merge的使用 (未完成)</title>
    <url>/blog/git/git-merge.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git rebase的使用</title>
    <url>/blog/git/git-rebase.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase（译注：rebase 的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。<br>同时，比如要要合并多个commit,就可以用git rebase -i head~2。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge // 合并分支</span><br><span class="line">git cherry-pick // copy单个commit</span><br><span class="line">git rebase // 衍合</span><br><span class="line">git rebase [startpoint]   [endpoint]  --onto  [branchName] // copy多个commit</span><br><span class="line">git rebase -i  [startpoint]  [endpoint] // 合并多个commit</span><br><span class="line">//  pick：保留该commit（缩写:p）</span><br><span class="line">//  reword：保留该commit，但我需要修改该commit的注释（缩写:r）</span><br><span class="line">//  edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</span><br><span class="line">//  squash：将该commit和前一个commit合并（缩写:s）</span><br><span class="line">//  fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</span><br><span class="line">//  exec：执行shell命令（缩写:x）</span><br><span class="line">//  drop：我要丢弃该commit（缩写:d）</span><br></pre></td></tr></table></figure>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>使用 git merge 合并master1和dev1分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master1</span><br><span class="line">git merge dev1</span><br></pre></td></tr></table></figure>
<p><img src="../../images/git/1-1.png" alt="git merge"><br>如上图所示：<br>最新的快照c2和c3，还有它们共同的祖先c1进行三方合并，合并的结果会产生以下新的c5，同时太还会对你的master1分支上的合并线条产生不好的结果。<br><img src="../../images/git/1-2.jpg" alt="git merge"></p>
<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>我们现在使用 git rebase 来合并master1和dev1分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev1</span><br><span class="line">git rebase master1</span><br><span class="line">git checkout master1</span><br><span class="line">git merge dev1</span><br></pre></td></tr></table></figure>
<p><img src="../../images/git/1-3.png" alt="git merge"><br>如上图所示：<br>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 dev1）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master1）最后一个提交对象（C2）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 dev1 的提交历史，使它成为 master1 分支的直接下游.<br>把 C3 里产生的改变到 C2 上重演一遍。<br>现在回到 master1 分支，进行一次快进合并.<br><img src="../../images/git/1-4.png" alt="git merge"></p>
<h2 id="git-rebase-startpoint-endpoint-–onto-branchName"><a href="#git-rebase-startpoint-endpoint-–onto-branchName" class="headerlink" title="git rebase [startpoint]   [endpoint]  –onto  [branchName]"></a>git rebase [startpoint]   [endpoint]  –onto  [branchName]</h2><p>当我们想从master1分支上复制b、c、d节点复制到dev1分支上，如下图所示：<br><img src="../images/git/1-5.png" alt="git rebase [startpoint]   [endpoint]  --onto  [branchName]"><br>master1分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 302d0381120b55518924d0fa5d91aeb651e7d4fd (HEAD -&gt; master1)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:38:25 2019 +0800</span><br><span class="line"></span><br><span class="line">    d</span><br><span class="line"></span><br><span class="line">commit 9ef980cce33baa48a96f2d989d17330047cdf36b</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:38:04 2019 +0800</span><br><span class="line"></span><br><span class="line">    c</span><br><span class="line"></span><br><span class="line">commit 0d00c05dc3cb28447e35d5d4be23ca76cc32741c</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:37:27 2019 +0800</span><br><span class="line"></span><br><span class="line">    b</span><br><span class="line"></span><br><span class="line">commit 57840ed32293ca5218a9734402b51d6bcad9698d</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:34:50 2019 +0800</span><br><span class="line"></span><br><span class="line">    a</span><br><span class="line"></span><br><span class="line">commit 24b0963b54f65fc58ca2642e81e7cdc7dae1e8ac (origin/develop, master, develop)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Feb 22 13:28:15 2019 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit from Create React App</span><br></pre></td></tr></table></figure>
<p>dev1分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 1225ea20d48bd16fbcfe1465e84f06292c52fe42 (HEAD -&gt; dev1)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:36:58 2019 +0800</span><br><span class="line"></span><br><span class="line">    e</span><br><span class="line"></span><br><span class="line">commit 57840ed32293ca5218a9734402b51d6bcad9698d</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:34:50 2019 +0800</span><br><span class="line"></span><br><span class="line">    a</span><br><span class="line"></span><br><span class="line">commit 24b0963b54f65fc58ca2642e81e7cdc7dae1e8ac (origin/develop, master, develop)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Feb 22 13:28:15 2019 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit from Create React App</span><br></pre></td></tr></table></figure>
<p>我们使用命令的形式为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase   [startpoint]   [endpoint]  --onto  [branchName]</span><br></pre></td></tr></table></figure>
<p>其中，[startpoint]  [endpoint]仍然和上一个命令一样指定了一个编辑区间(前开后闭)，–onto的意思是要将该指定的提交复制到哪个分支上。<br>所以，在找到b(7343021a9f5a65c6042bf62589ca02bd7bb95e7f)和c(d422a0cb01609f9007b5acf8771428d04ef5d963)的提交hash后，我们运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase 0d00c05dc^ 302d0381 --onto dev1</span><br></pre></td></tr></table></figure>
<p>如果有冲突解决冲突就解决冲突,如果没有就跳过这一步：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure></p>
<p><img src="../images/git/1-6.png" alt="git rebase [startpoint]   [endpoint]  --onto  [branchName]"><br>当前HEAD处于<font color="#ff502c">游离状态</font>，实际上，此时所有分支的状态应该是这样:<br>![git rebase [startpoint]   [endpoint]  –onto  [branchName]](../images/git/1-7.png<br>所以，虽然此时<font color="#ff502c">HEAD</font>所指向的内容正是我们所需要的，但是<font color="#ff502c">dev1</font>分支是没有任何变化的，git只是将<font color="#ff502c">b-c-d</font>部分的提交内容复制一份粘贴到了<font color="#ff502c">dev1</font>所指向的提交后面，我们需要做的就是将<font color="#ff502c">dev1</font>所指向的提交id设置为当前HEAD所指向的提交id就可以了，即:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev1</span><br><span class="line">git reset --hard 316ad6d</span><br></pre></td></tr></table></figure>
<p>这时候就完成了。</p>
<font color="#ff502c">git rebase [startpoint]   [endpoint]  –onto  [branchName] </font>还有一种用法。<br>参考 &gt;<font color="#ff502c"><a href="https://blog.csdn.net/endlu/article/details/51605861" target="_blank" rel="noopener">https://blog.csdn.net/endlu/article/details/51605861</a></font>

<h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>如果只是复制某一两个提交到其他分支，建议使用更简单的命令:git cherry-pick</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout '你的分支'</span><br><span class="line">git cherry-pick '你要copy的id'</span><br><span class="line">git log //查看</span><br></pre></td></tr></table></figure>
<h2 id="git-rebase-i-startpoint-endpoint-合并多个commit"><a href="#git-rebase-i-startpoint-endpoint-合并多个commit" class="headerlink" title="git rebase -i  [startpoint]  [endpoint] // 合并多个commit"></a>git rebase -i  [startpoint]  [endpoint] // 合并多个commit</h2><p>其中-i的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint]  [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。<br>在查看到了log日志后，我们运行以下命令：<br>未完待续。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中删除git本地远程分支、本地分支、远程分支</title>
    <url>/blog/git/git-delete.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在项目中使用 git 管理代码后，有些时候会创建很多不同名称的分支，以此区分各个分支代码功能。 而随着代码的合并，以前的分支就可能不再需要保存了，所以就要对没有用的分支进行删除，包括紧急回滚时从中抽取某一个版本记录所创建的临时分支。 这时候就可以使用下面的命令：</p>
<h3 id="删除本地-git-分支"><a href="#删除本地-git-分支" class="headerlink" title="删除本地 git 分支"></a>删除本地 git 分支</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git branch -D branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure>
<h3 id="删除本地-git-远程分支"><a href="#删除本地-git-远程分支" class="headerlink" title="删除本地 git 远程分支"></a>删除本地 git 远程分支</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git branch -D origin/branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure>
<h3 id="删除远程-git-分支"><a href="#删除远程-git-分支" class="headerlink" title="删除远程 git 分支"></a>删除远程 git 分支</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git push origin -D origin/branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码中Mixins原理和源码解析 (未完成)</title>
    <url>/blog/vue/vue-mixins.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Http中的缓存（二） HTTP中的缓存</title>
    <url>/blog/http/http-etag-cache.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/http/http-cache.html">Http中的缓存（一） 多级缓存结构</a><br><a href="/blog/http/http-etag-cache.html">Http中的缓存（二） HTTP中的缓存</a><br><a href="/blog/http/http-cache-serviceworker.html">Http中的缓存（三） PWA中的ServiceWorker</a></p>
</blockquote>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><strong>HTTP缓存</strong>相信都不陌生，因为它是在前端性能优化中必不可少的一个环节。在<strong>首次进入或者请求数据</strong>正常传输数据，而当<strong>再次进入或者请求数据</strong>时，可以走本地或者服务器上的缓存，来<strong>节省流量</strong>、<strong>优化性能</strong>、<strong>提高用户体验</strong>、<strong>降低网络负荷</strong>等等。</p>
<p><strong>web缓存</strong>主要用来缓存<strong>html文件</strong>、<strong>js文件</strong>、<strong>css文件</strong>、<strong>数据</strong>，基本上都是提升<strong>客户端/浏览器</strong>请求到<strong>服务器</strong>之间的速度，当然也可以结合数据压缩如<strong>gzip</strong>、<strong>7z</strong>等等加快响应数据传输。</p>
<p>在整个应用中可以错多层缓存结构这里不多做介绍，因为前面已经大致介绍过了，这里主要介绍和前端比较相关的<strong>HTTP缓存</strong>。</p>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>大致分为下面几步来加深对<strong>HTTP中的缓存</strong>理解和应用场景。</p>
<ol>
<li><strong>必知缓存策略的基础</strong></li>
<li><strong>缓存的判断策略</strong></li>
<li><strong>用户操作对缓存策略的影响</strong></li>
<li><strong>缓存储存的位置</strong></li>
<li><strong>缓存策略之间的对比</strong></li>
</ol>
<h2 id="必知缓存策略的基础"><a href="#必知缓存策略的基础" class="headerlink" title="必知缓存策略的基础"></a>必知缓存策略的基础</h2><p>大致把协议分为<strong>强缓存（过期策略）</strong>和<strong>协商缓存（协商策略）</strong>两类缓存，可能不太准确只是自己的现在的见解，<strong>浏览器/客户端</strong>通过这两种策略决定使用<strong>缓存中的副本</strong>还是从<strong>服务器</strong>中获取最新的资源。</p>
<ul>
<li><strong>强缓存（过期策略）</strong>：也就是缓存副本有效期。<br>一个缓存副本必须满足以下任一条件，浏览器会认为它是有效的，足够新的，而直接从缓存中获取副本并渲染：<ul>
<li><em>含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内</em></li>
<li><em>浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度</em></li>
</ul>
</li>
<li><strong>协商缓存（协商策略）</strong>：<em>服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如果发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。</em></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">key</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">缓存策略</th>
<th style="text-align:center">首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">指定缓存机制（http 1.0 字段）</td>
<td style="text-align:center">强缓存（过期策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">Cache-COntrol</td>
<td style="text-align:center"><code>Cache-Control</code> 通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。</td>
<td style="text-align:center">强缓存（过期策略）</td>
<td style="text-align:center">响应/请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center"><code>Expires</code> 响应头包含日期/时间， 即在此时候之后，响应过期。</td>
<td style="text-align:center">强缓存（过期策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center"><code>Last-Modified</code>  是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center"><code>If-Modified-Since</code> 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <code>200</code>。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center"><code>ETag</code>HTTP响应头是资源的特定版本的标识符。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center"><code>If-None-Match</code> 是一个条件式请求首部。对于 <code>GET</code> 和 <code>HEAD</code> 请求方法来说，当且仅当服务器上没有任何资源的 <code>ETag</code> 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为  <code>200</code>  。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">If-Match（辅助）</td>
<td style="text-align:center"><code>If-Match</code> 的使用表示这是一个条件请求。在请求方法为 <code>GET</code> 和 <code>HEAD</code> 的情况下，服务器仅在请求的资源满足此首部列出的 <code>ETag</code>值时才会返回资源。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since（辅助）</td>
<td style="text-align:center"><code>If-Unmodified-Since</code> 只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 <code>POST</code> 或其他 <code>non-safe</code> 方法的请求。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">Vary（辅助）</td>
<td style="text-align:center"><code>Vary</code> 是一个<code>HTTP</code>响应头部信息，它决定了对于未来的一个请求头，应该用一个缓存的回复(response)还是向源服务器请求一个新的回复。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
</tbody>
</table>
<!-- 下面四个就多做介绍了，大家可以去**mdn**中观看，下面是mdn中的连接。

- [Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma)
- [If-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match)
- [If-Unmodified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)
- [Vary](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary) -->
<p><em>缓存又分为<strong>强缓存和协商缓存</strong>。其中强缓存包括<code>Expires</code>和<code>Cache-Control</code>，<strong>主要是在过期策略生效时应用的缓存</strong>。弱缓存包括<code>Last-Modified</code>和<code>ETag</code>，<strong>是在协商策略后应用的缓存</strong>。<strong>强弱缓存之间的主要区别在于获取资源时是否会发送请求</strong>。</em></p>
<p><strong>强缓存和协商缓存</strong></p>
<ul>
<li>如果本地缓存过期，则要依靠协商缓存</li>
<li><strong>强缓存</strong>的 http状态码是 <code>200 OK</code></li>
<li><strong>协商缓存</strong>的 http 状态码是 <code>304 Not Modified</code></li>
</ul>
<h2 id="强缓存（过期策略）"><a href="#强缓存（过期策略）" class="headerlink" title="强缓存（过期策略）"></a>强缓存（过期策略）</h2><p>属于<strong>强缓存（过期策略）</strong>的有如下：</p>
<ul>
<li>Cache-COntrol</li>
<li>Expires</li>
</ul>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><code>Cache-Control</code>用于指定资源的缓存机制，可以同时在<strong>请求和响应头</strong>中设定。但是<code>Cache-Control</code>中的属性也分为<strong>请求和响应</strong>缓存指令，大致分为如下：</p>
<p><strong>缓存请求指令</strong><br>客户端可以在<strong>HTTP请求</strong>中使用的标准 <code>Cache-Control</code> 指令。</p>
<blockquote>
<p>Cache-Control: max-age=<seconds><br>Cache-Control: max-stale[=<seconds>]<br>Cache-Control: min-fresh=<seconds><br>Cache-control: no-cache<br>Cache-control: no-store<br>Cache-control: no-transform<br>Cache-control: only-if-cached</seconds></seconds></seconds></p>
</blockquote>
<p><strong>缓存响应指令</strong><br>服务器可以在<strong>响应</strong>中使用的标准 <code>Cache-Control</code> 指令。</p>
<blockquote>
<p>Cache-control: must-revalidate<br>Cache-control: no-cache<br>Cache-control: no-store<br>Cache-control: no-transform<br>Cache-control: public<br>Cache-control: private<br>Cache-control: proxy-revalidate<br>Cache-Control: max-age=<seconds><br>Cache-control: s-maxage=<seconds></seconds></seconds></p>
</blockquote>
<p><code>Cache-Control</code>: <code>cache-directive[,cache-directive]</code>。<code>cache-directive</code>为缓存指令，大小写不敏感，共有<strong>12</strong>个与<strong>HTTP</strong>缓存标准相关，如下所示。其中请求指令<em>7</em>种，响应指令<em>9</em>种。<code>Cache-Control</code>可以设置多个缓存指令，以逗号<code>,</code>分隔。</p>
<h4 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h4><ul>
<li><strong>public</strong>： 表明响应可以被<strong>任何对象（包括：发送请求的客户端、代理服务器、CDN等中间代理服务器等等）缓存</strong>，如下图所示：<br><img src="../../images/http/http-cache-3-1.png" alt="http-cache-public"></li>
<li><strong>private</strong>：表明响应只能被<strong>单个用户缓存</strong>，<strong>不能作为共享缓存（即代理服务器不能缓存它）</strong>。<br><img src="../../images/http/http-cache-3-2.png" alt="http-cache-public"></li>
<li><strong>no-cache</strong>：指定<strong>不缓存响应</strong>，表明资源<strong>不进行缓存</strong>，但是设置了 <code>no-cache</code> 之后并不代表<strong>浏览器</strong>不缓存，而是在<strong>获取缓存前</strong>要向<strong>服务器确认资源</strong>是否被更改。相当于<code>max-age: 0, must-revalidate</code></li>
<li><strong>no-store</strong>： <strong>绝对禁止缓存，请求和响应都不缓存，每次请求都从服务器获取完整资源</strong>。</li>
</ul>
<h4 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h4><ul>
<li><strong>max-age=<seconds></seconds></strong>: 设置<strong>缓存存储的最大周期</strong>，超过这个时间缓存被认为过期(<strong>单位秒</strong>)。</li>
<li><strong>s-maxage=<seconds></seconds></strong>: 覆盖<code>max-age</code>或者<code>Expires</code>头，但是<strong>仅适用于</strong>共享缓存(比如各个代理)，私有缓存会忽略它。</li>
<li><strong>max-stale[=<seconds>]</seconds></strong>: <strong>指定时间内，即使缓存过期，资源依然有效</strong>。</li>
<li><strong>min-fresh=<seconds></seconds></strong>：<strong>表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应</strong>。</li>
</ul>
<h4 id="重新验证和重新加载"><a href="#重新验证和重新加载" class="headerlink" title="重新验证和重新加载"></a>重新验证和重新加载</h4><ul>
<li><strong>muse-revalidate</strong>: 使用缓存资源之前，<strong>必须先验证状态</strong>，如果页面是<strong>过期的(如max-age)</strong>，则去服务器进行<strong>获取</strong>。</li>
<li><strong>proxy-revalidate</strong>： 与<code>must-revalidate</code>作用相同，但它<strong>仅适用于共享缓存（例如代理）</strong>，并被私有缓存忽略。</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><strong>no-transform</strong>：强制要求代理服务器不要对资源进行转换，禁止代理服务器对<code>Content-Encoding</code>、<code>Content-Range</code>、<code>Content-Type</code>等字段的修改，因此代理服务器的<code>gzip</code>压缩将<strong>不被允许</strong>。</li>
</ul>
<h4 id="no-cache和no-store"><a href="#no-cache和no-store" class="headerlink" title="no-cache和no-store"></a>no-cache和no-store</h4><p>还有一点需要注意的是，<code>no-cache</code>并不是指<strong>不缓存文件</strong>，<code>no-store</code>才是指<strong>不缓存文件</strong>。<code>no-cache</code>仅仅是表明<strong>跳过强缓存</strong>，强制进入<strong>协商策略</strong>。</p>
<h4 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h4><p><strong>禁止缓存</strong><br><code>Cache-Control: no-cache, no-store, must-revalidate</code></p>
<p><strong>缓存静态资源</strong><br><code>Cache-Control:public, max-age=86400</code></p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>指定缓存的<strong>过期时间</strong>，为绝对时间，即某一时刻。</p>
<blockquote>
<p>注意：参考<strong>本地时间</strong>进行比对，在指定时刻后过期。<strong>RFC 2616建议最大值不要超过1年</strong>。</p>
</blockquote>
<h3 id="max-age与Expires"><a href="#max-age与Expires" class="headerlink" title="max-age与Expires"></a>max-age与Expires</h3><p><code>Cache-Control</code>中的<code>max-age</code>指令用于指定<strong>缓存过期的相对时间</strong>。资源达到指定时间后过期。该功能与<code>Expires</code>类似。但其<strong>优先级高于Expires</strong>，如果同时设置<code>max-age</code>和<code>Expires</code>，<code>max-age</code>生效，忽略<code>Expires</code>。</p>
<blockquote>
<p>Cache-Control &gt; Expires</p>
</blockquote>
<h3 id="强缓存大致流程"><a href="#强缓存大致流程" class="headerlink" title="强缓存大致流程"></a>强缓存大致流程</h3><p>强缓的设置流程图大致如下：<br><img src="../../images/http/http-cache-3-3.png" alt="http-cache-public"></p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>在没有<strong>强缓存</strong>时，就会走协商缓存，协商缓存大致流程：</p>
<ul>
<li>第一次请求时，服务端返回给客户端一个<strong>key(如Etag的资源值、Last-Modified最后修改时间)</strong>和资源</li>
<li>第二次请求时，客户端带上第一次服务端返回的key</li>
<li>服务器端验证当前的key是否和上次返回给客户端的是否一致，一致返回304使用缓存，不一致重新返回key和新的资源</li>
</ul>
<p>属于<strong>协商缓存（协商策略）</strong>的有如下：</p>
<ul>
<li>Last-Modified/If-Modified-Since/If-Unmodified-Since</li>
<li>ETag/If-Match/If-None-Match</li>
</ul>
<h3 id="Last-Modified-If-Modified-Since-If-Unmodified-Since"><a href="#Last-Modified-If-Modified-Since-If-Unmodified-Since" class="headerlink" title="Last-Modified/If-Modified-Since/If-Unmodified-Since"></a>Last-Modified/If-Modified-Since/If-Unmodified-Since</h3><p><code>Last-Modified/If-Modified-Since</code>大致流程如下：</p>
<ul>
<li>第一次请求时，服务器会获取资源的最后修改时间通过设置<code>Last-Modified</code>，返回给客户端</li>
<li>后面请求时，客户端(浏览器)会自动带上<code>If-Modified-Since</code>字段</li>
<li>服务器从新获取修改时间与<code>If-Modified-Since</code>中的时间对比，如果没有变化返回<code>304</code>状态码（浏览器得知304状态码，资源从缓存中获取），如果改变返回<code>200</code>并且更新资源、更新<code>Last-Modified</code></li>
</ul>
<p>上面的流程是在设置不使用<strong>强缓存</strong>时的场景，这个只是现在的理解可能有很多的不太完善的地方。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p><code>Last-Modified</code>用于标记<strong>请求资源的最后一次修改时间</strong>。</p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Last-Modified: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT</span><br><span class="line"></span><br><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li><strong>GMT(格林尼治标准时间)</strong></li>
<li><code>Last-Modified</code>只能精确到秒，因此不适合在一秒内多次改变的资源。</li>
</ul>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p><code>If-Modified-Since</code> 是一个条件式请求首部，与<code>Last-Modified</code>何用。有两种结果如下：</p>
<ul>
<li><code>If-Modified-Since/Last-Modified</code>相同返回<code>304</code>状态码，客户端使用缓存</li>
<li><code>If-Modified-Since/Last-Modified</code>不相同返回<code>200</code>状态码，返回新的资源</li>
</ul>
<blockquote>
<p><code>If-Modified-Since</code> 只可以用在 <code>GET</code> 或 <code>HEAD</code> 请求中。</p>
</blockquote>
<h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><p><code>If-Unmodified-Since</code>表示资源未修改则正常执行更新，否则返回<code>412(Precondition Failed)</code>状态码的响应。主要有如下两种场景。</p>
<ol>
<li>用于不安全的请求中从而是请求具备条件性（如POST或者其他不安全的方法），如请求更新wiki文档，<strong>文档未修改时才执行更新</strong>。</li>
<li>与<code>If-Range</code>字段同时使用时，可以用来保证新的片段请求来自一个未修改的文档。</li>
</ol>
<h3 id="ETag-If-Match-If-None-Match"><a href="#ETag-If-Match-If-None-Match" class="headerlink" title="ETag/If-Match/If-None-Match"></a>ETag/If-Match/If-None-Match</h3><p>根据实体内容生成一段<strong>唯一hash字符串</strong>，标识资源的状态，由服务端产生。浏览器会将这<strong>串字符串传回服务器</strong>，验证资源是否已经修改，如果没有修改，过程如下：</p>
<p><img src="../../images/http/http-cache-3-4.png" alt="http-cache-public"></p>
<p><code>ETag</code> <strong>HTTP响应头</strong>是资源的特定版本的标识符。<br><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ETag: W/<span class="string">"&lt;etag_value&gt;"</span></span><br><span class="line">ETag: <span class="string">"&lt;etag_value&gt;"</span></span><br></pre></td></tr></table></figure>
<p><strong>W/ 可选</strong><br><strong>‘W/‘(大小写敏感) </strong>表示使用<strong>弱验证器</strong>。 弱验证器很<strong>容易</strong>生成，但<strong>不利</strong>于比较。 强验证器是<strong>比较的理想</strong>选择，但<strong>很难</strong>有效地生成。</p>
<p><strong>“&lt;etag_value&gt;”</strong><br>实体标签唯一地表示所请求的资源。 它们是位于<strong>双引号</strong>之间的ASCII字符串（如“675af34563dc-tr34”）。</p>
<blockquote>
<p>注意：ETag和If-None-Match的值均为双引号包裹的。<br><code>ETag</code>的优先级高于<code>Last-Modified</code>。当<code>ETag</code>和<code>Last-Modified</code>，<code>ETag</code>优先级更高，但不会忽略<code>Last-Modified</code>，需要服务端实现。</p>
</blockquote>
<p><code>ETag</code> 和 <code>If-None-Match</code> 常被用来处理<strong>协商缓存</strong>。而 <code>ETag</code> 和 <code>If-Match</code> 可以 <strong>避免“空中碰撞”</strong>。</p>
<p><code>ETag</code> HTTP 响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web 服务器不需要发送完整的响应。而如果内容发生了变化，使用 <code>ETag</code> 有助于防止资源的<strong>同时更新相互覆盖（“空中碰撞”）</strong>。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>当编辑MDN时，当前的WIki内容被散列，并在相应中放入<code>Etag</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ETag: <span class="string">"33a64df551425fcc55e4d42a148795d9f25f89d4"</span></span><br></pre></td></tr></table></figure>
<p>将更改保存到WIKI页面（发布数据）时，POST请求将包含有<code>ETag</code>值的<code>If-Match</code>头来检车是否为最新版本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">If-Match: <span class="string">"33a64df551425fcc55e4d42a148795d9f25f89d4"</span></span><br></pre></td></tr></table></figure>
<p>如果哈希值不匹配，则意味着文档已经被编辑，抛出 <code>412 ( Precondition Failed)</code> 前提条件失败错误。</p>
<p><code>If-None-Match</code> 是客户端发送给服务器时的请求头，其值是服务器返回给客户端的 <code>ETag</code>，当 <code>If-None-Match</code> 和服务器资源最新的 <code>Etag</code> 不同时，返回最新的资源及其 <code>Etag</code>。</p>
<h2 id="缓存的判断策略"><a href="#缓存的判断策略" class="headerlink" title="缓存的判断策略"></a>缓存的判断策略</h2><p>缓存策略分为<strong>强缓存</strong>和<strong>协商缓存</strong>，首先经过<strong>强缓存</strong>的<strong>过期策略</strong>，才会走后面的<strong>协商缓存</strong>的<strong>协商策略</strong>，大致把缓存分为三个阶段<strong>本地缓存阶段（强缓存）</strong>、<strong>协商缓存阶段（本地+服务器）</strong>、<strong>缓存失败阶段</strong>。</p>
<p>大致在每个阶段中做的什么判断：</p>
<ol>
<li><strong>本地缓存阶段</strong>：如果设置了<strong>强缓存</strong>，那么会现在本地查找该资源，如果发现该资源，而且该资源还没有过期，就使用这个资源副本，完全不会发起<code>http</code>请求到服务器。（主要应用是<strong>强缓存</strong>、<strong>serverWorker</strong>）;</li>
<li><strong>协商缓存阶段</strong>：如果在<strong>本地缓存</strong>找到对应的资源，但是不知道该资源<strong>是否过期或者已经过期</strong>，则发一个http请求到服务器，然后服务器<strong>判断</strong>这个请求，如果请求的资源在服务器上没有改动过，则返回<code>304</code>，让浏览器使用本地找到的那个资源；</li>
<li><strong>缓存失败阶段</strong>: 当服务器发现请求的资源<strong>已经修改过</strong>，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回<code>200</code>， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回<code>404</code>。</li>
</ol>
<p>大致流程如下图所示：</p>
<p><img src="../../images/http/http-cache-3-5.png" alt="http-cache-public"></p>
<p>这张图中没有包含<code>serverWorker</code>的缓存判断流程b，但是在后面会有一篇文章专门介绍<strong>serverWorker</strong>，因为他是属于<strong>PWA</strong>中的内容。</p>
<blockquote>
<p><strong>存储策略</strong>发生在<strong>收到请求响应后</strong>，用于决定<strong>是否缓存</strong>相应资源；<strong>过期策略</strong>发生在<strong>请求前</strong>，用于判断缓存<strong>是否过期</strong>；<strong>协商策略</strong>发生在<strong>请求中</strong>，用于判断缓存资源<strong>是否更新</strong>。</p>
</blockquote>
<h2 id="用户操作对缓存策略的影响"><a href="#用户操作对缓存策略的影响" class="headerlink" title="用户操作对缓存策略的影响"></a>用户操作对缓存策略的影响</h2><p>在用户刷新页面（F5）时，会对缓存产生影响，这里就会记录用户操作对缓存产生的影响。用户操作事项如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">用户操作</th>
<th style="text-align:center">强缓存</th>
<th style="text-align:center">协商缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(新标签)地址栏回车</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">(地址不变)地址栏回车</td>
<td style="text-align:center">兼容性问题Chrome(失效)/Firefox(有效)</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">链接跳转</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">前进/后退</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">从收藏栏打开链接</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">(window.open)新开窗口</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">刷新（Command/Ctrl + R / F5）</td>
<td style="text-align:center">失效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">强制刷新（Command + Shift + R / Ctrl + F5）</td>
<td style="text-align:center">失效</td>
<td style="text-align:center">失效</td>
</tr>
</tbody>
</table>
<p>基本上包含了一些常见的用户操作对<strong>强缓存</strong>和<strong>协商缓存</strong>的影响，大致的判断流程如下：</p>
<p><img src="../../images/http/http-cache-3-6.png" alt="http-cache-public"></p>
<p><strong>注意</strong></p>
<blockquote>
<ul>
<li>(地址不变)地址栏回车：它比较特殊，为什么它在<strong>Chrome</strong>是<strong>失效</strong>，在<strong>Firefox</strong>中是<strong>有效</strong>。因为<strong>Chrome</strong>把<strong>地址不变回车</strong>等同于<strong>刷新当前页面</strong>，而在<strong>Firefox</strong>都是作为<strong>新地址回车</strong>处理的。</li>
<li><code>webkit(Chrome内核)</code>资源分为<strong>主资源</strong>和<strong>派生资源</strong>。<strong>主资源</strong>是地址栏输入的URL请求返回的<strong>资源</strong>，<strong>派生资源</strong>是主资源中所引用<strong>的JS、CSS、图片等资源</strong>。</li>
<li>在<code>Chrome</code>下刷新时，只有主资源的缓存应用方式如上图所示，<strong>派生资源</strong>的<strong>缓存应用方式与新标签打开类似</strong>，会判断缓存是否过期。强缓存生效时的区别在于新标签打开为<code>from disk cache</code>，而当前页刷新派生资源是<code>from memory cache</code>。</li>
<li>而在<code>Firefox</code>下，当前页面刷新，所有资源都会如上图所示。</li>
</ul>
</blockquote>
<h2 id="缓存储存的位置"><a href="#缓存储存的位置" class="headerlink" title="缓存储存的位置"></a>缓存储存的位置</h2><p>从缓存的位置上来说分为<strong>四种</strong>，并且各自有优先级，当<strong>依次由上到下</strong>查找缓存且<strong>都没有命中</strong>的时候，才会去请求网络，大致如下：</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p><strong>Service Worker</strong> 是一种独立于主线程之外的 <strong>Javascript</strong> 线程。它可以帮我们实现<strong>离线缓存</strong>、<strong>消息推送</strong>和<strong>网络代理</strong>等功能。</p>
<blockquote>
<p>使用 <code>Service Worker</code>的话，传输协议<strong>必须</strong>为 <code>HTTPS</code>。因为 <code>Service Worker</code> 中涉及到请求拦截，所以必须使用 <code>HTTPS</code> 协议来保障安全。</p>
</blockquote>
<p><strong>Service Worker</strong> 实现缓存大致分为以下几个步骤：</p>
<ul>
<li>首先需要在页面的 <strong>JavaScript 主线程中注册 Service Worker</strong>。</li>
<li>注册成功后后台开始安装步骤， 通常在安装的过程中需要缓存一些静态资源。</li>
<li>安装成功后开始<strong>激活 Service Worker</strong></li>
<li>激活成功后 <strong>Service Worker</strong> 可以控制页面了（<strong>监听 fetch 和 message 事件</strong>），但是只针对在成功注册了 <strong>Service Worker</strong> 后打开的页面。</li>
</ul>
<p>在这里就不细说了，后面有一个单独的章节来讲述<strong>Service Worker</strong>, <strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</strong>。</p>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p><strong>Memory Cache</strong> 是内存中的缓存。主要包含的是当前页面中请求到的数据如<strong>图片（base64）</strong>、<strong>脚本（JavaScript）</strong>、<strong>样式（css）</strong>等静态数据。读取内存中的数据肯定比磁盘中的<strong>快</strong>，但是内存中的<strong>缓存持续性很短</strong>，它会随着当前<strong>Tab页面关闭，内存中的缓存也就被释放</strong>。</p>
<p>比如在<strong>百度首页</strong>刷新页面，效果如下图所示：<br><img src="../../images/http/http-cache-3-7.png" alt="http-cache-public"></p>
<p><strong>preload</strong><br><code>&lt;link&gt;</code> 元素的 <code>rel</code> 属性的属性值<code>preload</code>，<code>&lt;link rel=&quot;preload&quot;&gt;</code>来显示的指定的预加载资源，也会被放入<code>memory cache</code>中。</p>
<p><strong>prefetch</strong><br><code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 已经被许多浏览器支持了相当长的时间，但它是意图预获取一些资源，以备下一个导航/页面使用（比如，当你去到下一个页面时）。<br>浏览器会给使用<code>prefetch</code>的资源一个<strong>相对较低的优先</strong>级与使用<code>preload</code>的资源相比。</p>
<p><strong>subresource</strong><br><code>&lt;link rel=&quot;subresource&quot;&gt;</code>被Chrome支持了有一段时间，并且已经有些搔到预加载当前导航/页面（所含有的资源）的痒处了。这些资源会以一个<strong>相当低的优先级</strong>被加载。<br><code>Memory Cache</code>不会轻易的命中一个请求，除了要有<strong>匹配的URL</strong>，还要有相同的<strong>资源类型</strong>、<strong>CORS模式</strong>以及一些<strong>其他特性</strong>。<br><code>Memory Cache</code>是不关心<code>HTTP语义</code>的，比如<code>Cache-Control: max-age=0</code>的资源，仍然可以在同一个导航中被重用。但是在特定的情况下，<code>Memory Cache</code>会遵守<code>Cache-Control: no-store</code>指令，不缓存相应的资源。</p>
<blockquote>
<p><code>Memory Cache</code>匹配规则在标准中没有详尽的描述，所以不同的浏览器内核在实现上会有所不同。</p>
</blockquote>
<h3 id="Disk-Cache-HTTP-Cache"><a href="#Disk-Cache-HTTP-Cache" class="headerlink" title="Disk Cache/HTTP Cache"></a>Disk Cache/HTTP Cache</h3><p><code>HTTP Cache</code>也被叫做<code>Disk Cache</code>。从字面的意思上理解<code>Disk Cache</code>就是储存在硬盘上的<strong>缓存</strong>，因此它是持久存储的，是实际存在于文件系统中的。<br>而且<strong>它允许相同的资源在跨会话</strong>，甚至<strong>跨站点</strong>的情况下使用，例如<strong>两个站点都使用了同一张图片</strong>。</p>
<p><code>HTTP Cache</code>会根据<code>HTTP Herder</code>中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<br>当<strong>命中缓存</strong>之后，浏览器会从<strong>硬盘中读取资源</strong>，虽然比起从内存中<strong>读取慢</strong>了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 <code>disk cache</code>。</p>
<blockquote>
<p>凡是<strong>持久性存储</strong>都会面临<strong>容量增长</strong>的问题，<code>disk cache</code> 也不例外。在<strong>浏览器自动清理</strong>时，会有神秘的算法去把“最老的”或者“最可能过时的”资源删除，因此是一个一个删除的。不过每个浏览器识别“最老的”和“最可能过时的”资源的算法不尽相同，可能也是它们差异性的体现。</p>
</blockquote>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p><code>Push Cache</code>（推送缓存）是 <code>HTTP/2</code> 中的内容，当以上三种缓存都没有命中时，它才会被使用。<br><strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong>，在Chrome浏览器中只有5分钟左右，同时它也<strong>并非严格执行HTTP头中的缓存指令</strong>。</p>
<p><code>Push Cache</code> 在国内能够查到的资料很少，也是因为 <code>HTTP/2</code> 在国内不够普及。这里推荐阅读<code>Jake Archibald</code>的 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p>
<ul>
<li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
<p>如果以上<strong>四种缓存都没有命中</strong>的话，那么只能发起<strong>请求来获取资源</strong>了。</p>
<p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：<strong>强缓存和协商缓存</strong>，并且缓存策略都是通过设置 <code>HTTP Header</code> 来实现的。</p>
<h3 id="关于-memory-cache-和-disk-cache"><a href="#关于-memory-cache-和-disk-cache" class="headerlink" title="关于 memory cache 和 disk cache"></a>关于 memory cache 和 disk cache</h3><p>这两种缓存类型存在于 Chrome 中。<br><code>disk cache</code> 存在硬盘，可以存很多，容量上限比内容缓存高很多，而 <code>memory cache</code> 从内存直接读取，速度上占优势，这两个各有各的好处！</p>
<p>因为关于在什么时候用到什么缓存的文档相当的少所以真的不好判断，是当前使用的是哪个缓存，比如下面这个例子：</p>
<p><img src="../../images/http/http-cache-3-8.png" alt="http-cache-public"></p>
<h2 id="缓存策略之间的对比"><a href="#缓存策略之间的对比" class="headerlink" title="缓存策略之间的对比"></a>缓存策略之间的对比</h2><p>其实缓存之间也没有太好的对比性，大致可以从<strong>缓存策略</strong>和<strong>缓存位置</strong>两个角度对比缓存的优缺点。</p>
<ul>
<li><strong>强缓存</strong>返回 <strong>http 200 OK状态码</strong>，而<strong>协商缓存</strong>返回<strong>http 304 Not Modified 状态码</strong></li>
<li><strong>强缓存</strong>中的优先级为： <strong>Cache-Control &gt; Expires</strong></li>
<li><strong>协商缓存</strong>中的优先级： <strong>Etag/If-None-Match &gt; Last-Modified/Last-Since-Modified</strong></li>
<li><strong>协商缓存</strong>中，<strong>Last-Modified</strong>不能记录秒级以下的更新缓存，而<strong>Etag可以</strong>。但是<strong>Etag生成唯一资源标识符又比叫困难</strong>，而<strong>Last-Modified实现起来比价简单</strong></li>
<li><code>Service Worker</code>相对于<code>Disk Cache/Memory Cache</code>配置会麻烦一点，但是<code>Service Worker</code>应用场景更广，性能也会好一点。</li>
<li><code>Service Worker</code>必须要在<code>Https</code>协议中才会生效。</li>
<li><strong>Disk Cache</strong>相对于<strong>Memory Cache</strong>，它的优点在于<strong>容量大、储存周期长、可被多域使用</strong>，缺点在于<strong>读取速度慢</strong></li>
<li><strong>Memory Cache</strong>相对于<strong>Memory Cache</strong>，它的优点在于<strong>速度快、对前端link字段支持性</strong>，缺点在于<strong>储存周期短（tab也关闭）、空间有限</strong></li>
</ul>
<p>它们的值优缺点如上所示，如在<strong>chrome</strong>、<strong>firefox</strong>、<strong>ie</strong>中<strong>Memory cache</strong>和<strong>Disk cache</strong>也是不太相同的。</p>
<h3 id="关于-Chrome、FF、IE-的缓存区别"><a href="#关于-Chrome、FF、IE-的缓存区别" class="headerlink" title="关于 Chrome、FF、IE 的缓存区别"></a>关于 Chrome、FF、IE 的缓存区别</h3><p><strong>Chrome</strong>浏览器的速度比其他两个浏览器的速度更快一点，主要是因为<strong>V8</strong>引擎的执行速度更快，另一方面应该就是它的<strong>缓存策略</strong>的使用。<br>从这四个方面<strong>强缓存</strong>、<strong>协商缓存</strong>、<strong>Disk Cache</strong>、<strong>Memory Cache</strong>来对比，为什么说<strong>Chrome</strong>执行效果比其它的两个浏览器的执行速度和加载速度更快。</p>
<p>就以百度首页为例看一下<strong>Chrome</strong>和<strong>Firefox</strong>的差别。</p>
<p>在<code>Chrome</code>和<code>Firefox</code>中打开<code>https://www.baidu.com/</code>首页，结果如下图所示<br><strong>Firefox</strong>效果如下：<br><img src="../../images/http/http-cache-3-9.png" alt="http-cache-public"><br><strong>Chrome</strong>效果如下：<br><img src="../../images/http/http-cache-3-10.png" alt="http-cache-public"></p>
<p>我们以百度的<code>bd_logo1.png</code>的请求为例，<code>logo</code>的请求是一个<code>Get</code>请求，同时它被设置了<strong>四个缓存</strong>配置，但是它在两个浏览器中表现并不相同，如下图所示</p>
<p><strong>Firefox</strong>效果如下：<br><img src="../../images/http/http-cache-3-12.png" alt="http-cache-public"><br><strong>Chrome</strong>效果如下：<br><img src="../../images/http/http-cache-3-11.png" alt="http-cache-public"></p>
<p>首先在<strong>再次请求</strong>时浏览器端都<strong>没有携带协商缓存</strong>需要的头部字段，所以它们肯定走的是<strong>强缓存</strong>，在<strong>强缓存</strong>中<code>Cache-Control</code>的优先级是最高的，所以都是走的<strong>Cache-Control</strong>的策略。</p>
<p>可以看到它们的区别如下几点：</p>
<ul>
<li><strong>状态码</strong>： 首先它们返回的状态码是不同的，<strong>Chrome</strong>返回的状态码是<code>200</code>,<strong>Firefox</strong>返回的状态码是<code>304</code>。</li>
<li><strong>使用的资源</strong>： 可以看到<strong>Chrome</strong>中的资源大小为<code>0(耗时 0ms，也就是 1ms 以内)</code>，那么它使用的本地的资源。而<strong>Firefox</strong>中它是从服务器获取的资源。</li>
</ul>
<h2 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h2><p>在这里我们来一个一个测试<code>expires/cache-control/etag/last-modified/pragma</code>它们是否和我们上面所总结的一致。</p>
<p>测试环境<code>chrome 78.0.3904.70</code>、<code>node 12.9.1</code>、<code>koa 2.x</code>.</p>
<p>整体的目录结构如下图所示：<br><img src="../../images/http/http-cache-3-13.png" alt="http-cache-public"></p>
<p>代码可能写的比较粗糙，但是后面会优化一下，公共代码如下：</p>
<p><strong>index.html</strong>代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/index/index.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    测试cache</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/index/rotateX.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>app.js</strong>代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> Static = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> Path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.type = mime.getType(<span class="string">'.html'</span>);</span><br><span class="line">    <span class="comment">// console.log(__dirname)</span></span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(Path.resolve(__dirname + <span class="string">'/index/index.html'</span>), <span class="string">'UTF-8'</span>);</span><br><span class="line">    <span class="comment">// console.log(content);</span></span><br><span class="line">    ctx.body = content;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 待优化</span></span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; response, path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line">    <span class="keyword">const</span> imageBuffer = <span class="keyword">await</span> fs.readFile(Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>));</span><br><span class="line">    ctx.body = imageBuffer;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待优化</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>), <span class="string">'UTF-8'</span>);</span><br><span class="line">    ctx.body = content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待优化</span></span><br><span class="line">router.get(<span class="string">'/index/index.js'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>), <span class="string">'UTF-8'</span>);</span><br><span class="line">    ctx.body = content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use(Static('./index'))</span></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log()</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'启动成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>下面的代码都是在这个代码上修改，<code>index.js</code>、<code>index.css</code>、<code>rotateX.png</code>自己写就可以，或者去网上下载一个稍微超过<code>2kb</code>大小的文件。</p>
<h3 id="Cache-Control实例"><a href="#Cache-Control实例" class="headerlink" title="Cache-Control实例"></a>Cache-Control实例</h3><p>使用<code>Cache-Control</code>缓存测试效果，修改代码如下：</p>
<p>修改<strong>app.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 添加代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'max-age='</span> + <span class="number">10</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 添加代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'max-age='</span> + <span class="number">10</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.js'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 添加代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'max-age='</span> + <span class="number">10</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们在通过<code>nodemon app.js</code>运行代码，运行效果大致如下：</p>
<ol>
<li>第一个打开<code>localhost:3000</code>时，因为没有任何缓存所以资源是<code>从服务器中请求</code>来的，如下图所示<br><img src="../../images/http/http-cache-3-14.png" alt="http-cache-public"></li>
<li>当我们刷新页面时，因为我们设置了<code>Cache-Control: max-age=10</code>，所以会走<code>本地缓存</code>，如下图所示<br><img src="../../images/http/http-cache-3-15.png" alt="http-cache-public"><br>第二次请求，三个请求都来自 <code>memory cache</code>。因为我们没有关闭 TAB，所以浏览器把缓存的应用加到了<code>memory cache</code>。(耗时 0ms，也就是 1ms 以内)</li>
<li>当我们跳转到<code>https://www.baidu.com</code>，再返回页面时，它也会<code>走本地缓存</code>，如下图所示<br><img src="../../images/http/http-cache-3-16.png" alt="http-cache-public"><br>因为跳转页面等于是<strong>关闭了 TAB</strong>，<code>memory cache</code> 也随之清空。但是 <code>disk cache</code> 是持久的，于是所有资源来自 <code>disk cache</code>。(大约耗时 3ms，因为文件有点小)而且对比 2 和 3，很明显看到 <code>memory cache</code> 还是比 <code>disk cache</code>快得多的。</li>
</ol>
<h3 id="no-cache和no-store对比"><a href="#no-cache和no-store对比" class="headerlink" title="no-cache和no-store对比"></a>no-cache和no-store对比</h3><p>我们来对比一下<code>no-cache</code>和<code>no-store</code>的区别，修改代码如下：</p>
<p>修改<strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/index/index.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/index/index.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    测试cache</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/index/rotateX.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/index/rotateX.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 异步请求图片 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="javascript">            img.src = <span class="string">'/index/rotateX.png'</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(img)</span></span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们暂时不修改缓存的配置，通过<code>nodemon app.js</code>运行代码，运行效果大致如下：</p>
<ul>
<li>同步请求方面，浏览器会<strong>自动</strong>把当次 <code>HTML</code> 中的资源存入到缓存 (<code>memory cache</code>)，这样碰到相同 <code>src</code> 的图片就会自动读取缓存(但不会在 <code>Network</code> 中显示出来)</li>
<li>异步请求方面，浏览器同样是不发请求而<strong>直接读取缓存</strong>返回。但同样不会在 <code>Network</code> 中显示。</li>
</ul>
<p>下面我们修改<strong>app.js</strong>中的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.js'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们运行代码看的效果如下图所示：<br><img src="../../images/http/http-cache-3-18.png" alt="http-cache-public"></p>
<ul>
<li>同步请求方面，浏览器会<strong>自动</strong>把当次 <code>HTML</code> 中的资源存入到缓存 (<code>memory cache</code>)，这样碰到相同 <code>src</code> 的图片就会自动读取缓存(但不会在 <code>Network</code> 中显示出来)</li>
</ul>
<p>如果把<code>no-cache</code>修改为<code>no-store</code></p>
<p>修改<strong>app.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-store'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-store'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.js'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-store'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们运行代码看的效果如下图所示：<br><img src="../../images/http/http-cache-3-17.png" alt="http-cache-public"></p>
<p>当我们设置了<code>Cache-Control: no-store</code>时，可以看到<code>css</code>、<code>js</code>文件都被请求了两次，<code>png</code>请求了三次。</p>
<ul>
<li>如之前原理所述，虽然 <code>memory cache</code> 是无视 <code>HTTP</code> 头信息的，但是 <code>no-store</code> 是特别的。在这个设置下，<code>memory cache</code> 也不得不每次都请求资源。</li>
<li>异步请求和同步遵循相同的规则，在 <code>no-store</code> 情况下，依然是每次都发送请求，不进行任何缓存。</li>
</ul>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h3><p>这里来设置协商缓存<code>Last-Modified/If-Modified-Since</code>，代码修改如下：</p>
<p>修改<strong>app.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> responseFile = <span class="keyword">async</span> (path, context, encoding) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fileContent = <span class="keyword">await</span> fs.readFile(path, encoding);</span><br><span class="line">  context.type = mime.getType(path);</span><br><span class="line">  context.body = fileContent;</span><br><span class="line">&#125;;</span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">'Pragma'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; response, request, path &#125; = ctx;</span><br><span class="line">  <span class="keyword">const</span> imagePath = Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> ifModifiedSince = request.headers[<span class="string">'if-modified-since'</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(ifModifiedSince)</span><br><span class="line">  <span class="keyword">const</span> imageStatus = <span class="keyword">await</span> fs.stat(imagePath);</span><br><span class="line">  <span class="keyword">const</span> lastModified = imageStatus.mtime.toGMTString();</span><br><span class="line">  <span class="keyword">if</span> (ifModifiedSince === lastModified) &#123;</span><br><span class="line">      response.status = <span class="number">304</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.lastModified = lastModified;</span><br><span class="line">      <span class="keyword">await</span> responseFile(imagePath, ctx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>大致流程如下：</p>
<ol>
<li>在<code>Chrome</code>中选中<code>Disable Cache</code>禁用缓存，可以通过下面图片看到服务器端发送给客户端<code>Last-Modified: Thu, 24 Oct 2019 05:12:37 GMT</code>。<br><img src="../../images/http/http-cache-3-19.png" alt="http-cache-public"></li>
<li>关闭 <code>disable cache</code> 后再次访问图片时，发现带上了 <code>if-modified-since</code> 请求头，值就是上次请求响应的 <code>last-modified</code> 值，因为图片最后修改时间不变，所以 <code>304 Not Modified</code>。效果如下图所示<br><img src="../../images/http/http-cache-3-20.png" alt="http-cache-public"></li>
</ol>
<blockquote>
<p>启用<code>Disable Cache</code>时，我们可以看到<strong>客户端/浏览器端</strong>自动带上了<code>Pragma&#39;:&#39;no-cache&#39;</code>、<code>&#39;Cache-Control&#39;: &#39;no-cache&#39;</code>这两个字段，不适用缓存。</p>
</blockquote>
<h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h3><p>修改<strong>app.js</strong>，通过<code>npm i crypto -D</code>安装<code>crypto</code>,用于生成<code>md5</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 处理 css 文件</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; request, response, path &#125; = ctx;</span><br><span class="line">    ctx.type = mime.getType(path);</span><br><span class="line">    response.set(<span class="string">'pragma'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ifNoneMatch = request.headers[<span class="string">'if-none-match'</span>];</span><br><span class="line">    <span class="keyword">const</span> imagePath = Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> hash = crypto.createHash(<span class="string">'md5'</span>);</span><br><span class="line">    <span class="keyword">const</span> imageBuffer = <span class="keyword">await</span> fs.readFile(imagePath);</span><br><span class="line">    hash.update(imageBuffer);</span><br><span class="line">    <span class="keyword">const</span> etag = <span class="string">`"<span class="subst">$&#123;hash.digest(<span class="string">'hex'</span>)&#125;</span>"`</span>;</span><br><span class="line">    <span class="keyword">if</span> (ifNoneMatch === etag) &#123;</span><br><span class="line">        response.status = <span class="number">304</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.set(<span class="string">'etag'</span>, etag);</span><br><span class="line">        ctx.body = imageBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="../../images/http/http-cache-3-20.png" alt="http-cache-public"></p>
<p>他的过程和<code>Last-Modified/If-Modified-Since</code>，但是因为<code>Last-Modified/If-Modified-Since</code>它不能监听<code>1s</code>以内的资源变化，所以一般用他来做<code>Etag/If-None-Match</code>的补充方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存大致分为：<code>强缓存</code>、<code>协商缓存</code>。</p>
<ul>
<li><code>强缓存</code>: <code>pragma</code>、<code>cache-control</code>、<code>expires</code></li>
<li><code>协商缓存</code>: <code>last-modified/If-modified-since</code>、<code>etag/if-none-match</code></li>
<li><code>强缓存优先级</code>: <code>cache-control &gt; pragma &gt; expires</code></li>
<li><code>协商缓存优先级</code>: <code>etag/if-none-match &gt; last-modified/If-modified-since</code></li>
</ul>
<p>缓存位置分为： <code>Service Worker</code>、<code>Memory Cache</code>、<code>Disk Cache</code>、<code>Push Cache</code>，也是从左到右如果命中就使用。</p>
<p>上面的实例只是比较简单的应用，其实还有很多有意思的实例能加深对缓存的理解，如下：</p>
<ul>
<li><code>pragma</code>、<code>cache-control</code>、<code>expires</code>优先级</li>
<li><code>last-modified/If-modified-since</code>、<code>etag/if-none-match</code>优先级</li>
<li><code>cache-control: no-cache</code>与<code>cache-control: max-age=0, must-revalidate</code>效果是否相同</li>
<li><code>chrome</code>、<code>firefox</code>、<code>ie</code>之间的缓存差别</li>
</ul>
<p>本篇文章有意避开<code>Service Worker</code>的详细介绍，因为会有单独的一篇文章来介绍<code>Service Worker</code>在真实应用的使用。</p>
<blockquote>
<p>在线代码，可以<strong>刷新页面（刷新内部页面）</strong>在<strong>控制台</strong>中查看当前效果</p>
</blockquote>
<iframe src="https://codesandbox.io/embed/agitated-rain-55pzk?fontsize=14" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="agitated-rain-55pzk" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDYxNTM0OQ==&amp;mid=2247484082&amp;idx=1&amp;sn=2efec72057f7fa448a6c0e258fd80370&amp;chksm=ebf9f568dc8e7c7e7d9e134b023c4cc71528caebd14153922bd8a753eb7330ec04289b4c89cc&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568210174017&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b&amp;key=87d0d2afc25bc11ed40773ae28d50dc35909a8612c034880c5d0f249e5ab7525f1e6476a825113b59ad0f71ae424aa90bc5ef63bd55775c844a86d0d7b64c96480f095a3072da752b723851f6685d76b&amp;ascene=1&amp;uin=MTY4MzM5MzY2Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=x2ObXwYE5mF5saSt6Ycrs%2FnJfxgIYByJ8YPenA%2Ft5rl%2FXcqc7s6LVGsTuEjoprxw" target="_blank" rel="noopener">一文搞懂浏览器缓存机制</a><br><a href="https://mp.weixin.qq.com/s/MYEXGtMxa3tj4H2-Wl378w" target="_blank" rel="noopener">关于 http 缓存，这些知识点你可能都不懂</a><br><a href="https://mp.weixin.qq.com/s/b_vo_epjycDsGvczU6ol3Q" target="_blank" rel="noopener">浏览器缓存策略</a><br><a href="https://zhuanlan.zhihu.com/p/44789005" target="_blank" rel="noopener">一文读懂前端缓存</a><br><a href="https://juejin.im/post/5d0f9585e51d4510926a7b68" target="_blank" rel="noopener">通过 koa2 服务器实践探究浏览器HTTP缓存机制</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 react的 setState 在不同情况下同步异步之间切换（未完待续）</title>
    <url>/blog/react/react-setState.html</url>
    <content><![CDATA[<h2 id="总结-setState-在不同环境中同步、异步不同"><a href="#总结-setState-在不同环境中同步、异步不同" class="headerlink" title="总结 setState 在不同环境中同步、异步不同"></a>总结 setState 在不同环境中同步、异步不同</h2><ol>
<li><font color="#ff502c">setState</font> 只在<font color="#ff502c">合成事件</font>和<font color="#ff502c">钩子函数</font>中是”异步”的,在<font color="#ff502c">原生事件</font>和<font color="#ff502c">setTimeout</font>中都是<font color="#ff502c">同步</font>的。</li>
<li><font color="#ff502c">setState</font>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的<font color="#ff502c">callback</font>拿到更新后的结果。</li>
<li><font color="#ff502c">setState</font> 的批量更新优化也是建立在<font color="#ff502c">“异步”（合成事件、钩子函数）</font>之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行<font color="#ff502c">多次 setState </font>， setState 的批量更新策略会对其进行<font color="#ff502c">覆盖</font>，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行<font color="#ff502c">合并批量更新</font>。</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>自己手动实现call、apply、bind this（三）</title>
    <url>/blog/javascript/js-call-apply-bind-polyfill.html</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li><font color="#ff502c">将函数设为对象的属性</font></li>
<li><font color="#ff502c">执行该函数</font></li>
<li><font color="#ff502c">删除该函数</font>

</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line">foo.fn = bar;</span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">foo.fn();</span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="keyword">delete</span> foo.fn;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol>
<li><font color="#ff502c">传入的参数并不确定</font></li>
<li><font color="#ff502c">this 参数可以传 null，当为 null 的时候，视为指向 window</font></li>
<li><font color="#ff502c">函数是可以有返回值的！</font>

</li>
</ol>
<h2 id="call-实现代码"><a href="#call-实现代码" class="headerlink" title="call 实现代码"></a>call 实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="comment">// arguments是类数组对象，遍历之前需要保存长度，过滤出第一个传参</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 避免object之类传入</span></span><br><span class="line">    args.push(<span class="string">"arguments["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">"context.fn("</span> + args + <span class="string">")"</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> aArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> oObj = &#123;</span><br><span class="line">  firstName: <span class="string">"joy"</span>,</span><br><span class="line">  lastName: <span class="string">"tony"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callArr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">callArr.call(aArr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calloObj</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">"firstName："</span> +</span><br><span class="line">    <span class="keyword">this</span>.firstName +</span><br><span class="line">    <span class="string">"/ lastName："</span> +</span><br><span class="line">    <span class="keyword">this</span>.lastName +</span><br><span class="line">    <span class="string">"/ age："</span> +</span><br><span class="line">    age</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">calloObj.call(oObj, <span class="number">25</span>); <span class="comment">// "firstName：joy/ lastName：tony/ age：25"</span></span><br></pre></td></tr></table></figure>
<h2 id="apply-实现代码"><a href="#apply-实现代码" class="headerlink" title="apply 实现代码"></a>apply 实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(<span class="string">"arr["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">"context.fn("</span> + args + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyArr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">applyArr.apply(aArr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyoObj</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">"firstName："</span> +</span><br><span class="line">    <span class="keyword">this</span>.firstName +</span><br><span class="line">    <span class="string">"/ lastName："</span> +</span><br><span class="line">    <span class="keyword">this</span>.lastName +</span><br><span class="line">    <span class="string">"/ age："</span> +</span><br><span class="line">    age</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">calloObj.call(oObj, [<span class="number">25</span>]); <span class="comment">// "firstName：joy/ lastName：tony/ age：25"</span></span><br></pre></td></tr></table></figure>
<h2 id="bind-实现-polyfill"><a href="#bind-实现-polyfill" class="headerlink" title="bind 实现 polyfill"></a>bind 实现 polyfill</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">        <span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">      fToBind = <span class="keyword">this</span>,</span><br><span class="line">      fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">      fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">        <span class="keyword">return</span> fToBind.apply(</span><br><span class="line">          <span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : oThis,</span><br><span class="line">          <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">          aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      <span class="comment">// Function.prototype doesn't have a prototype property</span></span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">    <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript对于继承的面试题 (未完成)</title>
    <url>/blog/InterviewQuestion/extends-javascript.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>InterviewQuestion</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个stringify、parse (未完成)</title>
    <url>/blog/InterviewQuestion/javascript-stringify-parse.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>InterviewQuestion</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中对于优先级的面试题 (未完成)</title>
    <url>/blog/InterviewQuestion/priority.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>InterviewQuestion</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Css怎么实现一个 高度随宽度变化 1:1 或者别的比例的布局</title>
    <url>/blog/InterviewQuestion/css-padding.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>一个网站的<code>logo</code>它的宽度是不固定的，并且要求它的高度与它的宽度相等也就是正方向，用<code>css</code>实现。<br>在以前的一篇文章中有记录<a href="/blog/css/css-padding.html">深入理解 css 系列 css 中 padding</a>，可以通过<code>padding</code>的百分比是<strong>规定基于父元素的宽度的百分比的内边距。</strong><br>也可以通过<code>vh、vw</code>实现</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="通过-padding-实现"><a href="#通过-padding-实现" class="headerlink" title="通过 padding 实现"></a>通过 padding 实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .header &#123;</span><br><span class="line">    wdith: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .header-logo &#123;</span><br><span class="line">    padding: 50%;</span><br><span class="line">    background-color: #000;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hedaer-logo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就可以创建一个宽高<code>1:1</code>的正方形，只需要修改<code>header</code>元素的宽度就可以动态修改<code>logo</code>元素的大小。</p>
<h3 id="通过-vh、vw-实现"><a href="#通过-vh、vw-实现" class="headerlink" title="通过 vh、vw 实现"></a>通过 vh、vw 实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .header-logo &#123;</span><br><span class="line">    width: 10vh; // 或者vw</span><br><span class="line">    height: 10vh; // 或者vw</span><br><span class="line">    background-color: #000;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hedaer-logo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把<code>logo</code>元素的宽高通过设置为<code>vh、vw</code>来实现他们的的宽度和高度值都来自与屏幕的<strong>宽或高</strong>。</p>
<h3 id="通过-rem-实现"><a href="#通过-rem-实现" class="headerlink" title="通过 rem 实现"></a>通过 rem 实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">font-size</span>=<span class="string">"12px"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .header-logo &#123;</span><br><span class="line">    width: 10rem;</span><br><span class="line">    height: 10rem;</span><br><span class="line">    background-color: #000;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hedaer-logo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过设置<code>html</code>元素上的<code>font-size: 12px</code>，<code>logo</code>元素的宽高通过rem控制为<code>10rem</code>也可以实现宽高<code>1:1</code>的元素。</p>
<h3 id="通过-js-实现"><a href="#通过-js-实现" class="headerlink" title="通过 js 实现"></a>通过 js 实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  /* header &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125; */</span><br><span class="line">  .header-logo &#123;</span><br><span class="line">    width: 20%;</span><br><span class="line">    background-color: #000;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">var dom = document.querySelector('.header-logo'),</span><br><span class="line">    nDomWidth = dom.clientWidth;</span><br><span class="line">    dom.style.height = nDomWidth + 'px';</span><br><span class="line"></span><br><span class="line">    window.onresize = function () &#123;</span><br><span class="line">        let nDomWidth = dom.clientWidth;</span><br><span class="line">        dom.style.height = nDomWidth + 'px';</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只设置<code>logo</code>元素的宽度，默认通过js获取<code>logo</code>元素的<strong>宽度</strong>赋值给<strong>高度</strong>，后面监听窗口变化适时更新高度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面一共通过<strong>四种方法</strong>来实现的宽高1:1，并且高度跟随宽度变化。其实上面四种解决方法比较相近，如果有更好的方法请留言探讨，谢谢。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="/blog/css/css-padding.html">深入理解 css 系列 css 中 padding</a></p>
</blockquote>
]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>InterviewQuestion</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 css中margin</title>
    <url>/blog/css/css-margin.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在平常开发过程中经常用到<strong>margin</strong>属性，但是也会遇到很多的问题，比如说<strong>margin重叠（BFC）</strong>、<strong>负margin</strong>等等问题，下面就一个一个来记录问什么会这样。</p>
<p><strong>标准盒模型</strong></p>
<p><img src="../../images/css/css-margin-1-1.png" alt="css margin"></p>
<p>要了解<strong>margin</strong>就要先了解<strong>css</strong>中的<strong>盒子模型（Box Model）</strong>，<strong>标准盒模型</strong>可以分为：外边距(margin)、边框（border）、内边距（padding）、内容区域（content）。在<strong>标准盒模型</strong>中平常所说道的高度只是<strong>content</strong>的高度，不包含<strong>border</strong>的高度，而在<strong>ie盒模型</strong>中是把<strong>border</strong>算在内的。</p>
<p><strong>margin属性</strong></p>
<p>margin有四个属性<strong>margin-top</strong>、<strong>margin-left</strong>、<strong>margin-bottom</strong>、<strong>margin-right</strong>，它们的值可以为<strong>百分比</strong>、<strong>数值（左右可为负数）</strong>、<strong>em、rem、vh、vw</strong>、<strong>auto</strong>等等。</p>
<h2 id="margin与容器尺寸"><a href="#margin与容器尺寸" class="headerlink" title="margin与容器尺寸"></a>margin与容器尺寸</h2><p>元素尺寸：①可视尺寸 clientWidth（标准）；②占据尺寸</p>
<p><img src="../../images/css/css-margin-1-2.png" alt="css margin"></p>
<p>margin与可视尺寸：<strong>①适用于没有设定width/height的普通block元素；②只适用于水平方向尺寸</strong><br>margin与占据尺寸：<strong>①block/inline-block水平元素均适用；②与有没有设定width/height无关；</strong></p>
<p>③适用于水平方向和垂直方向。可用于页面的上下留白（padding兼容性不好）。</p>
<h3 id="margin与可视尺寸"><a href="#margin与可视尺寸" class="headerlink" title="margin与可视尺寸"></a>margin与可视尺寸</h3><p>特性：</p>
<ul>
<li>适用于没有设定<code>width/height</code>的普通<code>block</code>元素</li>
<li><strong>只适用于水平方向尺寸</strong></li>
</ul>
<p>应用：一侧定宽自适应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"150px"</span> <span class="attr">style</span>=<span class="string">"float:left"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"margin-left:170px;"</span>&gt;</span>图片左浮动....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="../../images/css/css-margin-1-3.png" alt="css margin"></p>
<h3 id="margin与占据尺寸"><a href="#margin与占据尺寸" class="headerlink" title="margin与占据尺寸"></a>margin与占据尺寸</h3><p>特性：</p>
<ul>
<li><code>block、inline-block</code>水平元素均适应</li>
<li>与有没有设定<code>width、height</code>值无关</li>
<li>适应于水平方向和垂直方向</li>
</ul>
<h2 id="margin与百分比单位"><a href="#margin与百分比单位" class="headerlink" title="margin与百分比单位"></a>margin与百分比单位</h2><ul>
<li>普通元素的百分比：<strong>相对于容器宽度计算</strong>。</li>
<li>绝对定位元素的百分比：<strong>相对于第一个定位的祖先容器的宽度计算的</strong>。</li>
</ul>
<h2 id="margin中的重叠"><a href="#margin中的重叠" class="headerlink" title="margin中的重叠"></a>margin中的重叠</h2><h3 id="margin重叠通常特性"><a href="#margin重叠通常特性" class="headerlink" title="margin重叠通常特性"></a>margin重叠通常特性</h3><ol>
<li><code>block</code>水平元素（不包括<code>float</code>和<code>absolute</code>元素）</li>
<li>不考虑<code>writing-mode</code>，只发生垂直方向（<code>margin-top/margin-bottom</code>）</li>
</ol>
<h3 id="margin重叠的3种情景"><a href="#margin重叠的3种情景" class="headerlink" title="margin重叠的3种情景"></a>margin重叠的3种情景</h3><ol>
<li><strong>相邻的兄弟元素</strong></li>
<li><strong>父级和第一个/最后一个子元素</strong></li>
<li><strong>空的block元素</strong></li>
</ol>
<h3 id="父子margin重叠其他条件"><a href="#父子margin重叠其他条件" class="headerlink" title="父子margin重叠其他条件"></a>父子margin重叠其他条件</h3><p><strong>margin-top重叠</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">margin-top重叠</th>
<th style="text-align:center">解决</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">父元素<strong>非块状格式化上下文</strong>元素</td>
<td style="text-align:center">设置父元素<code>overflow</code>：<code>hidden</code></td>
</tr>
<tr>
<td style="text-align:center">父元素没有<code>border-top</code>设值</td>
<td style="text-align:center">设置父元素<code>border</code></td>
</tr>
<tr>
<td style="text-align:center">父元素没有<code>padding-top</code>值</td>
<td style="text-align:center">设置父元素<code>padding-top</code></td>
</tr>
<tr>
<td style="text-align:center">父元素和第一个子元素之间没有<code>inline</code>元素分隔</td>
<td style="text-align:center"><strong>插入一个内联元素如空格&bsp;</strong></td>
</tr>
</tbody>
</table>
<p><strong>margin-bottom重叠</strong></p>
<ol>
<li>父元素<strong>非块状格式化上下文</strong>元素</li>
<li>父元素没有<code>border-bottom</code>设置</li>
<li>父元素没有<code>padding-bottom</code>值</li>
<li>父元素和最后一个子元素之间没有<code>inline</code>元素分隔</li>
<li>父元素没有<code>height</code>相关声明</li>
</ol>
<h3 id="空block元素margin重叠"><a href="#空block元素margin重叠" class="headerlink" title="空block元素margin重叠"></a>空block元素margin重叠</h3><p>条件限制：</p>
<ol>
<li>元素没有<code>border</code>设置</li>
<li>元素没有<code>padding</code>值</li>
<li>里面没有<code>inline</code>元素</li>
<li>没有<code>height、或者min-height</code></li>
</ol>
<h3 id="重叠的计算规则"><a href="#重叠的计算规则" class="headerlink" title="重叠的计算规则"></a>重叠的计算规则</h3><ul>
<li><strong>正正取大值</strong></li>
<li><strong>正负值相加</strong></li>
<li><strong>负负最负值</strong></li>
</ul>
<h3 id="理解CSS中的margin-auto"><a href="#理解CSS中的margin-auto" class="headerlink" title="理解CSS中的margin:auto"></a>理解CSS中的margin:auto</h3><p><code>margin:auto</code>的作用机制：<strong>自动分配剩余空间</strong></p>
<h3 id="垂直居中方法-margin实现"><a href="#垂直居中方法-margin实现" class="headerlink" title="垂直居中方法(margin实现)"></a>垂直居中方法(margin实现)</h3><p><strong>writing-mode</strong></p>
<p>更改流为垂直方向，但是水平居中失效</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123; <span class="attribute">height</span>:<span class="number">200px</span>; <span class="attribute">width</span>:<span class="number">100%</span>; <span class="attribute">writing-mode</span>:vertical-lr; &#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123; <span class="attribute">height</span>:<span class="number">100px</span>; <span class="attribute">width</span>:<span class="number">500px</span>; <span class="attribute">margin</span>:auto; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/css/css-margin-1-4.png" alt="css margin"></p>
<p><strong>绝对定位元素的margin:auto居中</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123; <span class="attribute">height</span>:<span class="number">200px</span>; <span class="attribute">position</span>:relative; &#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123; <span class="attribute">position</span>:absolute; <span class="attribute">top</span>:<span class="number">0</span>; <span class="attribute">right</span>:<span class="number">0</span>; <span class="attribute">left</span>:<span class="number">0</span>; <span class="attribute">bottom</span>:<span class="number">0</span>; <span class="attribute">height</span>:<span class="number">100px</span>; <span class="attribute">width</span>:<span class="number">500px</span>; <span class="attribute">margin</span>:auto; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/css/css-margin-1-5.png" alt="css margin"></p>
<h2 id="margin负值"><a href="#margin负值" class="headerlink" title="margin负值"></a>margin负值</h2><p>为了方便理解负值<code>margin</code>，我们引入参考线的定义，参考线就是就是<code>margin</code>移动的基准点，而<code>margin</code>的值就是移动的数值。<br><code>margin</code>的参考线有两类，一类是<code>top、left</code>，它们以外元素作为参考线;<br>另一类是<code>right、bottom</code>，它们以自身作为参考线。<br>简单点说就是：</p>
<ul>
<li><code>top</code>负值就是以包含块<code>(Containing block)</code> 内容区域的上边或者上方相连元素 <code>margin</code> 的下边线为参考线;</li>
<li><code>left</code>负值就是以包含块<code>(Containing block)</code> 内容区域的左边或者左方相连元素 <code>margin</code> 的右边为参考线;</li>
<li><code>right</code>负值就是以元素本身<code>border</code>的右边为参考线；</li>
<li><code>bottom</code>负值就是以元素本身<code>border</code>的下边为参考线；</li>
</ul>
<p>另外关于包含块的定义具体<a href="http://w3help.org/zh-cn/kb/008/" target="_blank" rel="noopener">请参考KB008包含块(Containing block)</a>。</p>
<p><img src="../../images/css/css-margin-1-6.png" alt="css margin"></p>
<p><strong>公用代码</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">    height: 200px;</span><br><span class="line">    margin: auto;</span><br><span class="line">    border: 1px black solid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:orange</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:green</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="margin-top和margin-left负值"><a href="#margin-top和margin-left负值" class="headerlink" title="margin-top和margin-left负值"></a>margin-top和margin-left负值</h3><h4 id="margin-top"><a href="#margin-top" class="headerlink" title="margin-top"></a>margin-top</h4><p>修改css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="../../images/css/css-margin-1-7.png" alt="css margin"></p>
<p>当设置<code>.two</code>的<code>div</code>的<code>margin-top: -50px</code>的时候，它的参考线是<code>div.one</code>的下边，整个<code>div.two</code>向上移动<code>-50px</code>使得<code>div.two</code>覆盖<code>div.one</code>。</p>
<h4 id="margin-left"><a href="#margin-left" class="headerlink" title="margin-left"></a>margin-left</h4><p>修改css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="../../images/css/css-margin-1-8.png" alt="css margin"></p>
<p>当设置<code>.two</code>的<code>div</code>的<code>margin-left: -50px</code>的时候，它的参考线是<code>div.one</code>的右边线，整个<code>div.two</code>向左移动<code>-50px</code>使的<code>div.two</code>覆盖<code>div.one</code>。</p>
<h3 id="margin-right和margin-bottom负值"><a href="#margin-right和margin-bottom负值" class="headerlink" title="margin-right和margin-bottom负值"></a>margin-right和margin-bottom负值</h3><h4 id="margin-right"><a href="#margin-right" class="headerlink" title="margin-right"></a>margin-right</h4><p>修改css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="../../images/css/css-margin-1-8.png" alt="css margin"></p>
<p>当设置<code>.one</code>的<code>div</code>的<code>margin-right: -50px</code>的时候，它的参考线是<code>div.one</code>的右边线，整个<code>div.one</code>向左收缩<code>-50px</code>使的<code>div.two</code>覆盖<code>div.one</code>。</p>
<h4 id="margin-bottom"><a href="#margin-bottom" class="headerlink" title="margin-bottom"></a>margin-bottom</h4><p>修改css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: static;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="../../images/css/css-margin-1-7.png" alt="css margin"></p>
<p>当设置<code>.one</code>的<code>div</code>的<code>margin-bottom: -50px</code>的时候，它的参考线是<code>div.one</code>的下边线，整个<code>div.one</code>向上收缩<code>-50px</code>使的<code>div.two</code>覆盖<code>div.one</code>。</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p><strong>margin负值下的两端对齐：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 1200px;</span><br><span class="line">    margin: auto;</span><br><span class="line">    background: orange;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.ul</span> &#123;</span></span><br><span class="line">    list-style: none;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    margin-right: -20px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.li</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span>: 386<span class="selector-class">.66px</span>;</span></span><br><span class="line">    height: 300px;</span><br><span class="line">    margin-right: 20px;</span><br><span class="line">    background: green;</span><br><span class="line">    float: left;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li"</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li"</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li"</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="../../images/css/css-margin-1-9.png" alt="css margin"></p>
<p><strong>margin负值下的等高布局：</strong></p>
<p><img src="../../images/css/css-margin-1-10.png" alt="css margin"></p>
<p><strong>margin负值下的两栏自适应布局：</strong></p>
<p><img src="../../images/css/css-margin-1-11.png" alt="css margin"></p>
<h2 id="margin无效情形解析"><a href="#margin无效情形解析" class="headerlink" title="margin无效情形解析"></a>margin无效情形解析</h2><ol>
<li><p><code>inline</code>水平元素的垂直<code>margin</code>无效前提：</p>
<ul>
<li>非替换元素，例如不是<code>&lt;img&gt;</code>元素；</li>
<li>正常书写模式。</li>
</ul>
</li>
<li><p><code>margin</code>重叠</p>
</li>
<li><code>display:table-cell</code>与<code>margin：display:table-cell/display:table-row</code>等声明的<code>margin</code>无效。</li>
<li><code>position:absolute</code>与<code>margin</code>：绝对定位元素未设置定位方向的<code>margin</code>值”无效“。例如，<code>img{top:10%}</code>的<code>margin-top</code>有效其他均无效。</li>
<li>内联特性导致的<code>margin</code>无效：</li>
</ol>
<h2 id="了解margin-start-margin-end属"><a href="#了解margin-start-margin-end属" class="headerlink" title="了解margin-start/margin-end属"></a>了解margin-start/margin-end属</h2><h3 id="webkit-margin-start、-webkit-margin-end"><a href="#webkit-margin-start、-webkit-margin-end" class="headerlink" title="-webkit-margin-start、-webkit-margin-end"></a>-webkit-margin-start、-webkit-margin-end</h3><ul>
<li>正常的流向，<code>margin-start</code>等同于<code>margin-left</code>，两者重叠不累加</li>
<li>如果水平流是从右往左，<code>margin-start</code>等同于<code>margin-right</code></li>
<li>在垂直流下（<code>writing-mode:vertical-*;</code>）,<code>margin-start</code>等同于<code>margin-top</code></li>
</ul>
<h3 id="margin-collaps"><a href="#margin-collaps" class="headerlink" title="margin-collaps"></a>margin-collaps</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">-webkit-margin-collaps: &lt;collaps&gt; | &lt;discard&gt; | &lt;separate&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>collaps</code>,默认，重叠</li>
<li><code>discard</code>，取消重叠，使<code>margin</code>无效</li>
<li><code>separate</code>，取消重叠，不合并</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇文章中介绍主要的<code>margin百分比</code>、<code>margin重叠条件</code>、<code>margin在盒模型中的区域</code>，但是本文总结的<code>margin负值</code>并不是全部情况，比如说<code>div.two</code>设置为<code>margin-right: -50px</code>为什么不会收缩自己的宽度等等。希望大家多多做补充。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.imooc.com/learn/565" target="_blank" rel="noopener">CSS深入理解之relative</a><br><a href="https://www.kancloud.cn/dunizb/web-dev-marrow/647633#11_margin_2" target="_blank" rel="noopener">CSS深入理解之margin</a><br><a href="https://cloud.tencent.com/developer/article/1053594" target="_blank" rel="noopener">CSS深入理解学习笔记之margin</a><br><a href="https://zhuanlan.zhihu.com/p/25892372" target="_blank" rel="noopener">浅谈margin负值</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列 css中relative</title>
    <url>/blog/css/css-relative.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>relative</code>其实是<code>position</code>中的一个属性，<code>positon</code>有五个属性分别为<code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>、<code>sticky</code>，分别代表不同的定位类型。大致分为下面四种：</p>
<p><strong>定位类型</strong></p>
<ul>
<li><strong>定位元素（positioned element）</strong>是其计算后位置属性为 <code>relative</code>, <code>absolute</code>, <code>fixed</code> 或 <code>sticky</code> 的一个元素。</li>
<li><strong>相对定位元素（relatively positioned element）</strong>是计算后位置属性为 <code>relative</code> 的元素。</li>
<li><strong>绝对定位元素（absolutely positioned element）</strong>是计算后位置属性为 <code>absolute</code> 或 <code>fixed</code> 的元素。</li>
<li><strong>粘性定位元素（stickily positioned element）</strong>是计算后位置属性为 <code>sticky</code> 的元素。</li>
</ul>
<p><strong><code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>、<code>sticky</code>取值</strong></p>
<p><strong>static</strong></p>
<p>该关键字指定元素使用正常的布局行为，即元素在文档<strong>常规流</strong>中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code> 属性无效。</p>
<p><strong>relative</strong></p>
<p>该关键字下，元素先放置在未添加定位时的位置，再在<strong>不改变</strong>页面布局的前提下<strong>调整元素</strong>位置（因此会在此元素未添加定位时所在位置留下空白）。<code>position:relative</code> 对 <code>table-*-group</code>, <code>table-row</code>, <code>table-column</code>, <code>table-cell</code>, <code>table-caption</code> 元素无效。</p>
<p><strong>absolute</strong></p>
<p>不为元素预留空间，通过指定<strong>元素相对于最近的非 static 定位祖先元素的偏移</strong>，来确定元素位置。绝对定位的元素可以设置外边距（margins），<strong>且不会与其他边距合并</strong>。</p>
<p><strong>fixed</strong></p>
<p>不为元素预留空间，而是通过指定元素<strong>相对于屏幕视口（viewport）的位置来指定元素位置</strong>。<strong>元素的位置在屏幕滚动时不会改变</strong>。打印时，元素会出现在的每页的固定位置。<strong>fixed 属性会创建新的层叠上下文。当元素祖先的 transform  属性非 none 时，容器由视口改为该祖先</strong>。</p>
<p><strong>sticky（实验属性）</strong></p>
<p>盒位置根据正常流计算(这称为正常流动中的位置)，然后<strong>相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位</strong>。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<strong>position: sticky 对 table 元素的效果与 position: relative 相同</strong>。</p>
<p><strong>语法</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">postion: static | relative | absolute | sticky | fixed;</span><br></pre></td></tr></table></figure>
<h2 id="relative的特性"><a href="#relative的特性" class="headerlink" title="relative的特性"></a>relative的特性</h2><p>在上面看到<strong>MDN</strong>对<code>relative</code>的定位的一下描述，但是并没有描述的比较通俗，通过下面的实例总结一下<code>relative</code>的特性。</p>
<p><strong>公用代码</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.one</span> &#123;</span></span><br><span class="line">    background: orange;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.two</span> &#123;</span></span><br><span class="line">    background: purple;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="relative是相对于定位"><a href="#relative是相对于定位" class="headerlink" title="relative是相对于定位"></a>relative是相对于定位</h3><p>直接上代码，修改代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="../../images/css/css-relative-1-1.png" alt="css margin"></p>
<p>把<code>div.one</code>设置<code>position: relative</code>时，并且设置<code>top: 50px</code>时，可以看到<code>div.one</code>的元素相对于自身在正常流中的位置向下移动了<code>50px</code>，它挡住了一半的<code>div.two</code>元素。<br><code>relative</code>的四个定位值<code>top</code>、<code>left</code>、<code>bottom</code>、<code>right</code>是相对自身移动的。</p>
<blockquote>
<p><strong>如果设置了对立属性top/bottom、left/right的相对定位元素，它的top/left生效，right/bottom无效。</strong></p>
</blockquote>
<h3 id="relative不改变布局"><a href="#relative不改变布局" class="headerlink" title="relative不改变布局"></a>relative不改变布局</h3><p><code>margin-top: 负值</code>修改代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行效果如下：<br><img src="../../images/css/css-relative-1-2.png" alt="css margin"></p>
<p>可以看到<code>div.one</code>设置<code>margin-top: -50px;</code>时，它会影响到它相邻的兄弟元素<code>div.two</code>的位置，<code>div.one/div.two</code>都相对于原来的位置<strong>向上</strong>移动了<code>50px</code>。</p>
<p><code>top: -50px;</code>修改代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行效果如下：<br><img src="../../images/css/css-relative-1-3.png" alt="css margin"></p>
<p>可以看到<code>div.one</code>设置<code>postion: relative; top: -50px;</code>时，它不会影响到它相邻的兄弟元素<code>div.two</code>的位置，<code>div.one</code>都相对于原来的位置<strong>向上</strong>移动了<code>50px</code>，而<code>div.two</code>的位置是不变的。</p>
<ul>
<li><code>relative</code>是相对于自身定位的。</li>
<li><code>relative</code>是不会改变布局的</li>
</ul>
<h2 id="relative的限制作用"><a href="#relative的限制作用" class="headerlink" title="relative的限制作用"></a>relative的限制作用</h2><h3 id="relative对absolute的限制作用"><a href="#relative对absolute的限制作用" class="headerlink" title="relative对absolute的限制作用"></a>relative对absolute的限制作用</h3><p><code>absolute</code>定位的是其<strong>第一个祖先元素定位属性不为static属性</strong>。这个就不多赘述，基本上都在用这种布局。<br>如果设置<code>postion: absolute;</code>元素的父元素没有设置<code>position: relative;</code>，那么设置<code>position: absolute;</code>元素的绝对定位就会最外层的<strong>根元</strong>素定位。</p>
<h3 id="relative对overflow的限制作用"><a href="#relative对overflow的限制作用" class="headerlink" title="relative对overflow的限制作用"></a>relative对overflow的限制作用</h3><p>其实这个也比较常用但是一般不会太注意<code>relative</code>对<code>overflow</code>的影响。</p>
<p><strong>父元素不添加relative</strong></p>
<p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div class="two"&gt;two&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div class="two"&gt;two&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改<strong>css</strong>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下过显示如下图所示：</p>
<p><img src="../../images/css/css-relative-1-4.png" alt="css margin"></p>
<p>可以看到第一个<code>div.box</code>没有设置<code>position: relative;</code>时，子元素设置<code>position: absoulte;</code>时，并且子元素的宽度高度大于父元素的宽度高度时，它会超出父元素的范围。<br>第二个<code>div.box</code>设置了<code>position: relative;</code>时，子元素设置不会超出父元素的宽高范围。</p>
<h3 id="relative对层级z-index的限制作用"><a href="#relative对层级z-index的限制作用" class="headerlink" title="relative对层级z-index的限制作用"></a>relative对层级z-index的限制作用</h3><p>对于一个已经定位的元素（即<code>position</code>属性值不是<code>static</code>的元素），<code>z-index</code> 属性指定：</p>
<ul>
<li>元素在当前堆叠上下文中的堆叠层级。</li>
<li>元素是否创建一个新的本地堆叠上下文。</li>
</ul>
<p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改<strong>css</strong>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background</span>: purple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="../../images/css/css-relative-1-5.png" alt="css margin"></p>
<p>在下面的第一幅图中，设置了<code>margin</code>负值，虽然同时设置了<code>z-index</code>为数值，但是后面的元素依然覆盖了前面的元素，而当增加了定位属性<code>position: relative</code>后，创建了层叠上下文，前面元素的层叠顺序高，虽然同时设置了<code>margin</code>负值，但是后面的元素依然覆盖不了前面的元素。</p>
<h2 id="相对定位relative的使用原则-最小化"><a href="#相对定位relative的使用原则-最小化" class="headerlink" title="相对定位relative的使用原则-最小化"></a>相对定位relative的使用原则-最小化</h2><p>虽然<code>relative</code>定位很好用，并且使用的频率很高，但是根据张鑫旭大神总结的布局实践原则，最好基于以下原则为好：</p>
<ul>
<li>尽量避免使用<code>relative</code>，如果要定位某些元素，看能否使用”无依赖的绝对定位”实现；</li>
<li>如果使用场景受限，一定要使用<code>relative</code>，则务必使<code>relative</code>最小化。</li>
</ul>
<p>比如，我们想在某个模块的右上角定位一个图标，如果让你去布局实现的话，你该如何布局呢？十有八九会如下面的方式实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"icon.png"</span> <span class="attr">style</span>=<span class="string">"position: absolute;top:0;right:0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，我们可以采用”relative的最小化使用原则”的方式实现，其代码如下面的方式实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"icon.png"</span> <span class="attr">style</span>=<span class="string">"position: absolute;top:0;right:0"</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>position: relative;</code>其实它的特殊性比较少，但是最后的规则尽量要遵循，就是<strong>relative的最小化使用原则</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.imooc.com/learn/565" target="_blank" rel="noopener">CSS深入理解之relative</a><br><a href="https://juejin.im/entry/5b15fdb05188251371242963" target="_blank" rel="noopener">CSS深入理解之relative定位</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">position</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index" target="_blank" rel="noopener">z-index</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>关于this的面试级分析（二） (未完成)</title>
    <url>/blog/InterviewQuestion/this-priority-1.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>call、apply谁的速度更快</li>
<li>隐式绑定、显示绑定、new、箭头函数那个的优先级更高</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于this的面试级分析（一） (未完成)</title>
    <url>/blog/InterviewQuestion/this-priority.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>call、apply谁的速度更快</li>
<li>隐式绑定、显示绑定、new、箭头函数那个的优先级更高</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（五）this的面试题 (未完成)</title>
    <url>/blog/javascript/javascript-this-five.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（四）this的面试题 (未完成)</title>
    <url>/blog/javascript/javascript-this-four.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（三）this的绑定优先级 (未完成)</title>
    <url>/blog/javascript/javascript-this-three.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（二）this的绑定 (未完成)</title>
    <url>/blog/javascript/javascript-this-two.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（一）this的产生 (未完成)</title>
    <url>/blog/javascript/javascript-this-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （六）闭包面试题 (未完成)</title>
    <url>/blog/javascript/javascript-clouser-three.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （五）作用域面试题  (未完成)</title>
    <url>/blog/javascript/javascript-scope-three.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （四）闭包的作用 (未完成)</title>
    <url>/blog/javascript/javascript-clouser-two.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （三）理解闭包 (未完成)</title>
    <url>/blog/javascript/javascript-clouser-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （二）理解作用域链 (未完成)</title>
    <url>/blog/javascript/javascript-scope-two.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （一）理解作用域 (未完成)</title>
    <url>/blog/javascript/javascript-scope-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 配置前端 字段 gzip</title>
    <url>/blog/other/nginx-gzip.html</url>
    <content><![CDATA[<h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p>windows 直接从<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">nginx 官网</a>下载即可</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行nginx 在nginx安装目录运行nginx.exe</span></span><br><span class="line"><span class="comment"># 打开cmd</span></span><br><span class="line">nginx.exe start</span><br><span class="line"><span class="comment"># 打开conf/nginx.conf添加下面几行</span></span><br><span class="line"><span class="comment"># gzip  on;</span></span><br><span class="line"><span class="comment"># gzip_comp_level 1;</span></span><br><span class="line"><span class="comment"># gzip_min_length 256;</span></span><br><span class="line"><span class="comment"># gzip_types text/plain text/css application/json application/javascript text/javascript;</span></span><br><span class="line">nginx.exe -s reload</span><br></pre></td></tr></table></figure>
<p>就可以在 localhost:8080 中打开 network 查看 js、css 已经压缩</p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli结合jekins配置 实现自动部署，持续化集成</title>
    <url>/blog/vue/vue-cli-jenkins.html</url>
    <content><![CDATA[<h1 id="vue-cli-配置"><a href="#vue-cli-配置" class="headerlink" title="vue-cli 配置"></a>vue-cli 配置</h1><p><a href="https://github.com/Braveheartforyou/vue-cli-jenkins" target="_blank" rel="noopener">项目源码</a><br><a href>nginx配置gzip传输</a></p>
<h2 id="source-map、devtool、gzip"><a href="#source-map、devtool、gzip" class="headerlink" title="source-map、devtool、gzip"></a>source-map、devtool、gzip</h2><p>vue-cli 已经配置了一部分优化的，如关闭 <font color="#ff502c">source-map</font>、<font color="#ff502c">devtool</font>,<font color="#ff502c">开启gzip</font> 打包压缩，虽然打包时间变长但是，在配置好服务器的话，用户访问时间会很快 <font color="#ff502c">config/index.js</font> 如下<br><img src="../../images/vue_build/jenkins_vue_cli6.png" alt="vue-cli config"><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  build: &#123;</span><br><span class="line">  <span class="comment">// Template for index.html</span></span><br><span class="line">  index: path.resolve(__dirname, <span class="string">'../dist/index.html'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Paths</span></span><br><span class="line">  assetsRoot: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">  assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">  assetsPublicPath: <span class="string">'./'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Source Maps</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// https://webpack.js.org/configuration/devtool/#production</span></span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gzip off by default as many popular static hosts such as</span></span><br><span class="line">  <span class="comment">// Surge or Netlify already gzip all static assets for you.</span></span><br><span class="line">  <span class="comment">// Before setting to `true`, make sure to:</span></span><br><span class="line">  <span class="comment">// npm install --save-dev compression-webpack-plugin</span></span><br><span class="line">  productionGzip: <span class="literal">true</span>,</span><br><span class="line">  productionGzipExtensions: [<span class="string">'js'</span>, <span class="string">'css'</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the build command with an extra argument to</span></span><br><span class="line">  <span class="comment">// View the bundle analyzer report after build finishes:</span></span><br><span class="line">  <span class="comment">// `npm run build --report`</span></span><br><span class="line">  <span class="comment">// Set to `true` or `false` to always turn it on or off</span></span><br><span class="line">  bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="抽取公用包"><a href="#抽取公用包" class="headerlink" title="抽取公用包"></a><a href="http://asyncnode.com/blog/vue-build-dll.html">抽取公用包</a></h2><h2 id="懒加载-按模块打包"><a href="#懒加载-按模块打包" class="headerlink" title="懒加载 按模块打包"></a><a href="http://asyncnode.com/blog/vue-build-dll.html">懒加载 按模块打包</a></h2><h2 id="service-worker-这个必须要在https下才支持"><a href="#service-worker-这个必须要在https下才支持" class="headerlink" title="service-worker (这个必须要在https下才支持)"></a>service-worker (这个必须要在https下才支持)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 sw-precache-webpack-plugin</span></span><br><span class="line">yarn add sw-precache-webpack-plugin --save</span><br></pre></td></tr></table></figure>
<p>在<font color="#ff502c">webpack.prod.conf.js</font><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SWPrecacheWebpackPlugin = <span class="built_in">require</span>(<span class="string">'sw-precache-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//在 plugins 数组中写入</span></span><br><span class="line"><span class="comment">// Generate a service worker script that will precache, and keep up to date,</span></span><br><span class="line"><span class="comment">// the HTML &amp; assets that are part of the Webpack build.</span></span><br><span class="line"><span class="keyword">new</span> SWPrecacheWebpackPlugin(&#123;</span><br><span class="line">    <span class="comment">// By default, a cache-busting query parameter is appended to requests</span></span><br><span class="line">    <span class="comment">// used to populate the caches, to ensure the responses are fresh.</span></span><br><span class="line">    <span class="comment">// If a URL is already hashed by Webpack, then there is no concern</span></span><br><span class="line">    <span class="comment">// about it being stale, and the cache-busting can be skipped.</span></span><br><span class="line">    dontCacheBustUrlsMatching: <span class="regexp">/\.\w&#123;8&#125;\./</span>,</span><br><span class="line">    filename: <span class="string">'service-worker.js'</span>,</span><br><span class="line">    logger(message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message.indexOf(<span class="string">'Total precache size is'</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This message occurs for every build and is a bit too noisy.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (message.indexOf(<span class="string">'Skipping static resource'</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This message obscures real errors so we ignore it.</span></span><br><span class="line">        <span class="comment">// https://github.com/facebookincubator/create-react-app/issues/2612</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;,</span><br><span class="line">    minify: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// For unknown URLs, fallback to the index page</span></span><br><span class="line">    navigateFallback: <span class="string">'./'</span> + <span class="string">'/index.html'</span>,</span><br><span class="line">    <span class="comment">// Ignores URLs starting from /__ (useful for Firebase):</span></span><br><span class="line">    <span class="comment">// https://github.com/facebookincubator/create-react-app/issues/2237#issuecomment-302693219</span></span><br><span class="line">    navigateFallbackWhitelist: [<span class="regexp">/^(?!\/__).*/</span>],</span><br><span class="line">    <span class="comment">// Don't precache sourcemaps (they're large) and build asset manifest:</span></span><br><span class="line">    staticFileGlobsIgnorePatterns: [<span class="regexp">/\.map$/</span>, /asset-manifest\.json$/],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>在<font color="#ff502c">src文件夹</font>中新建一个文件叫做<font color="#ff502c">registerServiceWorker.js</font>的文件写入<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In production, we register a service worker to serve assets from local cache.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This lets the app load faster on subsequent visits in production, and gives</span></span><br><span class="line"><span class="comment">// it offline capabilities. However, it also means that developers (and users)</span></span><br><span class="line"><span class="comment">// will only see deployed updates on the "N+1" visit to a page, since previously</span></span><br><span class="line"><span class="comment">// cached resources are updated in the background.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.</span></span><br><span class="line"><span class="comment">// This link also includes instructions on opting out of this behavior.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isLocalhost = <span class="built_in">Boolean</span>(</span><br><span class="line">  <span class="built_in">window</span>.location.hostname === <span class="string">'localhost'</span> ||</span><br><span class="line">    <span class="comment">// [::1] is the IPv6 localhost address.</span></span><br><span class="line">    <span class="built_in">window</span>.location.hostname === <span class="string">'[::1]'</span> ||</span><br><span class="line">    <span class="comment">// 127.0.0.1/8 is considered localhost for IPv4.</span></span><br><span class="line">    <span class="built_in">window</span>.location.hostname.match(</span><br><span class="line">      /^<span class="number">127</span>(?:\.(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?))&#123;<span class="number">3</span>&#125;$/</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span> &amp;&amp; <span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="comment">// The URL constructor is available in all browsers that support SW.</span></span><br><span class="line">    <span class="keyword">const</span> publicUrl = <span class="keyword">new</span> URL(<span class="string">'./'</span>, <span class="built_in">window</span>.location);</span><br><span class="line">    <span class="keyword">if</span> (publicUrl.origin !== <span class="built_in">window</span>.location.origin) &#123;</span><br><span class="line">      <span class="comment">// Our service worker won't work if PUBLIC_URL is on a different origin</span></span><br><span class="line">      <span class="comment">// from what our page is served on. This might happen if a CDN is used to</span></span><br><span class="line">      <span class="comment">// serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> swUrl = <span class="string">`<span class="subst">$&#123;<span class="string">'./'</span>&#125;</span>service-worker.js`</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isLocalhost) &#123;</span><br><span class="line">        <span class="comment">// This is running on localhost. Lets check if a service worker still exists or not.</span></span><br><span class="line">        checkValidServiceWorker(swUrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add some additional logging to localhost, pointing developers to the</span></span><br><span class="line">        <span class="comment">// service worker/PWA documentation.</span></span><br><span class="line">        navigator.serviceWorker.ready.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">'This web app is being served cache-first by a service '</span> +</span><br><span class="line">              <span class="string">'worker. To learn more, visit https://goo.gl/SC7cgQ'</span></span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Is not local host. Just register service worker</span></span><br><span class="line">        registerValidSW(swUrl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerValidSW</span>(<span class="params">swUrl</span>) </span>&#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(swUrl)</span><br><span class="line">    .then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">      registration.onupdatefound = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> installingWorker = registration.installing;</span><br><span class="line">        installingWorker.onstatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (installingWorker.state === <span class="string">'installed'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (navigator.serviceWorker.controller) &#123;</span><br><span class="line">              <span class="comment">// At this point, the old content will have been purged and</span></span><br><span class="line">              <span class="comment">// the fresh content will have been added to the cache.</span></span><br><span class="line">              <span class="comment">// It's the perfect time to display a "New content is</span></span><br><span class="line">              <span class="comment">// available; please refresh." message in your web app.</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'New content is available; please refresh.'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// At this point, everything has been precached.</span></span><br><span class="line">              <span class="comment">// It's the perfect time to display a</span></span><br><span class="line">              <span class="comment">// "Content is cached for offline use." message.</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'Content is cached for offline use.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Error during service worker registration:'</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkValidServiceWorker</span>(<span class="params">swUrl</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check if the service worker can be found. If it can't reload the page.</span></span><br><span class="line">  fetch(swUrl)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Ensure service worker exists, and that we really are getting a JS file.</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        response.status === <span class="number">404</span> ||</span><br><span class="line">        response.headers.get(<span class="string">'content-type'</span>).indexOf(<span class="string">'javascript'</span>) === <span class="number">-1</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// No service worker found. Probably a different app. Reload the page.</span></span><br><span class="line">        navigator.serviceWorker.ready.then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">          registration.unregister().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Service worker found. Proceed as normal.</span></span><br><span class="line">        registerValidSW(swUrl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">'No internet connection found. App is running in offline mode.'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.ready.then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">      registration.unregister();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins配置前端不同环境打包不同的文件</title>
    <url>/blog/other/jenkins-fornt.html</url>
    <content><![CDATA[<h2 id="vue-cli-配置"><a href="#vue-cli-配置" class="headerlink" title="vue-cli 配置"></a>vue-cli 配置</h2><p>vue-cli <font color="#ff502c">2.x</font>版本，因为自己不太习惯 3.x 的这种配置，很多配置不容易写进去，同时 3.x 也在不断的修 bug,所以没有升级.<br>最新代码在<a href="https://github.com/Braveheartforyou/vue-cli-jenkins.git" target="_blank" rel="noopener">github</a>，这个项目基本上是一些打包优化，缓存，等等并不是后台模版，你可以在这个项目上再搭建自己的东西，直接只是提供了一个项目比较基础的一些东西。</p>
<h2 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h2><p>在<font color="#ff502c">package.json</font>文件中的<font color="#ff502c">scripts</font>添加三个字段:</p>
<ul>
<li>“build:sit”: “cross-env API_ROOT=sit node build/build.js”,</li>
<li>“build:uat”: “cross-env API_ROOT=uat node build/build.js”,</li>
<li>“build:prod”: “cross-env API_ROOT=prod node build/build.js”</li>
</ul>
<p>其中<font color="#ff502c">cross-env</font>包是为了兼容 liunx 和 window 不同系统都可以把 <font color="green">API_ROOT</font>参数传进进程中.<br><img src="../../images/vue_build/jenkins_vue_cli.png" alt="jenkins_vue_cli"><br>然后配置<font color="#ff502c">config</font>文件夹下的<font color="green">dev.env.js、prod.env.js</font></p>
<h3 id="dev-env-js"><a href="#dev-env-js" class="headerlink" title="dev.env.js"></a>dev.env.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">"webpack-merge"</span>);</span><br><span class="line"><span class="keyword">const</span> prodEnv = <span class="built_in">require</span>(<span class="string">"./prod.env"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断环境 运行不同的api</span></span><br><span class="line"><span class="comment"> * 登录地址切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (process.env.API_ROOT) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"sit"</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = merge(prodEnv, &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"development"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://localhost:3800/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://localhost:3800/public_api"'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="prod-env-js"><a href="#prod-env-js" class="headerlink" title="prod.env.js"></a>prod.env.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前环境 打包不同的 api地址  login地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (process.env.API_ROOT) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"sit"</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://localhost:3800/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-sit.com/api"'</span>,</span><br><span class="line">      version: <span class="string">"v1.0.0"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"uat"</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://youapi-uat.com/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-uat.com/api"'</span>,</span><br><span class="line">      version: <span class="string">"v1.0.0"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"prod"</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://youapi-prod.com/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-prod.com/api"'</span>,</span><br><span class="line">      version: <span class="string">"v1.0.0"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后也是最重要的也就是我们要有一个统一的调用地址，如果不是统一的一个，那就多声明几个模块如<font color="#ff502c">PAYMENT、PRODUCT</font>等来区分不同环境的不同后台接口<br><img src="../../images/vue_build/jenkins_vue_cli2.png" alt="jenkins_vue_cli2"></p>
<h1 id="jenkins-配置"><a href="#jenkins-配置" class="headerlink" title="jenkins 配置"></a>jenkins 配置</h1><ul>
<li>新建一个 构建一个自由风格的软件项目</li>
<li>配置》源码管理》Git(git 地址和 ssh 帐号密码、拉去代码的分支)<br><img src="../../images/vue_build/jenkins_vue_cli3.png" alt="jenkins_vue_cli3"></li>
<li>锁定编译环境 node 版本为 8.9.3 或者别的<br><img src="../../images/vue_build/jenkins_vue_cli4.png" alt="jenkins_vue_cli4"></li>
<li>jenkins 前端的构建脚本<br><img src="../../images/vue_build/jenkins_vue_cli5.png" alt="jenkins_vue_cli5"><br>这个只是最简单的打包发送到对应的服务器，其实你在这个时候还可以做很多其他的事，如运行单元测试、sonar 平台质量检测、备份等等</li>
</ul>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>函数编程系列 ———— 简介函数式编程中的一些概念 (未完成)</title>
    <url>/blog/funcitonal/functional-introduction.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Funcitonal</tag>
      </tags>
  </entry>
  <entry>
    <title>函数编程系列 ———— 函数柯里化 (未完成)</title>
    <url>/blog/funcitonal/functional-currying.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Funcitonal</tag>
      </tags>
  </entry>
  <entry>
    <title>react中redux的使用简介 (未完成)</title>
    <url>/blog/react/react-redux.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单的Redux (未完成)</title>
    <url>/blog/react/react-redux1.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单的react-redux (未完成)</title>
    <url>/blog/react/react-redux2.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的context应用场景和使用方法 (未完成)</title>
    <url>/blog/react/react-context.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的renderProps的使用 (未完成)</title>
    <url>/blog/react/react-render-props.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的使用immutable作用和如何优化项目 (未完成)</title>
    <url>/blog/react/react-immutable.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理 （二）html中的css、javascript、dom之间的解析和相互阻塞关系</title>
    <url>/blog/html/html-style-javascript.html</url>
    <content><![CDATA[<p><strong><em>将欲取之，必先与之，是谓微明。柔弱胜刚强。——老子</em></strong></p>
<blockquote>
<p><a href="/blog/html/html-browser-render.html">浏览器渲染原理 （一）在网址中输入一个网站后面都做了什么</a><br><a href="/blog/html/html-style-javascript.html">浏览器渲染原理 （二）css、javascript、dom 阻塞关系</a><br><a href="/blog/html/html-reload-reflow.html">浏览器渲染原理 （三） repaint(重绘)和 reflow(回流)详解</a></p>
</blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><hr>
<p>我们在看一些前端优化规则的时候，比如雅虎军规等等，都有看到 style 写在 head 中，但是外链 script 写在 body 的最后，以优化性能，都知道应该怎么做，但是不知道其中的原理。<br>如果还不知道浏览器渲染的原理的，看一看<a href="/blog/html/html-style-javascript.html">浏览器渲染原理</a>这一篇文章。其实这个就是考验大家对 html 中的 css、javascript、dom 之间的解析和相互阻塞关系。</p>
<h2 id="JavaScript-会阻塞-CSS、DOM-吗"><a href="#JavaScript-会阻塞-CSS、DOM-吗" class="headerlink" title="JavaScript 会阻塞 CSS、DOM 吗"></a>JavaScript 会阻塞 CSS、DOM 吗</h2><h3 id="提出自己观点"><a href="#提出自己观点" class="headerlink" title="提出自己观点"></a>提出自己观点</h3><p>当我们把 script 标签写到页面的顶部时，dom 树在解析的时候检测到 script 标签是，会加载 script 里面的内容并且执行。我们假设在<font color="#ff502c">执行</font>javascript 会<font color="#ff502c">阻塞 dom</font>的解析和渲染，<font color="#ff502c">阻塞 css</font>的解析和加载。</p>
<h3 id="验证自己的观点"><a href="#验证自己的观点" class="headerlink" title="验证自己的观点"></a>验证自己的观点</h3><p>在验证之前我们先把 chrome 的网速调到 40kb 每秒的下载和上传数据<br><strong>第一步</strong><br><img src="../../images/html/images/html-1.png" alt="html operation"><br><strong>第二步</strong><br><img src="../../images/html/images/html-2.png" alt="html operation"></p>
<p>我们来验证这个结论:<br>html 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        console.log('start load');</span></span><br><span class="line"><span class="regexp">        function h () &#123;</span></span><br><span class="line"><span class="regexp">            console.log(document.querySelectorAll('h1'))</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">        setTimeout(h, 0);</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        h1 &#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        console.log('end load');</span></span><br><span class="line"><span class="regexp">        setTimeout(h, 0);</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;测试阻塞加载&lt;/</span>h1&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>
<p>在<font color="#ff502c">加载到</font>jquery 文件后，会先下载远程的 jquery 并且<font color="#ff502c">执行</font>他，他会<font color="#ff502c">阻塞 dom 的解析和渲染</font>，<font color="#ff502c">css 解析和渲染</font>，一直是白屏，等 jquery<font color="#ff502c">执行完成</font>了才接着解析 Dom 和 cssom 并且渲染，console.log 打印 h1 标签也是空数组。<br>如下图所示：<br><img src="../../images/html/images/html-gif.gif" alt="html operation"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>javascript 加载会阻塞 css 解析和渲染<br>javascript 加载会阻塞 dom 解析和渲染</p>
</blockquote>
<h2 id="css-加载会阻塞-JavaScript-的加载和执行、会阻塞-Dom-的解析和渲染？"><a href="#css-加载会阻塞-JavaScript-的加载和执行、会阻塞-Dom-的解析和渲染？" class="headerlink" title="css 加载会阻塞 JavaScript 的加载和执行、会阻塞 Dom 的解析和渲染？"></a>css 加载会阻塞 JavaScript 的加载和执行、会阻塞 Dom 的解析和渲染？</h2><h3 id="提出自己观点-1"><a href="#提出自己观点-1" class="headerlink" title="提出自己观点"></a>提出自己观点</h3><p>因为上面我们已经验证过 JavaScript 会阻塞 Dom 的解析和渲染，同时也会解析 cssom 的解析和渲染，所以我们假设 css 的加载会<font color="#ff502c">阻塞</font>Dom 的<font color="#ff502c">解析</font>和<font color="#ff502c">渲染</font>，会<font color="#ff502c">阻塞</font>JavaScript 的<font color="#ff502c">加载</font>和<font color="#ff502c">执行</font>。</p>
<h3 id="验证我们的假设"><a href="#验证我们的假设" class="headerlink" title="验证我们的假设"></a>验证我们的假设</h3><p>在上面的代码基础上修改代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        console.log('start load');</span></span><br><span class="line"><span class="regexp">        function h () &#123;</span></span><br><span class="line"><span class="regexp">            console.log(document.querySelectorAll('h1'))</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">        setTimeout(h, 0);</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">    &lt;link href=<span class="string">"https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        h1 &#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        console.log('end load');</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;测试阻塞加载&lt;/</span>h1&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>
<p>执行结果如下图所示<br><img src="../../images/html/images/html-gif1.gif" alt="html operation"></p>
<h4 id="css-加载对-Dom-的阻塞"><a href="#css-加载对-Dom-的阻塞" class="headerlink" title="css 加载对 Dom 的阻塞"></a>css 加载对 Dom 的阻塞</h4><p>如果按我们假设的 css 加载会阻塞 Dom 的解析和渲染，那么执行的结果，应该是首先是白屏，然后 h1 标签的 nodeList 应该是为空数组的，但是在执行的时我们看到 h1 标签的 nodeList 是有值的，注（还有 setTimeout 的作用是为了在下一个 Task 最先执行，感觉并不会影响我们的实验的结果。）<br>这表示我们一开始的假设是有问题的，css 加载会阻塞 Dom 的渲染有阻塞，但是并不会阻塞 Dom 的解析。</p>
<h4 id="css-加载对-JavaScript-的阻塞"><a href="#css-加载对-JavaScript-的阻塞" class="headerlink" title="css 加载对 JavaScript 的阻塞"></a>css 加载对 JavaScript 的阻塞</h4><p>css 加载会对后续的 JavaScript 的执行会造成阻塞。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong><em>css 加载对 Dom 的解析没有阻塞，但是对于 Dom 的渲染造成了阻塞。</em></strong><br><strong><em>css 加载对 JavaScript 的执行会造成阻塞</em></strong></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>如果还不了解整体的渲染流程可以看以前我前面的文章，<a href="/blog/html/html-style-javascript.html">浏览器渲染原理 （一）在网址中输入一个网站后面都做了什么</a></p>
<ul>
<li><strong><em>JavaScript 的加载会阻塞 Dom 的解析和渲染，并且也会阻塞 css 的解析和渲染。</em></strong></li>
<li><strong><em>Css 的加载会阻塞 Dom 的渲染，并不会阻塞 Dom 的解析，也会阻塞 JavaScript 的执行。</em></strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b88ddca6fb9a019c7717096" target="_blank" rel="noopener">css 加载会造成阻塞吗？</a></p>
]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的继承对比 继承（二）（未完成）</title>
    <url>/blog/javascript/javascript-constructor-propotype.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript实现一个自己的new 继承 （三）</title>
    <url>/blog/javascript/javascript-new.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>node中的垃圾回收机制 （未完成）</title>
    <url>/blog/node/node-gc.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome中的preformance 性能监控（一） （未完成）</title>
    <url>/blog/performance/preformance.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的BFC简介</title>
    <url>/blog/css/css-bfc.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<blockquote>
<p>注意：一个BFC的范围包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。这从另一方角度说明，一个元素不能同时存在于两个BFC中。因为如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用。</p>
</blockquote>
<p>下列方式会创建<strong>块格式上下文</strong>：</p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 <code>float</code> 不是 <code>none</code>）</li>
<li>绝对定位元素（元素的 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>）</li>
<li>行内块元素（元素的 <code>display</code> 为 <code>inline-block</code>）</li>
<li>表格单元格（元素的 <code>display</code>为 <code>table-cell</code>，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 <code>display</code> 为 t<code>able-caption</code>，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 <code>display</code>为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是<code>HTML table</code>、<code>row</code>、<code>tbody</code>、<code>thead</code>、<code>tfoot</code>的默认属性）或 <code>inline-table</code>）</li>
<li><code>overflow</code> 值不为 <code>visible</code> 的块元素</li>
<li><code>display</code> 值为 <code>flow-root</code> 的元素</li>
<li><code>contain</code> 值为 <code>layout</code>、<code>content</code>或 <code>strict</code> 的元素</li>
<li>弹性元素（<code>display</code>为 <code>flex</code> 或 <code>inline-flex</code>元素的直接子元素）</li>
<li>网格元素（<code>display</code>为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li>
<li>多列容器（元素的 <code>column-count</code> 或 <code>column-width</code> 不为 <code>auto</code>，包括 <code>column-count</code> 为 1）</li>
<li><code>column-span</code> 为 all 的元素始终会创建一个新的<code>BFC</code>，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>
</ul>
<p>块格式化上下文包含创建它的元素内部的所有内容。</p>
<p><strong>表现</strong></p>
<p>在<strong>BFC(Block formatting contexts)</strong>中，在<strong>包含块</strong>内一个盒子一个盒子不重叠地<strong>垂直排列</strong>，两个兄弟盒子直接的垂直距离由 <code>margin</code>决定。<strong>浮动</strong>也是如此（虽然有可能两个盒子的距离会因为 floats而变小），除非该盒子再创建一个新的<code>BFC</code>。</p>
<h2 id="三中文档流的定位方案"><a href="#三中文档流的定位方案" class="headerlink" title="三中文档流的定位方案"></a>三中文档流的定位方案</h2><p>我们常说的文档流其实分为<strong>定位流</strong>、<strong>浮动流</strong>、<strong>普通流三种</strong>。而普通流其实就是指<code>BFC</code>中的<code>FC</code>。<code>FC(Formatting Context)</code>，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的<code>FC</code>有<code>BFC(Block Formatting Contexts)、IFC</code>，还有<code>GFC(GridLayout Formatting Contexts)</code>和<code>FFC(Flex Formatting Contexts)</code>。</p>
<p>大致的文档流分类</p>
<ul>
<li>普通文档流<code>(Normal flow)</code></li>
<li>浮动<code>(Floats)</code></li>
<li>绝对定位<code>(Absolute positioning)</code></li>
</ul>
<h3 id="普通文档流"><a href="#普通文档流" class="headerlink" title="普通文档流"></a>普通文档流</h3><ul>
<li><strong>在普通文档流中，盒一个接着一个排列；</strong></li>
<li><strong>在块级格式化上下文里面， 它们竖着排列；</strong></li>
<li><strong>在行内格式化上下文里面， 它们横着排列；</strong></li>
<li><strong>当position为static或relative，并且float为none时会触发普通文档流；</strong></li>
<li><strong>对于静态定位(static positioning)，position: static，盒的位置是普通文档流布局里的位置；</strong></li>
<li><strong>对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有的位置，其它普通文档流不能占用这个位置。</strong></li>
</ul>
<h3 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动(Floats)"></a>浮动(Floats)</h3><ul>
<li><strong>左浮动元素尽量靠左、靠上，右浮动同理</strong></li>
<li><strong>这导致普通文档流环绕在它的周边，除非设置 clear 属性</strong></li>
<li><strong>浮动元素不会影响块级元素的布局</strong></li>
<li><strong>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</strong></li>
<li><strong>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</strong></li>
<li><strong>不超过它的包含块，除非元素本身已经比包含块更宽</strong></li>
<li><strong>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的</strong></li>
</ul>
<h3 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位(Absolute positioning)"></a>绝对定位(Absolute positioning)</h3><ul>
<li><strong>绝对定位方案，盒从普通文档流中被移除，不影响普通文档流的布局；</strong></li>
<li><strong>它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right；</strong></li>
<li><strong>如果元素的属性position为absolute或fixed，它是绝对定位元素；</strong></li>
<li><strong>对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body；</strong></li>
</ul>
<h2 id="BFC大致规则"><a href="#BFC大致规则" class="headerlink" title="BFC大致规则"></a>BFC大致规则</h2><ul>
<li><strong>内部的Box会在垂直方向上一个接一个的放置</strong></li>
<li><strong>内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。）</strong></li>
<li><strong>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</strong></li>
<li><strong>BFC的区域不会与float的元素区域重叠</strong></li>
<li><strong>计算BFC的高度时，浮动子元素也参与计算</strong></li>
</ul>
<p><strong>普通文档流布局</strong></p>
<ul>
<li><strong>浮动的元素是不会被父级计算高度</strong></li>
<li><strong>非浮动元素会覆盖浮动元素的位置</strong></li>
<li><strong>margin会传递给父级元素</strong></li>
<li><strong>两个相邻元素上下的margin会重叠</strong></li>
</ul>
<h2 id="开发中的使用"><a href="#开发中的使用" class="headerlink" title="开发中的使用"></a>开发中的使用</h2><ul>
<li><strong>BFC 可以防止 margin 折叠</strong></li>
<li><strong>可以阻止元素被浮动元素覆盖</strong></li>
<li><strong>多列布局中使用 BFC</strong></li>
<li><strong>可以包含浮动元素</strong></li>
</ul>
<h3 id="BFC-可以防止-margin-折叠"><a href="#BFC-可以防止-margin-折叠" class="headerlink" title="BFC 可以防止 margin 折叠"></a>BFC 可以防止 margin 折叠</h3><p>了解边距合并是另一个被低估的 <code>CSS</code> 技能。在下一个示例中，假设有一个背景颜色为灰色的 <code>div</code>。<br>这个 div 包含两个标签 p。外部 div 元素的 margin-bottom 为 <code>40</code> 像素，标签 p 的顶部和底部 margin 都是 20 像素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am paragraph one and I have a margin top and bottom of 20px;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am paragraph one and I have a margin top and bottom of 20px;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">40px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(233,78,119);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：<br><img src="../../images/bfc/bfc-1-1.png" alt="bfc"><br>可以看到它和外层<code>div</code>的<code>margin-bottom</code>也有重叠，两个相邻的p段落的<code>margin</code>也有重叠。<br>在CSS当中，<strong>相邻</strong>的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个<strong>单独</strong>的外边距。这种合并外边距的方式被称为<strong>折叠</strong>，并且因而所结合成的外边距称为<strong>折叠外边距</strong>。折叠的结果按照如下规则计算：</p>
<ul>
<li><strong>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</strong></li>
<li><strong>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</strong></li>
<li><strong>两个外边距一正一负时，折叠结果是两者的相加的和。</strong></li>
</ul>
<blockquote>
<p>产生折叠的必备条件：margin必须是邻接的!</p>
</blockquote>
<p>如果我们把盒子设为 <strong>BFC</strong>，它现在包含了标签 <code>p</code> 和它们的<strong>边距</strong>，这样它们就不会<strong>折叠</strong>，我们可以看到边距后面容器的<strong>灰色背景</strong>。<br>修改css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">40px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="../../images/bfc/bfc-1-2.png" alt="bfc"></p>
<h3 id="可以阻止元素被浮动元素覆盖、可以包含浮动元素"><a href="#可以阻止元素被浮动元素覆盖、可以包含浮动元素" class="headerlink" title="可以阻止元素被浮动元素覆盖、可以包含浮动元素"></a>可以阻止元素被浮动元素覆盖、可以包含浮动元素</h3><p>你将熟悉 <strong>BFC</strong> 的这种行为，因为使用<strong>浮动</strong>的任何列类型布局都是这样工作的。如果一个项目创建了一个 BFC，那么该项目将<strong>不会包裹</strong>任何浮动元素。在下面的例子中，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>I am a floated element.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>I am textI am textI am textI am textI am textI am textI am textI am textI am textI am textI am text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#00ff00</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff00ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：<br><img src="../../images/bfc/bfc-1-3.png" alt="bfc"><br>我可以通过将包裹文本的 div 设置为 BFC 来防止这种包裹行为。新增css代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/bfc/bfc-1-4.png" alt="bfc"><br>这实际上是我们创建具有多个列的浮动布局的方法。浮动项还为该项创建了一个 BFC，因此，如果右边的列比左边的列高，那么我们的列就不会相互环绕。</p>
<h3 id="在多列布局中使用-BFC"><a href="#在多列布局中使用-BFC" class="headerlink" title="在多列布局中使用 BFC"></a>在多列布局中使用 BFC</h3><p><strong>如果我们创建一个占满整个容器宽度的多列布局，在某些浏览器中最后一列有时候会掉到下一行。这可能是因为浏览器四舍五入了列宽从而所有列的总宽度会超出容器。但如果我们在多列布局中的最后一列里创建一个新的BFC，它将总是占据其他列先占位完毕后剩下的空间</strong>。<br>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>column 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>column 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>column 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">31.33%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">1%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="../../images/bfc/bfc-1-5.png" alt="bfc"><br>添加以下样式创建一个 BFC:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.column</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/bfc/bfc-1-6.png" alt="bfc"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记录了什么叫做BFC，有哪些触发条件，在应用中有几种常用的方法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s/ifg6jtxK9iwIc6JfUkT8OQ" target="_blank" rel="noopener">理解 CSS 布局和 BFC</a><br><a href="https://mp.weixin.qq.com/s/gS-HPWZnrwaEM-X3vDEPyQ" target="_blank" rel="noopener">CSS中重要的BFC</a><br><a href="https://mp.weixin.qq.com/s/Ywxlr3nex--2-qTG2KjLGA" target="_blank" rel="noopener">前端进阶之你真的知道BFC是什么吗？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的BEM简介</title>
    <url>/blog/css/css-bem.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>BEM其实是一种CSS书写规范中的一种</strong>，使用BEM规范来命名CSS，组织HTML中选择器的结构，利于CSS代码的维护，使得代码结构更清晰（弊端主要是名字会稍长）。<br>BEM代表的是<strong>块（block）</strong>、<strong>元素（element）</strong>、<strong>修饰符（modifier）</strong>，是由Yandex团队提出的一种前端命名方法论。</p>
<p>在选择其中，由一下三种符号来表示扩展的关系：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-   中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</span><br><span class="line">__  双下划线：双下划线用来连接块和块的子元素</span><br><span class="line">_   单下划线：单下划线用来描述一个块或者块的子元素的一种状态</span><br><span class="line"></span><br><span class="line">type-block__element_modifier</span><br></pre></td></tr></table></figure>
<h2 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h2><p>一个快是设计或者布局的一部分，它有具体且唯一的意义，语义上的或视觉上的。<br>在大多数情况下，任何<strong>独立的页面元素</strong>（或复杂或简单）都可以被视作一个块。它的HTML容器会有一个<strong>唯一的CSS类名</strong>，也就是这个块的名字。<br>针对块的CSS类名会加一些前缀（ ui-），这些前缀在CSS中有类似 <strong>命名空间</strong> 的作用。<br>一个块的正式（实际上是半正式的）定义有下面三个基本原则：</p>
<ol>
<li>CSS中只能使用类名（不能是ID）。</li>
<li>每一个块名应该有一个命名空间（前缀）</li>
<li>每一条CSS规则必须属于一个块。</li>
</ol>
<p>一个自定义列表样例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">// css</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list</span> &#123;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常会把<code>ul</code>看做一个完整得块，所以在<code>ul</code>上面定义一个块的<code>class</code>为<code>list</code>。</p>
<h2 id="元素（element）"><a href="#元素（element）" class="headerlink" title="元素（element）"></a>元素（element）</h2><p>块中的子元素是块的子元素，并且子元素的子元素在 <strong>bem</strong> 里也被认为是块的直接子元素。<strong>一个块中元素的类名必须用父级块的名称作为前缀</strong>。<br>在上面的例子上扩展如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span>列表项一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span>列表项二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">// css</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list</span> &#123;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list__item</span> &#123;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为每一个<code>li</code>都是<code>ul</code>的子元素，所以在<code>li</code>上定义一个为<code>list__item</code>的<code>class</code>。</p>
<h2 id="修饰符（modifier）"><a href="#修饰符（modifier）" class="headerlink" title="修饰符（modifier）"></a>修饰符（modifier）</h2><p>一个“修饰符”可以理解为一个块的<strong>特定状态</strong>，标识着它持有一个<strong>特定的属性</strong>。<br>在上面的例子上扩展如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item list__item_active"</span>&gt;</span>列表项一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span>列表项二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">// css</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list</span> &#123;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list__item</span> &#123;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list__item_active</span> &#123;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假如<code>ul</code>是一个<code>menu</code>，它的第一项默认是<strong>选中状态</strong>给第一项添加一个选中的<code>class</code>为<code>list__item_active</code>。</p>
<h2 id="书写原则"><a href="#书写原则" class="headerlink" title="书写原则"></a>书写原则</h2><ol>
<li><strong>原则上不会出现<em>2层以上</em>选择器嵌套</strong></li>
</ol>
<p>使用<code>BEM</code>原则，用命名来解耦，所有类名都为一层，增加效率和复用性</p>
<ol start="2">
<li><strong>两层选择器嵌套出现在<code>.mod-xxx__item_current</code>子元素的情况</strong></li>
</ol>
<p>请看下面一个样例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"xxx__item"</span>&gt;</span>第一项</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"xxx__product-name"</span>&gt;</span>我是名称<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"xxx__ming-zi-ke-yi-hen-chang"</span>&gt;</span>看类名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"xxx__link"</span>&gt;</span>我是link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"xxx__item xxx__item_current"</span>&gt;</span>第二项 且 当前选择项</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"xxx__product-name"</span>&gt;</span>我是名称<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"xxx__item-link"</span>&gt;</span>我是link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"xxx__item xxx__item_hightlight"</span>&gt;</span>第三项 且 特殊高亮</span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"xxx__product-name"</span>&gt;</span>我是名称<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"xxx__item-link"</span>&gt;</span>我是link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 常规写法：</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.xxx</span>&#123;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item</span>&#123;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item_current</span>&#123;&#125;</span></span><br><span class="line">  // 嵌套写法</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item_current</span> <span class="selector-class">.mod-xxx__link</span>&#123;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 推荐：</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.xxx</span>&#123;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.xxx__item</span>&#123;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.xxx__item_hightlight</span>&#123;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.xxx__product-name</span>&#123;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.xxx__link</span>&#123;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.xxx__ming-zi-ke-yi-hen-chang</span>&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">// 嵌套写法</span><br><span class="line"><span class="css"><span class="selector-class">.xxx__item_current</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__link</span>&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="BEM-解决问题"><a href="#BEM-解决问题" class="headerlink" title="BEM 解决问题"></a>BEM 解决问题</h2><p>组件之间的完全解耦，不会造成命名空间的污染，如：.mod-xxx ul li 的写法带来的潜在的嵌套风险。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BEM规则的应用规则如下：</p>
<ul>
<li>一个独立的（语义上或视觉上），可以复用而不依赖其它组件的部分，可作为一个块（Block）</li>
<li>属于块的某部分，可作为一个元素（Element）</li>
<li>用于修饰块或元素，体现出外形行为状态等特征的，可作为一个修饰器（Modifier）</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/Tencent/tmt-workflow/wiki/%E2%92%9B-%5B%E8%A7%84%E8%8C%83%5D--CSS-BEM-%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">[规范] CSS BEM 书写规范</a><br><a href="https://www.cnblogs.com/imwtr/p/8521031.html" target="_blank" rel="noopener">使用BEM命名规范来组织CSS代码</a><br><a href="https://www.w3cplus.com/css/mindbemding-getting-your-head-round-bem-syntax.html" target="_blank" rel="noopener">BEM思想之彻底弄清BEM语法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>node中的node-lru的使用和lru的作用 （未完成）</title>
    <url>/blog/node/node-lru.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie、localStorage、sessionStorage、session深入理解</title>
    <url>/blog/browser/browser-store.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在以前经常用到的<code>cookie</code>、<code>session</code>，但在<strong>H5</strong>中新引入了新的浏览器本地缓存方案。因为大家使用的不太规范用来作为本地储存工具，在下次请求时会默认带上<code>cookie</code>中的数据导致浪费性能和流量。</p>
<p>下面就从开始介绍为什么产生的<code>cookie</code>，它的出现是为了解决什么问题，它有什么问题；后面<code>localStorage</code>是为什么产生，它又解决了那部分的问题。最后是<code>cookie</code>、<code>session</code>、<code>localStorage</code>、<code>sessionStorage</code>之间的对比。</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>首先了解为什么会产生<code>cookie</code>?<code>cookie</code>是什么?</p>
<h3 id="cookie是什么、cookie产生原因"><a href="#cookie是什么、cookie产生原因" class="headerlink" title="cookie是什么、cookie产生原因"></a>cookie是什么、cookie产生原因</h3><p>在<code>HTTP</code>请求建立连接时，有一个<strong>客户端</strong>、<strong>服务端</strong>它们两个之间建立的连接。但是<code>HTTP</code>协议每次建立连接都是独立，也可以说是<code>HTTP</code>协议是无状态的连接。</p>
<ul>
<li>第一次建立连接，客户在<strong>客户端</strong>中登录，<strong>服务端</strong>验证登录信息，生成<strong>Token</strong>为以后的请求不需要从新登录</li>
<li>第二次建立连接，<strong>客户端</strong>携带服务端在登录成功时返回的<strong>Token</strong>，但是这个<strong>Token</strong>要储存在哪里？一般会存在<strong>cookie</strong>里。</li>
</ul>
<p>简单总结一下就是，因为<code>HTTP</code>协议是无状态的所以客户端需要一个<code>cookie</code>来储存起来。<br><!-- **`Cookie`实际上是一小段的文本信息**，**用来服务端和客户端之间传递信息**。 --><br><strong><code>HTTP Cookie</code>（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</strong></p>
<p><code>Cookie</code>主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h3><p>当服务器收到<code>HTTP</code>请求时，服务器可以在响应头里面添加一个<code>Set-Cookie</code>选项。浏览器收到响应后通常会保存下<code>Cookie</code>，之后对该服务器每一次请求中都通过<code>Cookie</code>请求头部将<code>Cookie</code>信息发送给服务器。</p>
<p>在创建<code>Cookie</code>是可以设置很多属性，如<code>Expires</code>、<code>Max-Age</code>、<code>Domain</code>、<code>Path</code>、<code>Secure</code>、<code>HttpOnly</code>，因为它会自动携带到服务器端，同时又支持服务器端设置。所以有很多的方面要注意，比如<strong>时效性</strong>、<strong>作用域</strong>、<strong>安全性</strong>。下面就从这三个方面来解释他属性的作用。</p>
<h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>如果在<code>Set-Cookie</code>时不通过<code>Expries</code>、<code>Max-Age</code>两个字段设置<code>Cookie</code>的时效性，那么这个<code>Cookie</code>是一个简单的<strong>会话期Cookie</strong>。它在关闭浏览器是会被自动删除。</p>
<p>如果设置了<code>Expries</code>、<code>Max-Age</code>那么这个<code>Cookie</code>在指定时间内都是有效的。</p>
<blockquote>
<p>提示：当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
</blockquote>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>Domain</code> 和 <code>Path</code> 标识定义了<code>Cookie</code>的作用域：即<code>Cookie</code>应该发送给哪些<code>URL</code>。</p>
<p><code>Domain</code> 标识指定了哪些主机可以接受<code>Cookie</code>。如果不指定，默认为<strong>当前文档的主机（不包含子域名）</strong>。如果指定了<code>Domain</code>，则一般包含子域名。</p>
<p><code>Path</code> 标识指定了主机下的哪些路径可以接受<code>Cookie</code><strong>（该URL路径必须存在于请求URL中）</strong>。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>标记为 <code>Secure</code> 的<code>Cookie</code>只应通过被<code>HTTPS</code>协议加密过的请求发送给服务端。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过<code>Cookie</code>传输，因为<code>Cookie</code>有其固有的不安全性，<code>Secure</code> 标记也无法提供确实的安全保障。</p>
<blockquote>
<p>从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用Cookie的 Secure 标记。</p>
</blockquote>
<p>为避免跨域脚本 <strong>(XSS)</strong> 攻击，通过<strong>JavaScript</strong>的 <code>Document.cookie</code> <strong>API</strong>无法访问带有 <code>HttpOnly</code> 标记的<code>Cookie</code>，它们只应该发送给服务端。</p>
<h3 id="客户端操作Cookie"><a href="#客户端操作Cookie" class="headerlink" title="客户端操作Cookie"></a>客户端操作Cookie</h3><p>通过<code>Document.cookie</code>属性可创建新的<code>Cookie</code>，也可通过该属性访问非<code>HttpOnly</code>标记的<code>Cookie</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">documnet.cookie</span><br><span class="line"><span class="comment">// 这里就不多做赘述，有一篇文章专门讲解了</span></span><br></pre></td></tr></table></figure>
<h3 id="cookie的特点"><a href="#cookie的特点" class="headerlink" title="cookie的特点"></a>cookie的特点</h3><p><strong>优点</strong></p>
<ul>
<li>储存用户信息（用户token）</li>
<li>标记用户行为（uuid、埋点）</li>
</ul>
<p><strong>弊端</strong></p>
<ul>
<li><code>Cookie</code>会被附加在每个<code>HTTP</code>请求中，所以无形中增加了流量</li>
<li><code>Cookie</code>可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的<code>Cookie</code>功能；</li>
<li>由于在<code>HTTP</code>请求中的<code>Cookie</code>是明文传递的，潜在的安全风险，<code>Cookie</code> 可能会被篡改</li>
<li><p><code>Cookie</code>数量和长度的限制。每个域名(Domain)下<br><strong>IE6或IE6-(IE6以下版本)：最多20个cookie</strong><br><strong>IE7或IE7+(IE7以上版本)：最多50个cookie</strong><br><strong>FF:最多50个cookie</strong><br><strong>Opera:最多30个cookie</strong><br><strong>Chrome和safari没有硬性限制</strong><br>当超过单个域名限制之后，再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会清理近期最少使用的cookie，FF会随机清理cookie；</p>
</li>
<li><p>每个<code>Cookie</code>长度不能超过<strong>4KB</strong></p>
</li>
</ul>
<h3 id="cookie安全问题"><a href="#cookie安全问题" class="headerlink" title="cookie安全问题"></a>cookie安全问题</h3><p><code>Cookie</code>面临什么样的安全问题，常见的<strong>xss</strong>、<strong>csrf</strong>等等下面开始。</p>
<p><strong>xss 和 防御xss</strong></p>
<p>如果在服务器端<code>Set-Cookie</code>时没有设置<code>HttpOnly=true</code>时，在浏览器端就可以通过<code>document.cookie</code>来读取和修改<code>Cookie</code>中的值，这是十分安全的会造成<code>xss</code>。当<code>Cookie</code>中有关键性信息是要设置<code>HttpOnly=true</code>。</p>
<p><strong>防止中间人劫持 和 中间人劫持</strong></p>
<p>大致的分布图是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">         DNS</span><br><span class="line">     &lt;-----&gt;</span><br><span class="line">用户          中间人       外网</span><br><span class="line">     &lt;-----&gt;</span><br><span class="line">       HTTP</span><br></pre></td></tr></table></figure>
<p>当使用<code>HTTPS</code>协议和购买正规的<code>CA证书</code>时，即使中间人劫持也无法解密。并且在<code>Set-Cookie</code>设置<code>Secure=true</code>时<code>Cookie</code>只应通过被<code>HTTPS</code>协议加密过的请求发送给服务端。</p>
<p><strong>csrf 和 csrf防御</strong></p>
<p>CSRF: 跨站请求伪造<code>（CSRF）</code>是一种冒充受信任用户，向服务器发送非预期请求的攻击方式。</p>
<p>例如，这些非预期请求可能是通过在跳转链接后的 URL 中加入恶意参数来完成:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://www.example.com/index.php?action=delete&amp;id=123"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于在 <code>https://www.example.com</code> 有权限的用户，这个 <code>&lt;img&gt;</code> 标签会在他们根本注意不到的情况下对 <code>https://www.example.com</code> 执行这个操作，即使这个标签根本不在 <code>https://www.example.com</code> 内亦可。</p>
<p><code>SameSite Cookie</code>允许服务器要求某个<code>cookie</code>在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击<code>（CSRF）</code>。但目前<code>SameSite Cookie</code>还处于实验阶段，并不是所有浏览器都支持。</p>
<ul>
<li><code>strict</code>：浏览器在任何跨域请求中都不会携带<code>Cookie</code>，这样可以有效的防御<code>CSRF</code>攻击，但是对于有多个子域名的网站采用主域名存储用户登录信息的场景，每个子域名都需要用户重新登录，造成用户体验非常的差。</li>
<li><code>lax</code>：相比较<code>strict</code>，它允许从三方网站跳转过来的时候使用<code>Cookie</code>。</li>
</ul>
<p><strong>其他防御</strong></p>
<ul>
<li>设置<code>cookie</code>有效期时间</li>
<li>防止<code>cookie</code>是明文，服务器端生成密钥验证</li>
<li>生成随机数和<code>cookie</code>发送给服务器端</li>
<li><code>flash编程安全</code>，审核<code>flash代码</code>，尽量不要用<code>flash</code>用最新的视频<code>vedio</code> + <code>https</code> + <code>socket</code>或者动画</li>
</ul>
<p>到此<code>cookie</code>的<strong>产生原因</strong>、<strong>作用</strong>、<strong>特点/缺点</strong>、<strong>安全问题</strong>。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>session是什么？</strong><br><code>Session</code>是一种记录客户状态的机制，不同于<code>Cookie</code>的是<code>Cookie</code>保存在客户端浏览器中，而Session保存在服务器上。避免了在客户端<code>Cookie</code>中存储敏感数据。</p>
<h3 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h3><p><code>Session</code>从字面意思上可以理解为<strong>会话</strong>，谁与谁的会话呢？其实是<strong>客户端浏览器与服务器之间一系列交互的动作称为一个 Session</strong>。</p>
<p><strong>创建Session（java）</strong></p>
<ol>
<li><code>Session</code>在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建<code>Session</code>的方法， 在<code>Java</code>中是通过调用<code>HttpServletRequest</code>的<code>getSession</code>方法(使用true作为参数)创建的。 创建<code>Session</code>的同时，服务器会为该<code>Session</code>生成唯一的<code>session id</code>， 这个<code>session id</code>在随后的请求中会被用来重新获得已经创建的<code>Session</code>。</li>
<li><code>Session</code>被创建之后，就可以调用<code>Session</code>相关的方法往<code>Session</code>中增加内容了， 而这些内容只会保存在服务器中，发到客户端的只有<code>session id</code></li>
<li>当客户端再次发送请求的时候，会将这个<code>session id</code>带上， 服务器接受到请求之后就会依据<code>session id</code>找到相应的<code>Session</code>，从而再次使用<code>Session</code>。</li>
</ol>
<h3 id="Session的生命周期"><a href="#Session的生命周期" class="headerlink" title="Session的生命周期"></a>Session的生命周期</h3><p><code>Session</code>保存在服务器端。为了获得更高的存取速度，服务器一般把<code>Session</code>放在内存中。 每个用户都会有一个独立的<code>Session</code>。 如果<code>Session</code>内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。 因此，<code>Session</code>里的信息应该尽量精简。</p>
<p><code>Session</code>在用户第一次访问服务器的时候自动创建。 需要注意只有访问<code>JSP、Servlet</code>等程序时才会创建<code>Session</code>， 只访问<code>HTML、IMAGE</code>等静态资源并不会创建<code>Session</code>。 如果尚未生成<code>Session</code>，也可以使用<code>request.getSession(true)</code>强制生成<code>Session</code>。</p>
<p><code>Session</code>生成后，只要用户继续访问，服务器就会更新<code>Session</code>的最后访问时间，并维护该<code>Session</code>。 用户每访问服务器一次，无论是否读写<code>Session</code>，服务器都认为该用户的<code>Session&quot;活跃(active)&quot;了一次</code>。</p>
<h3 id="Session的有效期"><a href="#Session的有效期" class="headerlink" title="Session的有效期"></a>Session的有效期</h3><p>由于会有越来越多的用户访问服务器，因此<code>Session</code>也会越来越多。 为防止内存溢出，服务器会把长时间内没有活跃的<code>Session</code>从内存删除。 这个时间就是<code>Session</code>的超时时间。如果超过了超时时间没访问过服务器，<code>Session</code>就自动失效了。</p>
<p><code>Session</code>的超时时间为<code>maxInactiveInterval</code>属性， 可以通过对应的<code>getMaxInactiveInterval()</code>获取，通过<code>setMaxInactiveInterval(longinterval)</code>修改。</p>
<p><code>Session</code>的超时时间也可以在<code>web.xml</code>中修改。 另外，通过调用<code>Session</code>的<code>invalidate()</code>方法可以使<code>Session</code>失效。</p>
<p>三种方法让<code>Session</code>失效：</p>
<ul>
<li><strong>服务器意外关闭</strong>。（服务器正常关闭时session是会被服务器保存在服务器的 session.ser 文件中（在work文件夹下））</li>
<li><code>session自杀</code>： 调用<code>session.invalidate()</code>方法可以立即杀死<code>session</code>；</li>
<li>可以在服务器下的<code>web.xml</code>文件中的 <code>&lt;session-timeout&gt; 30 &lt;/session-timeout&gt;</code> 修改这是默认值(默认30分钟)，是以分为单位。</li>
</ul>
<h3 id="浏览器关闭session会失效"><a href="#浏览器关闭session会失效" class="headerlink" title="浏览器关闭session会失效?"></a>浏览器关闭session会失效?</h3><p>在几年前看很多网上的资料时有的会说<code>session</code>会在浏览器关闭时会失效。为什么会失效？怎么能让它不失效？</p>
<p><strong>为什么会失效？</strong></p>
<p>下面梳理一下<code>session</code>为什么会在浏览器关闭时失效，其实这样说并不准确：</p>
<ol>
<li>在服务器端生成<code>session</code>，并且把<code>sessionid</code>通过<code>set-cookie</code>发送给浏览器</li>
<li>以后每次请求除了图片、静态文件请求，其它的请求都会带上<strong>服务端</strong>写入浏览器中<code>cookie</code></li>
<li><strong>服务端</strong>接收到<code>sessionid</code>，通过<code>sessionid</code>找到对应的<code>session</code>信息</li>
<li>当浏览器关闭时，当前域名中设置的<code>cookie</code>会被清空</li>
<li>再下次请求使，服务端接收到的<code>session</code>为<code>null</code>，服务端就会认为当前用户是一个新的用户，重新登录或者直接设置新的<code>sessionid</code></li>
</ol>
<p>上面也就是为什么会说<code>session</code>会在浏览器关闭时会失效。</p>
<p><strong>怎么能让它不失效？</strong></p>
<p>在<code>Set-Cookie</code>时设置<code>Expries</code>或<code>Max-Age</code>，其实就是设置<code>Cookie</code>的失效时间。<br>或者直接把<code>Sessionid</code>储存在本地。</p>
<h2 id="web-Storage"><a href="#web-Storage" class="headerlink" title="web Storage"></a>web Storage</h2><p><strong>Web Storage API</strong>提供机制， 使浏览器能以一种比使用<code>Cookie</code>更直观的方式存储键/值对。</p>
<p>Web Storage 包含如下两种机制：</p>
<ul>
<li><code>sessionStorage</code> 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</li>
<li><code>localStorage</code> 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</li>
</ul>
<p><strong>应注意，无论数据存储在 localStorage 还是 sessionStorage ，它们都特定于页面的协议。</strong></p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>只读的<code>localStorage</code> 属性允许你访问一个<code>Document</code> 源（<code>origin</code>）的对象 <code>Storage</code>；存储的数据将保存在浏览器会话中。存储在 <code>localStorage</code> 的数据可以长期保留。</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code> 属性允许你访问一个 <code>session Storage</code> 对象。存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。<strong>在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话</strong>，这点和 session cookies 的运行方式不同。</p>
<h3 id="localStorage和sessionStorage区别"><a href="#localStorage和sessionStorage区别" class="headerlink" title="localStorage和sessionStorage区别"></a>localStorage和sessionStorage区别</h3><p>存储在 <code>localStorage</code> 的数据可以长期保留，而存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>session</code>和<code>cookie</code>的区别：</p>
<ul>
<li><code>session</code>储存在服务端，<code>cookie</code>储存在客户端</li>
<li><code>session</code>比<code>cookie</code>更安全，因为<code>session</code>储存在服务端</li>
<li><code>session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。</li>
<li><code>cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现<code>session</code>的一种方式。</li>
</ul>
<p><code>web storage</code>和<code>cookie</code>的区别：</p>
<ul>
<li><code>web storages</code>和<code>cookie</code>的作用不同，<code>web storage</code>是用于本地大容量存储数据(<code>web storage</code>的存储量大到5MB);而<code>cookie</code>是用于客户端和服务端间的信息传递；</li>
<li><code>web storage</code>有<code>setItem</code>、<code>getItem</code>、<code>removeItem</code>、<code>clear</code>等方法，<code>cookie</code>需要我们自己来封装<code>setCookie</code>、<code>getCookie</code>、<code>removeCookie</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">HTTP cookies</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">Web Storage API</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">Window.localStorage</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener">Window.sessionStorage</a><br><a href="https://mp.weixin.qq.com/s/RJuHkTYd7pSS_RhHeuh0iQ" target="_blank" rel="noopener">这一次把cookie给你说透彻！</a><br><a href="https://mp.weixin.qq.com/s/sycJeIBY_2h0h6SwUTWI9A" target="_blank" rel="noopener">深入理解Session和Cookie的区别</a><br><a href="https://mp.weixin.qq.com/s/VeodMTKbwCdodx0fZjTlhw" target="_blank" rel="noopener">详解cookie和session的运作机制（上篇）</a><br><a href="https://mp.weixin.qq.com/s/Idl0eheciAck5WznXqO0Lw" target="_blank" rel="noopener">面试稳了！这才是cookie，session与token的真正区别</a></p>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的requestAnimationFrame （未完成）</title>
    <url>/blog/javascript/javascript-requestAnimationFrame.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Http中的缓存（一） 强缓存、协商缓存 缓存</title>
    <url>/blog/http/http-cache.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/http/http-cache.html">Http中的缓存（一） 多级缓存结构</a><br><a href="/blog/http/http-etag-cache.html">Http中的缓存（二） HTTP中的缓存</a><br><a href="/blog/http/http-cache-serviceworker.html">Http中的缓存（三） PWA中的ServiceWorker</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>缓存</strong>相信现在这个词大家都不陌生，因为在当前的应用中被广泛的应用。因为<strong>缓存</strong>会带来更高的<strong>性能</strong>、<strong>用户体验</strong>，同时也会<strong>节省流量</strong>、<strong>离线体验</strong>等等好处。</p>
<p>关于缓存的文章分为三篇：<strong>多级缓存结构</strong>、<strong>HTTP缓存详解</strong>、<strong>离线缓存</strong></p>
<h3 id="缓存的分层"><a href="#缓存的分层" class="headerlink" title="缓存的分层"></a>缓存的分层</h3><p><strong>缓存</strong>大致分为如下：</p>
<ul>
<li><strong>客户端/浏览器缓存</strong></li>
<li><strong>http/服务器缓存</strong></li>
<li><strong>cdn缓存</strong></li>
<li><strong>代理服务器缓存</strong></li>
<li><strong>后端进程缓存redis、lru等等</strong></li>
<li><strong>分布式缓存</strong></li>
<li><strong>数据库</strong></li>
</ul>
<p>可以在下面几层做缓存大致如下：</p>
<p><img src="../../images/http/http-cache-1-1.png" height="300" alt="http-cache"></p>
<h3 id="多层缓存流程"><a href="#多层缓存流程" class="headerlink" title="多层缓存流程"></a>多层缓存流程</h3><p>整个的缓存判断流程是：</p>
<ol>
<li><strong>用户刷新页面发出请求</strong></li>
<li>客户端/浏览器是否命中<code>serviceWorker</code>、<strong>强缓存（缓存策略）</strong>、<strong>协商缓存</strong></li>
<li><strong>cdn缓存</strong></li>
<li><strong>代理服务器缓存</strong></li>
<li><strong>进程缓存</strong></li>
<li><strong>分布式缓存</strong></li>
<li><strong>数据库</strong></li>
</ol>
<p>这里主要记述<strong>客户端/浏览器缓存</strong>、<strong>http/服务器缓存</strong>的一些使用和细节。</p>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p><code>HTTP</code>缓存基本上可以分为两类： <strong>一类强缓存（有效期策略）</strong>、<strong>另一类 协商缓存（资源唯一标识符）</strong>。它们缓存在不同的位置，按照分类为：<strong>本地硬盘缓存</strong>、<strong>本地内存缓存</strong>。当时对于一些不同的文件类型要用不同的缓存来做，同时让它们缓存在不同的位置。<br>跟随<strong>移动端</strong>应用的发展，为了提高用户离线的体验，延伸出了不同<strong>离线缓存方案</strong>大致有两种实现方式：<strong>AppCache</strong>、<strong>ServiceWorker</strong>两种方式。</p>
<p>在这里一些详细的实现方式和细节不多做解释，在下片文章<a href="/blog/http/http-etag-cache.html">Http中的缓存（二） HTTP中的缓存</a>来详细的记录，比如<strong>有限期是怎么验证的</strong>、<strong>详细的配置</strong>、<strong>不同的本地缓存储存在那</strong>、<strong>它们之间的对比和适用缓存文件</strong>等等。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>强缓存</strong>可以用三种实行方式： <code>cache-control</code>、<code>Expires</code>、<code>Pragma</code>它们都是通过<strong>有效期</strong>来决定是否命中缓存的。</p>
<p>大致的优先级如下： 在本地 <code>Cache-Control &gt; Expires，Pragma 在不支持 Cache-Control</code> 时生效。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存</strong>可以用两种种实行方式： <code>Last-Modified/If-Modified-Since</code>、<code>Etag/If-None-Match</code>它们的实现方式是不同的。</p>
<p><strong>Last-Modified/If-Modified-Since</strong>是通过<strong>有限期</strong>来检验是否使用缓存，而<strong>Etag/If-None-Match</strong>它是通过<strong>唯一资源标识符</strong>来判断是否使用缓存。<br>同时它们的整体流程也是不同，比如说<strong>Last-Modified/If-Modified-Since</strong>返回的<strong>HTTP状态</strong>为<strong>200状态码</strong>，而<strong>Etag/If-None-Match</strong>它返回的是<strong>304状态码</strong>。</p>
<h3 id="储存位置"><a href="#储存位置" class="headerlink" title="储存位置"></a>储存位置</h3><p>从缓存位置上来看，分为<strong>4种</strong>，<strong>从上往下依次检查</strong>是否命中，如果但都没有命中则重新发起请求。</p>
<ul>
<li><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 <code>Service Worker</code>的话，传输协议必须为 <code>HTTPS</code>。</li>
<li><code>Memory Cache</code> 也就是<strong>内存</strong>中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。</li>
<li><code>Disk Cache</code> 也就是存储在硬盘中的缓存。</li>
<li><code>Push Cache</code>（推送缓存）是 <code>HTTP/2</code> 中的内容，当以上三种缓存都没有命中时，它才会被使用。</li>
</ul>
<p>它们之间是有优缺点的，比如说静态资源适用于<code>Memory Cache</code>。</p>
<h3 id="用户操作对缓存的影响"><a href="#用户操作对缓存的影响" class="headerlink" title="用户操作对缓存的影响"></a>用户操作对缓存的影响</h3><p>当用户的操作比如<strong>地址栏回车</strong>、<strong>前进回退</strong>、<strong>F5刷新</strong>、<strong>Ctrl+F5强制刷新</strong>等等对缓存的影响。大致如下图所示：</p>
<p><img src="../../images/http/http-cache-1-2.png" alt="http-cache"></p>
<p>在这里就不细究了不然这篇文章太长了。</p>
<h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><p><strong>CND</strong>的全称是<strong>Content Delivery NetWork</strong>内容分发网络。<strong>HTTP</strong>缓存主要是对一些<strong>客户端/浏览器</strong>中的静态资源和<strong>不长更新的数据</strong>资源。<br><strong>CDN</strong>是在<strong>客户端</strong>和<strong>服务器</strong>端加设的一层，可以让<strong>CDN</strong>为应用服务器提供缓存，如果在 <strong>CDN</strong> 上缓存，就不用再请求应用服务器了。并且 <strong>HTTP</strong> 缓存提到的两种策略同样可以在 <strong>CDN</strong>服务器执行。</p>
<h3 id="CDN流程"><a href="#CDN流程" class="headerlink" title="CDN流程"></a>CDN流程</h3><p><strong>CDN</strong>缓存流程大致如下：<br><img src="../../images/http/http-cache-1-3.png" alt="http-cache"></p>
<ul>
<li>客户端发送 <code>URL</code> 给 <code>DNS</code> 服务器。</li>
<li><code>DNS</code> 通过域名解析，把请求指向 <code>CDN</code> 网络中的 <code>DNS</code> 负载均衡器。</li>
<li><code>DNS</code> 负载均衡器将最近 <code>CDN</code> 节点的 <code>IP</code> 告诉 <code>DNS</code>，<code>DNS</code> 告之客户端最新 <code>CDN</code> 节点的 <code>IP</code>。</li>
<li>客户端请求最近的 <code>CDN</code> 节点。</li>
<li><code>CDN</code> 节点从应用服务器获取资源返回给客户端，同时将静态信息缓存。</li>
</ul>
<blockquote>
<p>注意：客户端下次互动的对象就是 <code>CDN</code> 缓存了，<code>CDN</code> 可以和应用服务器同步缓存信息。</p>
</blockquote>
<p><code>CDN</code> 接受客户端的请求，它就是离客户端最近的服务器，它后面会链接多台服务器，起到了缓存和负载均衡的作用。</p>
<h2 id="负载均衡缓存"><a href="#负载均衡缓存" class="headerlink" title="负载均衡缓存"></a>负载均衡缓存</h2><p>说完客户端（<code>HTTP</code>）缓存和 <code>CDN</code> 缓存，我们离应用服务越来越近了，在到达应用服务之前，请求还要经过<strong>负载均衡器</strong>。</p>
<p>虽说它的主要工作是对<strong>应用服务器进行负载均衡</strong>，但是它也可以作<strong>缓存</strong>。可以把一些修改频率不高的数据缓存在这里，例如：用户信息，配置信息。通过服务定期刷新这个缓存就行了。</p>
<p><img src="../../images/http/http-cache-1-4.png" alt="http-cache"></p>
<p>以 <code>Nginx</code> 为例，我们看看它是如何工作的：</p>
<ul>
<li>用户请求在达到应用服务器之前，会<strong>先访问 Nginx 负载均衡器</strong>，如果发现<strong>有缓存信息</strong>，直接<strong>返回</strong>给用户。</li>
<li>如果<strong>没有发现</strong>缓存信息，<strong>Nginx 回源</strong>到应用服务器获取信息。</li>
<li>另外，有一个<strong>缓存更新服务</strong>，定期把应用服务器中<strong>相对稳定</strong>的信息更新到 <strong>Nginx 本地缓存</strong>中。</li>
</ul>
<h2 id="进程内缓存"><a href="#进程内缓存" class="headerlink" title="进程内缓存"></a>进程内缓存</h2><p>通过了<strong>客户端</strong>，<strong>CDN</strong>，<strong>负载均衡器</strong>，我们终于来到了应用服务器。应用服务器上部署着一个个应用，这些应用以进程的方式运行着，那么在进程中的缓存是怎样的呢？</p>
<p><strong>进程内缓存又叫托管堆缓存</strong>，以 Java 为例，这部分缓存放在<strong>JVM的托管堆</strong>上面，同时会受到<strong>托管堆回收算法</strong>的影响。</p>
<p>由于其运行在内存中，对<strong>数据的响应速度很快</strong>，通常我们会把热点数据放在这里。</p>
<p>在<strong>进程内缓存没有命中</strong>的时候，我们会去<strong>搜索进程外的缓存或者分布式缓存</strong>。这种缓存的好处是<strong>没有序列化和反序列化</strong>，是<strong>最快的缓存</strong>。<strong>缺点是缓存的空间不能太大</strong>，<strong>对垃圾回收器的性能有影响</strong>。</p>
<p>目前比较流行的实现有 <strong>Ehcache</strong>、<strong>GuavaCache</strong>、<strong>Caffeine</strong>。这些架构可以很方便的把一些热点数据放到<strong>进程内的缓存</strong>中。</p>
<p>这里我们需要关注几个缓存的回收策略，具体的实现架构的回收策略会有所不同，但大致的思路都是一致的：</p>
<ul>
<li><strong>FIFO（First In First Out）</strong>：先进先出算法，最先放入缓存的数据最先被移除。</li>
<li><strong>LRU（Least Recently Used）</strong>：最近最少使用算法，把最久没有使用过的数据移除缓存。</li>
<li><strong>LFU（Least Frequently Used）</strong>：最不常用算法，在一段时间内使用频率最小的数据被移除缓存。</li>
</ul>
<p>在分布式架构的今天，多应用中如果采用进程内存缓存会存在数据一致性的问题。</p>
<p>这里推荐两个方案：</p>
<ul>
<li><strong>消息队列修改方案</strong></li>
<li><strong>Timer修改方案</strong></li>
</ul>
<h3 id="消息队列修改方案"><a href="#消息队列修改方案" class="headerlink" title="消息队列修改方案"></a>消息队列修改方案</h3><p>应用在<strong>修改完自身缓存数据和数据库数据</strong>之后，给消息队列<strong>发送数据变化通知</strong>，其他<strong>应用订阅了消息通知</strong>，在收到通知的时候<strong>修改缓存数据</strong>。</p>
<p><img src="../../images/http/http-cache-1-5.png" alt="http-cache"></p>
<h3 id="Timer修改方案"><a href="#Timer修改方案" class="headerlink" title="Timer修改方案"></a>Timer修改方案</h3><p>为了<strong>避免耦合</strong>，<strong>降低复杂性</strong>，对“实时一致性”不敏感的情况下。每个应用都会<strong>启动一个 Timer</strong>，<strong>定时</strong>从数据库拉取最新的数据<strong>更新缓存</strong>。</p>
<p>不过在有的应用更新数据库后，其他节点通过 Timer 获取数据之间，会读到脏数据。这里需要控制好 Timer 的频率，以及应用与对实时性要求不高的场景。</p>
<p><img src="../../images/http/http-cache-1-11.png" alt="http-cache"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>场景一</strong>：<strong>只读数据</strong>，可以考虑在进程启动时加载到内存。当然，把数据加载到类似 Redis 这样的进程外缓存服务也能解决这类问题。</p>
</li>
<li><p><strong>场景二</strong>：<strong>高并发</strong>，可以考虑使用进程内缓存，例如：秒杀。</p>
</li>
</ul>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>说完进程内缓存，自然就过度到<strong>进程外缓存</strong>了。与进程内缓存不同，进程外缓存在应用运行的进程之外，它拥有<strong>更大的缓存容量</strong>，并且可以部署到<strong>不同的物理节点</strong>，通常会用<strong>分布式缓存</strong>的方式实现。</p>
<p>分布式缓存是与应用分离的缓存服务，最大的特点是，自身是一个独立的应用/服务，与本地应用隔离，<strong>多个应用可直接共享一个或者多个缓存应用/服务</strong>。</p>
<p><img src="../../images/http/http-cache-1-6.png" height="300" alt="http-cache"></p>
<p>既然是分布式缓存，缓存的数据会分布到不同的缓存节点上，每个缓存节点缓存的数据大小通常也是<strong>有限制</strong>的。</p>
<p>数据被缓存到不同的节点，为了能方便的访问这些节点，需要引入<strong>缓存代理</strong>，类似 Twemproxy。他会帮助请求找到对应的缓存节点。</p>
<p>同时如果缓存节点增加了，这个代理也会只能识别并且把新的缓存数据分片到新的节点，做横向的扩展。</p>
<p>为了<strong>提高缓存的可用性</strong>，会在原有的缓存节点上加入 <strong>Master/Slave 的设计</strong>。当缓存数据写入 <strong>Master 节点</strong>的时候，会<strong>同时同步</strong>一份到 <strong>Slave 节点</strong>。</p>
<p>一旦 <strong>Master</strong> 节点失效，可以通过代理直接切换到 <strong>Slave</strong> 节点，这时 <strong>Slave 节点就变成了 Master 节点</strong>，保证缓存的正常工作。</p>
<p>每个缓存节点还会提供缓存过期的机制，并且会把缓存内容定期以快照的方式保存到文件上，方便缓存崩溃之后启动预热加载。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>当缓存做成分布式的时候，数据会根据一定的规律分配到每个缓存应用/服务上。</p>
<p>如果我们把这些<strong>缓存应用/服务叫做缓存节点</strong>，每个节点一般都可以<strong>缓存一定容量的数据</strong>，例如：Redis 一个节点可以缓存 2G 的数据。</p>
<p>如果需要缓存的数据量比较大就需要扩展多个缓存节点来实现，这么多的缓存节点，客户端的请求不知道访问哪个节点怎么办？缓存的数据又如何放到这些节点上？</p>
<p>缓存代理服务已经帮我们解决这些问题了，例如：Twemproxy 不但可以帮助缓存路由，同时可以管理缓存节点。</p>
<p>这里有介绍三种缓存数据分片的算法，有了这些<strong>算法缓存代理</strong>就可以方便的找到分片的数据了。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p><code>Hash</code> 表是最常见的数据结构，实现方式是，对数据记录的<strong>关键值</strong>进行 <code>Hash</code>，然后再对需要分片的缓存节点个数进行取模得到的余数进行数据分配。</p>
<p>例如：有三条记录数据分别是 <code>R1，R2，R3</code>。他们的 ID 分别是 <code>01，02，03</code>，假设对这三个记录的 ID 作为关键值进行 Hash 算法之后的结果依旧是 <code>01，02，03</code>。</p>
<p>我们想把这三条数据放到三个缓存节点中，可以把这个结果分别对 3 这个数字取模得到余数，这个余数就是这三条记录分别放置的缓存节点。</p>
<p><img src="../../images/http/http-cache-1-7.png" alt="http-cache"></p>
<p><strong>Hash 算法是某种程度上的平均放置，策略比较简单，如果要增加缓存节点，对已经存在的数据会有较大的变动。</strong></p>
<h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p>一致性 <code>Hash</code> 是将数据按照特征值<strong>映射</strong>到一个<strong>**首尾相接</strong>的 <code>Hash</code>环上，同时也将缓存节点映射到这个环上。</p>
<p>如果要缓存数据，通过数据的<strong>关键值（Key）</strong>在环上找到自己存放的位置。这些数据按照自身的 <code>ID</code> 取 <code>Hash</code> 之后得到的值按照<strong>顺序</strong>在<strong>环上排列</strong>。</p>
<p><img src="../../images/http/http-cache-1-8.png" alt="http-cache"></p>
<p>如果这个时候要<strong>插入</strong>一条新的数据其 <code>ID</code> 是 <code>115</code>，那么就应该插入到如下图的位置</p>
<p><img src="../../images/http/http-cache-1-9.png" alt="http-cache"></p>
<p>同理如果要<strong>增加</strong>一个<strong>缓存节点</strong> <code>N4 150</code>，也可以放到如下图的位置。</p>
<p><img src="../../images/http/http-cache-1-10.png" alt="http-cache"></p>
<p><strong>这种算法对于增加缓存数据，和缓存节点的开销相对比较小。</strong></p>
<h4 id="Range-Based-算法"><a href="#Range-Based-算法" class="headerlink" title="Range Based 算法"></a>Range Based 算法</h4><p>这种方式是按照关键值（例如 <code>ID</code>）将数据划分成不同的区间，每个缓存节点负责一个或者多个区间。跟一致性哈希有点像。</p>
<p>例如：存在三个缓存节点分别是 <code>N1，N2，N3</code>。他们用来存放数据的区间分别是，<code>N1(0, 100]</code>， <code>N2(100, 200]</code>， <code>N3(300, 400]</code>。</p>
<p>那么数据根据自己 <code>ID</code> 作为关键字做 <code>Hash</code> 以后的结果就会分别对应放到这几个区域里面了。</p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>根据事物的两面性，在<strong>分布式缓存带来高性能</strong>的同时，我们也需要重视它的可用性。那么哪些潜在的风险是我们需要防范的呢？</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>当<strong>缓存失效</strong>，<strong>缓存过期被清</strong>除，缓存<strong>更新</strong>的时候。请求是<strong>无法命中缓存</strong>的，这个时候请求会直接<strong>回源到数据库</strong>。</p>
<p>如果上述情况<strong>频繁发生</strong>或者<strong>同时发生</strong>的时候，就会造成大面积的<strong>请求直接到数据库</strong>，造成<strong>数据库访问瓶颈</strong>。我们称这种情况为<strong>缓存雪崩</strong>。</p>
<p>从如下两方面来思考解决方案：</p>
<p>缓存方面：</p>
<ul>
<li><p><strong>避免缓存同时失效，不同的 key 设置不同的超时时间</strong>。</p>
</li>
<li><p>增加<strong>互斥锁</strong>，<strong>对缓存的更新操作进行加锁保护，保证只有一个线程进行缓存更新</strong>。缓存一旦失效可以通过缓存快照的方式迅速重建缓存。对缓存节点增加主备机制，当主缓存失效以后切换到备用缓存继续工作。</p>
</li>
</ul>
<p>设计方面，这里给出了几点建议供大家参考</p>
<ul>
<li><strong>熔断机制</strong>：某个缓存节点<strong>不能工作</strong>的时候，需要通知<strong>缓存代理不要</strong>把请求路由到该节点，减少用户等待和请求时长。</li>
<li><strong>限流机制</strong>：在<strong>接入层和代理层可以做限流</strong>，当缓存服务无法支持高并发的时候，前端可以把无法响应的请求放入到队列或者丢弃。</li>
<li><strong>隔离机制</strong>：<strong>缓存无法提供服务或者正在预热重建的时候</strong>，把该请求放入队列中，这样该请求因为被隔离就不会被路由到其他的缓存节点。</li>
<li>如此就不会因为这个节点的问题影响到其他节点。当缓存重建以后，再从队列中取出请求依次处理。</li>
</ul>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存一般是 <code>Key</code>，<code>Value</code> 方式存在，一个 <code>Key</code> 对应的 <code>Value</code> 不存在时，请求会回源到数据库。</p>
<p>假如对应的 <code>Value</code> 一直不存在，则会频繁的请求数据库，对数据库造成访问压力。如果有人利用这个漏洞攻击，就麻烦了。</p>
<p>解决方法：如果一个 <code>Key</code> 对应的 <code>Value</code> 查询返回为空，我们仍然把这个空结果缓存起来，如果这个值没有变化下次查询就不会请求数据库了。</p>
<p>将所有可能存在的数据哈希到一个足够大的 <code>Bitmap</code> 中，那么不存在的数据会被这个 <code>Bitmap</code> 过滤器拦截掉，避免对数据库的查询压力。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>在数据请求的时候，某一个缓存<strong>刚好失效或者正在写入缓存</strong>，同时这个缓存数据可能会在<strong>这个时间点被超高并发请求</strong>，成为“热点”数据。</p>
<p>这就是缓存击穿问题，这个和缓存雪崩的区别在于，这里是<strong>针对某一个缓存</strong>，前者是针对多个缓存。</p>
<p>解决方案：导致问题的原因是在同一时间读/写缓存，所以<strong>只有保证同一时间只有一个线程写</strong>，写完成以后，其他的请求再使用缓存就可以了。</p>
<p>比较常用的做法是使用 <strong>mutex（互斥锁）</strong>。在缓存失效的时候，不是立即写入缓存，而是先设置一个<strong> mutex（互斥锁）</strong>。当缓存被写入完成以后，再放开这个锁让请求进行访问。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多层缓存结构：</p>
<p><strong>缓存结构</strong>大致分为如下：</p>
<ul>
<li><strong>客户端/浏览器缓存</strong></li>
<li><strong>http/服务器缓存</strong></li>
<li><strong>cdn缓存</strong></li>
<li><strong>代理服务器缓存</strong></li>
<li><strong>后端进程缓存redis、lru等等</strong></li>
<li><strong>分布式缓存</strong></li>
<li><strong>数据库</strong></li>
</ul>
<p>其中，前两种缓存静态数据，后三种缓存动态数据：</p>
<ul>
<li><strong>HTTP 缓存包括强缓存（缓存策略）和协商缓存</strong>。</li>
<li><strong>CDN 缓存和 HTTP 缓存是好搭档</strong>。</li>
<li><strong>负载均衡器缓存相对稳定资源，需要服务协助工作</strong>。</li>
<li><strong>进程内缓存，效率高，但容量有限制，有两个方案可以应对缓存同步的问题</strong>。</li>
<li><strong>分布式缓存容量大，能力强，牢记三个性能算法并且防范三个缓存风险</strong>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/post/5d86cf7f6fb9a06b211724e7?utm_source=gold_browser_extension#heading-13" target="_blank" rel="noopener">一篇文章让你明白你多级缓存的分层架构</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>资源实现懒加载 （未完成）</title>
    <url>/blog/performance/preformance-lazy.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>道</title>
    <url>/blog/taoist/taoist-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Taoist</category>
      </categories>
      <tags>
        <tag>Taoist</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的类数组和一些常见的面试题 （未完成）</title>
    <url>/blog/javascript/javascript-array-list.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Http系列(-) Http发展历史</title>
    <url>/blog/http/http-http2.html</url>
    <content><![CDATA[<p><strong><em>知者不言，言者不知。——老子</em></strong></p>
<blockquote>
<p><a href="/blog/http/http-http2.html">Http 系列(-) Http 发展历史</a><br><a href="/blog/http/http-http2-1.html">Http 系列(二) Http2 中的多路复用</a><br><a href="/blog/http/http-tcp.html">Http 系列(三) Http/Tcp 三次握手和四次挥手</a><br><a href="/blog/http/http-get-post.html">Http 系列(四) Http 中 Get/Post 的区别</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><strong>Hyper Text Transfer Protocol（超文本传输协议）</strong>,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。</p>
<p><strong>超文本传输 ​​ 协议（HTTP）</strong>是用于传输诸如 HTML 的超媒体文档的<strong>应用层协议</strong>。它被设计用于 Web 浏览器和 Web 服务器之间的通信，但它也可以用于其他目的。<br><strong>HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。也要通过三次握手，四次挥手。</strong></p>
<p><strong>HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统</strong>。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。</p>
<p><strong>HTTP 协议工作于客户端-服务端架构为上</strong>。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="../../images/http/http2.0-1-1.png" alt="http2.0"></p>
<h2 id="HTTP-协议版本"><a href="#HTTP-协议版本" class="headerlink" title="HTTP 协议版本"></a>HTTP 协议版本</h2><p>大致版本可以分为以下四个：</p>
<ul>
<li>HTTP/0.9</li>
<li>HTTP/1.0</li>
<li>HTTP/1.1</li>
<li>HTTP/2</li>
</ul>
<p>发展的历史如下：<br><img src="../../images/http/http2.0-1-2.png" alt="http2.0"></p>
<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>HTTP 是基于 <font color="#ff502c">TCP/IP 协议的应用层协议</font>。<strong>它不涉及数据包（packet）传输</strong>，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。<br>最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令 GET。</p>
<blockquote>
<p>GET /index.html</p>
</blockquote>
<p>上面命令表示，<strong>TCP 连接（connection）建立后</strong>，客户端向服务器请求（request）网页 index.html。协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>
<p>服务器发送完毕，就关闭 TCP 连接。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>1996 年 5 月，HTTP/1.0 版本发布，内容大大增加。<br>相对于 HTTP/0.9 大致增加了如下几点：</p>
<ul>
<li>首先，<strong>任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础</strong>。</li>
<li>其次，<strong>除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段</strong>。</li>
<li>再次，<strong>HTTP 请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据</strong>。</li>
<li>其他的新增功能还包括状态码<strong>（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）</strong>等。</li>
</ul>
<p>当时其实也存在一些别的问题如下：</p>
<ul>
<li><strong>HTTP/1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求</strong>。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</li>
<li><strong>TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）</strong>。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>1997 年 1 月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了 20 年后的今天，直到现在还是最流行的版本。</p>
<p>相对于 HTTP/1.0 版本 HTTP/1.1 做了一些优化大致如下：</p>
<ul>
<li><p><strong>长连接：</strong> <font color="#ff502c">HTTP 1.1 支持长连接（PersistentConnection）</font>和<font color="#ff502c">请求的流水线（Pipelining）处理</font>，在一个 TCP 连接上可以传送<font color="#ff502c">多个 HTTP 请求和响应</font>，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中<font color="#ff502c">默认开启 Connection： keep-alive</font>，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p>
</li>
<li><p><strong>缓存处理：</strong>在 HTTP1.0 中主要使用 header 里的<font color="#ff502c">If-Modified-Since,Expires</font>来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如<font color="#ff502c">Entity tag</font>，<font color="#ff502c">If-Unmodified-Since</font>, <font color="#ff502c">If-Match</font>, <font color="#ff502c">If-None-Match</font>等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p><strong>带宽优化及网络连接的使用</strong>，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，<font color="#ff502c">并且不支持断点续传功能</font>，HTTP1.1 则在请求头引入了<font color="#ff502c">range 头域</font>，它允许只请求资源的某个部分，即返回码是<font color="#ff502c">206（Partial Content）</font>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li><p><strong>错误通知的管理</strong>，在 HTTP1.1 中新增了<strong>24 个错误状态响应码</strong>，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p><strong>Host 头处理</strong>，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</p>
</li>
</ul>
<p>但是同时也存在一些问题如下：</p>
<ul>
<li>虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。<strong>这称为”队头堵塞”（Head-of-line blocking）</strong>。</li>
<li>HTTP1.x 在传输数据时，所有传输的内容都是<font color="#ff502c">明文</font>，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li>
<li>HTTP1.x 在使用时，<font color="#ff502c">header 里携带的内容过大</font>，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</li>
<li>虽然 HTTP1.x 支持了 keep-alive，来弥补多次创建连接产生的延迟，但是 keep-alive 使用多了同样会给<font color="#ff502c">服务端带来大量的性能压力</font>，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive 可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li>
</ul>
<h2 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h2><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。<br>这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。SPDY 可以说是综合了 HTTPS 和 HTTP 两者有点于一体的传输协议，主要解决：</p>
<ul>
<li><strong>降低延迟</strong>，针对 HTTP 高延迟的问题，SPDY 优雅的采取了<font color="#ff502c"><strong>多路复用（multiplexing）</strong></font>。多路复用通过多个请求 stream 共享一个 tcp 连接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。</li>
<li><strong>请求优先级（request prioritization）</strong>。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。<font color="#ff502c">SPDY 允许给每个 request 设置优先级</font>，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li>
<li><strong>header 压缩</strong>。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li>
<li><strong>基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性</strong>。</li>
<li><strong>服务端推送（server push）</strong>，采用了 SPDY 的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。</li>
</ul>
<p>SPDY 构成图：<br><img src="../../images/http/http2.0-1-3.png" alt="http2.0"></p>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p><code>HTTP/2</code> 可以说是 <code>SPDY</code> 的升级版（其实原本也是基于 <code>SPDY</code> 设计的），但是<code>HTTP2.0</code> 跟 <code>SPDY</code> 仍有不同的地方，主要是以下两点：</p>
<ul>
<li><code>HTTP2.0</code> 支持明文 <code>HTTP</code> 传输，而 <code>SPDY</code> 强制使用 <code>HTTPS</code></li>
<li><code>HTTP2.0</code> 消息头的压缩算法采用 <code>HPACK</code>，而非 <code>SPDY</code> 采用的 <code>DEFLATE</code></li>
</ul>
<p>HTTP/2 的新特性:</p>
<ul>
<li>二进制分帧：<code>HTTP/2</code> 的所有帧都采用二进制编码</li>
<li>多路复用 (<code>Multiplexing</code>)</li>
<li>请求优先级</li>
<li><code>header</code> 压缩</li>
<li>服务端推送</li>
</ul>
<h3 id="二进制分帧：HTTP-2-的所有帧都采用二进制编码"><a href="#二进制分帧：HTTP-2-的所有帧都采用二进制编码" class="headerlink" title="二进制分帧：HTTP/2 的所有帧都采用二进制编码"></a>二进制分帧：HTTP/2 的所有帧都采用二进制编码</h3><p>先理解几个概念：</p>
<ul>
<li><strong>帧</strong>：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。</li>
<li><strong>消息</strong>：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li>
<li><strong>流</strong>：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；</li>
</ul>
<p>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</strong><br><img src="../../images/http/http2.0-1-4.png" alt="http2.0"></p>
<h4 id="帧、流、消息的关系"><a href="#帧、流、消息的关系" class="headerlink" title="帧、流、消息的关系"></a>帧、流、消息的关系</h4><p><strong>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成</strong>。<br><strong>帧是流中的数据单位。一个数据报的 header 帧可以分成多个 header 帧，data 帧可以分成多个 data 帧。</strong></p>
<h3 id="多路复用-Multiplexing"><a href="#多路复用-Multiplexing" class="headerlink" title="多路复用 (Multiplexing)"></a>多路复用 (Multiplexing)</h3><p><strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息</strong>。即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。多路复用原理图：<br><img src="../../images/http/http2.0-1-5.png" alt="http2.0"></p>
<h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><ul>
<li>把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。</li>
<li>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。</li>
<li>HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。</li>
</ul>
<h3 id="header-压缩"><a href="#header-压缩" class="headerlink" title="header 压缩"></a>header 压缩</h3><p>HTTP1.x 的 header 带有大量信息，而且每次都要<strong>重复发送</strong>，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自<strong>cache 一份 header fields 表</strong>，既<font color="#ff502c">避免了重复 header 的传输</font>，又<font color="#ff502c">减小了需要传输的大小</font>。<br>为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略：</p>
<ul>
<li><strong>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，不再重复发送 header</strong></li>
<li><strong>首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</strong></li>
<li><strong>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值</strong></li>
</ul>
<p>两次请求不相同的 header，传说的 header 如下图所示：<br><img src="../../images/http/http2.0-1-10.png" alt="http2.0"></p>
<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p><strong>Server Push 即服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”</strong>。<br>服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求，服务端可以提前给客户端推送必要的资源，这样可以减少请求延迟时间，例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不是等到 HTML 解析到资源时发送请求，大致过程如下图所示：<br><img src="../../images/http/http2.0-1-11.png" alt="http2.0"></p>
<p>注意：<br><strong>所有推送的资源都遵守同源策略</strong>。<br><strong>服务器必须遵循请求- 响应的循环，只能借着对请求的响应推送资源</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 http/0.9 到 http/2 的发展，有了很多的优化点如下：</p>
<ul>
<li>二进制分帧：HTTP/2 的所有帧都采用二进制编码</li>
<li>多路复用 (Multiplexing)</li>
<li>请求优先级</li>
<li>header 压缩</li>
<li>服务端推送<br>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用<font color="#ff502c">二进制编码</font>，HTTP/2 的通过支持请求与响应的<font color="#ff502c">多路复用</font>来减少延迟，通过<font color="#ff502c">压缩 HTTP 首部字段</font>将协议开销降至最低，同时增加对<font color="#ff502c">请求优先级</font>和<font color="#ff502c">服务器端推送</font>的支持。<br>在上面也分别描述的大致优化的细节，后面会有一个专门来讲从多个 Tcp 请求到多路复用的发展。<!-- 在HTTP/2中优化在对请求做了很多优化主要是多路复用，各个版本对比大致如下：
**HTTP/0.9**
<img src="../../images/http/http2.0-1-6.png" alt="http2.0" width="50%"/>
上图：连接无法复用
**HTTP/1.0**
<img src="../../images/http/http2.0-1-7.png" alt="http2.0" width="50%"/>
上图：设置Connection:Keep-Alive，保持连接在一段时间内不断开。
**HTTP/1.1**
<img src="../../images/http/http2.0-1-8.png" alt="http2.0" width="50%"/>
上图：HTTPpipelining：建立多个连接
**HTTP/2**
<img src="../../images/http/http2.0-1-9.png" alt="http2.0" width="50%"/>
上图：多路复用 -->
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s/fwRzZ8RWouyAhBiYDe9M7w" target="_blank" rel="noopener">HTTP 协议入门</a><br><a href="https://mp.weixin.qq.com/s/x-KE9B3s6GyJbS-T3oya4w" target="_blank" rel="noopener">HTTP,HTTP2.0,SPDY,HTTPS 你应该知道的一些事</a><br><a href="https://mp.weixin.qq.com/s/0m4R31gSV-DfY_-VOSb_jA" target="_blank" rel="noopener">http2.0 的时代真的来了…</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Http2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Https系列（二） https怎么建立连接的 （未完成）</title>
    <url>/blog/http/http-https.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>Https系列 (一) https和http的区别 （未完成）</title>
    <url>/blog/http/https.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript类型转换（一） 常见数据类型</title>
    <url>/blog/javascript/javascript-Type-conversion.html</url>
    <content><![CDATA[<p><strong><em>莫逆于心，遂相与为友。——庄子</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript数据类型（一） 常见数据类型</a><br><a href="/blog/javascript/javascript-type-one-question.html">JavaScript数据类型（二） 类型转换</a><br><a href="/blog/javascript/javascript-type-one-questionone.html">JavaScript数据类型（三）常见的面试题</a><br><a href="/blog/javascript/javascript-IF-False-options.html">JavaScript数据类型（四）IF 转换规则</a><br><a href="/blog/javascript/javascript-false-true.html">JavaScript数据类型（五）== 混乱的转换规则</a><br><a href="/blog/javascript/javascript-bool-type.html">JavaScript数据类型（六）多种数据类型判断方法</a></p>
</blockquote>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><hr>
<p>JavaScript中的内置类型，七中类型中的又分为两大类：<strong>基本类型（值类型）和引用类型</strong><br>基本类型有六种：<strong>null</strong>、<strong>number</strong>、<strong>string</strong>、<strong>undefined</strong>、<strong>boolean</strong>、<strong>symbol</strong><br>引用类型：<strong>object</strong><br>所有基本类型的值都是<strong>不可改变</strong>的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。<br>变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p>
<p><strong>基本类型</strong> 是储存在<font color="#ff502c">栈</font>中<br><strong>引用类型</strong> 引用数据类型的<font color="#ff502c">值</font>是保存在<font color="#ff502c">堆内存</font>中的对象。JavaScript<font color="#ff502c">不允许</font>直接访问堆内存中的位置，堆内存中的<font color="#ff502c">值地址引用</font>保存在<font color="#ff502c">栈</font>中，我们都是操作<font color="#ff502c">栈中</font>的地址引用。</p>
<p><strong>如果想看数据结构如堆、栈、链表等等，可以在本站搜索。</strong></p>
<p>如下图所示：</p>
<p><img src="../../images/javascript/javascript-type.png" alt="javascript-type" width="60%" style="margin: 0 auto;"></p>
<p>如果不知道怎么判断数据类型的请看另一篇文章 <a href="/blog/javascript/javascript-bool-type.html">JavaScript类型判断</a></p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>像基本类型如果<strong>String、Boolean、Number</strong>我们就不细写了，讲一下里面比较特殊的。如 <strong>null、undefined、NaN、symbol</strong>等等。</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>值<code>null</code>是一个字面量，他不像<strong>undefined</strong>是一个<strong>全局对象</strong>的一个<strong>属性</strong>。<strong>null</strong>是表示缺少的标识，知识变量未被指向任何对象，也可以看做是一个<strong>空指针对象</strong>。</p>
<p>如果我们在浏览器中赋值 <strong>null</strong>,他会报错如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chrome Google Chrome 已是最新版本</span></span><br><span class="line"><span class="comment">// 版本 75.0.3770.100（正式版本） （64 位）</span></span><br><span class="line"><span class="literal">null</span> = <span class="string">'111'</span>;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>
<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p><strong>undefined</strong>它是一个JavaScript<strong>基本类型</strong>。它也是一个<strong>全局的属性</strong>undefined表示undefined，undefined也可以表示一个被<strong>声明</strong>没有被<strong>赋值</strong>的<strong>变量</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">undefined 属性的属性特性：</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">writable</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">enumerable</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">configurable</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
<p>在现代浏览器（JavaScript 1.8.5/Firefox 4+），自ECMAscript5标准以来undefined是一个不能被配置（non-configurable），不能被重写（non-writable）的属性。即便事实并非如此，也要避免去重写它。</p>
<p>如果我们在浏览器中赋值 <strong>undefined</strong>, 因为他的writable是为false,所以我们的赋值没有生效，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chrome Google Chrome 已是最新版本</span></span><br><span class="line"><span class="comment">// 版本 75.0.3770.100（正式版本） （64 位）</span></span><br><span class="line"><span class="literal">undefined</span> = <span class="string">'111'</span>;</span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><strong>全局属性</strong> NaN 的值表示<strong>不是</strong>一个数字（Not-A-Number），<code>NaN</code>是一种特殊的<code>Number</code>类型.<br><code>NaN</code> 属性的初始值就是 <code>NaN</code>，和 <code>Number.NaN</code> 的值一样。在现代浏览器中（ES5中），<code>NaN</code> 属性是一个不可配置（non-configurable），不可写（non-writable）的属性。但在ES3中，这个属性的值是可以被更改的，但是也应该避免覆盖。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>NaN</strong> 属性的属性特性：</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">writable</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">enumerable</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">configurable</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
<p>如果我们在浏览器中赋值 <strong>NaN</strong>, 因为他的<code>writable</code>是为<code>false</code>,所以我们的赋值没有生效，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chrome Google Chrome 已是最新版本</span></span><br><span class="line"><span class="comment">// 版本 75.0.3770.100（正式版本） （64 位）</span></span><br><span class="line"><span class="literal">NaN</span> = <span class="string">'111'</span>;</span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>判断NaN</strong><br>我们必须使用 <strong>Number.isNaN()</strong> 或 <strong>isNaN()</strong> 函数和比较中<strong>不等于</strong>它<strong>自己</strong>来判断是否为NaN，为什么NaN不等于NaN自己，这是因为NaN它使表示一个<strong>集合</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p>这个技术术语页面同时描述了一种称为 “<strong>symbol</strong>” 的数据类型，还有一个像类的函数 “<strong>Symbol()</strong>”，用来创建 <strong>symbol</strong> 数据类型实例。</p>
<p>数据类型 “<strong>symbol</strong>” 是一种原始数据类型，该类型的性质在于这个类型的值可以用来创建匿名的对象属性。该数据类型通常被用作一个对象属性的键值——当你想让它是私有的时候。<br><code>Symbol</code> 是 JavaScript 的 原始数据类型 ，Symbol实例是唯一且不可改变的.<br>符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值(如下). 在某些语言当中也有类似的原子类型(Atoms).<br>我们只能通过<code>Symbol(&#39;ssss&#39;)</code>声明<code>symbol</code>，不能通过<code>new</code>声明<code>Symbol</code>.</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在计算机科学中, 对象是指内存中的可以被 标识符引用的一块区域.<br>在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。<br>ECMAScript定义的对象中有两种属性：数据属性和访问器属性。</p>
<p><strong>数据属性</strong><br>数据属性的特性(Attributes of a data property)</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[[Value]]</td>
<td style="text-align:center">任何Javascript类型</td>
<td style="text-align:center">包含这个属性的数据值。</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">[[Writable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 false，则该属性的 [[Value]] 特性 不能被改变。</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">[[Enumerable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 true，则该属性可以用 for…in 循环来枚举。</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">[[Configurable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 false，则该属性不能被删除，并且 除了 [[Value]] 和 [[Writable]] 以外的特性都不能被改变。</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<p>还有一些过时的数据属性<strong>Read-only</strong>、<strong>DontEnum</strong>、<strong>DontDelete</strong><br><strong>访问器属性</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[[Get]]</td>
<td style="text-align:center">函数对象或者 undefined</td>
<td style="text-align:center">该函数使用一个空的参数列表，能够在有权访问的情况下读取属性值。另见 get。</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">[[Set]]</td>
<td style="text-align:center">函数对象或者 undefined</td>
<td style="text-align:center">该函数有一个参数，用来写入属性值，另见 set。</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">[[Enumerable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 true，则该属性可以用 for…in 循环来枚举。</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">[[Configurable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 false，则该属性不能被删除，并且 除了 [[Value]] 和 [[Writable]] 以外的特性都不能被改变。</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>注意：这些特性只有 JavaScript 引擎才用到，因此你不能直接访问它们。所以特性被放在两对方括号中，而不是一对。</li>
</ul>
</blockquote>
<h4 id="“标准的”-对象-和函数"><a href="#“标准的”-对象-和函数" class="headerlink" title="“标准的” 对象, 和函数"></a>“标准的” 对象, 和函数</h4><p><strong>对象</strong><br>一个 Javascript 对象就是键和值之间的映射.。键是一个字符串（或者 Symbol） ，值可以是任意类型的值。 这使得对象非常符合 哈希表。<br><strong>函数</strong><br>函数是一个附带可被调用功能的常规对象。<br><strong>日期</strong><br>当你想要显示日期时，毋庸置疑，使用内建的 Date 对象。<br><strong>数组和类型数组</strong><br>数组是一种使用整数作为键(integer-key-ed)属性和长度(length)属性之间关联的常规对象。<br>Int8Array、Uint8Array、Uint8ClampedArray    、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array、Float64Array<br><strong>键控集: Maps, Sets, WeakMaps, WeakSets</strong><br>Map, Set, WeakMap, WeakSet</p>
<h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>JavaScript是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。这意味着我们不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="string">'one'</span>; <span class="comment">// one is a String now</span></span><br><span class="line">one = <span class="number">456</span>; <span class="comment">// one is a Number now</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。<br>JavaScript中的内置类型，七中类型中的又分为两大类：基本类型（值类型）和引用类型</p>
<p>基本类型有六种：<strong>null</strong>、<strong>number</strong>、<strong>string</strong>、<strong>undefined</strong>、<strong>boolean</strong>、<strong>symbol</strong><br>引用类型：<strong>object</strong></p>
<p>所有基本类型的值都是<strong>不可改变</strong>的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。</p>
<p><strong>基本类型</strong> 是储存在<font color="#ff502c">栈</font>中</p>
<p><strong>引用类型</strong> 引用数据类型的<font color="#ff502c">值</font>是保存在<font color="#ff502c">堆内存</font>中的对象。JavaScript<font color="#ff502c">不允许</font>直接访问堆内存中的位置，堆内存中的<font color="#ff502c">值地址引用</font>保存在<font color="#ff502c">栈</font>中，我们都是操作<font color="#ff502c">栈中</font>的地址引用。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>http-fetch现在新的fetch请求方法 （未完成）</title>
    <url>/blog/http/http-fetch.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title>基于tcp的socket （未完成）</title>
    <url>/blog/http/http-socket.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>尾递归和普通的递归的区别 （未完成）</title>
    <url>/blog/algorithm/algorithm-tailCall.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（一）线性表 （顺序表、链表、栈和队列） （未完成）</title>
    <url>/blog/algorithm/algorithm-awaly-structure.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（二）二叉树 （未完成）</title>
    <url>/blog/algorithm/algorithm-awaly-tree.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（二）二叉树（先序遍历、中序遍历、后续遍历） （未完成）</title>
    <url>/blog/algorithm/algorithm-awaly-treeTwo.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（二）二叉树(广度优先、深度优先) （未完成）</title>
    <url>/blog/algorithm/algorithm-awaly-treeThree.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的页面性能优化 （未完成）</title>
    <url>/blog/performance/preformance-awaly.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中的class的babel的实现 （未完成）</title>
    <url>/blog/es6/es6-babel-class.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中的async用babel的实现 （未完成）</title>
    <url>/blog/es6/es6-babel-async.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中的for...of用babel的实现 （未完成）</title>
    <url>/blog/es6/es6-for-of.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型系列（三）Function、Object、null等等的关系和鸡蛋问题</title>
    <url>/blog/javascript/javascript-prototype-two.html</url>
    <content><![CDATA[<p><strong><em>將欲廢之，必固興之；將欲奪之，必固與之。——《道德經》</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-prototype.html">JavaScript原型系列（一）构造函数、原型和原型链</a><br><a href="/blog/javascript/javascript-prototype-one.html">JavaScript原型系列（二）什么是原型继承</a><br><a href="/blog/javascript/javascript-prototype-two.html">JavaScript原型系列（三）Function、Object、Null等等的关系和鸡蛋问题</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><img src="../../images/javascript/javascript-prototype-1-3.jpg" width="50%" alt="JavaScript-prototype"></p>
<p>基本上都知道原型链的尽头指向<code>null</code>，那么<code>Function.prototype</code>、<code>Object.prototype</code>、<code>null</code>、<code>Function.prototype.__proto__</code>、<code>Object.prototype.__proto__</code>、<code>function、object</code>之间的关系是什么，下面慢慢来记录一下。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><hr>
<p><strong>Object</strong> 构造函数创建一个对象包装器。<strong>JavaScript</strong>中的所有对象都来自 <code>Object</code>；所有对象从<code>Object.prototype</code>继承方法和属性，尽管它们可能被覆盖。</p>
<p><strong><em>Object 作为构造函数时，其 [[Prototype]] 内部属性值指向 Function.prototype</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="../../images/javascript/javascript-prototype-1-9.png" alt="JavaScript-prototype"></p>
<h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p><code>Object.prototype</code> 表示 <code>Object</code> 的原型对象，其 <code>[[Prototype]]</code> 属性是 <code>null</code>，访问器属性 <code>__proto__</code> 暴露了一个对象的内部 <code>[[Prototype]]</code> 。<code>Object.prototype</code>是浏览器底层根据 ECMAScript 规范创造的一个对象。</p>
<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>通过<strong>字面量</strong>实例化一个<code>object</code>，它的<code>__proto__</code>指向<code>Object.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>而通过<strong>new Object</strong>实例化一个<code>object</code>，它的<code>__proto__</code>指向<code>Object.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><hr>
<p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4" target="_blank" rel="noopener">摘录来自ECMAScript 5.1规范</a></p>
<blockquote>
<p>对象类型的成员，标准内置构造器 Function的一个实例，并且可做为子程序被调用。<br>注： 函数除了拥有命名的属性，还包含可执行代码、状态，用来确定被调用时的行为。函数的代码不限于 ECMAScript。</p>
</blockquote>
<p><strong>Function构造函数</strong>创建一个新的<code>Function</code>对象。在<strong>JavaScript</strong>中每个函数实际上都是一个<code>Function</code>对象。</p>
<h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p>全局的<code>Function</code>对象<strong>没有</strong>自己的属性和方法, 但是因为它本身也是<strong>函数</strong>，所以它也会通过原型链从<code>Function.prototype</code>上继承部分属性和方法。<code>Function.prototype</code>也是一个“函数对象“，其<code>[[prototype]]</code>内部属性值指向<code>Object.prototype</code>。</p>
<p>Function.prototype 的 [[Class]] 属性是 Function，所以这是一个函数，但又不大一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype; <span class="comment">// ƒ () &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.prototype; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>用 Function.prototype.bind 创建的函数对象没有 prototype 属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Function</span>.prototype.bind();</span><br><span class="line">foo.prototype; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><code>Function.prototype</code> 是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 <code>prototype</code> 属性，不然 <code>Function.prototype.prototype…</code> 将无休无止并且没有存在的意义。</p>
<p><code>Function.prototype.__proto__</code>指向<code>Object.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Function-proto"><a href="#Function-proto" class="headerlink" title="Function.proto"></a>Function.<strong>proto</strong></h3><p><code>Function</code> 构造函数是一个函数对象，其 <code>[[Class]]</code> 属性是 <code>Function</code>。<code>Function</code> 的 <code>[[Prototype]]</code> 属性指向了 <code>Function.prototype</code>，即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="../../images/javascript/javascript-prototype-1-8.png" alt="JavaScript-prototype"></p>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>实例化一个<code>Function</code>，它的<code>__proto__</code>指向<code>Function.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo.__proto__ =&gt; Function.prototype =&gt; Function.prototype.__proto__ =&gt; Object.prototype =&gt; Object.prototype.__proto__ =&gt; null</span></span><br></pre></td></tr></table></figure>
<h2 id="Object和Function的鸡和蛋的问题"><a href="#Object和Function的鸡和蛋的问题" class="headerlink" title="Object和Function的鸡和蛋的问题"></a>Object和Function的鸡和蛋的问题</h2><hr>
<p>经过上面对<code>Object</code>和<code>Function</code>的阐述，延伸出来几个问题如下：</p>
<ul>
<li><p>在忽滤<code>null</code>在原型链上时，原型链的尽头（root）是<code>Object.prototype</code>。所有对象均从<code>Object.prototype</code>继承属性。<br><img src="../../images/javascript/javascript-prototype-1-10.png" alt="JavaScript-prototype"></p>
</li>
<li><p><code>Function.prototype</code>和<code>Function.__proto__</code>为同一对象。<br><img src="../../images/javascript/javascript-prototype-1-11.png" alt="JavaScript-prototype"><br>这意味着： <code>Object/Array/String</code>等等<strong>构造函数</strong>本质上和<code>Function</code>一样，均继承于<code>Function.prototype</code>。</p>
</li>
<li><p><code>Function.prototype</code>直接继承root（<code>Object.prototype</code>）。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function.prototype继承了Object.prototype</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object Array Function 等等构造函数继承了Function.prototype</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>;  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过上面代码知道继承的原型链大致是： <strong>Object.prototype(root)&lt;—Function.prototype&lt;—Function|Object|Array…</strong>。</p>
<p>上面的会出现一个比较奇特的现象如下：</p>
<ul>
<li>第一问</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype;</span><br></pre></td></tr></table></figure>
<p><code>Function</code>对象是不是由<code>Function</code>构造函数创建的实例？</p>
<ul>
<li>第二问</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>为什么<code>Function instanceof Object</code>为<code>true</code>，<code>Object instanceof Function</code>也为<code>true</code>，那么他们到底是什么关系？</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><hr>
<p>先要了解清楚<code>Function.prototype</code>和<code>Object构造函数</code>如下：<br>回归规范，摘录2点：</p>
<ul>
<li><code>Function.prototype</code>是个不同于一般函数（对象）的函数（对象）。</li>
</ul>
<blockquote>
<p>The Function prototype object is itself a Function object (its [[Class]] is “Function”) that, when invoked, accepts any arguments and returns undefined.<br>The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object (15.2.4). The initial value of the [[Extensible]] internal property of the Function prototype object is true.<br>The Function prototype object does not have a valueOf property of its own; however, it inherits the valueOf property from the Object prototype Object.</p>
</blockquote>
<p>上面的可以总结为：</p>
<ul>
<li><code>Function.prototype</code>像普通函数一样可以调用，但总是返回<code>undefined</code>。</li>
<li>普通函数实际上是<code>Function</code>的实例，即普通函数继承于<code>Function.prototype</code>。<code>func.__proto__ === Function.prototype</code>。</li>
<li><code>Function.prototype</code>继承于<code>Object.prototype</code>，并且没有<code>prototype</code>这个属性。<code>func.prototype</code>是普通对象，<code>Function.prototype.prototype</code>是<code>null</code>。</li>
<li><p>所以，<code>Function.prototype</code>其实是个另类的函数，可以独立于/先于Function产生。</p>
</li>
<li><p><code>Object</code>本身是个（构造）函数，是<code>Function</code>的实例，即<code>Object.__proto__</code>就是<code>Function.prototype</code>。</p>
</li>
</ul>
<blockquote>
<p>The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object.<br>The value of the [[Prototype]] internal property of the Object prototype object is null, the value of the [[Class]] internal property is “Object”, and the initial value of the [[Extensible]] internal property is true.</p>
</blockquote>
<h3 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h3><p><code>Function</code>对象是由<code>Function</code>构造函数创建的一个实例？</p>
<p>Yes 的部分：<br>按照 <code>JavaScript</code> 中“实例”的定义，<code>a</code> 是 <code>b</code>的实例即 <code>a instanceof b</code> 为 <code>true</code>，默认判断条件就是 <code>b.prototype</code> 在 <code>a</code> 的原型链上。而 <code>Function instanceof Function</code> 为 true，本质上即 <code>Object.getPrototypeOf(Function) === Function.prototype</code>，正符合此定义。</p>
<p>No 的部分：<br><code>Function</code> 是 <code>built-in</code> 的对象，也就是并不存在“<code>Function</code>对象由<code>Function</code>构造函数创建”这样显然会造成鸡生蛋蛋生鸡的问题。实际上，当你直接写一个函数时（如 <code>function f() {}</code> 或 <code>x =&gt; x</code>），也不存在调用 <code>Function</code> 构造器，只有在显式调用 <code>Function</code> 构造器时（如 <code>new Function(&#39;x&#39;, &#39;return x&#39;)</code> ）才有。</p>
<p>个人偏向先有的<code>Function.prototype</code>，再有的<code>function Function</code>，所有构造函数本质上都是集成于<code>Function.prototype</code><br>，所以<code>Function.__proto__ === Function.prototype</code>。</p>
<h3 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function.__proto__、Function.prototype指向同一个对象，Function.prototype.__proto__指向Object.prototype</span></span><br><span class="line"><span class="comment">// Function.__proto__ =&gt; Function.prototype.__proto__ =&gt; Object.prototype =&gt; Object.prototype.__proto__ =&gt; null</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object作为构造函数继承自Function.prototype</span></span><br><span class="line"><span class="comment">// Object.__proto__ =&gt; Function.prototype</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object作为构造函数继承自Function.prototype，Function.prototype__proto__指向Object.prototype</span></span><br><span class="line"><span class="comment">// Object.__proto__ =&gt; Function.prototype =&gt; Function.prototype.__proto__ =&gt; Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Function构造函数也是继承自Function.prototype</span></span><br><span class="line"><span class="comment">// Function.__proto__ =&gt; Function.prototype</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>总结一下：<strong>先有 <code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code> 继承 <code>Object.prototype</code> 而产生，最后，<code>Function</code> 和 <code>Object</code> 和其它构造函数继承 <code>Function.prototype</code> 而产生。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<ul>
<li><code>Object.prototype</code>是浏览器底层根据 <code>ECMAScript</code> 规范创造的一个对象。</li>
<li><code>Function.prototype</code>直接继承的<code>Object.prototype</code>，同样它也是由是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 <code>prototype</code> 属性。<code>Function.prototype.prototype</code>为<code>undefined</code>。</li>
<li><strong>先有 <code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code> 继承 <code>Object.prototype</code> 而产生，最后，<code>Function</code> 和 <code>Object</code> 和其它构造函数继承 <code>Function.prototype</code> 而产生。</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="noopener">MDN Object.prototype</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype" target="_blank" rel="noopener">MDN Function.prototype</a><br><a href="https://github.com/creeperyang/blog/issues/9" target="_blank" rel="noopener">从<strong>proto</strong>和prototype来深入理解JS对象和原型链</a><br><a href="https://github.com/jawil/blog/issues/13" target="_blank" rel="noopener">从探究Function.<strong>proto</strong>===Function.prototype过程中的一些收获</a><br><a href="https://juejin.im/post/5cb4861ff265da036504efbc#heading-5" target="_blank" rel="noopener">【进阶5-3期】深入探究 Function &amp; Object 鸡蛋问题</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型系列（二）什么是原型继承</title>
    <url>/blog/javascript/javascript-prototype-one.html</url>
    <content><![CDATA[<p><strong><em>將欲歙之，必固張之；將欲弱之，必固強之；——《道德經》</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-prototype.html">JavaScript原型系列（一）构造函数、原型和原型链</a><br><a href="/blog/javascript/javascript-prototype-one.html">JavaScript原型系列（二）什么是原型继承</a><br><a href="/blog/javascript/javascript-prototype-two.html">JavaScript原型系列（三）Function、Object、Null等等的关系和鸡蛋问题</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><img src="../../images/javascript/javascript-prototype-1-3.jpg" width="50%" alt="JavaScript-prototype"></p>
<p>在上一节上面介绍了原型和原型链，即每个对象拥有一个<strong>原型对象</strong>，通过 <code>__proto__</code> 指针指向上一个<strong>原型</strong> ，并从中<strong>继承方法和属性</strong>，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>，这种关系被称为<code>原型链(prototype chain)</code>。</p>
<p><code>继承</code>是面向对象编程语言的一大核心功能点，<code>JavaScript</code>是面向对象的只不过是比较特殊的面向对象的语言。它不像<code>Java</code>是基于类的面向对象，而<code>javaScript</code>是基于<code>prototype</code>的面向对象。</p>
<p>会用一篇文章来介绍什么面向对象，<code>javascript</code>是怎么实现<code>继承</code>、<code>封装</code>、<code>多态</code>和<code>javascript</code>面向对象的特殊之处。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><hr>
<p><code>JavaScript</code> 对象是动态的属性“包”（指其自己的属性）。<code>JavaScript</code> 对象有一个指向一个<strong>原型对象</strong>的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，<strong>依次层层</strong>向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p>原型链继承的本质是<strong>重写原型对象，代之以一个新类型的实例</strong>。将父类的实例作为子类的原型。看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'subtype'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将父类的实例作为子类的原型</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line">sub.constructor === SubType; <span class="comment">// true</span></span><br><span class="line">Sub.prototype.constructor === SubType; <span class="comment">// true</span></span><br><span class="line">sub.name = <span class="string">'sub'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sub.getName()); <span class="comment">// sub</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>基于原型的方法所有子类都可以复用</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>多个实例对引用类型的操作会被篡改</li>
<li>子类型的原型上的 constructor 属性被重写了</li>
<li>创建子类型实例时无法向父类型的构造函数传参</li>
</ul>
<p>主要分析一下它的缺点暂时不分析它的优点。</p>
<h3 id="引用类型被修改"><a href="#引用类型被修改" class="headerlink" title="引用类型被修改"></a>引用类型被修改</h3><p>因为本质上每个实例的<code>__proto__</code>都会指向构造函数的<code>prototype</code>，实例上都是保存了一个<strong>引用地址</strong>，所以当<code>prototype</code>中的引用类型修改所有实例都会被改变。在上面代码基础上修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'subtype'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype.Arr = [<span class="string">'sub'</span>, <span class="string">'subtype'</span>, <span class="string">'Sub'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将父类的实例作为子类的原型</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">sub2.Arr.push(<span class="string">'push'</span>);</span><br><span class="line"></span><br><span class="line">sub1.Arr; <span class="comment">// ["sub", "subtype", "Sub", "push"]</span></span><br><span class="line">sub2.Arr; <span class="comment">// ["sub", "subtype", "Sub", "push"]</span></span><br></pre></td></tr></table></figure>
<p>在构造函数<code>SubType.prototype</code>新增<code>Arr</code>属性并且赋值为<code>[&#39;sub&#39;, &#39;subtype&#39;, &#39;Sub&#39;]</code>，通过<code>new</code>关键字实例化两个实例<code>sub1</code>、<code>sub1</code>,当修改了<code>sub2.Arr</code>的时候，<code>sub1.Arr</code>的也会被影响。</p>
<h3 id="实例constructor被重写"><a href="#实例constructor被重写" class="headerlink" title="实例constructor被重写"></a>实例constructor被重写</h3><p>子类型原型上的 <code>constructor</code> 属性被重写, 执行 <code>Sub.prototype = new SubType()</code> 后原型被覆盖，<code>Sub.prototype</code> 上丢失了 <code>constructor</code> 属性， <code>Sub.prototype</code> 指向了 <code>SubType.prototype</code>，而 <code>SubType.prototype.constructor</code> 指向了 <code>SubType</code>，所以 <code>Sub.prototype.constructor</code> 指向了 <code>SubType</code>。<br>如下图所示：<br><img src="../../images/javascript/javascript-prototype-1-6.png" alt="JavaScript-prototype"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'subtype'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将父类的实例作为子类的原型</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="comment">// 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。</span></span><br><span class="line">Sub.prototype.constrcutor = Sub;</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">Sub.prototype.constrcutor === Sub; <span class="comment">// true</span></span><br><span class="line">sub.__proto__.constrcutor === Sub; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过<code>Sub.prototype.constrcutor = Sub;</code>把<code>Sub.prototype.constrcutor</code>指向<code>Sub</code>，如果所示：<br><img src="../../images/javascript/javascript-prototype-1-7.png" alt="JavaScript-prototype"></p>
<blockquote>
<p>给子类型原型添加属性和方法必须在替换原型之后，原因在第二点已经解释过了，因为子类型的原型会被覆盖。</p>
</blockquote>
<h3 id="属性遮蔽"><a href="#属性遮蔽" class="headerlink" title="属性遮蔽"></a>属性遮蔽</h3><p>在<code>Sub.prototype</code>上添加<code>getName</code>方法，当调用<code>sub</code>上得<code>getName</code>时，访问到的是<code>Sub.prototype.getName</code>而不是访问到<code>SubType.prototype.getName</code>，这种情况称为<strong>属性遮蔽（property shadowing）</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'subtype'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将父类的实例作为子类的原型</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="comment">// 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。</span></span><br><span class="line">Sub.prototype.constrcutor = Sub;</span><br><span class="line"><span class="comment">// 添加getName属性</span></span><br><span class="line">Sub.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Sub.prototype.getName'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">sub.getName(); <span class="comment">// Sub.prototype.getName</span></span><br></pre></td></tr></table></figure>
<p>可以通过<code>__proto__</code>调用原型链上的属性即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sub.__proto__.__proto__.getName()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="实现一个new"><a href="#实现一个new" class="headerlink" title="实现一个new"></a>实现一个new</h2><hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Preson = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">    obj.__proto__ = Preson.prototype;</span><br><span class="line">    <span class="comment">// 绑定this指向，执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> result = Preson.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里不多做赘述了，详细内容我另一片博客<a href="/blog/javascript/javascript-extends.html">javascript中实现一个自己的new</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每个对象拥有一个原型对象，通过<code>__proto__</code> 指针指向上一个原型 ，并从中<strong>继承方法和属性</strong>，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>，这种关系被称为 <strong>原型链</strong>。</li>
<li>当访问一个对象的属性 / 方法时，它不仅仅在该对象上查找，还会查找该对象的原型，以及该对象的原型的原型，<strong>一层一层向上查找</strong>，直到找到一个名字匹配的属性 / 方法或到达原型链的末尾<strong>null</strong>。</li>
<li>原型链的构建依赖于 <code>__proto__</code>，一层一层最终链接到 <code>null</code>。</li>
<li><code>instanceof</code> 原理就是一层一层查找 <code>__proto__</code>，如果和 <code>constructor.prototype</code> 相等则返回 <code>true</code>，如果一直没有查找成功则返回 <code>false</code>。</li>
<li>原型链继承的本质是<strong>重写原型对象，代之以一个新类型的实例</strong>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener">对象原型</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a><br><a href="https://www.muyiy.cn/blog/5/5.2.html#%E5%BC%95%E8%A8%80" target="_blank" rel="noopener">图解原型链及其继承优缺点</a><br><a href="https://mp.weixin.qq.com/s/oEyMZl-7q3pczK1GpnoqSA" target="_blank" rel="noopener">一篇文章理解 JS 继承</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型系列（一）构造函数、原型和原型链</title>
    <url>/blog/javascript/javascript-prototype.html</url>
    <content><![CDATA[<p><strong><em>大方無隅，大器晚成，大音希聲，大象無形。——《道德經》</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-prototype.html">JavaScript原型系列（一）构造函数、原型和原型链</a><br><a href="/blog/javascript/javascript-prototype-one.html">JavaScript原型系列（二）什么是原型继承</a><br><a href="/blog/javascript/javascript-prototype-two.html">JavaScript原型系列（三）Function、Object、Null等等的关系和鸡蛋问题</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>首先要了解几个属性<code>constructor</code>、<code>prototype</code>、<code>[[prototype]]</code>、<code>__proto__</code>分别作用是什么，还要理解几个概念<strong>原型</strong>、<strong>原型链</strong>、<strong>构造函数</strong>。</p>
<p>结合代码先把上面的的属性和记录清楚。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><hr>
<p><code>constrcutor</code>是一种用于创建和初始化<code>class</code>创建的对象的特殊方法。<br><code>构造函数</code>本身就是一个函数，与普通函数<code>没有</code>任何区别，不过为了规范一般将其<code>首字母</code>大写。<code>构造函数</code>和<code>普通函数</code>的区别在于，使用 <code>new</code> 生成实例的函数就是<code>构造函数</code>，直接调用的就是<code>普通函数</code>。下面示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorFun</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new关键字创建实例</span></span><br><span class="line"><span class="keyword">let</span> constructorfun = <span class="keyword">new</span> ConstructorFun();</span><br></pre></td></tr></table></figure>
<p>其实<code>ConstructorFun</code>就是一个普通函数，但是在通过<code>new</code>关键字生成实例的时候，就可以把这个函数叫做<strong>构造函数</strong>;</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>除了<code>null</code>、<code>undefined</code>其他无论是通过<code>new</code>生成的实例，还是通过字面量生成的<strong>变量</strong>，普通的函数都是有<code>constructor</code>属性的。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorFun</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new关键字创建实例</span></span><br><span class="line"><span class="keyword">var</span> constructorfun = <span class="keyword">new</span> ConstructorFun();</span><br><span class="line">constructorfun.constructor === ConstructorFun; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number.constructor); <span class="comment">// ƒ Number() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数扩展"><a href="#构造函数扩展" class="headerlink" title="构造函数扩展"></a>构造函数扩展</h3><ul>
<li><code>let a = {}</code> 其实是 <code>let a = new Object()</code> 的语法糖</li>
<li><code>let a = []</code> 其实是 <code>let a = new Array()</code> 的语法糖</li>
<li><code>function Foo()</code>{ … } 其实是 var Foo = new Function(…)</li>
<li><strong>可以使用 <code>instanceof</code> 判断一个函数是否为一个变量的构造函数</strong></li>
</ul>
<p>手动实现一个<code>instanceof</code>函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟实现instanceof</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfInstanceof</span> (<span class="params">left, right</span>) </span>&#123;  <span class="comment">//left 表示左表达式，right 表示右表达式</span></span><br><span class="line">    <span class="keyword">let</span> cur = left.__proto__; <span class="comment">// 取的cur的隐式原型</span></span><br><span class="line">    <span class="keyword">let</span> parent = right.prototype; <span class="comment">// 取的right的显式原型</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur === <span class="literal">null</span>) &#123; <span class="comment">// 如果cur为null 直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur === parent) &#123; <span class="comment">// 如果cur与parent相同 返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.__proto__; <span class="comment">// 上面两个条件都不满足，继续向上一层原型链查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="constructor-的值是否可更改"><a href="#constructor-的值是否可更改" class="headerlink" title="constructor 的值是否可更改"></a>constructor 的值是否可更改</h3><p><strong>对于引用类型来说<code>constructor</code> 属性值是可以修改的，但是对于基本类型来说是只读的。</strong></p>
<blockquote>
<p>注意：<code>null</code> 和 <code>undefined</code> 是没有 <code>constructor</code> 属性的。</p>
</blockquote>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><hr>
<p>官方解释原型：”JavaScript常被描述为一种<strong>基于原型的语言（prototype-based language）</strong>————每个对象拥有一个<strong>原型对象</strong>，对象以其原型为模板、从原型继承方法和属性。”<br>每个函数都有一个特殊的属性就叫作<code>原型（prototype）</code>，请看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype);</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：<br><img src="../../images/javascript/javascript-prototype-1-1.png" alt="JavaScript-prototype"><br><code>Foo.prototype</code>上有两个属性，一个是<code>constructor</code>它指向了函数本身；另一个是<code>__proto__</code>它指向了<code>Object.prototype</code>。</p>
<p>构造函数<code>Foo</code>有一个指向原型的指针，原型<code>Foo.prototype</code>有一个指向构造函数的指针<code>Foo.prototype.constructor</code>，用下面的图来表示更清晰一点：<br><img src="../../images/javascript/javascript-prototype-1-2.png" alt="JavaScript-prototype"></p>
<p>其实更重要的是任何一个<code>prototype</code>对象都有一个<code>constructor</code>属性，指向这个构造函数。</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>在上面看到<code>__proto__</code>这个属性，每个实例对象（object）都有一个<code>隐式原型</code>属性(称之为<code>__proto__</code>)指向了创建该对象的构造函数的<code>原型</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name</span>) </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="../../images/javascript/javascript-prototype-1-3.png" alt="JavaScript-prototype"></p>
<p>当通过<code>new Foo()</code>生成的实例对象<code>foo</code>，它有一个<code>__proto__</code>属性指向<code>Foo.prototype</code>，可以通过以下代码验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.__proto__ === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Foo</code>、<code>Foo.prototype</code>、<code>Foo.prototype.constructor</code>、<code>foo.__proto__</code>三者的关系如下图所示：</p>
<p><img src="../../images/javascript/javascript-prototype-1-4.png" alt="JavaScript-prototype"></p>
<p><code>__proto__</code> 属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 <code>Object.getPrototypeOf()</code>。</p>
<blockquote>
<p>通过改变一个对象的 <code>[[Prototype]]</code> 属性来改变和继承属性会对性能造成非常严重的影响，并且性能消耗的时间也不是简单的花费在 <code>obj.__proto__ = ...</code> 语句上, 它还会影响到所有继承自该 <code>[[Prototype]]</code> 的对象，如果你关心性能，你就不应该修改一个对象的 <code>[[Prototype]]</code>。</p>
</blockquote>
<p>如果要读取或修改对象的 <code>[[Prototype]]</code> 属性，建议使用如下方案，但是此时设置对象的 <code>[[Prototype]]</code> 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf()</span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf()</span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf()</span><br></pre></td></tr></table></figure>
<p>如果要创建一个新对象，同时继承另一个对象的 <code>[[Prototype]]</code> ，推荐使用 <code>Object.create()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    age: <span class="number">50</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(p);</span><br></pre></td></tr></table></figure>
<h3 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h3><p><code>[[Prototype]]</code> 是对象的一个内部属性，外部代码无法直接访问。</p>
<blockquote>
<p>遵循 ECMAScript 标准，<code>someObject.[[Prototype]]</code> 符号用于指向 someObject 的<strong>原型</strong></p>
</blockquote>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><hr>
<p>每个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>。这种关系被称为<code>原型链 (prototype chain)</code>，通过原型链一个对象会拥有定义在其他对象中的属性和方法。看一面一张经典的图可能更直观：</p>
<p><img src="../../images/javascript/javascript-prototype-1-3.jpg" width="50%" alt="JavaScript-prototype"></p>
<p>看一下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.__proto__ === Foo.prototype; <span class="comment">// true</span></span><br><span class="line">foo.__proto__.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line">foo.__proto__.__proto__.__proto__ === <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下面的图可以很好的展示上面的代码<code>prototype</code>和<code>__proto__</code>指向问题。<br><img src="../../images/javascript/javascript-prototype-1-5.png" alt="JavaScript-prototype"></p>
<h2 id="特殊的Symbol"><a href="#特殊的Symbol" class="headerlink" title="特殊的Symbol"></a>特殊的Symbol</h2><p><code>Symbol</code>是基础数据类型，它可以通过<code>Symbol(123)</code>生成实例，不能通过<code>new Symbol()</code>生成实例，<code>Symbol</code>不是构造函数，但是它有<code>constructor</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sSymbol = <span class="built_in">Symbol</span>(<span class="string">'symbol'</span>);</span><br><span class="line"><span class="keyword">let</span> errSymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">'symbol'</span>); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.constructor; <span class="comment">// ƒ Symbol() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每一个函数对象都有一个<code>prototype</code>属性，指向函数对象的原型，原型对象上有一个<code>constructor</code>属性指向<strong>构造函数</strong>本身。</li>
<li>引用类型 <code>constructor</code> 属性值是可以<strong>修改</strong>的，但是对于基本类型来说是<strong>只读</strong>的，当然 <code>null</code> 和 <code>undefined</code> 没有 <code>constructor</code> 属性。</li>
<li><code>__proto__</code> 属性在 <code>ES6</code> 时被标准化，但因为性能问题并不推荐使用，推荐使用 <code>Object.getPrototypeOf()</code>。</li>
<li><code>__proto__</code> 是每个实例上都有的属性，<code>prototype</code> 是构造函数的属性，在实例上并不存在，所以这两个并不一样，但 <code>foo.__proto__</code> 和 <code>Foo.prototype</code> 指向同一个对象。</li>
<li>每个对象拥有一个原型对象，通过<code>__proto__</code>指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>，这就是原型链。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.muyiy.cn/blog/5/5.1.html#%E5%BC%95%E8%A8%80" target="_blank" rel="noopener">重新认识构造函数、原型和原型链</a><br><a href="https://mp.weixin.qq.com/s/y49klI7seb3tlP4hx2A_Lg" target="_blank" rel="noopener">JS 系列二：原型与原型链</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener">对象原型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列 css中float</title>
    <url>/blog/css/css-float.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>float CSS</code>属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素<strong>环绕</strong>它。该元素从网页的正常流动(文档流)中<strong>移除</strong>，尽管仍然保持部分的<strong>流动性</strong>（与绝对定位<strong>相反</strong>）。</p>
<p><strong>浮动元素是 float 的计算值非 none 的元素。</strong><br>基本上可以认为：<strong>“让block元素无视float元素，让inline元素像流水一样围绕着float元素实现浮动布局。”</strong></p>
<h2 id="float特性"><a href="#float特性" class="headerlink" title="float特性"></a>float特性</h2><p><code>float</code>有四种特性：</p>
<ul>
<li>包裹性</li>
<li>高度破坏性</li>
<li>没有任何margin合并</li>
</ul>
<h3 id="包裹性"><a href="#包裹性" class="headerlink" title="包裹性"></a>包裹性</h3><p><strong>包裹性： 包裹性指的是元素尺寸刚好容纳内容，并且不会超越父级元素的宽度</strong>。</p>
<p>具有包裹性的其他属性：</p>
<ul>
<li>display:inline-block/table-cell/…</li>
<li>position:absolute/fixed/sticky</li>
<li>overflow:hidden/scroll</li>
</ul>
<p>通过一个实例来看一下什么是包裹性：</p>
<p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container fl"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">background-clip</span>: content-box;<span class="comment">/*将背景裁剪到内容框，方便看浮动元素效果*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fl</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="../../images/css/css-float-1-1.png" alt="css margin"></p>
<p>可以看到下面的元素的宽度就是它内部文本信息的宽度，而上面的元素是占了整个一行的元素。</p>
<h3 id="包裹性的原理"><a href="#包裹性的原理" class="headerlink" title="包裹性的原理"></a>包裹性的原理</h3><p>浮动之所以会产生包裹性这样的效果是<strong>因为float属性会改变元素display属性最终的计算值</strong>。</p>
<p>设置float前的display属性——》设置浮动后的display属性计算值:</p>
<ul>
<li><strong>inline——》block</strong></li>
<li><strong>inline-block——》block</strong></li>
<li><strong>inline-table——》table</strong></li>
<li><strong>table-row——》block</strong></li>
<li><strong>table-row-group——》block</strong></li>
<li><strong>table-column——》block</strong></li>
<li><strong>table-column-group——》block</strong></li>
<li><strong>table-caption——》block</strong></li>
<li><strong>table-header-group——》block</strong></li>
<li><strong>table-footer-group——》blcok</strong></li>
<li><strong>flex——》flex</strong></li>
<li><strong>inline-flex——》inline-flex【inline-flex在chrome下测试，float后display:flex】</strong></li>
<li><strong>other——》unchanged</strong></li>
</ul>
<p>可以自己自行测试在不同浏览其中的表现，<strong>chrome</strong>测试方法如下：</p>
<p><strong>修改css如下</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fl</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过<strong>chrome</strong>的控制台首先查看<strong>Styles</strong>面板，可以看到<code>display: inline-block;float: left;</code>属性生效，如下：<br><img src="../../images/css/css-float-1-2.png" alt="css margin"></p>
<p>然后再查看<strong>Computed</strong>面板查看真正生效到元素上的所有属性，如下：<br><img src="../../images/css/css-float-1-3.png" alt="css margin"></p>
<p>可以看到<code>display: flex;</code>属性，得以验证上面的结论。</p>
<h3 id="高度破坏性"><a href="#高度破坏性" class="headerlink" title="高度破坏性"></a>高度破坏性</h3><p><strong>破坏性是指元素浮动后可能导致父元素高度塌陷</strong>。</p>
<p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nofl"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="../../images/css/css-float-1-4.png" alt="css margin"></p>
<p>在<code>div.container</code>元素没有设置高度时，<code>div.nofl</code>不设置<code>float: left;</code>时元素的高度会撑开父元素的高度。而<code>div.fl</code>元素设置了<code>float: left;</code>元素的高度不会包含在父元素的高度内。</p>
<p><strong>其他破坏性的属性</strong>：</p>
<ul>
<li>display:none</li>
<li>position:absolute/fixed/sticky</li>
</ul>
<p><strong>浮动破坏性原理：</strong><br>因为浮动元素被从文档<strong>正常流中移除</strong>了，<strong>父元素</strong>当然还处在<strong>正常流</strong>中，所以父元素<strong>不能</strong>被浮动元素<strong>撑大</strong>。</p>
<h3 id="没有任何margin合并"><a href="#没有任何margin合并" class="headerlink" title="没有任何margin合并"></a>没有任何margin合并</h3><p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl one"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl two"</span>&gt;</span></span><br><span class="line">    测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改<strong>css</strong>如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">background-clip</span>: content-box; <span class="comment">/*将背景裁剪到内容框，方便看浮动元素效果*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fl</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/css/css-float-1-5.png" alt="css margin"></p>
<p>根据效果图可以看到<code>div.one</code>和<code>div.two</code>都是有<code>margin: 10px;</code>的属性，但是它们之间的<code>margin</code>并没有重合。如果没有<code>float: left</code>属性的话，<code>div.one</code>的下边距和<code>div.two</code>的上边距会发生合并，也就是说它们合并后的外间距就会是<code>10px</code>。</p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>在上面的实例中就用到了<code>clear</code>清除浮动属性，它可以解决<code>float</code>带来一些副作用比如说<code>高度破坏性</code>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">clear: none | left | right | both</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>none：默认值，允许两边都有浮动对象；</strong></li>
<li><strong>left：不允许左侧有浮动对象；</strong></li>
<li><strong>right：不允许右侧有浮动对象；</strong></li>
<li><strong>both：两侧不允许有浮动对象。</strong></li>
</ul>
<p>具体原理：在元素上外边距之上增加清除空间，比如清除左浮动会让元素的上外边距刚好在左边浮动元素的下外边距之下。</p>
<p>清除浮动课两大类方法：</p>
<ul>
<li>在兄弟元素最后一个设置 clear:both</li>
<li>父元素生成BFC(IE8+)或者hashlayout(IE6/IE7)</li>
</ul>
<h3 id="兄弟元素清除"><a href="#兄弟元素清除" class="headerlink" title="兄弟元素清除"></a>兄弟元素清除</h3><p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ....省略代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注释掉 */</span></span><br><span class="line"><span class="comment">/* .container::after &#123;</span></span><br><span class="line"><span class="comment">  content: "";</span></span><br><span class="line"><span class="comment">  display: block;</span></span><br><span class="line"><span class="comment">  clear: both;</span></span><br><span class="line"><span class="comment">  overflow: hidden;</span></span><br><span class="line"><span class="comment">  zoom: 1;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="comment">/* ....省略代码  */</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在没有添加<code>.clearfix { clear: both; }</code>时显示如图一，在添加<code>.clearfix</code>后显示为图二。</p>
<p><strong>图一</strong><br><img src="../../images/css/css-float-1-6.png" alt="css margin"></p>
<p><strong>图二</strong><br><img src="../../images/css/css-float-1-5.png" alt="css margin"></p>
<p>这种方式也是有很多不好的地方，比如增加了一个<strong>无用标签</strong>、<strong>结构更复杂</strong>、<strong>比较难复用</strong>。</p>
<h3 id="父元素添加after伪元素"><a href="#父元素添加after伪元素" class="headerlink" title="父元素添加after伪元素"></a>父元素添加after伪元素</h3><p>为了解决上面兄弟元素的问题，引出父元素的after伪元素。</p>
<p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"."</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="comment">/* IE &lt; 8 */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * For IE 6/7 only</span></span><br><span class="line"><span class="comment">  * Include this rule to trigger hasLayout and contain floats.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样可以实现与上面想同的效果并且不会产生兄弟元素产生的问题</strong>。</p>
<h3 id="父元素生成BFC（IE8-）-或haslayout-IE6-IE7"><a href="#父元素生成BFC（IE8-）-或haslayout-IE6-IE7" class="headerlink" title="父元素生成BFC（IE8+） 或haslayout(IE6/IE7)"></a>父元素生成BFC（IE8+） 或haslayout(IE6/IE7)</h3><p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"."</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*IE6和IE7*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="父元素设置为float"><a href="#父元素设置为float" class="headerlink" title="父元素设置为float"></a>父元素设置为float</h3><h2 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h2><h3 id="一列自适应一列固定布局"><a href="#一列自适应一列固定布局" class="headerlink" title="一列自适应一列固定布局"></a>一列自适应一列固定布局</h3><p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"."</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="../../images/css/css-float-1-7.png" alt="css margin"></p>
<p>还有<strong>圣杯和双飞翼布局</strong>，这里就不一一列举，可在本在中查找。</p>
<h2 id="float布局和inline-block布局对比"><a href="#float布局和inline-block布局对比" class="headerlink" title="float布局和inline-block布局对比"></a>float布局和inline-block布局对比</h2><p><code>float</code>和<code>inline-block</code>都能让元素排成一排，那么应该如何抉择？下面对比一下。</p>
<ul>
<li>文档流：<strong>浮动元素脱离正常流，让文字环绕。inline-block仍然在正常流中</strong>。</li>
<li>水平位置：<strong>不能通过给父元素设置text-align:center让浮动元素无法水平居中【因为脱离文档流】，而inline-block可以</strong>。</li>
<li>垂直对齐：<strong>浮动元素紧贴顶部，inline-block默认基线对齐，可通过vertical-align调整</strong>。</li>
<li>空白：<strong>浮动忽略空白元素彼此紧靠，inline-block保留空白</strong>。</li>
</ul>
<p>其实<code>float</code>和<code>inline-block</code>看个人喜好和具体的场景。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>float</code>即使到现在还没有淘汰，虽然现在有很多更方便的布局如<code>flex</code>、<code>colmun</code>、<code>grid</code>等等，现在还有很多场景在应用，所以还是要仔细学习。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/starof/p/4608962.html" target="_blank" rel="noopener">深入理解css浮动</a><br><a href="https://segmentfault.com/a/1190000014554601#articleHeader4" target="_blank" rel="noopener">【前端Talkking】CSS系列——CSS深入理解之float浮动</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列 css中border (未完成)</title>
    <url>/blog/css/css-border.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列  css中absolute (未完成)</title>
    <url>/blog/css/css-absolute.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（五）JavaScript中的Mixin、extends、object.assign的实现 （未完成）</title>
    <url>/blog/javascript/javascript-extends-six.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（四）JavaScript多种继承方式，各自的优缺点 （未完成）</title>
    <url>/blog/javascript/javascript-extends-five.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（三）JavaScript多种继承方式，各自的优缺点 （未完成）</title>
    <url>/blog/javascript/javascript-extends-four.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（二）JavaScript怎么实现Java中的 继承、多态、封装 （未完成）</title>
    <url>/blog/javascript/javascript-extends-three.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（一）JavaScript中有类？基于原型的继承 （未完成）</title>
    <url>/blog/javascript/javascript-extends-two.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>在开发前端中的一些注意事项</title>
    <url>/blog/other/Precautions.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>其实很多时候发现很多别人遗留的代码，不是他写不好或者什么，而是没时间，时间不够的时候自己只能用自己比较顺手的写法去写，但是一定要有一个人去管理整个公司的前端技术栈，不然真的是一团乱，</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/blog/javascript/JavaScript-Operator-priority.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>运算符的优先级决定了表达式中运算执行的先后顺序，优先级高的运算符最先被执行。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span> <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p>
<p><font color="#ff502c"></font><br>乘法运算符 (“<font color="#ff502c">*</font>“)比起加法运算符(“<font color="#ff502c">+</font>“)有着更高的优先级，所以它会被最先执行。</p>
<h3 id="结合性"><a href="#结合性" class="headerlink" title="结合性"></a>结合性</h3><p>结合性决定了拥有相同优先级的运算符的执行顺序。考虑下面这个表达式：</p>
<ul>
<li>左结合<br>左结合(从左到右计算)相当于把左边的子表达式加上小括号(a OP b) OP c</li>
<li>右关联<br>(从右到左计算)相当于a OP (b OP c)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = b = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果 a 和 b 的值都会成为5。这是因为赋值运算符的返回结果就是赋值运算符右边的那个值，具体过程是：b被赋值为5，然后a也被赋值为 b=5 的返回值，也就是5。</p>
<h3 id="汇总表"><a href="#汇总表" class="headerlink" title="汇总表"></a>汇总表</h3><p>下面的表将所有运算符按照优先级的不同从高到低排列。<br>可以查看 mdn中的 table来分他的等级。</p>
<p>mdn运算符优先级参考表 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的作用域和作用域链</title>
    <url>/blog/javascript/javascript-scope.html</url>
    <content><![CDATA[<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p><font color="#ff502c"></font><br>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<h3 id="最外层的函数、变量拥有全局作用域"><a href="#最外层的函数、变量拥有全局作用域" class="headerlink" title="最外层的函数、变量拥有全局作用域"></a>最外层的函数、变量拥有全局作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sGl = <span class="string">"全局变量"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fGL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _sGl = <span class="string">"局部变量"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(_sGl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sGl); <span class="comment">// 全局变量</span></span><br><span class="line">fGL(); <span class="comment">// 局部变量</span></span><br></pre></td></tr></table></figure>
<h3 id="没有使用-var-关键字声明的变量也都是全局变量。"><a href="#没有使用-var-关键字声明的变量也都是全局变量。" class="headerlink" title="没有使用 var 关键字声明的变量也都是全局变量。"></a>没有使用 var 关键字声明的变量也都是全局变量。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">"全局变量"</span>;</span><br><span class="line">  alert(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:全局变量</span></span><br></pre></td></tr></table></figure>
<h3 id="所有-window-对象的属性拥有全局作用域"><a href="#所有-window-对象的属性拥有全局作用域" class="headerlink" title="所有 window 对象的属性拥有全局作用域"></a>所有 window 对象的属性拥有全局作用域</h3><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域：<font color="#ff502c">函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行。</font>也就是说词法作用域取决于源码，通过静态分析就能确定，因此<font color="#ff502c">词法作用域也叫做静态作用域</font><br>在通常情况下，变量的查询从最近接的绑定上下文开始，向外部逐渐扩展，直到查询到第一个绑定，一旦完成查找就结束搜索。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gl = <span class="string">"全局变量"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fGl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gl = <span class="string">"局部变量"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(gl);</span><br><span class="line">&#125;</span><br><span class="line">fGl(); <span class="comment">// 局部变量</span></span><br></pre></td></tr></table></figure>
<h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>在编程实践中，最容易低估和过度滥用的概念就是动态作用域，因为很少有语言支持这种方式为绑定解析方案。</p>
<p>动态作用域与词法作用域相对而言的，不同于词法作用域在定义时确定，<font color="#ff502c">动态作用域在执行时确定，其生存周期到代码片段执行为止</font>。动态变量存在于动态作用域中，<font color="#ff502c">任何给定的绑定的值，在确定调用其函数之前，都是不可知的</font>。</p>
<p>在代码执行时，对应的作用域链常常是保持静态的。然而当遇到 with 语句、call 方法、apply 方法和 try-catch 中的 catch 时，会改变作用域链的。以 with 为例，在遇到 with 语句时，会将传入的对象属性作为局部变量来显示，使其便于访问，也就是说把一个新的对象添加到了作用域链的顶端，这样必然影响对局部标志符的解析。<font color="#ff502c">当 with 语句执行完毕后，会把作用域链恢复到原始状态</font>。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with之前</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123; <span class="attr">name</span>: <span class="string">"jeri"</span> &#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with之后，作用域链恢复</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure>
<p>在作用域链中有动态作用域时，this 引用也会变得更加复杂，不再指向第一次创建时的上下文，而是由调用者确定。比如在使用 apply 或 call 方法时，传入它们的第一个参数就是被引用的对象。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalThis(); <span class="comment">// 输出:Window &#123;document: document,external: Object…&#125;</span></span><br><span class="line">globalThis.call(&#123; <span class="attr">name</span>: <span class="string">"jeri"</span> &#125;); <span class="comment">// 输出:Object &#123;name: "jeri"&#125;</span></span><br><span class="line">globalThis.apply(&#123; <span class="attr">name</span>: <span class="string">"jeri"</span> &#125;, []); <span class="comment">// 输出:Object &#123;name: "jeri"&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域，顾名思义就是在定义函数时候产生的作用域，这个作用域也可以称为<font color="#ff502c">局部作用域</font>。和全局作用域相反，函数作用域一般只在函数的代码片段内可访问到，外部不能进行变量访问。在函数内部定义的变量存在于函数作用域中，其生命周期随着函数的执行结束而结束。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"jeri"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">with</span> (&#123; <span class="attr">name</span>: <span class="string">"with"</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 输出:with</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能访问函数作用域</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在 JavaScript 中，<font color="#ff502c">函数也是对象</font>，实际上，JavaScript 里<font color="#ff502c">一切</font>都是<font color="#ff502c">对象</font>。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是<font color="#ff502c">[[Scope]]</font>，由 ECMA-262 标准第三版定义，该内部属性包含了<font color="#ff502c">函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链</font>，<font color="#ff502c">它决定了哪些数据能被函数访问</font>。<font color="#ff502c">它用来保证对执行环境有权访问的变量和函数的有序访问</font>。<br>当一个函数创建后，它的作用域会被创建此函数的作用域中可访问的数据对象填充</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../images/scope/scope1.jpg" alt="JavaScript-scope"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义函数执行的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。<br>这些值按照它们出现在函数中的顺序被复制到运行期的上下文的作用域中，它们共同组成一个新的对象，叫“活动对象(activation object)”,该对象包含了函数的所有局部变量、命名参数、参数集合以及 this,然后此对象会被推入作用域链前端，当运行期上下文被销毁时，活动对象也随之销毁。<br><img src="../../images/scope/scope2.jpg" alt="JavaScript-scope"><br>在全局作用域中创建的函数,其作用域链会自动成为作用域中的一员。而当函数执行时,其活动对象就会成为作用域中的第一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// output:global</span></span><br><span class="line">  name = <span class="string">"change"</span>;</span><br><span class="line">  <span class="comment">// 函数内部可以修改全局变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// output:change</span></span><br><span class="line">  <span class="comment">// 先查询活动对象</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="string">"18"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// output:18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行完毕，执行环境销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// output:Uncaught ReferenceError: age is not defined</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是 JavaScript 的一个比较重要的东西，关于这个问题有很多文章进行讲述，然而依然有相当数量的程序员对这个概念理解不透彻，我就是其中一个，闭包报的官方定义为：<font style="font-weight: bold;">一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也该是表达式的一部分</font>。<br>一句话概括就是：<font style="font-weight: bold; color: red">闭包就是一个函数，捕获作用域内的外部绑定</font>。这些绑定是为之后使用而被绑定，即使作用域已经销毁。</p>
<h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><p><font style="font-weight: bold;">自由变量与闭包的关系是，自由变量闭合于闭包的创建</font>。闭包背后的逻辑是，如果一个函数内部有其他函数，那么这些内部函数可以访问在这个外部函数中声明的变量（这些变量就称之为自由变量）。然而，这些变量可以被内部函数捕获，从高阶函数（返回另一个函数的函数称为高阶函数）中 return 语句实现“越狱”，以供以后使用。内部函数在没有任何局部声明之前（既不是被传入，也不是局部声明）使用的变量就是被捕获的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">captured</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">free</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = free + captured;</span><br><span class="line">    <span class="built_in">console</span>.log(ret);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">add10(<span class="number">2</span>); <span class="comment">// 输出:12</span></span><br></pre></td></tr></table></figure>
<p>从上例可知，外部函数中的变量 captured 被执行加法的返回函数捕获，内部函数从未声明过 captured 变量，却可以引用它。<br>如果我们再创建一个加法器将捕获到同名变量 captured，但有不同的值，因为这个加法器是在调用 makeAdder 之后被创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add16 = makeAdder(<span class="number">16</span>);</span><br><span class="line">add16(<span class="number">18</span>); <span class="comment">// 输出:34</span></span><br><span class="line">add10(<span class="number">10</span>); <span class="comment">// 输出:20</span></span><br></pre></td></tr></table></figure>
<p>每一个新的加法器函数都保留了自己创建时捕获的 captured 实例。</p>
<h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h3><p><font style="font-weight: bold"> </font><br>在 JavaScript 中，当变量在一定作用域内声明，然后在另一个同名变量在一个较低的作用域声明，会发生<font style="font-weight: bold">变量的遮蔽</font>。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"jeri"</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"tom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">glbShadow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"fun"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 输出:fun</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glbShadow();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:tom</span></span><br></pre></td></tr></table></figure>
<p>当在一个变量同一作用域内声明了多次时，最后一次声明会生效，会遮蔽以前的声明。</p>
<p>变量声明的遮蔽很好理解，然而<font style="font-weight: bold">函数参数的遮蔽就略显复杂</font>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = [<span class="string">"Value is"</span>, shadowed].join(<span class="string">" "</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">argShadow(<span class="number">108</span>); <span class="comment">// output:Value is 108</span></span><br><span class="line"></span><br><span class="line">argShadow(); <span class="comment">// output:Value is</span></span><br></pre></td></tr></table></figure>
<p>函数 argShadow 的参数 shadowed 覆盖了全局作用域内的同名变量。即使没有传递任何参数，仍然绑定的是 shadowed，并没有访问到全局变量 shadowed = 0。</p>
<p><font style="font-weight: bold">任何情况下，离得最近的变量绑定优先级最高</font>。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shadowed = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">var</span> str = [<span class="string">"Value is"</span>, shadowed].join(<span class="string">" "</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">varShadow(<span class="number">108</span>); <span class="comment">// output:Value is 123</span></span><br><span class="line"></span><br><span class="line">varShadow(); <span class="comment">// output:Value is 123</span></span><br></pre></td></tr></table></figure>
<p>varShadow(108)打印出来的并不是 108 而是 123，即使没有参数传入也是打印的 123，先访问离得最近的变量绑定。<br>遮蔽变量同样发生在闭包内部，实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(shadowed); <span class="comment">// output:108</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(shadowed); <span class="comment">// output:2</span></span><br><span class="line">    <span class="keyword">var</span> ret = shadowed + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ret); <span class="comment">// output:3</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closureShadow = captureShadow(<span class="number">108</span>);</span><br><span class="line"></span><br><span class="line">closureShadow(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>典型的误区</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    ret[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> test0 = test()[<span class="number">0</span>]();</span><br><span class="line"><span class="built_in">console</span>.log(test0); <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test1 = test()[<span class="number">1</span>]();</span><br><span class="line"><span class="built_in">console</span>.log(test1); <span class="comment">//输出：5</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子可知，test 这个函数执行之后返回一个函数数组，表面上看数组内的每个函数都应该返回自己的索引值，然而并不是如此。当外部函数执行完毕后，外部函数虽然其执行环境已经销毁，但闭包依然保留着对其中变量绑定的引用，仍然驻留在内存之中。当外部函数执行完毕之后，才会执行内部函数，而这时内部函数捕获的变量绑定已经是外部函数执行之后的最终变量值了，所以这些函数都引用的是同一个变量 i=5。<br>另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔1秒输出一个5</span></span><br></pre></td></tr></table></figure>
<p>按照我们的推断，上例应该输出 1,2,3,4,5。然而，事实上输出的是连续 5 个 5。为什么出现这种诡异的状况呢？其本质上还是由闭包特性造成的，闭包可以捕获外部作用域的变量绑定。<br>上面这个函数片段在执行时，其内部函数和外部函数并不是同步执行的，因为当调用 setTimeout 时会有一个延时事件排入队列，等所有同步代码执行完毕后，再依次执行队列中的延时事件，而这个时候 i 已经 是 5 了。</p>
<p>那怎么解决这个问题呢？我们是不是可以在每个循环执行时，给内部函数传进一个变量的拷贝，使其在每次创建闭包时，都捕获一个变量绑定。因为我们每次传参不同，那么每次捕获的变量绑定也是不同的，也就避免了最后输出 5 个 5 的状况。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包具有非常强大的功能，函数内部可以引用外部的参数和变量，但其参数和变量不会被垃圾回收机制回，常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。但，闭包也是 javascript 语言的一大特点，主要应用闭包场合为：<font style="font-weight: bold">设计私有的方法和变量</font>。</p>
<h3 id="模拟私有变量"><a href="#模拟私有变量" class="headerlink" title="模拟私有变量"></a>模拟私有变量</h3><p>从上文的叙述我们知道，变量的捕获发生在创建闭包的时候，那么我们可以把闭包捕获到的变量做为私有变量。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closureDemo = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> PRIVATE = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    inc: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (PRIVATE += n);</span><br><span class="line">    &#125;,</span><br><span class="line">    dec: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (PRIVATE -= n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> testInc = closureDemo.inc(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testInc); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testDec = closureDemo.dec(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testDec); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">closureDemo.div = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PRIVATE / n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testDiv = closureDemo.div(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testDiv);</span><br><span class="line"><span class="comment">//输出：Uncaught ReferenceError: PRIVATE is not defined</span></span><br></pre></td></tr></table></figure>
<p>自执行函数 closureDemo 执行完毕之后，自执行函数作用和 PRIVATE 变量随之销毁，但 PRIVATE 仍滞留在内存中，也就是加入了到了 closureDemo.inc 和 closureDemo.dec 的作用域链中，闭包也就完成了变量捕获。但之后新加入的 closureDemo.div 并不能在作用域中继续寻找到 PRIVATE 了。因为，函数只有被调用时才会执行函数里面的代码，变量的捕获也只发生在创建闭包时，所以之后新加入的 div 方法并不能捕获 PRIVATE。</p>
<h3 id="创建特权方法"><a href="#创建特权方法" class="headerlink" title="创建特权方法"></a>创建特权方法</h3><p>通过闭包我们可以创建私有作用域，那么也就可以创建私有变量和私有函数。创建私有函数的方式和声明私有变量方法一致，只要在函数内部声明函数就可以了。当然，既然可以模拟私有变量和私有函数，我们也可以利用闭包这个特性，创建特权方法。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">var</span> privateVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MyObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  MyObj.prototype.pubulicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVar++;</span><br><span class="line">    <span class="keyword">return</span> privateFun();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>上面这个实例创建了一个私有作用域，并封装了一个构造函数和对应的方法。需要注意的是在上面的实例中，在声明 MyObj 这个函数时，使用的是不带 var 的函数表达式，我们希望产生的是一个全局函数而不是局部的，不然我们依然在外部无法访问。所以，MyObj 就成为了一个全局变量，能够在外部进行访问，我们在原型上定义的方法 publicMethod 也就可以使用，通过这个方法我们也就可以访问私有函数和私有变量了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="http://www.cnblogs.com/syfwhu/p/4839562.html" target="_blank" rel="noopener">http://www.cnblogs.com/syfwhu/p/4839562.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型（四）IF 转换规则</title>
    <url>/blog/javascript/javascript-IF-False-options.html</url>
    <content><![CDATA[<p><strong><em>多言多败，多事多害。——《训蒙增广》</em></strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript数据类型（一） 常见数据类型</a><br><a href="/blog/javascript/javascript-type-one-question.html">JavaScript数据类型（二） 类型转换</a><br><a href="/blog/javascript/javascript-type-one-questionone.html">JavaScript数据类型（三）常见的面试题</a><br><a href="/blog/javascript/javascript-IF-False-options.html">JavaScript数据类型（四）IF 转换规则</a><br><a href="/blog/javascript/javascript-false-true.html">JavaScript数据类型（五）== 混乱的转换规则</a><br><a href="/blog/javascript/javascript-bool-type.html">JavaScript数据类型（六）多种数据类型判断方法</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>在 JavaScript 中使用 if 的时候，自己如果不注意的话很可能出现判断进错，其实在 JavaScript 中只有<font color="#ff502c">固定的几个值会转为 false，其它的统一认为为 true。</font></p>
<ul>
<li><font color="#ff502c">false</font></li>
<li><font color="#ff502c">null</font></li>
<li><font color="#ff502c">undefined</font></li>
<li><font color="#ff502c">空字符串’ ‘</font></li>
<li><font color="#ff502c">数字零 0</font></li>
<li><font color="#ff502c">NaN</font>

</li>
</ul>
<p>其他的全部都算为 true,<font color="#ff502c">‘false’</font>、<font color="#ff502c">‘0’</font>也是为 true,其实这也是一种隐性的类型转换。和 == 又有不同。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>由于逻辑表达式是<font color="#ff502c">从左往右</font>计算的，由于运算符优先级的存在，下面的表达式的结果却不相同。如下例所示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>) || <span class="literal">true</span>; <span class="comment">// 结果为 true</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; (<span class="literal">true</span> || <span class="literal">true</span>); <span class="comment">// 结果为 false</span></span><br></pre></td></tr></table></figure>
<p>右侧被小括号括起来的操作变成了独立的表达式。</p>
<font color="#ff502c">转换规则</font>:<br><br>- 将 AND 转换为 OR<br>- 将 OR 转换为 AND<br>- 删除嵌套的 AND<br>- 删除嵌套的 OR<br>  可参考&gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators</a><br><br>### 逻辑与(&amp;&amp;)<br><br>尽管 <code>&amp;&amp;</code> 和 <code>||</code> 运算符能够使用<font color="#ff502c">非布尔值</font>的操作数, 但它们依然被看作是<font color="#ff502c">布尔操</font>作符，因为它们的返回值总是能够被转换为<font color="#ff502c">布尔值</font>。<br>expr1 &amp;&amp; expr2<br>如果<font color="#ff502c">expr1</font>能转换为<font color="#ff502c">false</font>则返回<font color="#ff502c">expr1</font>,否则返回<font color="#ff502c">expr2</font>。因此，与布尔值一起使用时，如果<font color="#ff502c">两个</font>操作数都为<font color="#ff502c">true</font>时<font color="#ff502c">&amp;&amp;</font>返回<font color="#ff502c">true</font>,否则返回<font color="#ff502c">false</font>.<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a1 = <span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// t &amp;&amp; t 结果为 true</span></span><br><span class="line">a2 = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// t &amp;&amp; f 结果为 false</span></span><br><span class="line">a3 = <span class="literal">false</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// f &amp;&amp; t 结果为 false</span></span><br><span class="line">a4 = <span class="literal">false</span> &amp;&amp; <span class="number">3</span> == <span class="number">4</span>; <span class="comment">// f &amp;&amp; f 结果为 false</span></span><br><span class="line">a5 = <span class="string">"Cat"</span> &amp;&amp; <span class="string">"Dog"</span>; <span class="comment">// t &amp;&amp; t 结果为 Dog</span></span><br><span class="line">a6 = <span class="literal">false</span> &amp;&amp; <span class="string">"Cat"</span>; <span class="comment">// f &amp;&amp; t 结果为 false</span></span><br><span class="line">a7 = <span class="string">"Cat"</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// t &amp;&amp; f 结果为 false</span></span><br></pre></td></tr></table></figure><br><br>### 逻辑与(||)<br><br>expr1 &amp;&amp; expr2<br>如果<font color="#ff502c">expr1</font>能转换为<font color="#ff502c">true</font>则返回<font color="#ff502c">expr1</font>,否则返回<font color="#ff502c">expr2</font>。因此，与布尔值一起使用时，如果<font color="#ff502c">任意一个</font>操作数为<font color="#ff502c">true</font>时<font color="#ff502c">||</font>返回<font color="#ff502c">true</font>.<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">o1 = <span class="literal">true</span> || <span class="literal">true</span>; <span class="comment">// t || t 结果为 true</span></span><br><span class="line">o2 = <span class="literal">false</span> || <span class="literal">true</span>; <span class="comment">// f || t 结果为 true</span></span><br><span class="line">o3 = <span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">// t || f 结果为 true</span></span><br><span class="line">o4 = <span class="literal">false</span> || <span class="number">3</span> == <span class="number">4</span>; <span class="comment">// f || f 结果为 false</span></span><br><span class="line">o5 = <span class="string">"Cat"</span> || <span class="string">"Dog"</span>; <span class="comment">// t || t 结果为 Cat</span></span><br><span class="line">o6 = <span class="literal">false</span> || <span class="string">"Cat"</span>; <span class="comment">// f || t 结果为 Cat</span></span><br><span class="line">o7 = <span class="string">"Cat"</span> || <span class="literal">false</span>; <span class="comment">// t || f 结果为 Cat</span></span><br></pre></td></tr></table></figure><br><br>### 逻辑非(!)<br><br>!expr 如果单个表达式能转换为<font color="#ff502c">true</font>的话返回<font color="#ff502c">false</font>，否则返回<font color="#ff502c">true</font>。<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">n1 = !<span class="literal">true</span>; <span class="comment">// !t 结果为 false</span></span><br><span class="line">n2 = !<span class="literal">false</span>; <span class="comment">// !f 结果为 true</span></span><br><span class="line">n3 = !<span class="string">"Cat"</span>; <span class="comment">// !t 结果为 false</span></span><br></pre></td></tr></table></figure><br><br>## 总结<br><br>在 JavaScript 中使用 if 的时候，自己如果不注意的话很可能出现判断进错，其实在 JavaScript 中只有<font color="#ff502c">固定的几个值会转为 false，其它的统一认为为 true</font>。<br><br>- <font color="#ff502c">false</font><br>- <font color="#ff502c">null</font><br>- <font color="#ff502c">undefined</font><br>- <font color="#ff502c">空字符串’ ‘</font><br>- <font color="#ff502c">数字零 0</font><br>- <font color="#ff502c">NaN</font>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中垃圾回收机制 （-）</title>
    <url>/blog/javascript/javascript-GC.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><font color="#ff502c">JavaScript 创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。</font> 后一个过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理。<font color="#ff502c">而不是别人所说的:编写 JavaScript 程序时，所需内存的分配以及无用内存的回收完全实现自动管理</font>但是他会按照固定的时间间隔（或代码执行中预定的收集时间）周期性地执行这一操作<br><br>## 内存生命周期<br><br>其实别的语言的内存声明周期基本是那个是一致的：<br><br>1. 分配你所需要的内存<br>2. 使用分配到内存（读、写）<br>3. 不需要时将其释放\归还<br><br>### JavaScript 的内存分配<br><br>1. JavaScript 在定义变量时就完成了内存分配<br>2. 通过函数调用分配内存<br><br>### 内存释放<br><br>当内存不再需要使用时释放，高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。<br><br>## 两种垃圾回收方式<br><br>浏览器的内存处理基本分为两种，<font color="#ff502c">引用技术垃圾收集</font>、<font color="#ff502c">标记清除</font>两种，下面一一介绍。<br><br>### 引用计数<br><br>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br><font color="#ff502c">但是他有比较大的限制，就是当对象循环引用，引用计数不会回收它</font>

<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>垃圾收集器会按照固定的时间间隔周期性的执行这一操作。<br>从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。<br>简单来讲就是，当变量进入环境时，就是将变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。<br>收集器在运行时会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。剩下的在被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量。最后，垃圾收集器完成内存清除，销毁那些带有标记的值并收回它们所占用的内存空间。<br>这中算法是没有循环引用限制的</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli中引入static文件中的iconfont无法显示解决方法</title>
    <url>/blog/webpack/webpack-build-iconfont.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在使用 webpack 打包自己在 icomoon 中的制作的 iconfont,即使放到最外层的 static 文件家中，打包后它的路径也是不对的，这个在 vue 的 github 的 issue 中有人是这么解决的<br>在 build 文件夹中的 utils.js 中用 vue-style-loader 来编译 css,修改如下<br>原</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.extract) &#123;</span><br><span class="line">  <span class="keyword">return</span> ExtractTextPlugin.extract(&#123;</span><br><span class="line">    use: loaders,</span><br><span class="line">    fallback: <span class="string">"vue-style-loader"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">"vue-style-loader"</span>].concat(loaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加路径后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.extract) &#123;</span><br><span class="line">  <span class="keyword">return</span> ExtractTextPlugin.extract(&#123;</span><br><span class="line">    use: loaders,</span><br><span class="line">    fallback: <span class="string">"vue-style-loader"</span>,</span><br><span class="line">    <span class="comment">// 添加路径</span></span><br><span class="line">    publicPath: <span class="string">"../../"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">"vue-style-loader"</span>].concat(loaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样编译完成以后的 iconfont 路径是正确的</p>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发中mock数据的几种办法</title>
    <url>/blog/node/mockData.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在项目开发中，有很多时候是在后台接口还没开发好，有的是 api 接口都没写，有的是有 api 接口但是没有数据，不管是那种，都是在大家都对数据格式，接口的方式都是有统一了的，才能做 mock 数据，不然的话数据格式变化，接口内容变化，基本上前端 mock 不 mocK 数据基本上没什么用，还是等于对接两遍。</p>
<ul>
<li>我自己的建议，当有接口 api 的时候，但是没有真实数据的时候，我推荐用<font color="#ff502c">mock.js</font>来解决问题，不需要自己再用 express，或者别的框架自己发布本地接口，直接在 ajax 返回数据的时候改变 response 的 data 数据</li>
<li>另一种就是完全都没有后台接口的时候，要自己本地跑起来接口或者别的地方要有接口 api 才可以 mock 数据，建议使用<font color="#ff502c">easy-mock</font></li>
</ul>
<h3 id="mock-js"><a href="#mock-js" class="headerlink" title="mock.js"></a>mock.js</h3><ul>
<li>首先：<br>可以在自己项目中的 package.json 中添加 mock.js 和版本号<font color="#ff502c">“mockjs”: “^1.0.1-beta3”</font>可以通过在 github 中看他的 tag 号，使用他最稳定的版本，通过<font color="#ff502c">npm install</font>or<font color="#ff502c">cnpm install</font>or<font color="#ff502c">yarn</font>都是可以的，这个完全看自己的网络了。</li>
<li>然后：<br>在自己的<font color="#ff502c">api</font>同级创建一个<font color="#ff502c">mock 文件夹</font>在里面再创建一个叫做，mock.js 的文件。我只是简单的做一个 demo,具体的 mock 怎么构思和构建要看自己的业务，可以见一个总开关来控制是否 mock 数据，和子开关来控制是否 mock 子接口，如<font color="#ff502c">process.env.NODE_ENV</font> 或者别的全局来判断是否开启 mock 数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span>;</span><br><span class="line"><span class="keyword">let</span> Random = Mock.Random; <span class="comment">// 这个只是 其中的一种形式 还有其他两种</span></span><br><span class="line"><span class="keyword">const</span> oMsgData = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'list|10'</span>: [&#123;</span><br><span class="line">    name: <span class="string">'@cname'</span>,</span><br><span class="line">    id: <span class="string">'@increment'</span>,</span><br><span class="line">    content: <span class="string">'@csentence'</span>,</span><br><span class="line">    createTime: <span class="string">'@date'</span>,</span><br><span class="line">    isRead: <span class="built_in">Number</span>(Random.boolean()),</span><br><span class="line">    isTop: <span class="built_in">Number</span>(Random.boolean()),</span><br><span class="line">    state: <span class="built_in">Number</span>(Random.boolean()),</span><br><span class="line">    type: <span class="string">'@increment'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// console.log(JSON.stringify(oMsgData, null, 4));</span></span><br><span class="line"><span class="comment">// console.log(oMsgData);</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; rurl 要替换的接口路径名</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; rtype 要替换的接口请求方式</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; data 要替换的接口的response的data</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">// 他会自动帮你填写 域名和端口号 rurl rtype response.data</span></span><br><span class="line"><span class="comment">Mock.mock('/api/notice/noticeListAdmin', 'post', &#123;oMsgData&#125;);</span></span><br></pre></td></tr></table></figure>
<p>具体的参数我这个就不讲了，首先引入<font color="#ff502c">Mock.js</font>,然后可以通过<font color="#ff502c"> ‘@cname’</font>生成随机的名字，也可以通过<font color="#ff502c"> Mock.Random.cname()</font>生成随机名字。<br>[参考] <a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a> 这个是 mock.js 的官方文档，里面有 mock 的具体用法.</p>
<h3 id="easy-mock"><a href="#easy-mock" class="headerlink" title="easy-mock"></a>easy-mock</h3><p>这种是在线方式的，完全可以在他这个里面创建一套符合自己的 api 接口，具体当可以看下面的连接，这个我感觉没什么好讲的了，因为感觉自己归纳的也没有人家文档好，反正是挺好的。<br>[easy-mock] <a href="https://easy-mock.com/docs" target="_blank" rel="noopener">https://easy-mock.com/docs</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中float精度问题</title>
    <url>/blog/javascript/float-Operation.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在用到 JavaScript 中 float 类型的值来运算时,会产生精度不准的问题。<br>例如：<br><img src="../../images/float/float.jpg" alt="float operation"><br>可以看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure>
<p>它得到的值是不精准的，简单来说，你的电脑做着正确的二进制浮点运算，但问题是你输入的是十进制的数，电脑以二进制运算，这两者并不是总是转化那么好的。<br>同时在调用<font color="#ff502c">Number.toFixed</font>在不同的<font color="#ff502c">浏览器</font>也会得到不同的结果。<br><a href="https://www.zhihu.com/question/20679634" target="_blank" rel="noopener">想了解更详细的请参考</a></p>
<h3 id="精度运算丢失"><a href="#精度运算丢失" class="headerlink" title="精度运算丢失"></a>精度运算丢失</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通精度丢失</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> !== <span class="number">0.3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 大整数运算</span></span><br><span class="line"><span class="number">9999999999999999</span> === <span class="number">10000000000000001</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">9007199254740992</span>;</span><br><span class="line">x + <span class="number">1</span> === x; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="toFixed-在不同浏览器的表现"><a href="#toFixed-在不同浏览器的表现" class="headerlink" title="toFixed 在不同浏览器的表现"></a>toFixed 在不同浏览器的表现</h3><h4 id="IE6-10"><a href="#IE6-10" class="headerlink" title="IE6-10"></a>IE6-10</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.35</span>).toFixed(<span class="number">1</span>); <span class="comment">// 1.4 正确</span></span><br><span class="line">(<span class="number">1.335</span>).toFixed(<span class="number">2</span>); <span class="comment">// 1.34  正确</span></span><br><span class="line">(<span class="number">1.3335</span>).toFixed(<span class="number">3</span>); <span class="comment">// 1.334 正确</span></span><br><span class="line">(<span class="number">1.33335</span>).toFixed(<span class="number">4</span>); <span class="comment">// 1.3334 正确</span></span><br><span class="line">(<span class="number">1.333335</span>).toFixed(<span class="number">5</span>); <span class="comment">// 1.33334 正确</span></span><br><span class="line">(<span class="number">1.3333335</span>).toFixed(<span class="number">6</span>); <span class="comment">// 1.333334 正确</span></span><br></pre></td></tr></table></figure>
<h4 id="chrome44-firefox41-里对于最后一位是-5-的有时竟然没有进位"><a href="#chrome44-firefox41-里对于最后一位是-5-的有时竟然没有进位" class="headerlink" title="chrome44/firefox41 里对于最后一位是 5 的有时竟然没有进位"></a>chrome44/firefox41 里对于最后一位是 5 的有时竟然没有进位</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.35</span>).toFixed(<span class="number">1</span>); <span class="comment">// 1.4 正确</span></span><br><span class="line">(<span class="number">1.335</span>).toFixed(<span class="number">2</span>); <span class="comment">// 1.33  错误</span></span><br><span class="line">(<span class="number">1.3335</span>).toFixed(<span class="number">3</span>); <span class="comment">// 1.333 错误</span></span><br><span class="line">(<span class="number">1.33335</span>).toFixed(<span class="number">4</span>); <span class="comment">// 1.3334 正确</span></span><br><span class="line">(<span class="number">1.333335</span>).toFixed(<span class="number">5</span>); <span class="comment">// 1.33333 错误</span></span><br><span class="line">(<span class="number">1.3333335</span>).toFixed(<span class="number">6</span>); <span class="comment">// 1.333333 错误</span></span><br></pre></td></tr></table></figure>
<h2 id="JS-数字丢失精度的原因"><a href="#JS-数字丢失精度的原因" class="headerlink" title="JS 数字丢失精度的原因"></a>JS 数字丢失精度的原因</h2><p>计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。如图<br><img src="../../images/float/float_bug.png" alt="float operation"></p>
<p><strong>意义</strong></p>
<ul>
<li>1 位用来表示符号位</li>
<li>11 位用来表示指数</li>
<li>52 位表示尾数<br>浮点数，比如</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> &gt;&gt; <span class="number">0.0001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span>…（<span class="number">1001</span>无限循环）</span><br><span class="line"><span class="number">0.2</span> &gt;&gt; <span class="number">0.0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span>…（<span class="number">0011</span>无限循环）</span><br></pre></td></tr></table></figure>
<p>此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。</p>
<p>大整数的精度丢失和浮点数本质上是一样的，尾数位最大是<font color="#ff502c"> 52 </font>位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992。</p>
<p>大于 9007199254740992 的可能会丢失精度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">9007199254740992</span>     &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.000</span> <span class="comment">// 共计 53 个 0</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">1</span> &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.001</span> <span class="comment">// 中间 52 个 0</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">2</span> &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.010</span> <span class="comment">// 中间 51 个 0</span></span><br></pre></td></tr></table></figure>
<p>实际上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> + <span class="number">1</span>; <span class="comment">// 丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">2</span>; <span class="comment">// 未丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">3</span>; <span class="comment">// 丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">4</span>; <span class="comment">// 未丢失</span></span><br></pre></td></tr></table></figure>
<p>以上，可以知道看似有穷的数字, 在计算机的二进制表示里却是无穷的，由于存储位数限制因此存在<font color="#ff502c">“舍去” </font>，精度丢失就发生了。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="运算丢失精度"><a href="#运算丢失精度" class="headerlink" title="运算丢失精度"></a>运算丢失精度</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * floatObj 包含加减乘除四个方法，能确保浮点数运算不丢失精度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们知道计算机编程语言里浮点数计算会存在精度丢失问题（或称舍入误差），其根本原因是二进制和实现位数限制有些数无法有限表示</span></span><br><span class="line"><span class="comment"> * 以下是十进制小数对应的二进制表示</span></span><br><span class="line"><span class="comment"> *      0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）</span></span><br><span class="line"><span class="comment"> *      0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）</span></span><br><span class="line"><span class="comment"> * 计算机里每种数据类型的存储是一个有限宽度，比如 JavaScript 使用 64 位存储数字类型，因此超出的会舍去。舍去的部分就是精度丢失的部分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ** method **</span></span><br><span class="line"><span class="comment"> *  add / subtract / multiply /divide</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ** explame **</span></span><br><span class="line"><span class="comment"> *  0.1 + 0.2 == 0.30000000000000004 （多了 0.00000000000004）</span></span><br><span class="line"><span class="comment"> *  0.2 + 0.4 == 0.6000000000000001  （多了 0.0000000000001）</span></span><br><span class="line"><span class="comment"> *  19.9 * 100 == 1989.9999999999998 （少了 0.0000000000002）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * floatObj.add(0.1, 0.2) &gt;&gt; 0.3</span></span><br><span class="line"><span class="comment"> * floatObj.multiply(19.9, 100) &gt;&gt; 1990</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> floatObj = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 判断obj是否为一个整数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(obj) === obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100</span></span><br><span class="line"><span class="comment">   * @param floatNum &#123;number&#125; 小数</span></span><br><span class="line"><span class="comment">   * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">   *   &#123;times:100, num: 314&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toInteger</span>(<span class="params">floatNum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = &#123; <span class="attr">times</span>: <span class="number">1</span>, <span class="attr">num</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> isNegative = floatNum &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isInteger(floatNum)) &#123;</span><br><span class="line">      ret.num = floatNum;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> strfi = floatNum + <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> dotPos = strfi.indexOf(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">var</span> len = strfi.substr(dotPos + <span class="number">1</span>).length;</span><br><span class="line">    <span class="keyword">var</span> times = <span class="built_in">Math</span>.pow(<span class="number">10</span>, len);</span><br><span class="line">    <span class="keyword">var</span> intNum = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.abs(floatNum) * times + <span class="number">0.5</span>, <span class="number">10</span>);</span><br><span class="line">    ret.times = times;</span><br><span class="line">    <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">      intNum = -intNum;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.num = intNum;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 核心方法，实现加减乘除运算，确保不丢失精度</span></span><br><span class="line"><span class="comment">   * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param a &#123;number&#125; 运算数1</span></span><br><span class="line"><span class="comment">   * @param b &#123;number&#125; 运算数2</span></span><br><span class="line"><span class="comment">   * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数</span></span><br><span class="line"><span class="comment">   * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params">a, b, digits, op</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o1 = toInteger(a);</span><br><span class="line">    <span class="keyword">var</span> o2 = toInteger(b);</span><br><span class="line">    <span class="keyword">var</span> n1 = o1.num;</span><br><span class="line">    <span class="keyword">var</span> n2 = o2.num;</span><br><span class="line">    <span class="keyword">var</span> t1 = o1.times;</span><br><span class="line">    <span class="keyword">var</span> t2 = o2.times;</span><br><span class="line">    <span class="keyword">var</span> max = t1 &gt; t2 ? t1 : t2;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">        <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">          <span class="comment">// 两个小数位数相同</span></span><br><span class="line">          result = n1 + n2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">          <span class="comment">// o1 小数位 大于 o2</span></span><br><span class="line">          result = n1 + n2 * (t1 / t2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// o1 小数位 小于 o2</span></span><br><span class="line">          result = n1 * (t2 / t1) + n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result / max;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"subtract"</span>:</span><br><span class="line">        <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">          result = n1 - n2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">          result = n1 - n2 * (t1 / t2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result = n1 * (t2 / t1) - n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result / max;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"multiply"</span>:</span><br><span class="line">        result = (n1 * n2) / (t1 * t2);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"divide"</span>:</span><br><span class="line">        result = (n1 / n2) * (t2 / t1);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加减乘除的四个接口</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operation(a, b, digits, <span class="string">"add"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operation(a, b, digits, <span class="string">"subtract"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operation(a, b, digits, <span class="string">"multiply"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operation(a, b, digits, <span class="string">"divide"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exports</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    subtract: subtract,</span><br><span class="line">    multiply: multiply,</span><br><span class="line">    divide: divide</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="toFixed-兼容封装"><a href="#toFixed-兼容封装" class="headerlink" title="toFixed 兼容封装"></a>toFixed 兼容封装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFixed</span>(<span class="params">num, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> times = <span class="built_in">Math</span>.pow(<span class="number">10</span>, s);</span><br><span class="line">  <span class="keyword">var</span> des = num * times + <span class="number">0.5</span>;</span><br><span class="line">  des = <span class="built_in">parseInt</span>(des, <span class="number">10</span>) / times;</span><br><span class="line">  <span class="keyword">return</span> des + <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尾数位最大是<font color="#ff502c"> 52 </font>位，当出现不能<strong>无限循环的二进制时</strong>，只能通过四舍五入来储存。<br>这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie_function</title>
    <url>/blog/javascript/javascript-cookie-function.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Cookie-在客户端-JavaScript-中"><a href="#Cookie-在客户端-JavaScript-中" class="headerlink" title="Cookie 在客户端 JavaScript 中"></a>Cookie 在客户端 JavaScript 中</h3><p>用 JavaScript 操作<font color="#ff502c">Cookie</font>，用原声的接口<font color="#ff502c">document.cookie</font>属性是比较难用的，所以封装一个添加、修改、删除的操作方法还是很有必要的。<br>同时要注意的是： Cookie 的所有<font color="#ff502c">name</font>和<font color="#ff502c">value</font>都是要经过<font color="#ff502c">URI</font>编码的，必须使用<font color="#ff502c">decodeURICompoent()</font>来编码。</p>
<h2 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h2><p>在浏览器端可以通过<code>document.cookie</code>来创建<code>cookie</code>，但是<code>cookie</code>只能是字符串形式并且格式必须是<code>url</code>格式，所以就要自行封装方法来使用。</p>
<p>代码封装如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @params &#123;String&#125; key 键名</span></span><br><span class="line"><span class="comment">* @params &#123;String&#125; value 键值</span></span><br><span class="line"><span class="comment">* @params &#123;String&#125; options 配置项 如 readOnly expires path secure</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">key, value, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否有document</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认配置</span></span><br><span class="line">  <span class="keyword">var</span> defalutConfig = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 合并配置</span></span><br><span class="line">  <span class="keyword">var</span> options = extend(defalutConfig, &#123;&#125;, options);</span><br><span class="line">  <span class="comment">// 判断expires是否为数字</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options.expires === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> days = options.expires, t = options.expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    t.setMilliseconds(t.getMilliseconds() + days * <span class="number">864e+5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断value是否为object，是的话通过JSON.stringify序列化</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="built_in">Object</span>.prototype.toString.call(value) !== <span class="string">'[object Object]'</span> ? <span class="built_in">String</span>(value) : <span class="built_in">JSON</span>.stringify(value);</span><br><span class="line">  <span class="built_in">document</span>.cookie = [</span><br><span class="line">    <span class="built_in">encodeURIComponent</span>(key), <span class="string">'='</span>, value,</span><br><span class="line">    options.expires ? <span class="string">'; expires='</span> + options.expires.toUTCString() : <span class="string">''</span>, <span class="comment">// use expires attribute, max-age is not supported by IE</span></span><br><span class="line">    options.path    ? <span class="string">'; path='</span> + options.path : <span class="string">''</span>,</span><br><span class="line">    options.domain  ? <span class="string">'; domain='</span> + options.domain : <span class="string">''</span>,</span><br><span class="line">    options.secure  ? <span class="string">'; secure'</span> : <span class="string">''</span></span><br><span class="line">  ].join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @descriptor 合并options</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;,</span><br><span class="line">    args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">    len = args.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> options = args[i];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">      result[key] = options[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setCookie(<span class="string">'token'</span>, <span class="string">'asd1231asdas123sfdsdf3453asas121asd'</span>, &#123;<span class="attr">expires</span>: <span class="number">1</span>, <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">domain</span>: <span class="string">'localhost'</span>&#125;)</span><br><span class="line"><span class="comment">// "token=asd1231asdas123sfdsdf3453asas121asd; expires=Fri, 20 Sep 2019 06:46:09 GMT; path=/; domain=localhost"</span></span><br></pre></td></tr></table></figure>
<h2 id="读取Cookie"><a href="#读取Cookie" class="headerlink" title="读取Cookie"></a>读取Cookie</h2><p>可以通过<code>document.cookie</code>获取<code>cookie</code>，但是要转换为对象，实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.replace(<span class="regexp">/(%[0-9A-Z]&#123;2&#125;)+/g</span>, <span class="built_in">decodeURIComponent</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @params &#123;Stirng&#125; key 要获取的键值</span></span><br><span class="line"><span class="comment">* @params &#123;Boolean&#125; json 是否返回json格式</span></span><br><span class="line"><span class="comment">* @return &#123;Object&#125; 返回cookie</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span> (<span class="params">key, json</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否存在document</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明变量</span></span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;,</span><br><span class="line">      cookies = <span class="built_in">document</span>.cookie ? <span class="built_in">document</span>.cookie.split(<span class="string">'; '</span>) : [],</span><br><span class="line">      len = cookies.length;</span><br><span class="line">  <span class="comment">// 循环获取cookie，拼接or匹配 key</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 以‘=’分割数组</span></span><br><span class="line">    <span class="keyword">var</span> parts = cookies[i].split(<span class="string">'='</span>),</span><br><span class="line">      cookie = parts.slice(<span class="number">1</span>).join(<span class="string">'='</span>);</span><br><span class="line">    <span class="keyword">if</span> (!json &amp;&amp; cookie.charAt(<span class="number">0</span>) === <span class="string">''</span>) &#123;</span><br><span class="line">      cookie = cookie.slice(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过decodeURIComponent 解码</span></span><br><span class="line">      <span class="keyword">var</span> name = decode(parts[<span class="number">0</span>]);</span><br><span class="line">      cookie = decode(cookie);</span><br><span class="line">      <span class="comment">// 根据实参json返回不同的数据类型</span></span><br><span class="line">      <span class="keyword">if</span> (json) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cookie = <span class="built_in">JSON</span>.parse(cookie);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result[name] = cookie;</span><br><span class="line">      <span class="keyword">if</span> (key === name) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回数据</span></span><br><span class="line">  <span class="keyword">return</span> key ? result[key]: result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">getCookie(<span class="string">'user'</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// &#123;name: "admin", age: 18&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h2><p>同样通过<code>setCookie</code>来实现删除<strong>cookie</strong>，只是传入特定参数<code>expires: -1</code>，实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span> (<span class="params">key, options</span>) </span>&#123;</span><br><span class="line">  setCookie(key, <span class="string">''</span>, extend(options, &#123; <span class="attr">expires</span>: <span class="number">-1</span> &#125;));</span><br><span class="line">  <span class="keyword">return</span> !getCookie(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">removeCookie(<span class="string">'token'</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>到此<code>cookie</code>的操作到此结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章比较简单，记录了对<code>cookie</code>的<strong>增删改查</strong>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue官方的vue-cli一些优化打包方式的配置和方法，懒加载和dll优化方式</title>
    <url>/blog/vue/vue-build-dll.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>我用了官方脚手架 vue-cli，有两个页面<font color="#ff502c">ppt_model.vue</font>和 <font color="#ff502c">ppt_model1.vue</font>,在两个页面中分别引入了 echarts、jquery<br>他<font color="#ff502c">默认</font>会把所有的报都打包到 <font color="#ff502c">app.js</font>和<font color="#ff502c">vendor.js</font>中。<br>运行<font color="#ff502c">npm run build –report</font><br>如下图所示：<br>在 cmd 中显示打包信息<br><img src="../../images/vue_build/vue_build_dos1.jpg" alt="cmd build"><br>在页面中显示打包信息<br><img src="../../images/vue_build/vue_build_dos2.jpg" alt="html build"></p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>使用 vue-router 官方推荐的懒加载,基本语法是 <font color="#ff502c">component: resolve =&gt; require([‘../view/ppt_model.vue’], resolve)</font><br>会把每一个页面分开打包成一个 js 文件，当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。<br>参考 &gt; <a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/advanced/lazy-loading.html</a><br>打包如下所示：<br>在 cmd 中显示打包信息<br><img src="../../images/vue_build/vue_build_dos3.jpg" alt="cmd build"><br>在页面中显示打包信息<br><img src="../../images/vue_build/vue_build_dos4.jpg" alt="html build"><br>其中的<font color="#ff502c">static/js/0.66e1ff74acbd166fa927.js</font>对应的是<font color="#ff502c">ppt_model.vue</font>页面</p>
<font color="#ff502c">static/js/1.f09ddc0b737b2466f148.js</font>对应的是<font color="#ff502c">ppt_model1.vue</font>页面<br><br>## webpack 官方提供的 DllReferencePlugin<br><br>这个插件是在 webpack 主配置文件中设置的， 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。<br>简单的说，就是把静态的插件库打包到一个静态文件里，同时生成对静态文件引用的 json 文件，通过 webpack 的 DllReferencePlugin 插件实现，打包的优化.<br>首先创建一个名为<font color="#ff502c">webpack.dll.config.js</font>文件，内容为：<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">"vue-router"</span>, <span class="string">"echarts"</span>, <span class="string">"jquery"</span>, <span class="string">"vue"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">"../static/js"</span>),</span><br><span class="line">    filename: <span class="string">"dll.[name].js"</span>,</span><br><span class="line">    library: <span class="string">"[name]"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">"dll"</span>, <span class="string">"[name]-manifest.json"</span>),</span><br><span class="line">      name: <span class="string">"[name]"</span>,</span><br><span class="line">      context: path.resolve(__dirname, <span class="string">"client"</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>在你的项目文件夹目录 cmd 中运行<font color="#ff502c">webpack –config ./build/webpack.dll.config.js</font>在<font color="#ff502c">build</font>中新建了一个<font color="#ff502c">dll</font>中有一个<font color="#ff502c">vendor-manifest.json</font>和，在<font color="#ff502c">static(最外层的 static)</font>中新建一个<font color="#ff502c">dll.vendor.js</font>。<br>在<font color="#ff502c">build</font>文件中<font color="#ff502c">webpack.prod.conf.js</font>添加一段代码<br>在打包前记得在 index.html 最下方，因为打包生成的 js,<font color="#ff502c"><script src="./static/js/dll.vendor.js"></script></font>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记得在plugins中添加</span></span><br><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">"client"</span>),</span><br><span class="line">    manifest: <span class="built_in">require</span>(<span class="string">"./dll/vendor-manifest.json"</span>)</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>再运行<font color="#ff502c">npm run build –report</font><br>运行结果如图所示：<br>在 cmd 中显示打包信息<br><img src="../../images/vue_build/vue_build_dos6.jpg" alt="cmd build"><br>在页面中显示打包信息<br><img src="../../images/vue_build/vue_build_dos7.jpg" alt="html build"></p>
<p><font color="#ff502c"><strong>注意</strong></font><br>在打包前记得在 index.html 最下方，引入打包生成的 js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>dq2.0<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./static/js/dll.vendor.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果报错，请参考 &gt; <a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/advanced/lazy-loading.html</a><br>本地可以预览页面效果，接口是不能调用的，dist 中的 index.html</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>heatmap.js绘制热力图和擦除热力图</title>
    <url>/blog/canvas/canvas-hetamap-draw.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>绘制了热力图的时候用到了插件heatmap.js,高德地图的热力图也是用了这个插件来绘制的。<br>heatmap &gt; <a href="https://www.patrick-wied.at/static/heatmapjs/" target="_blank" rel="noopener">https://www.patrick-wied.at/static/heatmapjs/</a><br>可能比较冷门，一般的话相信没人会用这个工具的，但是现在大数据这么火，相信还是有人能用到的。<br>要做的是，上传一张图片，然后在图片上绘制热力图，同是也是可以擦除，这个只是一个小的demo,可以根据自己的实际场景来实际应用</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>默认是绘制图形，点击清除，擦除热力图</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            .heatmap &#123;</span><br><span class="line">                width:1800px; height:600px;border: 1px solid;border-color: grey;cursor: pointer;</span><br><span class="line">            &#125;</span><br><span class="line">            .imgUpdate &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                left: 10px;</span><br><span class="line">                top: 60px;</span><br><span class="line">                z-index: -999;</span><br><span class="line">            &#125;</span><br><span class="line">            .draw, .clear&#123;</span><br><span class="line">                display: inline-block;</span><br><span class="line">                width: 50px;</span><br><span class="line">                height: 50px;</span><br><span class="line">            &#125;</span><br><span class="line">            .circle &#123;</span><br><span class="line">                width: 15px;</span><br><span class="line">                height: 15px;</span><br><span class="line">                position: absolute;</span><br><span class="line">                border: 2px solid red;</span><br><span class="line">                border-radius: 100%;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"activat"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"draw"</span>&gt;</span>画图<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span>清除<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"heatmap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ge_pic_icon_Infor"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"imgUpdate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"Infor_file"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"uploadPicture"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">"上传照片"</span> <span class="attr">onchange</span>=<span class="string">"getPhoto(this)"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/heatmap.js/2.0.2/heatmap.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> hm = <span class="built_in">document</span>.querySelector(<span class="string">'.heatmap'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> clearDom = <span class="built_in">document</span>.querySelector(<span class="string">'.clear'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> drawDom = <span class="built_in">document</span>.querySelector(<span class="string">'.draw'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> circleDom = <span class="built_in">document</span>.querySelector(<span class="string">'.circle'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> State = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// var hehedom = document.querySelector('#hehe');</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// hehedom.addEventListener('change', function () &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     console.log(this.value)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;);</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> heatmap = h337.create(&#123;</span></span><br><span class="line">        container: hm,</span><br><span class="line">        radius: 30</span><br><span class="line">    &#125;);</span><br><span class="line">    heatmap.setData (&#123;</span><br><span class="line">    max: 100,</span><br><span class="line">    min: 0,</span><br><span class="line">    data: []</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> lastX, lastY;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> key = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    body.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line">        key = 1;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    body.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line">        key = 0;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> arr = [];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> arr1 = [];</span></span><br><span class="line"><span class="javascript">    hm.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// console.log(222);</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (key !== <span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// console.log(ev);</span></span></span><br><span class="line">        lastX = ev.pageX;</span><br><span class="line">        lastY = ev.pageY - 50;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line">            x: lastX,</span><br><span class="line">            y: lastY,</span><br><span class="line">            value: 10</span><br><span class="line">        &#125;</span><br><span class="line">        heatmap.addData(obj);</span><br><span class="line">        arr.push(obj);</span><br><span class="line"><span class="javascript">        <span class="comment">// console.log(obj);</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    drawDom.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        hm.onmousemove = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        hm.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (key !== <span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// console.log(ev);</span></span></span><br><span class="line">            lastX = ev.pageX;</span><br><span class="line">            lastY = ev.pageY - 50;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line">                x: lastX,</span><br><span class="line">                y: lastY,</span><br><span class="line">                value: 10</span><br><span class="line">            &#125;</span><br><span class="line">            heatmap.addData(obj);</span><br><span class="line">            arr.push(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    clearDom.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        hm.onmousemove = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        hm.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            circleDom.style.left = ev.pageX + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="javascript">            circleDom.style.top = ev.pageY + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (key !== <span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// console.log(ev);</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> arr2 = [];</span></span><br><span class="line"><span class="javascript">            arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(typeof ev.pageX);</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(ev.pageX + '' + ev.pageY);</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// for (let i = 0; i &lt;= 15; i++) &#123;</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> dx = ev.pageX - item.x;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> dy = ev.pageY - item.y - <span class="number">50</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// console.log((dx * dx) + (dy * dy));</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> ((dx * dx) + (dy * dy) &lt;= <span class="number">15</span> * <span class="number">15</span>)&#123;</span></span><br><span class="line">                        arr2.push(index);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (arr2.length) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(arr2)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> arr3 = [];</span></span><br><span class="line"><span class="javascript">            <span class="comment">// console.log(arr);</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (arr.length === <span class="number">1</span>) &#123;</span></span><br><span class="line">                    arr = [];</span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">                    arr.splice((arr2[i]-i), 1)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> oObj = &#123;</span></span><br><span class="line">                max: 100,</span><br><span class="line">                min: 0,</span><br><span class="line">                data: arr</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.heatmap.setData(oObj);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> imgurl = <span class="string">""</span>;  </span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getPhoto</span>(<span class="params">node</span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> imgURL = <span class="string">""</span>;  </span></span><br><span class="line"><span class="javascript">            <span class="keyword">try</span>&#123;  </span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> file = <span class="literal">null</span>;  </span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(node.files &amp;&amp; node.files[<span class="number">0</span>] )&#123;  </span></span><br><span class="line">                    file = node.files[0];  </span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.files &amp;&amp; node.files.item(<span class="number">0</span>)) &#123;  </span></span><br><span class="line">                    file = node.files.item(0);  </span><br><span class="line">                &#125;  </span><br><span class="line"><span class="javascript">                <span class="comment">//Firefox 因安全性问题已无法直接通过input[file].value 获取完整的文件路径  </span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">try</span>&#123;  </span></span><br><span class="line">                    imgURL =  file.getAsDataURL();  </span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">catch</span>(e)&#123;  </span></span><br><span class="line"><span class="javascript">                    imgRUL = <span class="built_in">window</span>.URL.createObjectURL(file);  </span></span><br><span class="line">                &#125;  </span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">catch</span>(e)&#123;  </span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (node.files &amp;&amp; node.files[<span class="number">0</span>]) &#123;  </span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();  </span></span><br><span class="line"><span class="javascript">                    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  </span></span><br><span class="line">                        imgURL = e.target.result;  </span><br><span class="line">                    &#125;;  </span><br><span class="line">                    reader.readAsDataURL(node.files[0]);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            creatImg(imgRUL);  </span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> imgURL;  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    </span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">creatImg</span>(<span class="params">imgRUL</span>)</span>&#123;  </span></span><br><span class="line"><span class="xml">            // var textHtml = "<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'"+imgRUL+"'</span><span class="attr">width</span>=<span class="string">'414px'</span> <span class="attr">height</span>=<span class="string">'600px'</span>/&gt;</span>";</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.querySelector(<span class="string">".imgUpdate"</span>).setAttribute(<span class="string">'src'</span>, imgRUL);  </span></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如图所示：<br>  <img src="../../images/heatmap/heatmap1.jpg" alt="hearmap draw"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>heatmap</tag>
      </tags>
  </entry>
  <entry>
    <title>实现经典的三列布局</title>
    <url>/blog/css/css-Classic-layout.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>圣杯布局和双飞翼布局解决的问题是一样的，就是两边<font color="#ff502c">定宽</font>，中间<font color="#ff502c">自适应</font>的三栏布局，<font color="#ff502c">中间栏</font>要在放在文档流前面以<font color="#ff502c">优先渲染</font>。</p>
<h3 id="区别和统一"><a href="#区别和统一" class="headerlink" title="区别和统一"></a>区别和统一</h3><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是<font color="#ff502c">三栏</font>全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。</p>
<p>不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：<br>圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。</p>
<p>双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。</p>
<p>简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“，而不是你题目中说的”去掉relative”就是双飞翼布局“。</p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_continer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>先设置<font color="#ff502c">container</font>的左右<font color="#ff502c">padding</font>值来摆正<font color="#ff502c">con_continer的位置</font></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*圣杯布局*/</span></span><br><span class="line"><span class="comment">/*摆正中间栏的位置*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;<span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;&#125;</span><br><span class="line"><span class="comment">/*清除浮动*/</span></span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span>&#123;<span class="attribute">content</span>:<span class="string">""</span>; <span class="attribute">display</span>: block; <span class="attribute">clear</span>:both; <span class="attribute">overflow</span>: hidden; <span class="attribute">zoom</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">/*设置三栏高度*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span>, <span class="selector-class">.container</span> <span class="selector-class">.con_left</span>, <span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;<span class="attribute">height</span>: <span class="number">400px</span>;&#125;</span><br><span class="line"><span class="comment">/*设置三栏为左浮动 float:left*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">100%</span>;<span class="attribute">background</span>:red&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">background</span>:yellow;&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="../../images/css/shengbei1.jpg" alt="css 圣杯布局"></p>
<p>左右栏通过添加<font color="#ff502c">负的margin</font>放到正确的位置了<br>修改如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">100%</span>;<span class="attribute">background</span>:red&#125;</span><br><span class="line">// 通过margin-left为-100% 左侧栏 覆盖到中间栏上，再通过相对定位的负的left值来让他在左边</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">margin-left</span>:-<span class="number">100%</span>;<span class="attribute">background</span>:yellow;<span class="attribute">position</span>:relative;<span class="attribute">left</span>:-<span class="number">200px</span>&#125;</span><br><span class="line">// 通过margin-left为-200px 右侧栏 覆盖到中间栏上，再通过相对定位的负的right值来让他在右边</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">margin-left</span>:-<span class="number">200px</span>;<span class="attribute">background</span>:yellow;<span class="attribute">position</span>:relative;<span class="attribute">right</span>:-<span class="number">200px</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_continer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*双飞翼布局*/</span></span><br><span class="line"><span class="comment">/*清除浮动*/</span></span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span>&#123;<span class="attribute">content</span>:<span class="string">""</span>; <span class="attribute">display</span>: block; <span class="attribute">clear</span>:both; <span class="attribute">overflow</span>: hidden; <span class="attribute">zoom</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">/*设置三栏高度*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span>, <span class="selector-class">.container</span> <span class="selector-class">.con_left</span>, <span class="selector-class">.container</span> <span class="selector-class">.con_right</span>, <span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> <span class="selector-class">.item</span> &#123;<span class="attribute">height</span>: <span class="number">400px</span>;&#125;</span><br><span class="line"><span class="comment">/*设置三栏为左浮动 float:left*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">100%</span>;<span class="attribute">background</span>:red&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">background</span>:yellow;&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="../../images/css/shengbei2.jpg" alt="css 圣杯布局"><br>左右栏通过添加<font color="#ff502c">负的margin</font>放到正确的位置了<br>修改如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">100%</span>;<span class="attribute">background</span>:red&#125;</span><br><span class="line">// 通过margin-left为-100% 左侧栏 覆盖到中间栏上，再通过相对定位的负的left值来让他在左边</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">margin-left</span>:-<span class="number">100%</span>;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">// 通过margin-left为-200px 右侧栏 覆盖到中间栏上，再通过相对定位的负的right值来让他在右边</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">margin-left</span>:-<span class="number">200px</span>;<span class="attribute">background</span>:yellow;&#125;</span><br><span class="line">// 设置 con_continer内部 内容的margin来防止覆盖</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> <span class="selector-class">.item</span> &#123;<span class="attribute">margin</span>:<span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">180px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的结局为这样</p>
<p><img src="../../images/css/shengbei3.jpg" alt="css 圣杯布局"></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中Number一些新增的方法和属性</title>
    <url>/blog/es6/es6-Number.html</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Number 对象主要用于：</p>
<ul>
<li><font color="#ff502c">如果参数无法被转为数字，则返回NaN.</font></li>
<li><font color="#ff502c">早非构造器上下文中（如：没有new操作符），Number能被用来执行类型转换</font>

</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Number-EPSTION"><a href="#Number-EPSTION" class="headerlink" title="Number.EPSTION"></a><font color="#ff502c">Number.EPSTION</font></h3><p>两个可表示(representable)数之间的最小间隔。</p>
<font color="#ff502c">EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16，或者 2-52。</font><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0.2</span>;</span><br><span class="line">y = <span class="number">0.3</span>;</span><br><span class="line">z = <span class="number">0.1</span>;</span><br><span class="line">equal = (<span class="built_in">Math</span>.abs(x - y + z) &lt; <span class="built_in">Number</span>.EPSILON);</span><br></pre></td></tr></table></figure><br><br>### <font color="#ff502c">Number.MAX_SAFE_INTEGER Number.MIN_SAFE_INTEGER</font><br>Number.MAX_SAFE_INTEGER 常量表示在 JavaScript 中最大的安全整数（maxinum safe integer)（253 - 1）。<br>Number.MIN_SAFE_INTEGER 代表在 JavaScript中最小的安全的integer型数字 (-(253 - 1)).<br><font color="#ff502c">MAX_SAFE_INTEGER 常量值为 9007199254740991。</font><br><font color="#ff502c">MIN_SAFE_INTEGER 的值是-9007199254740991.</font><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>     <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER <span class="comment">// -9007199254740991</span></span><br><span class="line">-(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>)  <span class="comment">// -9007199254740991</span></span><br></pre></td></tr></table></figure><br><br>### <font color="#ff502c">Number.MAX_VALUE Number.MIN_VALUE</font><br>Number.MAX_VALUE 属性表示在 JavaScript 里所能表示的最大数值<br>Number.MIN_VALUE 属性表示在 JavaScript 中所能表示的最小的正值<br><font color="#ff502c">MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 “Infinity”。</font><br><font color="#ff502c">MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0。</font><br>因为 MAX_VALUE 是 Number 对象的一个静态属性，所有应该直接使用，Number.MAX_VALUE ，而不是作为一个创建的 Number 实例的属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num1 * num2 &lt;= <span class="built_in">Number</span>.MAX_VALUE) &#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num1 / num2 &gt;= <span class="built_in">Number</span>.MIN_VALUE) &#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### <font color="#ff502c">Number.NaN Number.prototype</font><br>Number.NaN 表示“非数字”（Not-A-Number）。和 NaN 相同。<br>Number.prototype 属性表示 Number 构造函数的原型。<br><font color="#ff502c">所有 Number 实例都继承自 Number.prototype。修改 Number 构造函数的原型对象会影响到所有 Number 实例。.</font><br><font color="#ff502c">不必创建一个 Number 实例来访问该属性，使用 Number.NaN 来访问该静态属性。</font><br>#### 属性<br><font color="#ff502c">constructor</font><br>返回创建该实例对象的构造函数。默认为 Number 对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Properties inherited <span class="keyword">from</span> <span class="built_in">Object</span>:</span><br><span class="line">__parent__, __proto__</span><br></pre></td></tr></table></figure><br><br>## 方法<br>实例本身的方法 Number.isFinite()、Number.isInteger()、Number.isNaN()、Number.isSafeInteger()、Number.parseFloat()、Number.parseInt()<br>prototype原型上的方法 Number.prototype.toExponential()、Number.prototype.toFixed()、Number.prototype.toLocaleString()、Number.prototype.toPrecision()、Number.prototype.toSource()、Number.prototype.toString()、Number.prototype.valueOf()<br>### Number.isFinite() Number.isSafeInteger()<br>Number.isFinite() 方法用来检测传入的参数是否是一个有穷数（finite number）。<br>Number.isSafeInteger() 方法用来判断传入的参数值是否是一个“安全整数”（safe integer）。一个安全整数是一个符合下面条件的整数<br>#### 语法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(value)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="comment">// 要被检测有穷性的值</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0</span>);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">2e64</span>);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'0'</span>);       <span class="comment">// false, 全局函数 isFinite('0') 会返回 true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(testValue)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// testValue</span></span><br><span class="line"><span class="comment">// 需要检测的参数。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 一个布尔值 表示给定的值是否是一个安全整数（safe integer）。</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>))       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>);                  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>);             <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">"3"</span>);                  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3.1</span>);                  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3.0</span>);                  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br><br>#### 注意<br>和<font color="#ff502c">全局的 isFinite() </font>函数相比，<font color="#ff502c">这个方法不会强制将一个非数值的参数转换成数值</font>，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。<br>Number.isSafeInteger() 安全整数范围为 -(253 - 1)到 253 - 1 之间的整数，包含 -(253 - 1)和 253 - 1。<br>### Number.isInteger()<br>Number.isInteger() 方法用来判断给定的参数是否为整数。<br>如果被检测的值是整数，则返回 true，否则返回 false。注意 NaN 和正负 Infinity 不是整数。<br>#### 语法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(value)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="comment">// 要判断此参数是否为整数</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 判断给定值是否是整数的 Boolean 值。</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">0</span>);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">1</span>);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">-100000</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">0.1</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="built_in">Math</span>.PI);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">Infinity</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">"10"</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">false</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger([<span class="number">1</span>]);       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><br><br>### Number.isNaN()<br>Number.isNaN() 方法确定传递的值是否为 NaN和其类型是 Number。它是原始的全局isNaN()的更强大的版本。<br>#### 语法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(value)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="comment">// 要被检测是否是 NaN 的值。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 一个布尔值，表示给定的值是否是 NaN。</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="built_in">Number</span>.NaN); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">0</span> / <span class="number">0</span>)       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这几个如果使用全局的 isNaN() 时，会返回 true。</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>);      <span class="comment">// false，字符串 "NaN" 不会被隐式转换成数字 NaN。</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(&#123;&#125;);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"blabla"</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的都返回 false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">37</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"37"</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"37.37"</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">""</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure><br><br>#### 描述<br>在 JavaScript 中，NaN 最特殊的地方就是，<font color="#ff502c">我们不能使用相等运算符（== 和 ===）来判断一个值是否是 NaN </font>，因为<font color="#ff502c"> NaN == NaN </font> 和<font color="#ff502c"> NaN === NaN  </font>都会返回<font color="#ff502c"> false </font>。因此，必须要有一个判断值是否是 NaN 的方法。<br><font color="#ff502c">同样：</font><br>和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。<br><br>### Number.parseInt() Number.parseFloat()<br>Number.parseFloat() 方法可以把一个字符串解析成浮点数。该方法与全局的 parseFloat() 函数相同，并且处于 ECMAScript 6 规范中（用于全局变量的模块化）。<br>Number.parseInt() 方法可以根据给定的进制数把一个字符串解析成整数。<br>#### 语法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.parseInt(string, radix);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="comment">// 被解析的值。如果不是一个字符串，则将其转换为字符串。字符串开头的空白符将会被忽略。</span></span><br><span class="line"><span class="comment">// radix</span></span><br><span class="line"><span class="comment">// 一个整数值，指定转换中采用的基数。总是指定该参数可以保证结果可预测。当忽略该参数时，不同的实现环境可能产生不同的结果。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(string)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="comment">// 被解析的字符串。</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">"3.14"</span>); <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">"314e-2"</span>); <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">"FF2"</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><br><br>#### 描述<br><font color="#ff502c">该方法和全局的 parseInt() 函数是同一个函数：</font><br><font color="#ff502c">该方法和全局的 parseFloat() 函数是同一个函数：</font><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">验证<span class="built_in">Number</span>.parseInt、<span class="built_in">Number</span>.parseFloat与全局的 <span class="built_in">parseInt</span>、<span class="built_in">parseFloat</span>是相同的</span><br><span class="line"><span class="built_in">Number</span>.parseInt === <span class="built_in">parseInt</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat === <span class="built_in">parseFloat</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"F"</span>, <span class="number">16</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"17"</span>, <span class="number">8</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"15"</span>, <span class="number">10</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"Hello"</span>, <span class="number">8</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"546"</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><br><br>parseInt 函数将其第一个参数转换为字符串，解析它，并返回一个整数或NaN。如果不是NaN，返回的值将是作为指定<font color="#ff502c">基数（基数）</font>中的数字的第一个参数的整数。<br>例如：radix<font color="#ff502c">参数为10</font> 将会把第一个参数看作是一个数的<font color="#ff502c">十进制</font>表示,如果不属于radix参数所指定的基数中的字符那么该字符和气候的字符创都将被忽略。<br>在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：<br>- 如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).<br>- 如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。<br>- 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。<br>需要注意的是：<br><font color="#ff502c">如果第一个字符不能被转换成数字，parseInt返回NaN。</font>

<h3 id="Number-prototype-toFixed-、Number-prototype-toPrecision"><a href="#Number-prototype-toFixed-、Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toFixed()、Number.prototype.toPrecision()"></a>Number.prototype.toFixed()、Number.prototype.toPrecision()</h3><p>toFixed() 方法使用定点表示法来格式化一个数。<br>toPrecision() 方法以指定的精度返回该数值对象的字符串表示。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">numObj.toFixed(digits)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// digits</span></span><br><span class="line"><span class="comment">// 小数点后数字的个数；介于 0 到 20 （包括）之间，实现环境可能支持更大范围。如果忽略该参数，则默认为 0。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 一个数值的字符串表现形式，不使用指数记数法，而是在小数点后有 digits 位数字。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numObj = <span class="number">12345.6789</span>;</span><br><span class="line">numObj.toFixed();         <span class="comment">// 返回 "12346"：进行四舍五入，不包括小数部分</span></span><br><span class="line">numObj.toFixed(<span class="number">1</span>);        <span class="comment">// 返回 "12345.7"：进行四舍五入</span></span><br><span class="line">numObj.toFixed(<span class="number">6</span>);        <span class="comment">// 返回 "12345.678900"：用0填充</span></span><br><span class="line">(<span class="number">1.23e+20</span>).toFixed(<span class="number">2</span>);    <span class="comment">// 返回 "123000000000000000000.00"</span></span><br><span class="line">(<span class="number">1.23e-10</span>).toFixed(<span class="number">2</span>);    <span class="comment">// 返回 "0.00"</span></span><br><span class="line"><span class="number">2.34</span>.toFixed(<span class="number">1</span>);          <span class="comment">// 返回 "2.3"</span></span><br><span class="line"><span class="number">-2.34</span>.toFixed(<span class="number">1</span>);         <span class="comment">// 返回 -2.3 （由于操作符优先级，负数不会返回字符串）</span></span><br><span class="line">(<span class="number">-2.34</span>).toFixed(<span class="number">1</span>);       <span class="comment">// 返回 "-2.3" （若用括号提高优先级，则返回字符串）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numObj.toPrecision(precision)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// precision</span></span><br><span class="line"><span class="comment">// 可选。一个用来指定有效数个数的整数。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 以定点表示法或指数表示法表示的一个数值对象的字符串表示，四舍五入到 precision 参数指定的显示数字位数。</span></span><br><span class="line"><span class="keyword">var</span> numObj = <span class="number">5.123456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"numObj.toPrecision()  is "</span> + numObj.toPrecision());  <span class="comment">//输出 5.123456</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"numObj.toPrecision(5) is "</span> + numObj.toPrecision(<span class="number">5</span>)); <span class="comment">//输出 5.1235</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"numObj.toPrecision(2) is "</span> + numObj.toPrecision(<span class="number">2</span>)); <span class="comment">//输出 5.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"numObj.toPrecision(1) is "</span> + numObj.toPrecision(<span class="number">1</span>)); <span class="comment">//输出 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：在某些情况下会以指数表示法返回</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1234.5</span>).toPrecision(<span class="number">2</span>)); <span class="comment">// "1.2e+3"</span></span><br></pre></td></tr></table></figure>
<p>该数值在必要时进行四舍五入，另外在必要时会用 0 来填充小数部分，以便小数部分有指定的位数。</p>
<h3 id="Number-prototype-toLocaleString-、Number-prototype-toString-、Number-prototype-valueOf"><a href="#Number-prototype-toLocaleString-、Number-prototype-toString-、Number-prototype-valueOf" class="headerlink" title="Number.prototype.toLocaleString()、Number.prototype.toString()、Number.prototype.valueOf()"></a>Number.prototype.toLocaleString()、Number.prototype.toString()、Number.prototype.valueOf()</h3><p>toString() 方法返回指定 Number 对象的字符串表示形式。<br>valueOf() 方法返回一个被 Number 对象包装的原始值。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">numObj.toString([radix]) </span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"> <span class="comment">// radix</span></span><br><span class="line"> <span class="comment">// 指定要用于数字到字符串的转换的基数(从2到36)。如果未指定 radix 参数，则默认值为 10。</span></span><br><span class="line"> <span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(count.toString());    <span class="comment">// 输出 '10'</span></span><br><span class="line"> <span class="built_in">console</span>.log((<span class="number">17</span>).toString());     <span class="comment">// 输出 '17'</span></span><br><span class="line"> <span class="built_in">console</span>.log((<span class="number">17.2</span>).toString());   <span class="comment">// 输出 '17.2'</span></span><br><span class="line"> <span class="keyword">var</span> x = <span class="number">6</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(x.toString(<span class="number">2</span>));       <span class="comment">// 输出 '110'</span></span><br><span class="line"> <span class="built_in">console</span>.log((<span class="number">254</span>).toString(<span class="number">16</span>));  <span class="comment">// 输出 'fe'</span></span><br><span class="line"> <span class="built_in">console</span>.log((<span class="number">-10</span>).toString(<span class="number">2</span>));   <span class="comment">// 输出 '-1010'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> numObj.valueOf()</span><br><span class="line"> <span class="keyword">var</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> numObj); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> num = numObj.valueOf();</span><br><span class="line"> <span class="built_in">console</span>.log(num);           <span class="comment">// 10</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);    <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<p>Number 对象覆盖了 Object 对象上的 toString() 方法，它不是继承的 Object.prototype.toString()。对于 Number 对象，toString() 方法以指定的基数返回该对象的字符串表示。<br>valueOf()该方法通常是由 JavaScript 引擎在内部隐式调用的，而不是由用户在代码中显式调用的</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>html5中的canvas基本使用方法</title>
    <url>/blog/canvas/canvas-des1.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>canvas元素负责在页面中设定一个区域，然后就可以通过JavaScript动态地在这个区域中绘制图形。<br>与浏览器环境中的其他组件类似，<canvas>由几组API构成，但非所有浏览器都支持所有这些api,基本绘制能力的2D上下文，<canvas>还建议了一个名为webGL的3D上下文。</canvas></canvas></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .canvas1 &#123;</span><br><span class="line">            border: 1px solid #000;</span><br><span class="line">            margin: auto;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">"canvas1"</span>  <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 使用canvas必须先设置其width和height属性，指定可以绘图的区域大小</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'.canvas'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 判断当前浏览器支不支持 canvas</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (canvas.getContext) &#123;</span></span><br><span class="line"><span class="javascript">            ctx = canvas.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="javascript">            ctx.strokeStyle = <span class="string">'red'</span>;</span></span><br><span class="line"><span class="javascript">            ctx.fillStyle = <span class="string">'#0000ff'</span>;</span></span><br><span class="line">            ctx.fillRect(0, 0, 150, 150);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">// fillStyle 填充颜色、strokeStyle 描边颜色</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 字符串（颜色名、十六进制、rgb、rgba、hsl、hsla）、渐变对象、模式对象</span></span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以获取到<font color="#ff502c">canvas</font>dom,再通过<font color="#ff502c">getContext(‘2d’)</font>获取到2D上下文，通过fillStyle<font color="#ff502c">fillStyle</font>设置填充颜色，通过<font color="#ff502c">strokeStyle</font>设置描边颜色（默认显示 #000），fillRect(0, 0, 150, 150)<br>设置矩形的位置和长宽<br>效果如下所示：<br><img src="../../images/canvas/canvas_1.jpg" alt="canvas_1"></p>
<h3 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h3><p>在我们开始画图之前，我们需要了解一下画布栅格<code>（canvas grid）</code>以及坐标空间。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。在课程的最后我们会平移原点到不同的坐标上，旋转网格以及缩放。现在我们还是使用原来的设置。<br><img src="../../images/canvas/Canvas_default_grid.png" alt="canvas_1"></p>
<h3 id="fillStyle-strokeStyle"><a href="#fillStyle-strokeStyle" class="headerlink" title="fillStyle strokeStyle"></a>fillStyle strokeStyle</h3><p><code>fillStyle、strokeStyle</code>这个两个属性的值可以是字符串、渐变对象或者模式对象，而且他们的默认值都是”#000000”。字符串值可以为颜色值、十六进制码、<code>rgb、rgba、hsl</code>或<code>hsla</code>.</p>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>不同于<code>SVG</code>，<code>HTML</code>中的元素<code>canvas</code>只支持一种原生的图形绘制：矩形。所有其他的图形的绘制都至少需要生成一条路径。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。</p>
<h4 id="fillRect"><a href="#fillRect" class="headerlink" title="fillRect"></a>fillRect</h4><p><code>fillRect(x, y, width, height)</code><br>参数<br><code>x</code><br>矩形起始点的 x 轴坐标。<br><code>y</code><br>矩形起始点的 y 轴坐标。<br><code>width</code><br>矩形的宽度。<br><code>height</code><br>矩形的高度。<br>绘制一个</p>
<p><img src="../../images/canvas/canvas_strokeRect.png" alt="canvas_1"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeStyle = <span class="string">"green"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h4 id="strokeRect"><a href="#strokeRect" class="headerlink" title="strokeRect"></a>strokeRect</h4><p>参数<br><code>x</code><br>矩形起始点的 x 轴坐标。<br><code>y</code><br>矩形起始点的 y 轴坐标。<br><code>width</code><br>矩形的宽度。<br><code>height</code><br>矩形的高度。</p>
<p><img src="../../images/canvas/canvas_strokeRect.png" alt="canvas_1"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">ctx.strokeStyle = <span class="string">"green"</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h4 id="clearRect"><a href="#clearRect" class="headerlink" title="clearRect"></a>clearRect</h4><p>参数<br><code>x</code><br>矩形起始点的 x 轴坐标。<br><code>y</code><br>矩形起始点的 y 轴坐标。<br><code>width</code><br>矩形的宽度。<br><code>height</code><br>矩形的高度。<br>这仅是一段简单地使用 clearRect 方法的代码片段。</p>
<p><img src="../../images/canvas/canvas_clearRect.png" alt="canvas_1"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">20</span>);</span><br><span class="line">ctx.lineTo(<span class="number">120</span>,<span class="number">120</span>);</span><br><span class="line">ctx.closePath(); <span class="comment">// draws last line of the triangle</span></span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.clearRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear the whole canvas</span></span><br><span class="line"><span class="comment">// ctx.clearRect(0, 0, canvas.width, canvas.height);</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>html5中的canvas的使用方法，实现自定义绘制图形</title>
    <url>/blog/canvas/canvas-des2.html</url>
    <content><![CDATA[<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。<br>1、首先，你需要创建路径起始点。<br>2、然后你使用画图命令去画出路径。<br>3、之后你把路径封闭。<br>4、一旦路径生成，你就能通过描边或填充路径区域来渲染图形。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="beginPath"><a href="#beginPath" class="headerlink" title="beginPath()"></a><strong>beginPath()</strong></h4><p>新建一条路径，生成之后，图形绘制命令会被指向到<font color="#ff502c">路径上生成路径。</font></p>
<h4 id="closePath"><a href="#closePath" class="headerlink" title="closePath()"></a><strong>closePath()</strong></h4><p>闭合路径之后图形绘制命令又<font color="#ff502c">重新指向到上下文</font>中</p>
<h4 id="stroke"><a href="#stroke" class="headerlink" title="stroke()"></a><strong>stroke()</strong></h4><p>通过<font color="#ff502c">线条</font>来绘制图像轮廓</p>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a><strong>fill()</strong></h4><p>通过填充路径的内容区域生成<font color="#ff502c">实心的图形</font>。</p>
<h4 id="moveTo-x-y"><a href="#moveTo-x-y" class="headerlink" title="moveTo(x, y)"></a><strong>moveTo(x, y)</strong></h4><p>将笔触移动到指定的坐标x以及y上。<br>你通常会使用moveTo()函数设置起点，使用moveTo()绘制一些不连续的路径<br>移动中心点<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'.canvas'</span>);</span><br><span class="line">    <span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">        <span class="keyword">var</span> ctx  = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(<span class="number">75</span>,<span class="number">75</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>); <span class="comment">// 绘制</span></span><br><span class="line">        ctx.moveTo(<span class="number">110</span>,<span class="number">75</span>);</span><br><span class="line">        ctx.arc(<span class="number">75</span>,<span class="number">75</span>,<span class="number">35</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI,<span class="literal">false</span>);   <span class="comment">// 口(顺时针)</span></span><br><span class="line">        ctx.moveTo(<span class="number">65</span>,<span class="number">65</span>);</span><br><span class="line">        ctx.arc(<span class="number">60</span>,<span class="number">65</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>);  <span class="comment">// 左眼</span></span><br><span class="line">        ctx.moveTo(<span class="number">95</span>,<span class="number">65</span>);</span><br><span class="line">        ctx.arc(<span class="number">90</span>,<span class="number">65</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>);  <span class="comment">// 右眼</span></span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <img src="../../images/canvas/Canvas_smiley.png" alt="css rotateX"></p>
<h4 id="lineTo-x-y"><a href="#lineTo-x-y" class="headerlink" title="lineTo(x, y)"></a><strong>lineTo(x, y)</strong></h4><p><font color="#ff502c">绘制直线</font>，需要用到的方法lineTo().<br>绘制一条从当前位置到指定x以及y位置的直线<br>绘制一个填充、描边的三角形<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'.canvas'</span>);]</span><br><span class="line">    <span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">        <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        <span class="comment">// 填充三角形</span></span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">105</span>,<span class="number">25</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">25</span>,<span class="number">105</span>);</span><br><span class="line">        ctx.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 描边三角形</span></span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(<span class="number">125</span>,<span class="number">125</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">125</span>,<span class="number">45</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">45</span>,<span class="number">125</span>);</span><br><span class="line">        ctx.closePath();</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <img src="../../images/canvas/Canvas_sanjiao.png" alt="css rotateX"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>注意：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，<font color="#ff502c">第一条路径</font>构造命令通常被视为是<font color="#ff502c">moveTo（）</font>，无论最后的是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。<br>注意：当你调用<font color="#ff502c">fill()</font>函数时，所有没有闭合的形状都会自动闭合，所以你<font color="#ff502c">不需要</font>调用<font color="#ff502c">closePath()</font>函数。但是调用<font color="#ff502c">stroke()</font>时<font color="#ff502c">不会</font>自动闭合。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>绘制一个<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        .canvas &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            margin: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (canvas.getContext)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line">                ctx.beginPath();</span><br><span class="line">                ctx.moveTo(75,50);</span><br><span class="line">                ctx.lineTo(100,75);</span><br><span class="line">                ctx.lineTo(100,25);</span><br><span class="line">                ctx.fill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        draw();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript中Array、Object深度复制、数据类型</title>
    <url>/blog/javascript/js-ArrayObject-deepCopy.html</url>
    <content><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>在 JavaScript 中类型分为两类：基本类型(值类型)、引用类型</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Undefind、Null、Boolean、Number、String</p>
<h4 id="实现复制"><a href="#实现复制" class="headerlink" title="实现复制"></a>实现复制</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"小伙子,25278"</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = str;</span><br><span class="line">str1 = <span class="string">"大伙子,5967"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 小伙子,25278</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// 大伙子,5967</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">25278</span>;</span><br><span class="line"><span class="keyword">var</span> num1 = num;</span><br><span class="line">num1 = <span class="number">5967</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 25278</span></span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// 5967</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>javascript 里的<font color="#ff502c">基本类型（值类型）</font>是不可以改变的，javascript 也没有提供任何一个改变字符串的方法和语法.<font color="#ff502c">他不是能当成对象来使用的。</font><br>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"myobject"</span>;</span><br><span class="line">str.name = <span class="string">"myname"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.name); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">num.name = <span class="string">"myname"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>如 Array、Object<br>javascript 引用数据类型是保存在堆内存中的对象，与其它语言不同的是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能通过操作对象的在栈内存中的引用地址。所以引用类型的数据，在栈内存中保存的实际上是对象在堆内存中的引用地址。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">"我有名字了"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// 我有名字了</span></span><br></pre></td></tr></table></figure>
<p>示例图：<img src="../images/Array_Object.jpg" alt="目录结构"><br>自然，给 obj2 添加 name 属性，实际上是给堆内存中的对象添加了 name 属性，obj2 和 obj1 在栈内存中保存的只是堆内存对象的引用地址，虽然也是拷贝了一份，但指向的对象却是同一个。故而改变 obj2 引起了 obj1 的改变。</p>
<p><strong>Array 实现复制</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr;</span><br><span class="line">arr1.push(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<font color="#ff502c">改为：</font>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// Array.prototype.slice() 返回一个新的数组，可以切断他们之间的联系</span></span><br><span class="line"><span class="keyword">var</span> arr1 = arr.slice(); <span class="comment">// 根据数组下标改变数组</span></span><br><span class="line"><span class="comment">// Array.prototype.splice() 返回一个新的数组，可以切断他们之间的联系</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.splice(); <span class="comment">// 根据数组下标改变数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.concat();</span><br><span class="line">arr1.push(<span class="number">6</span>);</span><br><span class="line">arr2.push(<span class="number">6</span>);</span><br><span class="line">arr3.push(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [6]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<font color="red">Array.prototype.slice()</font><a href="http://asyncnode.com/blog/es6-Array1.html">http://asyncnode.com/blog/es6-Array1.html</a>查看详情<br><font color="red">Array.prototype.splice()</font><a href="http://asyncnode.com/blog/es6-Array1.html">http://asyncnode.com/blog/es6-Array1.html</a>查看详情<br><font color="red">Array.prototype.concat()</font><a href="http://asyncnode.com/blog/es6-Array.html">http://asyncnode.com/blog/es6-Array.html</a>查看详情<br><strong>Object 实现复制</strong><br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"111"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = obj;</span><br><span class="line">obj1.age = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object &#123;name: "111", age: 12&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// Object &#123;name: "111", age: 12&#125;</span></span><br></pre></td></tr></table></figure><br><br><font color="#ff502c">改为：</font>、<br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"111"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// 先把对象通过浏览器对象转为 JSON字符串，再转为 JSON对象</span></span><br><span class="line">obj1.age = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object &#123;name: "111"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// Object &#123;name: "111", age: 12&#125;</span></span><br></pre></td></tr></table></figure><br><br><font color="#ff502c">同时 Object 也是有合并方法的为 assgin(),但是他是不能项 Array.prototype.concat()实现深度复制</font>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"111"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assgin(obj, &#123;&#125;); <span class="comment">// Object的合并对象方法</span></span><br><span class="line">obj1.age = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object &#123;name: "111", age: 12&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// Object &#123;name: "111", age: 12&#125;</span></span><br></pre></td></tr></table></figure>
<font color="#ff502c">最后一种也是比较官方的方法</font>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">  <span class="keyword">var</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">  propNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, name);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(copy, name, desc);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = copy(obj1); <span class="comment">// obj2 looks like obj1 now</span></span><br><span class="line">obj2.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// Object &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// Object &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>下面的代码会创建一个给定对象的副本。 创建对象的副本有不同的方法，以下是只是一种方法，并解释了 Array.prototype.forEach() 是如何使用 ECMAScript 5 Object.* 元属性（meta property ）函数工作的。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>node中的一个html转pdf、截图、生成图片的库</title>
    <url>/blog/node/node-phantom.html</url>
    <content><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>下载最新的 node 安装<br>下载地址 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>创建一个行的文件，文件名为 <font color="#ff502c">Test</font><br>然后在 <font color="#ff502c">Test</font> 运行 <font color="#ff502c">npm install phantom</font>或者 安装本地依赖 <font color="#ff502c">npm install phantom –save </font>,全局安装<font color="#ff502c"> npm install -g phantom</font><br>目录：<br><img src="../../images/phantom.jpg" alt="目录结构"><br>创建一个 index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你的node版本 高于 Node v7.9.0+  可通过 node -V (产看)</span></span><br><span class="line"><span class="keyword">const</span> phantom = <span class="built_in">require</span>(<span class="string">"phantom"</span>);</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">await</span> phantom.create();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> instance.createPage();</span><br><span class="line">  <span class="keyword">await</span> page.on(<span class="string">"onResourceRequested"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">requestData</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"Requesting"</span>, requestData.url);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> status = <span class="keyword">await</span> page.open(<span class="string">"https://stackoverflow.com/"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> content = <span class="keyword">await</span> page.property(<span class="string">"content"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(content);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> instance.exit();</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// node版本 高于 6.x</span></span><br><span class="line"><span class="keyword">var</span> phantom = <span class="built_in">require</span>(<span class="string">"phantom"</span>);</span><br><span class="line"><span class="keyword">var</span> _ph, _page, _outObj;</span><br><span class="line"></span><br><span class="line">phantom</span><br><span class="line">  .create()</span><br><span class="line">  .then(<span class="function"><span class="params">ph</span> =&gt;</span> &#123;</span><br><span class="line">    _ph = ph;</span><br><span class="line">    <span class="keyword">return</span> _ph.createPage();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">page</span> =&gt;</span> &#123;</span><br><span class="line">    _page = page;</span><br><span class="line">    <span class="keyword">return</span> _page.open(<span class="string">"./index_2.html"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">status</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(status);</span><br><span class="line">    <span class="keyword">return</span> _page.property(<span class="string">"content"</span>);</span><br><span class="line">    <span class="comment">// return _page.property('viewportSize', &#123;width: 1024, height: 600&#125;)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">content</span> =&gt;</span> &#123;</span><br><span class="line">    _page.render(<span class="string">"index_2.pdf"</span>);</span><br><span class="line">    <span class="comment">// console.log(content);</span></span><br><span class="line">    _page.close();</span><br><span class="line">    _ph.exit();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br></pre></td></tr></table></figure>
<p>根据自己不同的 node 版本 选择不同的 js 代码<br>新建一个 index_2.html 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="comment">/*重置css*/</span></span></span><br><span class="line">      body,</span><br><span class="line">      div,</span><br><span class="line">      dl,</span><br><span class="line">      dt,</span><br><span class="line">      dd,</span><br><span class="line">      ul,</span><br><span class="line">      ol,</span><br><span class="line">      li,</span><br><span class="line">      h1,</span><br><span class="line">      h2,</span><br><span class="line">      h3,</span><br><span class="line">      h4,</span><br><span class="line">      h5,</span><br><span class="line">      h6,</span><br><span class="line">      pre,</span><br><span class="line">      code,</span><br><span class="line">      form,</span><br><span class="line">      fieldset,</span><br><span class="line">      lengend,</span><br><span class="line">      input,</span><br><span class="line">      button,</span><br><span class="line">      textarea,</span><br><span class="line">      select,</span><br><span class="line">      p,</span><br><span class="line">      blockquote,</span><br><span class="line">      th,</span><br><span class="line">      td &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      html,</span><br><span class="line">      body,</span><br><span class="line">      form,</span><br><span class="line">      fieldset,</span><br><span class="line">      p,</span><br><span class="line">      div,</span><br><span class="line">      h1,</span><br><span class="line">      h2,</span><br><span class="line">      h3,</span><br><span class="line">      h4,</span><br><span class="line">      h5,</span><br><span class="line">      h6 &#123;</span><br><span class="line">        -webkit-text-size-adjust: none;</span><br><span class="line">      &#125;</span><br><span class="line">      table &#123;</span><br><span class="line">        border-collapse: collapse;</span><br><span class="line">        border-spacing: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      img &#123;</span><br><span class="line">        border: 0 none;</span><br><span class="line">        vertical-align: top;</span><br><span class="line">      &#125;</span><br><span class="line">      li &#123;</span><br><span class="line">        list-style-type: none;</span><br><span class="line">      &#125;</span><br><span class="line">      h1,</span><br><span class="line">      h2,</span><br><span class="line">      h3,</span><br><span class="line">      h4,</span><br><span class="line">      h5,</span><br><span class="line">      h6 &#123;</span><br><span class="line">        font-size: 100%;</span><br><span class="line">        font-weight: 400;</span><br><span class="line">      &#125;</span><br><span class="line">      body,</span><br><span class="line">      input,</span><br><span class="line">      button,</span><br><span class="line">      textarea,</span><br><span class="line">      select &#123;</span><br><span class="line">        font-size: 12px;</span><br><span class="line">        font-family: "PingFangSC-Light", "Microsoft Yahei", sans-serif;</span><br><span class="line">      &#125;</span><br><span class="line">      button &#123;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">        border: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      em,</span><br><span class="line">      cite &#123;</span><br><span class="line">        font-style: normal;</span><br><span class="line">      &#125;</span><br><span class="line">      body &#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">line-height</span>: 1<span class="selector-class">.17</span>;</span></span><br><span class="line">        -webkit-text-size-adjust: none;</span><br><span class="line">        -webkit-touch-callout: none;</span><br><span class="line">        -webkit-user-select: none;</span><br><span class="line">      &#125;</span><br><span class="line">      a &#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#2c2c2c</span>;</span></span><br><span class="line">        text-decoration: none !important;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span></span><br><span class="line">        text-decoration: none;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-pseudo">:focus</span> &#123;</span></span><br><span class="line">        outline: none;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.clearfixed</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">        content: ".";</span><br><span class="line">        clear: both;</span><br><span class="line">        display: block;</span><br><span class="line">        height: 0;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.clearfixed</span> &#123;</span></span><br><span class="line">        zoom: 1;</span><br><span class="line">        display: block;</span><br><span class="line">      &#125;</span><br><span class="line">      * &#123;</span><br><span class="line">        -webkit-text-size-adjust: none;</span><br><span class="line">        -moz-text-size-adjust: none;</span><br><span class="line">        -ms-text-size-adjust: none;</span><br><span class="line">        -o-text-size-adjust: none;</span><br><span class="line">        text-size-adjust: none;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        -webkit-box-sizing: border-box;</span><br><span class="line">        -moz-box-sizing: border-box;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-pseudo">::-webkit-scrollbar</span> &#123;</span></span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line"><span class="css">      &#125; <span class="comment">/*滚动条样式*/</span></span></span><br><span class="line"><span class="css">      <span class="selector-pseudo">::-ms-clear</span> &#123;</span></span><br><span class="line">        display: none;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-pseudo">::-ms-reveal</span> &#123;</span></span><br><span class="line">        display: none;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="comment">/*body &#123;background-color: #666&#125;*/</span></span></span><br><span class="line"><span class="css">      <span class="comment">/*padding: 0 50px;background-color: #fff*/</span></span></span><br><span class="line"><span class="css">      <span class="comment">/*width: 800px; */</span></span></span><br><span class="line"><span class="css">      <span class="selector-class">.higColor</span> &#123;</span></span><br><span class="line">        color: red;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.themeColor</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#2a548e</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.font14</span> &#123;</span></span><br><span class="line">        font-size: 14px !important;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.header</span>,</span></span><br><span class="line"><span class="css">      <span class="selector-class">.content</span>,</span></span><br><span class="line"><span class="css">      <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">        margin: 0 50px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.header</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        padding: 15px 0;</span><br><span class="line"><span class="css">        <span class="selector-tag">border-bottom</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#2a548e</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.header</span> <span class="selector-class">.images</span> &#123;</span></span><br><span class="line">        width: 165px;</span><br><span class="line">        height: 50px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.header</span> <span class="selector-class">.title</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 15px;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#2a548e</span>;</span></span><br><span class="line">        font-size: 16px;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">        padding-top: 30px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> <span class="selector-class">.title</span> &#123;</span></span><br><span class="line">        font-size: 18px;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> <span class="selector-class">.txt</span> &#123;</span></span><br><span class="line">        font-size: 16px;</span><br><span class="line">        line-height: 19px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> <span class="selector-class">.title</span>,</span></span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> <span class="selector-class">.txt</span>,</span></span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> <span class="selector-class">.des_tit</span> &#123;</span></span><br><span class="line">        padding-bottom: 22px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> <span class="selector-class">.img</span> &#123;</span></span><br><span class="line">        padding: 40px 0 60px 60px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="comment">/*.content .txt, .content .des_tit &#123;&#125;*/</span></span></span><br><span class="line"><span class="css">      <span class="selector-class">.text_indent</span> &#123;</span></span><br><span class="line">        text-indent: 22px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> <span class="selector-class">.bold_tit</span> &#123;</span></span><br><span class="line">        font-weight: bold;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.table</span> &#123;</span></span><br><span class="line">        padding-bottom: 22px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.table</span> <span class="selector-tag">table</span> &#123;</span></span><br><span class="line">        width: 100%;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.table</span> <span class="selector-tag">thead</span> <span class="selector-tag">th</span>,</span></span><br><span class="line"><span class="css">      <span class="selector-class">.table</span> <span class="selector-tag">tbody</span> <span class="selector-tag">td</span> &#123;</span></span><br><span class="line">        padding: 8px 0;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.table</span> <span class="selector-tag">thead</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#8d6974</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-top</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#2a548e</span>;</span></span><br><span class="line">        font-weight: bold;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#2a548e</span>;</span></span><br><span class="line">        padding: 5px 0;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://temp.im/165x50"</span> <span class="attr">alt</span>=<span class="string">"logo"</span> <span class="attr">class</span>=<span class="string">"images"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">        啊电话卡是的空间啊十大科技啊十大科技啊十大科技十大科技是打瞌睡的哈宽松觉得很愧疚2</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">        一、综合评定结果：</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt text_indent"</span>&gt;</span></span><br><span class="line">        中指大数据拿地阿萨德客户卡上快接啊时代快接啊获得卡号是的空间拉黑是的卡号是开店计划阿萨德哈空间是的哈空间啊看见的哈空间是的快接啊获得啊进口货是的快接啊黑色的快接啊黑色的快接啊黄寺大街是打瞌睡的哈空间</span><br><span class="line">        啊是的哈宽松的哈空间啊十大科技。<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt bold_tit text_indent"</span>&gt;</span></span><br><span class="line">        强化科维奇户外空间啊恢复快接啊黑色会计法哈斯空间很大空间是的空间啊十大科技啊是的快接啊黑色的快接啊哈萨克圣诞节</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt text_indent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bold_tit"</span>&gt;</span></span><br><span class="line">          1、城市潜力：</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"bold_tit"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>dasd<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>打扫的23123asdasdasd<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"bold_tit"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>dasd<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>打扫的23123asdasdasd<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt text_indent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bold_tit"</span>&gt;</span></span><br><span class="line">          1、城市潜力：</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"bold_tit"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>dasd<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>打扫的23123asdasdasd<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"bold_tit"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>dasd<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>打扫的23123asdasdasd<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt text_indent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bold_tit"</span>&gt;</span></span><br><span class="line">          1、城市潜力：</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"bold_tit"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>dasd<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>打扫的23123asdasdasd<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"bold_tit"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>dasd<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>打扫的23123asdasdasd<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt text_indent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bold_tit"</span>&gt;</span></span><br><span class="line">          1、城市潜力：</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"bold_tit"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>dasd<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>打扫的23123asdasdasd<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        啊打扫打扫打扫打扫打扫打扫打扫打扫打扫得撒打扫打扫打扫的23123asdasdasd打扫的23123asdasdasd打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"bold_tit"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>dasd<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>打扫的23123asdasdasd<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"higColor"</span>&gt;</span>打扫的23123asdasdasd<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt"</span>&gt;</span></span><br><span class="line">        表：标杆企业合理拿地总价（万元）</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>企业<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>合理拿地总价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>企业<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>合理拿地总价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">toby</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>asdasdasd<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>123123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>asdasdasd<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>123123123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>asdasdasd<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>123123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>asdasdasd<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>123123123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>asdasdasd<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>123123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>asdasdasd<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>123123123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">toby</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"themeColor"</span>&gt;</span> 表：<span class="tag">&lt;/<span class="name">span</span>&gt;</span>标杆企业合理拿地总价（万元）</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">        二、模块分析</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt bold_tit text_indent"</span>&gt;</span></span><br><span class="line">        1、城市潜力：</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt bold_tit text_indent"</span>&gt;</span></span><br><span class="line">        1.1、综合排名</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt text_indent"</span>&gt;</span></span><br><span class="line">        啊十大苏打撒打算的啊十大是开店哈继啊空间十大科技上方空间啊恢复及卡号是看见的哈空间十大健康啊就很大空间是的快接啊黑色的快接啊是<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"higColor"</span></span></span><br><span class="line"><span class="tag">          &gt;</span>啊获得卡号是看见的<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">        &gt;</span>啊十大苏打撒打算的啊十大是开店哈继啊空间十大科技上方空间啊恢复及卡号是看见的哈空间十大健康啊就很大空间是的快接啊黑色的快接啊是</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt bold_tit font14"</span>&gt;</span></span><br><span class="line">        啊十大苏打撒打算的啊十大是开店哈继啊空间十大科技上方空间啊恢复</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://temp.im/520x230"</span> <span class="attr">alt</span>=<span class="string">"图片"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt bold_tit text_indent"</span>&gt;</span></span><br><span class="line">        1.1、综合排名</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"txt text_indent"</span>&gt;</span></span><br><span class="line">        啊累积大量宽松基调绿卡时间的绿卡时间的来看了宽松基调徕卡建档立卡集散地立刻啊利空基调徕卡就旅客入境哦i后即可查看垃圾的垃圾了看破起哦贫穷品位磷矿vlklasfkalsjdlkj啊累积大量宽松基调绿卡时间的绿卡时间的来看了宽松基调徕卡建档立卡集散地立刻啊利空基调徕卡就旅客入境哦i后即可查看垃圾的垃圾了看破起哦贫穷品位磷矿vlklasfkalsjdlkj啊累积大量宽松基调绿卡时间的绿卡时间的来看了宽松基调徕卡建档立卡集散地立刻啊利空基调徕卡就旅客入境哦i后即可查看垃圾的垃圾了看破起哦贫穷品位磷矿vlklasfkalsjdlkj</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://temp.im/520x230"</span> <span class="attr">alt</span>=<span class="string">"图片"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">      啊的卡号是看见的哈宽松基调哈空间是的哈空间十大科技是的哈空间是的哈空间是的哈空间是的哈继是开店</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <font color="#ff502c">Test</font>中运行 <font color="#ff502c">node index.js</font>会生成一个<font color="#ff502c">index_2.pdf</font>文件<br>在谷歌中预览为<br><img src="../../images/phantom1.jpg" alt="目录结构"><br>其实 phantom 可以做很多的事，比如说截图等等，具体可以看<a href="https://github.com/amir20/phantomjs-node" target="_blank" rel="noopener">https://github.com/amir20/phantomjs-node</a></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Array系列(二) 一些常用array的扩展方法（二）</title>
    <url>/blog/es6/es6-Array1.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/es6/es6-Array.html">ES6 Array 系列(一) 一些常用array的扩展方法</a><br><a href="/blog/es6/es6-Array1.html">ES6 Array 系列(二) 一些常用array的扩展方法（二）</a><br><a href="/blog/es6/es6-Array-break-continue.html">ES6 Array系列(三) Array中的forEach方法可以用break、continue跳出循环？</a><br><a href="/blog/es6/es6-Array-function.html">ES6 Array系列(四) Array常用的方法和实现reduce、map、filter、forEach</a></p>
</blockquote>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><hr>
<p>every(): 对数组中的每一项运行给函数，如果该函数对每一项都返回true,则返回true.<br>filter(): 对数组中的每一项运行给函数，如果该函数会返回true的项目成的数组。<br>forEach(): 对数组中的每一项运行给函数，这个项目没有返回值.<br>map(): 对数组中的每一项运行给函数，返回每次函数调用的结果组成的数组。<br>some(): 对数组中的每一项运行给函数，如果该函数对任何项都返回true,则返回true.</p>
<h3 id="every-some"><a href="#every-some" class="headerlink" title="every()/some()"></a>every()/some()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> everyResult1 = numbers.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(everyResult1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter() 过滤"></a>filter() 过滤</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// [3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>方法对数组的每个元素执行一次提供的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> array.forEach(callback(currentValue, index, array)&#123;</span><br><span class="line">     <span class="comment">//do something</span></span><br><span class="line"> &#125;, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"> array.forEach(callback[, thisArg])</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"> <span class="comment">// callback</span></span><br><span class="line">   <span class="comment">//   为数组中每个元素执行的函数，该函数接收三个参数：</span></span><br><span class="line"> <span class="comment">// currentValue(当前值)</span></span><br><span class="line">    <span class="comment">//  数组中正在处理的当前元素。</span></span><br><span class="line"> <span class="comment">// index(索引)</span></span><br><span class="line">    <span class="comment">//  数组中正在处理的当前元素的索引。</span></span><br><span class="line"> <span class="comment">// array</span></span><br><span class="line"> <span class="comment">// forEach()方法正在操作的数组。</span></span><br><span class="line"> <span class="comment">// thisArg可选</span></span><br><span class="line">    <span class="comment">//  可选参数。当执行回调 函数时用作this的值(参考对象)。</span></span><br><span class="line"> <span class="comment">// 返回值</span></span><br><span class="line">    <span class="comment">// undefined.</span></span><br></pre></td></tr></table></figure>
<p>callback 函数会被依次传入三个参数：</p>
<font color="#ff502c">数组当前项的值</font><br><font color="#ff502c">数组当前项的索引</font><br><font color="#ff502c">数组对象本身</font><br><font color="yellow">注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。如果您正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用 Array.every 或 Array.some。如果可用，新方法 find() 或者findIndex() 也可被用于真值测试的提早终止。</font>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br>参数与forEach相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> doubles = numbers.map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 一个新数组，每个元素都是回调函数的结果。</span></span><br></pre></td></tr></table></figure>
<p>返回值<font color="#ff502c">一个新数组，每个元素都是回调函数的结果。</font></p>
<h2 id="栈方法-队列方法"><a href="#栈方法-队列方法" class="headerlink" title="栈方法/队列方法"></a>栈方法/队列方法</h2><p>栈是一种LIFO(Last-In-First-Out,后进先出)的数据结构，也就是最新添加的项被移除。<br>push() 添加到数组末尾<br>pop() 删除到数组末尾<br>shift() 添加到数组头部<br>unshift() 删除到数组头部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">arr.push(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [4, 5, 6, 7, 8]</span></span><br><span class="line">arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [4, 5, 6, 7]</span></span><br><span class="line">arr.unshift(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 4, 5, 6, 7]</span></span><br><span class="line">arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>
<h2 id="位置方法-indexOf-、lastIndexOf-、find-、findIndex"><a href="#位置方法-indexOf-、lastIndexOf-、find-、findIndex" class="headerlink" title="位置方法 indexOf()、lastIndexOf()、find()、findIndex()"></a>位置方法 indexOf()、lastIndexOf()、find()、findIndex()</h2><p>接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。<br>indexOf()方法从数组开头<br>lastIndexOf()方法则从数组的末尾</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p>
<p><strong>未完待续。。。。。</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中的async方法的使用和实现原理</title>
    <url>/blog/es6/es6-AsyncFuntion.html</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><font color="#ff502c">AsyncFunction</font> 构造函数 创建一个新的 async function 对象。在 JavaScript 中，每个异步函数实际上都是一个 AsyncFunction 对象。</p>
<p><font color="#ff502c">async function</font> 关键字可以用来定义一个异步函数表达式。<font color="#ff502c">返回一个 Promise</font><br>它就是 <font color="#ff502c">Generator</font> 函数的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add1 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = resolveAfter2Seconds(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">var</span> b = resolveAfter2Seconds(<span class="number">30</span>);</span><br><span class="line">  <span class="keyword">return</span> x + (<span class="keyword">await</span> a) + (<span class="keyword">await</span> b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add1(<span class="number">10</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// prints 60 after 2 seconds.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add2 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">30</span>);</span><br><span class="line">  <span class="keyword">return</span> x + a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add2(<span class="number">10</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// prints 60 after 4 seconds.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">async function [name]([param1[, param2[, ..., paramN]]]) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// name</span></span><br><span class="line">    <span class="comment">// 函数名称。 可以省略，以此来声明一个匿名的函数。也是用于本地调用函数体的一个名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// paramN</span></span><br><span class="line">    <span class="comment">// 传入函数的参数名</span></span><br><span class="line"><span class="comment">// statements</span></span><br><span class="line">    <span class="comment">// 函数体内的语句声明</span></span><br></pre></td></tr></table></figure>
<h4 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h4><p>async 函数返回一个 Promise 对象。<br>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>async function 表达式非常类似于 async function 声明语句，并且几乎拥有等同的语法。他们之间主要的区别在于函数名称，async function 表达式可以省略函数名称来创建一个匿名的函数。另见 functions 章节获取更多信息。</p>
<h3 id="async-函数对-Generator-函数的改进，体现在以下四点。"><a href="#async-函数对-Generator-函数的改进，体现在以下四点。" class="headerlink" title="async 函数对 Generator 函数的改进，体现在以下四点。"></a>async 函数对 Generator 函数的改进，体现在以下四点。</h3><h4 id="内置执行器。"><a href="#内置执行器。" class="headerlink" title="内置执行器。"></a>内置执行器。</h4><p>Generator 函数的执行必须靠执行器，所以才有了<font color="#ff502c">co</font>模块,而<font color="#ff502c">async</font>函数自带执行器，也就是说，<font color="#ff502c">async</font>函数的执行，与普通函数一模一样，只要一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">"/etc/fstab"</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">"/etc/shells"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> result = asyncReadFile();</span><br></pre></td></tr></table></figure>
<h4 id="更好的语义"><a href="#更好的语义" class="headerlink" title="更好的语义"></a>更好的语义</h4><p><font color="#ff502c">async</font>和<font color="#ff502c">await</font>，比起<font color="#ff502c">*</font>和<font color="#ff502c">yield</font>，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p>
<h4 id="返回值是-Promise。"><a href="#返回值是-Promise。" class="headerlink" title="返回值是 Promise。"></a>返回值是 Promise。</h4><p><font color="#ff502c">async</font>函数的返回值是 <font color="#ff502c">Promise</font>对象，这比 <font color="#ff502c">Generator</font>函数的返回值是 <font color="#ff502c">Iterator</font>对象方便多了。你可以用<font color="#ff502c">then</font>方法指定下一步的操作。<br>进一步说，<font color="#ff502c">async</font>函数完全可以看作多个异步操作，包装成的一个<font color="#ff502c">Promise</font> 对象，而<font color="#ff502c">await</font>命令就是内部<font color="#ff502c">then</font>命令的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">asyncPrint(<span class="string">"hello wrold"</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p><font color="#ff502c">await</font> 操作符被用于等待由一个 async function 返回的一个 Promise。如果不是，会被转成一个立即 resolve 的 Promise 对象。</p>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>await 表达式会造成异步函数停止执行并且等待 promise 的解决，当值被 resolved，异步函数会恢复执行以及返回 resolved 值。如果该值不是一个 promise，它将会被转换成一个 resolved 后的 promise。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。那么整个 async 函数都会中断执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await Promise.reject('出错了');</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">"hello world"</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">  .then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul>
<li>第一点，前面已经说过，await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。因为只有 getFoo 完成以后，才会执行 getBar,完全可以让他们同事触发。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三点，await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。 正确的写法是采用 for 循环。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> db.post(doc);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">        <span class="keyword">await</span> db.post(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>迷茫中寻求向前走</title>
    <url>/blog/other/hello-world.html</url>
    <content><![CDATA[<h2 id="混乱"><a href="#混乱" class="headerlink" title="混乱"></a>混乱</h2><h3 id="先说一个故事"><a href="#先说一个故事" class="headerlink" title="先说一个故事"></a>先说一个故事</h3><p>最近一直想换工作，但是一直没找满意的，不知道是自己的表达能力有问题，还是自己的能力有问题，还是自己太不自信了。<br>故事开始，我在这个公司开发人员比较少，也没有技术经理什么的，只有一个不怎么懂业务还很善变的项目经理，一个月换一个大方向，用这个项目经理的一句话说就是：“我们就是对付老板的，老板高兴了什么都好说”，所以为了迎合老板，基本上是一个月换一个想法，什么都没做出来，都是做一个demo就断了，然我感觉现在真的不知道到底要做什么，做的这个东西有价值吗？他的价值是相对于公司内部的业务部门，还是说直接就可以卖给别人，现在真的不知道是那个。还有就是一些技术上的不匹配，我真的不懂，难道前端真的就比后端低一头，还是有的人根本就不能明确自己的职责呢。我是做前端，前端的事情应该是我负责，一般怎么解决我比别人要清楚。</p>
<p>哈哈，真的是什么有什么的不好，试着去改变自己，再改变别人，但是如果改变不了，那只能换一个办法再去改变自己，改变别人，如果别人真的接受不了，那还是算了，只能说大家不怎么合适，不做马后炮，不頂雷，信我的自然会全力以赴，不信的也要全力以赴，至少对得起自己，不后悔就行。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中实现类(class)和类(class)的继承(extends)</title>
    <url>/blog/es6/es6-class-extends.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>extends 关键词被用在类声明或者类表达式上，以创建一个类是另一个类的子类。Class 可以通过 extends 关键字实现继承。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ..and an (optional) custom class constructor. If one is</span></span><br><span class="line">  <span class="comment">// not supplied, a default constructor is used instead:</span></span><br><span class="line">  <span class="comment">// constructor() &#123; &#125;</span></span><br><span class="line">  <span class="comment">// 只能有一个 constructor 不能多次定义、如果没有声明 默认定义 constructor() &#123; &#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Polygon"</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Simple class instance methods using short-hand method</span></span><br><span class="line">  <span class="comment">// declaration</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    ChromeSamples.log(<span class="string">"Hi, I am a "</span>, <span class="keyword">this</span>.name + <span class="string">"."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHistory() &#123;</span><br><span class="line">    ChromeSamples.log(</span><br><span class="line">      <span class="string">'"Polygon" is derived from the Greek polus (many) '</span> + <span class="string">"and gonia (angle)."</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will look at static and subclassed methods shortly</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// 这里把length传参给父类的构造方法</span></span><br><span class="line">    <span class="comment">// 作为父类Polygon的宽和高</span></span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">    <span class="comment">// 备注：在衍生类中使用this前必须先调用super()方法</span></span><br><span class="line">    <span class="comment">// 忽视这一点将会导致一个引用错误</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Square"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> area(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.area = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line">s.sayName();</span><br><span class="line">ChromeSamples.log(<span class="string">"The area of this square is "</span> + s.area);</span><br></pre></td></tr></table></figure>
<p>声明一个父类 Polygon，constructor(构造函数中)创建了三个属性 name,height,width,</p>
<p><font color="#ff502c">Square</font>通过<font color="#ff502c">extends</font>关键字,继承了<font color="#ff502c">Polygon</font>类中的所有属性和方法。<br>子类必须在<font color="#ff502c">constructor</font>方法中调用<font color="#ff502c">super</font>方法，否则新建实例时会报错。这是因为子类没有自己的<font color="#ff502c">this</font>对象，而是继承父类的<font color="#ff502c">this</font>对象，然后对其进行加工。如果不调用<font color="#ff502c">super</font>方法，子类就得不到<font color="#ff502c">this</font>对象。<br>检验<font color="#ff502c">Square</font>是否<font color="#ff502c">继承</font>自<font color="#ff502c">Polygon</font>可以通过 Object.getPrototypeOf()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Square) === Polygon; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>super 这个关键字，既可以当作<font color="#ff502c">函数</font>使用，也可以当作<font color="#ff502c">对象</font>使用。</p>
<p><font color="#ff502c">子类的构造函数必须执行一次 super 函数，代表调用父类的构造函数，不然会报错。</font></p>
<p><font color="#ff502c">super 内部的 this 指的是 Square,相当于 Polygon.prototype.constructor.call(this);</font><br>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="comment">//super(); // 报错</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Polygon(); <span class="comment">// Polygon</span></span><br><span class="line"><span class="keyword">new</span> Square(); <span class="comment">// Square</span></span><br></pre></td></tr></table></figure>
<p>super 可以作为对象在普通函数中使用，指向父类的原型对象，在静态方法中，指向父类</p>
<h3 id="类的-prototype-属性和proto属性"><a href="#类的-prototype-属性和proto属性" class="headerlink" title="类的 prototype 属性和proto属性"></a>类的 prototype 属性和<strong>proto</strong>属性</h3><p>在 JavaScript 中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的 prototype 属性。</p>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Array系列(一) 一些常用array的扩展方法</title>
    <url>/blog/es6/es6-Array.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/blog/es6/es6-Array.html">ES6 Array 系列(一) 一些常用array的扩展方法</a><br><a href="/blog/es6/es6-Array1.html">ES6 Array 系列(二) 一些常用array的扩展方法（二）</a><br><a href="/blog/es6/es6-Array-break-continue.html">ES6 Array系列(三) Array中的forEach方法可以用break、continue跳出循环？</a><br><a href="/blog/es6/es6-Array-function.html">ES6 Array系列(四) Array常用的方法和实现reduce、map、filter、forEach</a></p>
</blockquote>
<!--## Array中常用的属性，或者方法-->
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><hr>
<h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><p>length 属性表示一个无符号 32-bit 整数，返回一个数组中的元素个数。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h2><p>Array.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// arrayLike 想要转换成真实数组的类数组对象或可遍历对象。</span></span><br><span class="line"><span class="comment">// mapFn(可选) 可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。</span></span><br><span class="line"><span class="comment">// thisArg(可选) 可选参数，执行 mapFn 函数时 this 的值。</span></span><br><span class="line"><span class="comment">// 返回值 返回一个新的Array类型的实例</span></span><br></pre></td></tr></table></figure>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Array.from() 允许你从下面两者来创建数组：</p>
<ul>
<li>类数组对象（拥有一个 length 属性和若干索引属性的任意对象）</li>
<li>可遍历对象（你可以从它身上迭代出若干个元素的对象，比如有 Map 和 Set 等）<br>Array.from() 方法有一个可选参数 mapFn，让你可以在最后生成的数组上再执行一次 map 方法后再返回。也就是说 Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg), 除非创建的不是可用的中间数组。 这对一些数组的子类,如  typed arrays 来说很重要, 因为中间数组的值在调用 map() 时需要是适当的类型。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array from a String</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'foo'</span>); </span><br><span class="line"><span class="comment">// ["f", "o", "o"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array from a Set</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'foo'</span>, <span class="built_in">window</span>]); </span><br><span class="line"><span class="built_in">Array</span>.from(s); </span><br><span class="line"><span class="comment">// ["foo", window]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array from a Map</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">8</span>]]);</span><br><span class="line"><span class="built_in">Array</span>.from(m); </span><br><span class="line"><span class="comment">// [[1, 2], [2, 4], [4, 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array from an Array-like object (arguments)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Using arrow functions and Array.from</span></span><br><span class="line"><span class="comment">// Using an arrow function as the map function to</span></span><br><span class="line"><span class="comment">// manipulate the elements</span></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x + x);      </span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate a sequence of numbers</span></span><br><span class="line"><span class="comment">// Since the array is initialized with `undefined` on each position,</span></span><br><span class="line"><span class="comment">// the value of `v` below will be `undefined`</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;, (v, i) =&gt; i);</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h2><p>Array.isArray() 用于确定传递的值是否是一个 Array。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(obj)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// obj</span></span><br><span class="line"><span class="comment">// 需要检测的值。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 如果对象是 Array，则为true; 否则为false。</span></span><br></pre></td></tr></table></figure>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>如果对象是 Array ，则返回true，否则为false。<br>有关更多详细信息，请参阅文章以绝对精确度确定JavaScript对象是否为数组。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的函数调用都返回 true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]);</span><br><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="comment">// 鲜为人知的事实：其实 Array.prototype 也是一个数组。</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数调用都返回 false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray();</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="string">'Array'</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123; <span class="attr">__proto__</span>: <span class="built_in">Array</span>.prototype &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="兼容性代码"><a href="#兼容性代码" class="headerlink" title="兼容性代码"></a>兼容性代码</h3><p>假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展运算符（spread）"><a href="#扩展运算符（spread）" class="headerlink" title="扩展运算符（spread）"></a>扩展运算符（spread）</h2><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">    array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// elementN</span></span><br><span class="line"><span class="comment">// 任意个参数，将按顺序成为返回数组中的元素。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 新的 Array 实例。</span></span><br><span class="line"><span class="built_in">Array</span>.of(element0[, element1[, ...[, elementN]]])</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>);         <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>); <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h3 id="兼容旧环境"><a href="#兼容旧环境" class="headerlink" title="兼容旧环境"></a>兼容旧环境</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.of) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.of = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h2><p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = old_array.concat(value1[, value2[, ...[, valueN]]])</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// valueN</span></span><br><span class="line"><span class="comment">// 需要与原数组合并的数组或非数组值。详见下文。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 新的 Array 实例。</span></span><br></pre></td></tr></table></figure>
<h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式:</p>
<ul>
<li>对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.</li>
<li>字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里.</li>
</ul>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个数组合并为一个新数组</span></span><br><span class="line"><span class="keyword">var</span> alpha = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> numeric = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> three = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// 组成新数组 ["a", "b", "c", 1, 2, 3]; 原数组 alpha 和 numeric 未被修改</span></span><br><span class="line"><span class="keyword">var</span> alphaNumeric = alpha.concat(numeric);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组成新数组["a", "b", "c", 1, 2, 3, 4, 5, 6]; 原数组 num1, num2, num3 未被修改</span></span><br><span class="line"><span class="keyword">var</span> nums = num1.concat(num2, num3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个数组和多个非数组值合并为一个新数组</span></span><br><span class="line"><span class="comment">// 组成新数组 ["a", "b", "c", 1, 2, 3], 原alpha数组未被修改</span></span><br><span class="line"><span class="keyword">var</span> alphaNumeric1 = alpha.concat(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-copyWithin"><a href="#Array-prototype-copyWithin" class="headerlink" title="Array.prototype.copyWithin()"></a>Array.prototype.copyWithin()</h2><p>copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.copyWithin(target)</span><br><span class="line">arr.copyWithin(target, start)</span><br><span class="line">arr.copyWithin(target, start, end)</span><br><span class="line">arr.copyWithin(目标索引, [源开始索引], [结束源索引])</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// target</span></span><br><span class="line"><span class="comment">// 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。    如果 start 被忽略，copyWithin 将会从0开始复制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。 如果 end 被忽略，copyWithin 将会复制到 arr.length。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 改变了的数组。</span></span><br></pre></td></tr></table></figure>
<h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>参数target,start和end 必须为整数。<br>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。<br>copyWithin方法不要求其this值必须是一个数组对象；除此之外，copyWithin是一个可变方法，它可以改变this对象本身，并且返回它，而不仅仅是它的拷贝。<br>copyWithin 就像 C 和 C++ 的 memcpy 函数一样，且它是用来移动 Array 或者 TypedArray 数据的一个高性能的方法。复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。<br>copyWithin 函数是设计为通用的，其不要求其 this 值必须是一个数组对象。<br>The copyWithin 是一个可变方法，它不会改变 this 的 length，但是会改变 this 本身的内容，且需要时会创建新的属性。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 1, 2]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 3, 4]</span></span><br><span class="line"></span><br><span class="line">[].copyWithin.call(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2015 Typed Arrays are subclasses of Array</span></span><br><span class="line"><span class="keyword">var</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On platforms that are not yet ES2015 compliant: </span></span><br><span class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-entries-、Array-prototype-keys-、Array-prototype-values-遍历数组"><a href="#Array-prototype-entries-、Array-prototype-keys-、Array-prototype-values-遍历数组" class="headerlink" title="Array.prototype.entries()、Array.prototype.keys()、Array.prototype.values() 遍历数组"></a>Array.prototype.entries()、Array.prototype.keys()、Array.prototype.values() 遍历数组</h2><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<ul>
<li>entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。</li>
<li>keys() 方法返回一个新的Array迭代器，它包含数组中每个索引的键。</li>
<li>values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(index);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 0</span></span><br><span class="line"> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(elem);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 'a'</span></span><br><span class="line"> <span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(index, elem);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 0 "a"</span></span><br><span class="line"> <span class="comment">// 1 "b" </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> arr = [<span class="string">'w'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>];</span><br><span class="line"> <span class="keyword">let</span> eArr = arr.values();</span><br><span class="line"> <span class="comment">// 您的浏览器必须支持 for..of 循环</span></span><br><span class="line"> <span class="comment">// 以及 let —— 将变量作用域限定在 for 循环中</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> eArr) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(letter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 另一种 迭代方式</span></span><br><span class="line"> <span class="keyword">let</span> arr = [<span class="string">'w'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>];</span><br><span class="line"> <span class="keyword">let</span> eArr = arr.values();</span><br><span class="line"> <span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// w</span></span><br><span class="line"> <span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// y</span></span><br><span class="line"> <span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// k</span></span><br><span class="line"> <span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// o</span></span><br><span class="line"> <span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// p</span></span><br></pre></td></tr></table></figure>
<p>可以通过 for…of来循环数组</p>
<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>在javascript中所有的对象都具有 toLocaleString()、toString()、valueOf()方法。</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf()); <span class="comment">// [red,blue,green]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.toLocaleString()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">','</span>)); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="comment">// 在默认情况下都会以逗号分隔的字符串的形式返回数组项</span></span><br></pre></td></tr></table></figure>
<h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>如果数组中的某一项的值是null或者undefined,那么该只在join()、toLocaleString()、toString()、valueOf()方法返回的结果中以空字符串表示</p>
<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>reverse() 方法会反转数组项的顺序。  sort()方法按升序排列数组项</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reverse() 数组反转</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">values.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(values); <span class="comment">// [8, 7, 6, 5, 4, 3, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort() 排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values1 = [<span class="string">'2'</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">65</span>, <span class="number">2</span>];</span><br><span class="line">values1.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(values1); <span class="comment">//  [1, "2", 2, 2, 3, 4, 4, 5, 65]</span></span><br></pre></td></tr></table></figure>
<p><strong>未完待续。。。。。</strong></p>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ios中1px border解决方法</title>
    <url>/blog/moblie/ios-bug-border.html</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="1、引入flexible方案"><a href="#1、引入flexible方案" class="headerlink" title="1、引入flexible方案"></a>1、引入flexible方案</h3><p>可通过 手淘的 <font color="#ff502c">flexible方案</font>来解决这个问题</p>
<p><font color="#ff502c">flexible的原理讲解和使用 <a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html</a></font></p>
<p><font color="#ff502c">flexible 库地址：<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">https://github.com/amfe/lib-flexible</a></font></p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>在devicePixelRatio = 2 时，输出viewport<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在devicePixelRatio = 3 时，输出viewport<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。</p>
<h3 id="2、-transform-scale-0-5"><a href="#2、-transform-scale-0-5" class="headerlink" title="2、 transform: scale(0.5)"></a>2、 transform: scale(0.5)</h3><p>使用css3的transfrom的scale属性<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.weui-btn</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(0, 0, 0, 0.2);</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(0.5);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(0.5);</span><br><span class="line">    <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可参考微信的 web ui中的解决方案<br>参考地址 <a href="https://weui.io/#button" target="_blank" rel="noopener">https://weui.io/#button</a></p>
<h3 id="可用图片实现代替边框"><a href="#可用图片实现代替边框" class="headerlink" title="可用图片实现代替边框"></a>可用图片实现代替边框</h3><p>不建议使用</p>
]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>retina屏高清屏的具体原理</title>
    <url>/blog/moblie/ios-bug-retina.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随着2012年苹果发布第一款Retina Macbook Pro（以下简称RMBP），Retina屏幕开始进入笔记本行业。两年过去了，RMBP的市场占有率越来越高，且获得了一大批设计师朋友的青睐，网站对于Retina屏幕的适配也变成了迫在眉睫的问题。</p>
<ul>
<li>1、一种具有备超高像素密度的液晶屏</li>
<li>2、同样大小的屏幕上显示的像素点由1个变为多个<br>在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。<br><img src="../../images/ios_bug/retina-web-3.jpg" alt="css3 3d transfrom"></li>
</ul>
<h3 id="物理像素（physical-pixel）"><a href="#物理像素（physical-pixel）" class="headerlink" title="物理像素（physical pixel）"></a>物理像素（physical pixel）</h3><p>物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。<br><img src="../../images/ios_bug/retina-web-1.jpg" alt="css3 3d transfrom"></p>
<h3 id="设备独立像素-density-independent-pixel"><a href="#设备独立像素-density-independent-pixel" class="headerlink" title="设备独立像素(density-independent pixel)"></a>设备独立像素(density-independent pixel)</h3><p>设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。</p>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。</p>
<h3 id="设备像素比-device-pixel-ratio"><a href="#设备像素比-device-pixel-ratio" class="headerlink" title="设备像素比(device pixel ratio)"></a>设备像素比(device pixel ratio)</h3><p>设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：</p>
<p><font color="#ff502c">设备像素比 ＝ 物理像素 / 设备独立像素</font><br>在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。而在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。<br>dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。</p>
<ul>
<li>devicePixelRatio在大多数浏览器是值得信赖的。</li>
<li>在iOS设备，screen.width乘以devicePixelRatio得到的是物理像素值。</li>
<li>在Android以及Windows Phone设备，screen.width除以devicePixelRatio得到的是设备独立像素(dips)值。<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2>通过判断 devicePixelRatio 的值来加载不同尺寸的图片</li>
<li><font color="#ff502c">针对普通显示屏(devicePixelRatio = 1.0、1.3)，加载一张1倍的图片</font></li>
<li><font color="#ff502c">针对高清显示屏(devicePixelRatio &gt;= 1.5、2.0、3.0)，加载一张2倍大的图片</font><br>dpr为3的手机比较小，建议用两倍的图片<h3 id="Media-Queries判断当前的dpr"><a href="#Media-Queries判断当前的dpr" class="headerlink" title="Media Queries判断当前的dpr"></a>Media Queries判断当前的dpr</h3>通过媒体查询结合devicePixelRatio可以区分普通的显示屏和高清显示屏，<font color="#ff502c">兼容行比较好</font><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css</span>&#123;<span class="comment">/* 普通显示屏(设备像素比例小于等于1.3)使用1倍的图 */</span> </span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(img_1x.png);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">1.5</span>)&#123;</span><br><span class="line"><span class="selector-class">.css</span>&#123;<span class="comment">/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图  */</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(img_2x.png);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">3</span>)&#123;</span><br><span class="line"><span class="selector-class">.css</span>&#123;<span class="comment">/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图  */</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(img_2x.png);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="image-set-设计retina背景图"><a href="#image-set-设计retina背景图" class="headerlink" title="image-set 设计retina背景图"></a>image-set 设计retina背景图</h3><p>image-set，它是Webkit的私有属性，也是Css4的一个属性。<font color="#ff502c">目前支持苹果的 retina 显示屏和部分android 显示屏</font><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(../img/bank_ico.png) no-repeat;<span class="comment">/* 不支持image-set的显示屏 */</span> </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-webkit-image-set</span>(</span><br><span class="line">                url(../img/bank_ico.png) <span class="number">1</span>x,<span class="comment">/* 支持image-set的浏览器的[普通屏幕]下 */</span></span><br><span class="line">                <span class="built_in">url</span>(../img/bank_ico_retina.png) <span class="number">2</span>x);<span class="comment">/* 支持image-set的浏览器的[Retina屏幕] */</span></span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本文<br>参考: <a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html</a> © w3cplus.com<br>参考：<a href="http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/</a><br>参考：<a href="http://www.cnblogs.com/PeunZhang/p/3441110.html" target="_blank" rel="noopener">http://www.cnblogs.com/PeunZhang/p/3441110.html</a></p>
]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中 class（类）的用法</title>
    <url>/blog/javascript/javascript-oop.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>javascript是一种基于对象的语言，你遇到的所有东西几乎都是对象。但是,它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class(类)。<br>es6 中新提出了类（Class）概念，JavaScript中的类只是JavaScript中的类只是JavaScript现有基于原型的继承的一种语法包装（语法糖）,他能让我们用建明的语法实现继承。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>声明一个 Person “类”，它内部有一个constructor方法，这个就是构造方法，而this关键字则代表实例对象。<br>使用new关键子创建，是跟构造函数的用法完全一致。构造函数和普通的JavaScript中的构造函数是一个样的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    getPerson() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'名字：'</span> + <span class="keyword">this</span>.name + <span class="string">'年龄：'</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oObj = <span class="keyword">new</span> Person(<span class="string">'小明'</span>, <span class="number">20</span>);</span><br><span class="line">oObj.getPerson();<span class="comment">// "名字：小名年龄：20"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..and an (optional) custom class constructor. If one is </span></span><br><span class="line"><span class="comment">// not supplied, a default constructor is used instead:</span></span><br><span class="line"><span class="comment">// constructor() &#123; &#125;</span></span><br><span class="line"><span class="comment">// 只能有一个 constructor 不能多次定义、如果没有声明 默认定义 constructor() &#123; &#125;</span></span><br><span class="line"><span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Polygon'</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple class instance methods using short-hand method</span></span><br><span class="line"><span class="comment">// declaration</span></span><br><span class="line">sayName() &#123;</span><br><span class="line">    ChromeSamples.log(<span class="string">'Hi, I am a '</span>, <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHistory() &#123;</span><br><span class="line">    ChromeSamples.log(<span class="string">'"Polygon" is derived from the Greek polus (many) '</span> +</span><br><span class="line">    <span class="string">'and gonia (angle).'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We will look at static and subclassed methods shortly</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// 这里把length传参给父类的构造方法</span></span><br><span class="line">        <span class="comment">// 作为父类Polygon的宽和高</span></span><br><span class="line">        <span class="keyword">super</span>(length, length);</span><br><span class="line">        <span class="comment">// 备注：在衍生类中使用this前必须先调用super()方法</span></span><br><span class="line">        <span class="comment">// 忽视这一点将会导致一个引用错误</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> area() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> area(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.area = value;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line">s.sayName();</span><br><span class="line">ChromeSamples.log(<span class="string">'The area of this square is '</span> + s.area);</span><br></pre></td></tr></table></figure>
<p>构造函数的prototype(原型)属性，类的所有方法都定义在类的prototype属性上面。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="子类的使用"><a href="#子类的使用" class="headerlink" title="子类的使用"></a>子类的使用</h3><p>可以通过 extends关键字来实现继承</p>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>一个类必须有constructor方法,默认添加。默认返回this（实例对象），也可指定别的对象。<br>类必须使用new调用，否则会报错。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo()</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h3><p>类的所有实例共享一个原型对象。通过实例的<strong>proto</strong>属性为“类”添加方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oObj = <span class="keyword">new</span> Person(<span class="string">'小明'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> oObj1 = <span class="keyword">new</span> Person(<span class="string">'小明'</span>, <span class="number">20</span>);</span><br><span class="line">oObj.__proto__ === oObj1.__proto__; <span class="comment">// true</span></span><br><span class="line">oObj.__proto__.des = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'学习'</span>;</span><br><span class="line">&#125;</span><br><span class="line">oObj.des(); <span class="comment">// 学习</span></span><br><span class="line">oObj1.des(); <span class="comment">// 学习</span></span><br><span class="line"><span class="keyword">var</span> oObj2 = <span class="keyword">new</span> Preson(<span class="string">'小红'</span>, <span class="number">18</span>);</span><br><span class="line">oObj2.des(); <span class="comment">// 学习</span></span><br></pre></td></tr></table></figure></p>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>extends关键词被用在类声明或者类表达式上，以创建一个类是另一个类的子类。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>extends关键词用来创建一个普通类或者内建对象的子类。<br>扩展的.prototype必须是一个Object 或者 null。</p>
<h3 id="使用extends"><a href="#使用extends" class="headerlink" title="使用extends"></a>使用extends</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..and an (optional) custom class constructor. If one is </span></span><br><span class="line"><span class="comment">// not supplied, a default constructor is used instead:</span></span><br><span class="line"><span class="comment">// constructor() &#123; &#125;</span></span><br><span class="line"><span class="comment">// 只能有一个 constructor 不能多次定义、如果没有声明 默认定义 constructor() &#123; &#125;</span></span><br><span class="line"><span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Polygon'</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple class instance methods using short-hand method</span></span><br><span class="line"><span class="comment">// declaration</span></span><br><span class="line">sayName() &#123;</span><br><span class="line">    ChromeSamples.log(<span class="string">'Hi, I am a '</span>, <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHistory() &#123;</span><br><span class="line">    ChromeSamples.log(<span class="string">'"Polygon" is derived from the Greek polus (many) '</span> +</span><br><span class="line">    <span class="string">'and gonia (angle).'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We will look at static and subclassed methods shortly</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// 这里把length传参给父类的构造方法</span></span><br><span class="line">        <span class="comment">// 作为父类Polygon的宽和高</span></span><br><span class="line">        <span class="keyword">super</span>(length, length);</span><br><span class="line">        <span class="comment">// 备注：在衍生类中使用this前必须先调用super()方法</span></span><br><span class="line">        <span class="comment">// 忽视这一点将会导致一个引用错误</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> area() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> area(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.area = value;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line">s.sayName();</span><br><span class="line">ChromeSamples.log(<span class="string">'The area of this square is '</span> + s.area);</span><br></pre></td></tr></table></figure>
<h3 id="使用extends扩展内建对象"><a href="#使用extends扩展内建对象" class="headerlink" title="使用extends扩展内建对象"></a>使用extends扩展内建对象</h3><p>这个示例继承了Date 对象。 你可以从实战演示看到这个例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDate</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFormattedDate() &#123;</span><br><span class="line">    <span class="keyword">var</span> months = [<span class="string">'Jan'</span>,<span class="string">'Feb'</span>,<span class="string">'Mar'</span>,<span class="string">'Apr'</span>,<span class="string">'May'</span>,<span class="string">'Jun'</span>,<span class="string">'Jul'</span>,<span class="string">'Aug'</span>,<span class="string">'Sep'</span>,<span class="string">'Oct'</span>,<span class="string">'Nov'</span>,<span class="string">'Dec'</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getDate() + <span class="string">"-"</span> + months[<span class="keyword">this</span>.getMonth()] + <span class="string">"-"</span> + <span class="keyword">this</span>.getFullYear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展-null"><a href="#扩展-null" class="headerlink" title="扩展 null"></a>扩展 null</h3><p>可以像扩展普通类一样扩展null，但是新对象的原型将不会继承 Object.prototype.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nullExtends</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(nullExtends); <span class="comment">// Function.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(nullExtends.prototype) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="class表达式"><a href="#class表达式" class="headerlink" title="class表达式"></a>class表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class的取值函数（getter）和存值函数（setter）"><a href="#class的取值函数（getter）和存值函数（setter）" class="headerlink" title="class的取值函数（getter）和存值函数（setter）"></a>class的取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> prop() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> prop(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line">Bar.classMethod() <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure></p>
<p>如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<br>父类的静态方法，可以被子类继承。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS下的 Fixed + Input BUG现象</title>
    <url>/blog/moblie/ios-bug.html</url>
    <content><![CDATA[<h2 id="iOS下的-Fixed-Input-BUG现象"><a href="#iOS下的-Fixed-Input-BUG现象" class="headerlink" title="iOS下的 Fixed + Input BUG现象"></a>iOS下的 Fixed + Input BUG现象</h2><h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>让我们先举个例子，最直观的说明一个在ios中input + fixed布局，可能使用如下布局<br>转载 <a href="http://efe.baidu.com/" target="_blank" rel="noopener">http://efe.baidu.com/</a><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">header, footer, main &#123;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    height: 50px;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">footer &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    height: 34px;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main &#123;</span><br><span class="line">    margin-top: 50px;</span><br><span class="line">    margin-bottom: 34px;</span><br><span class="line">    height: 2000px</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"layout-fixed"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的头部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 可以滚动的区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内容在这里... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的底部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Footer..."</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后看起来就是下面这个样子。拖动页面时 header 和 footer 已经定位在了对应的位置，目测没问题了。<br><img src="../../images/ios_bug/fixed.png" alt="css3 3d transfrom"><br><!-- <img src="../../images/ios_bug/fixed.png" alt="ios_bug" title="ios_bug"/> --><br>但接下来问题就来了！如果底部输入框软键盘被唤起以后，再次滑动页面，就会看到如下图所示：<br><img src="../../images/ios_bug/fixed_bug_0.png" alt="css3 3d transfrom"> <img src="../../images/ios_bug/fixed_bug_1.png" alt="css3 3d transfrom"></p>
<p><font color="#ff502c"> 软键盘唤起后，页面的 fixed 元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。</font><br>这就是ios上fixed元素和输入框的bug,其中不仅陷入于<font color="#ff502c">type=”text”</font>的输入框，凡是软键盘（比如时间选择器、select选择等等）被唤起，都会遇到同样的问题。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>虽然 isScroll.js 可以很好的解决 fixed 定位滚动的问题，但是不在万不得已的情况下，我们尽量尝试一下不依赖第三方库的布局方案，以简化实现方式。这里抛砖引玉作为参考。</p>
<p>即使在ios下由于软键盘唤出后，页面fixed元素会失效，导致跟随页面一起滚动，那么<font color="#ff502c">页面不会过长出现滚动，那么即便fixed元素失效，也无法跟随页面滚动，也不会出现上面的问题了</font>，其实就是内部滚动<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"layout-scroll-fixed"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的头部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 可以滚动的区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内容在这里... --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的底部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Footer..."</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span>, <span class="selector-tag">footer</span>, <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">34px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="comment">/* main绝对定位，进行内部滚动 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">34px</span>;</span><br><span class="line">    <span class="comment">/* 使之可以滚动 */</span></span><br><span class="line">    <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2000px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在原始输入法下， fixed 元素可以定位在页面的正确位置。滚动页面时，由于滚动的是 main 内部的 div，因此 footer 没有跟随页面滚动。</p>
<p>上面貌似解决了问题，但是如果在手机上实际测试一下，会发现 main 元素内的滚动非常不流畅，滑动的手指松开后，滚动立刻停止，失去了原本的流畅滚动特性。百度一下弹性滚动的问题，发现在 webkit 中，下面的属性可以恢复弹性滚动。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-overflow-scrolling</span>: <span class="selector-tag">touch</span>;</span><br></pre></td></tr></table></figure></p>
<p>在 main 元素上加上该属性，嗯，丝般顺滑的感觉又回来了！<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="comment">/* main绝对定位，进行内部滚动 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">34px</span>;</span><br><span class="line">    <span class="comment">/* 使之可以滚动 */</span></span><br><span class="line">    <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">    <span class="comment">/* 增加该属性，可以增加弹性 */</span></span><br><span class="line">    <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，这里的 header 和 footer 使用的是 fixed 定位，如果考虑到更老一些的 iOS 系统不支持 fixed 元素，完全可以把 fixed 替换成 absolute 。测试后效果是一样的。</p>
<p>至此一个不依赖第三方库的 fixed 布局就完成了。</p>
<h3 id="Android-下布局"><a href="#Android-下布局" class="headerlink" title="Android 下布局"></a>Android 下布局</h3><p>谈到了 iOS ，也来简单说一下 Android 下的布局吧。</p>
<p>在 Android2.3+ 中，因为不支持 overflow-scrolling ，因此部分浏览器内滚动会有不流畅的卡顿。但是目前发现在 body 上的滚动还是很流畅的，因此使用第一种在 iOS 出现问题的 fixed 定位的布局就可以了。</p>
<p>如果需要考虑 Android2.3 以下系统，因为不支持 fixed 元素，所以依然要需要考虑使用 isScroll.js 来实现内部滚动。</p>
<p>其实在 fixed 和输入框的问题上，基本思路就是： &gt; 由于 fixed 在软键盘唤起后会失效，导致在页面可以滚动时，会跟随页面一起滚动。因此如果页面无法滚动，那么 fixed 元素即使失效，也不会滚动，也就不会出现 bug 了。</p>
<p>所以可以在这个方面去考虑解决问题。</p>
<h3 id="其他的一些细节处理"><a href="#其他的一些细节处理" class="headerlink" title="其他的一些细节处理"></a>其他的一些细节处理</h3><p>在细节处理上，其实还有很多要注意的，挑几个实际遇到比较大的问题来说一下：</p>
<p>有时候输入框 focus 以后，会出现软键盘遮挡输入框的情况，这时候可以尝试 input 元素的 scrollIntoView 进行修复。<br>在 iOS 下使用第三方输入法时，输入法在唤起经常会盖住输入框，只有在输入了一条文字后，输入框才会浮出。目前也不知道有什么好的办法能让唤起输入框时正确显示。这暂时算是 iOS 下的一个坑吧。<br>有些第三方浏览器底部的工具栏是浮在页面之上的，因此底部 fixed 定位会被工具栏遮挡。解决办法也比较简单粗暴——适配不同的浏览器，调整 fixed 元素距离底部的距离。<br>最好将 header 和 footer 元素的 touchmove 事件禁止，以防止滚动在上面触发了部分浏览器全屏模式切换，而导致顶部地址栏和底部工具栏遮挡住 header 和 footer 元素。<br>在页面滚动到上下边缘的时候，如果继续拖拽会将整个 View 一起拖拽走，导致页面的“露底”。<br><img src="../../images/ios_bug/fixed_pull_over.png" alt="css3 3d transfrom"><br>为了防止页面露底，可以在页面拖拽到边缘的时候，通过判断拖拽方向以及是否为边缘来阻止 touchmove 事件，防止页面继续拖拽。</p>
<p>以上面内滚动 layout-scroll-fixed 布局为例，给出一段代码作为参考：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止内容区域滚到底后引起页面整体的滚动</span></span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.querySelector(<span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">var</span> startY;</span><br><span class="line"></span><br><span class="line">content.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">content.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 高位表示向上滚动</span></span><br><span class="line">    <span class="comment">// 底位表示向下滚动</span></span><br><span class="line">    <span class="comment">// 1容许 0禁止</span></span><br><span class="line">    <span class="keyword">var</span> status = <span class="string">'11'</span>;</span><br><span class="line">    <span class="keyword">var</span> ele = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ele.scrollTop === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果内容小于容器则同时禁止上下滚动</span></span><br><span class="line">        status = ele.offsetHeight &gt;= ele.scrollHeight ? <span class="string">'00'</span> : <span class="string">'01'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.scrollTop + ele.offsetHeight &gt;= ele.scrollHeight) &#123;</span><br><span class="line">        <span class="comment">// 已经滚到底部了只能向上滚动</span></span><br><span class="line">        status = <span class="string">'10'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != <span class="string">'11'</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前的滚动方向</span></span><br><span class="line">        <span class="keyword">var</span> direction = currentY - startY &gt; <span class="number">0</span> ? <span class="string">'10'</span> : <span class="string">'01'</span>;</span><br><span class="line">        <span class="comment">// 操作方向和当前允许状态求与运算，运算结果为0，就说明不允许该方向滚动，则禁止默认事件，阻止滚动</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">parseInt</span>(status, <span class="number">2</span>) &amp; <span class="built_in">parseInt</span>(direction, <span class="number">2</span>))) &#123;</span><br><span class="line">            stopEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>JavaScript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的call、apply、bind的应用场景（二）</title>
    <url>/blog/javascript/js-Call-Apply-Bind.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>apply()方法吊用一个函数，其具有一种个指定的this值，<font color="#ff502c"> 以及作为一个数组（或类似数组的对象）提供的参数</font>。call()方法的作用和apply()方法类似，只有一个区别，就是call()方法<font color="#ff502c">接受的是若干个参数列表</font>，而apply()方法接受的是一个包含<font color="#ff502c">多个参数的数组</font><br>bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
<h2 id="apply语法"><a href="#apply语法" class="headerlink" title="apply语法"></a>apply语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="thisArg"><a href="#thisArg" class="headerlink" title="thisArg"></a>thisArg</h4><p>在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象</p>
<h4 id="argsArray"><a href="#argsArray" class="headerlink" title="argsArray"></a>argsArray</h4><p>一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。</p>
<p>apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表（原文：a named set of parameters）。apply 可以使用数组字面量（array literal），如 fun.apply(this, [‘eat’, ‘bananas’])，或数组对象， 如  fun.apply(this, new Array(‘eat’, ‘bananas’))。</p>
<p>你也可以使用 arguments  对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。</p>
<p>从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和[0…length) 范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {‘length’: 2, ‘0’: ‘eat’, ‘1’: ‘bananas’} 形式的对象。</p>
<p>需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">var</span> elements = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">array.push.apply(array, elements);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br></pre></td></tr></table></figure>
<h3 id="使用apply来链接构造器"><a href="#使用apply来链接构造器" class="headerlink" title="使用apply来链接构造器"></a>使用apply来链接构造器</h3><p>你可以使用apply来链接一个对象<font color="#ff502c">构造器</font>，类似于Java。在接下来的例子中我们会创建一个全局Function 对象的construct方法 ，来使你能够在构造器中使用一个类数组对象而非参数列表。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span> (<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oNew = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</span><br><span class="line">  <span class="keyword">this</span>.apply(oNew, aArgs);</span><br><span class="line">  <span class="keyword">return</span> oNew;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意: 上面使用的Object.create()方法相对来说比较新。另一种可选的方法，请考虑如下替代方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span> (<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oNew = &#123;&#125;;</span><br><span class="line">  oNew.__proto__ = <span class="keyword">this</span>.prototype;</span><br><span class="line">  <span class="keyword">this</span>.apply(oNew, aArgs);</span><br><span class="line">  <span class="keyword">return</span> oNew;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用闭包：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span>(<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fConstructor = <span class="keyword">this</span>, fNewConstr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fConstructor.apply(<span class="keyword">this</span>, aArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">  fNewConstr.prototype = fConstructor.prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> fNewConstr();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用 Function 构造器：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span>(<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fConstructor = <span class="keyword">this</span>, fNewConstr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fConstructor.apply(<span class="keyword">this</span>, aArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">  fNewConstr.prototype = fConstructor.prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> fNewConstr();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="call语法"><a href="#call语法" class="headerlink" title="call语法"></a>call语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><h4 id="thisArg-1"><a href="#thisArg-1" class="headerlink" title="thisArg"></a>thisArg</h4><p>在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于non-strict mode，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象</p>
<h4 id="arg1-arg2-…"><a href="#arg1-arg2-…" class="headerlink" title="arg1, arg2, …"></a>arg1, arg2, …</h4><p>指定的参数列表。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">参考地址</a></p>
<h2 id="bind语法"><a href="#bind语法" class="headerlink" title="bind语法"></a>bind语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">bind</span>(<span class="params">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><h4 id="thisArg-2"><a href="#thisArg-2" class="headerlink" title="thisArg"></a>thisArg</h4><p>调用绑定函数时作为this参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用bind在setTimeout中创建一个函数（作为回调提供）时，作为thisArg传递的任何原始值都将转换为object。如果bind函数的参数列表为空，执行作用域的this将被视为新函数的thisArg。</p>
<h4 id="arg1-arg2-…-1"><a href="#arg1-arg2-…-1" class="headerlink" title="arg1, arg2, …"></a>arg1, arg2, …</h4><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">参考地址</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的this指向问题（一）</title>
    <url>/blog/javascript/javascript-this.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先必须要说的是，this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象,那么接下来我会深入的探讨这个问题。</p>
<font color="#ff502c">function 执行默认返回 undefined</font>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="在一般函数方法中使用-this-指代全局对象"><a href="#在一般函数方法中使用-this-指代全局对象" class="headerlink" title="在一般函数方法中使用 this 指代全局对象"></a>在一般函数方法中使用 this 指代全局对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ale = <span class="string">"外部"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ale = <span class="string">"内部"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.ale); <span class="comment">// 外部</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 因为在全局中执行，所以this指向window</span></span><br><span class="line"><span class="comment">// window.a(); 与上面其实是一致的</span></span><br></pre></td></tr></table></figure>
<h3 id="作为对象方法调用，this-纸袋上级对象"><a href="#作为对象方法调用，this-纸袋上级对象" class="headerlink" title="作为对象方法调用，this 纸袋上级对象"></a>作为对象方法调用，this 纸袋上级对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ale = <span class="string">"外部"</span>;</span><br><span class="line"><span class="keyword">var</span> oObeject = &#123;</span><br><span class="line">  ale: <span class="string">"内部"</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.ale); <span class="comment">// 内部</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// oObeject</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">oObeject.fn();</span><br></pre></td></tr></table></figure>
<p>这里的 this 指向 oObeject,因为这个 fn 是通过 oObeject 调用的,所以指向 oObeject,this 在函数创建的时候是决定不了的,在调用的时候才能决定，<font color="#ff502c">谁调用 this 指像谁</font></p>
<h3 id="作为构造函数调用，this-指代-new-出的对象"><a href="#作为构造函数调用，this-指代-new-出的对象" class="headerlink" title="作为构造函数调用，this 指代 new 出的对象"></a>作为构造函数调用，this 指代 new 出的对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ale = <span class="string">"外部"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.ale = <span class="string">"内部"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.ale); <span class="comment">// 内部</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Test</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 默认 return 当前this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test1 = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(test1.ale); <span class="comment">// 内部</span></span><br></pre></td></tr></table></figure>
<p>new 关键字可以改变 this 的指向,将这个 this 指向对象 test1,此时仅仅只是创建，并没有执行，而调用这个函数 Fn 的是对象 test1，那么 this 指向的自然是对象 test1</p>
<h4 id="当函数中有-return-时"><a href="#当函数中有-return-时" class="headerlink" title="当函数中有 return 时"></a>当函数中有 return 时</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.user = <span class="string">"内部"</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 因为返回的是空对象像 or return function () &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Object &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<font color="#ff502c">如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还是指向函数的实例。</font>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.user = <span class="string">"内部"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 因为返回的是空对象像 or return undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Object &#123;user&#125;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是 <font color="#ff502c">还有一点就是虽然 null 也是对象，但是在这里 this 还是指向那个函数的实例，因为 null 比较特殊。</font></p>
<h3 id="apply、call、bind-改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this-指代第一个参数"><a href="#apply、call、bind-改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this-指代第一个参数" class="headerlink" title="apply、call、bind 改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this 指代第一个参数"></a>apply、call、bind 改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this 指代第一个参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">"外部"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  x: <span class="string">"内部"</span>,</span><br><span class="line">  m: test</span><br><span class="line">&#125;;</span><br><span class="line">o.m.apply(); <span class="comment">// 外部</span></span><br><span class="line"><span class="comment">//apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为</span></span><br><span class="line">o.m.apply(o); <span class="comment">// 内部</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>constructor的作用</title>
    <url>/blog/javascript/js-constructor-1.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>所有对象都有一个  constructor属性。在不明确使用构造函数（即对象和数组文字）的情况下创建的对象将具有constructor指向该对象的基础对象构造函数类型的属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = [];</span><br><span class="line">o.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">o.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line">a.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line">n.constructor === <span class="built_in">Number</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="显示对象的构造函数"><a href="#显示对象的构造函数" class="headerlink" title="显示对象的构造函数"></a>显示对象的构造函数</h3><p>以下示例创建一个原型，Tree以及该类型的对象theTree。该示例然后显示constructor该对象的属性theTree。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> theTree = <span class="keyword">new</span> Tree(<span class="string">'Redwood'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'theTree.constructor is'</span> + theTree.constructor);</span><br><span class="line"><span class="comment">//theTree.constructor is function Tree(name) &#123;</span></span><br><span class="line"><span class="comment">//  this.name = name;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="更改对象的构造函数"><a href="#更改对象的构造函数" class="headerlink" title="更改对象的构造函数"></a>更改对象的构造函数</h3><p>以下示例显示如何修改泛型对象的构造函数值。只有true，1并且”test” 不会受到影响，因为他们有只读的本地构造函数。这个例子表明，依靠constructor对象的属性并不总是安全的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> types = [</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Array</span>(),</span><br><span class="line">  [],</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Boolean</span>(),</span><br><span class="line">  <span class="literal">true</span>,             <span class="comment">// remains unchanged</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Error</span>(),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Function</span>(),</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="built_in">Math</span>,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Number</span>(),</span><br><span class="line">  <span class="number">1</span>,                <span class="comment">// remains unchanged</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">RegExp</span>(),</span><br><span class="line">  /(?:)/,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">String</span>(),</span><br><span class="line">  <span class="string">'test'</span>            <span class="comment">// remains unchanged</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">  types[i].constructor = Type;</span><br><span class="line">  types[i] = [types[i].constructor, types[i] <span class="keyword">instanceof</span> Type, types[i].toString()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(types.join(<span class="string">'\n'</span>));</span><br></pre></td></tr></table></figure></p>
<p>此示例显示以下输出：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,<span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Boolean</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    [native code]</span><br><span class="line">&#125;,<span class="literal">false</span>,<span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,Mon Sep <span class="number">01</span> <span class="number">2014</span> <span class="number">16</span>:<span class="number">03</span>:<span class="number">49</span> GMT+<span class="number">0600</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,<span class="built_in">Error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,<span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,[object <span class="built_in">Math</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Number</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    [native code]</span><br><span class="line">&#125;,<span class="literal">false</span>,<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,[object <span class="built_in">Object</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,[object <span class="built_in">Object</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,/(?:)/</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,/(?:)/</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Type</span>(<span class="params"></span>) </span>&#123;&#125;,<span class="literal">false</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">String</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    [native code]</span><br><span class="line">&#125;,<span class="literal">false</span>,test</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js继承实现</title>
    <url>/blog/javascript/javascript-extends-one.html</url>
    <content><![CDATA[<h2 id="创建-js-样例："><a href="#创建-js-样例：" class="headerlink" title="创建 js 样例："></a>创建 js 样例：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 约定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有属性</span></span><br><span class="line">  <span class="keyword">var</span> val = <span class="number">1</span>; <span class="comment">// 私有基本属性</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>]; <span class="comment">// 私有引用属性</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 私有函数（引用属性）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>; <span class="comment">// 实例基本属性</span></span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>]; <span class="comment">// 实例引用属性</span></span><br><span class="line">  <span class="keyword">this</span>.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 实例函数（引用属性）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型属性</span></span><br><span class="line">Fun.prototype.val = <span class="number">1</span>; <span class="comment">// 原型基本属性</span></span><br><span class="line">Fun.prototype.arr = [<span class="number">1</span>]; <span class="comment">// 原型引用属性</span></span><br><span class="line">Fun.prototype.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 原型函数（引用属性）</span></span><br></pre></td></tr></table></figure>
<p>这样创建比较合理</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>这是实现继承最简单的方式，核心就是一句话</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super(); <span class="comment">// 核心</span></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line">sub1.val = <span class="number">2</span>;</span><br><span class="line">sub1.arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.val); <span class="comment">// 2 基本类型 不共享</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.val); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub1.arr); <span class="comment">// [1, 2] 引用 array类型 共享</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.arr); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><font color="#ff502c">拿父类实例充当子类原型对象</font>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><p>简单，易于实现</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>修改 sub1.arr 后 sub2.arr 也变了，因为来自原型对象的引用树形是所有实例共享的。<br>执行顺序：执行 sub1.arr.push(2);先对 sub1 进行属性查找，找遍了实例属性（在本例中没有实例属性），没找到，就开始顺着原型链向上找，拿到了 sub1 的原型对象，一搜身，发现有 arr 属性。于是给 arr 末尾插入了 2，所以 sub2.arr 也变了</p>
<p>创建子类实例时，无法向父类构造函数传参</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>简单原型链真够简单，可是存在 2 个致命缺点简直不能用，于是上个世纪末的 jsers 就想办法 fix 这 2 个缺陷，然后出现了借用构造函数方式</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">this</span>.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>, val); <span class="comment">// 核心</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub(<span class="number">2</span>);</span><br><span class="line">sub1.arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.val); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.val); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub1.arr); <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.arr); <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">console</span>.log(sub1.fun === sub2.fun); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h3><p><font color="#ff502c">借父类的构造函数来增强子类实例</font>，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>解决了子类实例共享父类引用属性的问题<br>创建子类实例时，可以向父类构造函数传参</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>无法实现函数复用，每个子类实例都持有一个新的 fun 函数，太多了就会影响性能</p>
<h2 id="组合继承（常用）"><a href="#组合继承（常用）" class="headerlink" title="组合继承（常用）"></a>组合继承（常用）</h2><p>目前我们的借用构造函数方式还是有问题（无法实现函数复用），没关系，接着修复，jsers 吭哧吭哧又搞出了组合继承</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只在此处声明基本属性和引用属性</span></span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  在此处声明函数</span></span><br><span class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Super.prototype.fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//Super.prototype.fun3...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>); <span class="comment">// 核心</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super(); <span class="comment">// 核心</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.fun === sub2.fun); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="核心-2"><a href="#核心-2" class="headerlink" title="核心"></a>核心</h3><p>&lt;font color=”red&gt;把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过 Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过 Sub.prototype = new Super();继承父类函数，实现函数复用</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>不存在引用属性共享问题<br>可传参<br>函数可复用</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的</p>
<h2 id="寄生组合继承（最佳方式）"><a href="#寄生组合继承（最佳方式）" class="headerlink" title="寄生组合继承（最佳方式）"></a>寄生组合继承（最佳方式）</h2><p>从名字就能看出又是对组合继承的优化</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 生孩子函数 beget：龙beget龙，凤beget凤。</span></span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只在此处声明基本属性和引用属性</span></span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  在此处声明函数</span></span><br><span class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Super.prototype.fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//Super.prototype.fun3...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>); <span class="comment">// 核心</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> proto = beget(Super.prototype); <span class="comment">// 核心</span></span><br><span class="line"><span class="built_in">console</span>.log(proto); <span class="comment">// F &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(proto.constructor);</span><br><span class="line"><span class="comment">// function Super()&#123;</span></span><br><span class="line"><span class="comment">// 只在此处声明基本属性和引用属性</span></span><br><span class="line"><span class="comment">// this.val = 1;</span></span><br><span class="line"><span class="comment">// this.arr = [1];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">proto.constructor = Sub; <span class="comment">// 核心</span></span><br><span class="line"><span class="built_in">console</span>.log(proto.constructor);</span><br><span class="line"><span class="comment">// function Sub()&#123;</span></span><br><span class="line"><span class="comment">// Super.call(this);   // 核心</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Sub.prototype = proto; <span class="comment">// 核心</span></span><br><span class="line"><span class="built_in">console</span>.log(Sub.prototype);</span><br><span class="line"><span class="comment">// Super &#123;constructor: function&#125;</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(sub.val);</span><br><span class="line"><span class="built_in">console</span>.log(sub.arr);</span><br></pre></td></tr></table></figure>
<p>construcotr 可参考：</p>
<h3 id="核心-3"><a href="#核心-3" class="headerlink" title="核心"></a>核心</h3><p>用 beget(Super.prototype);&lt;font color=”red&gt;切掉了原型对象上多余的那份父类实例属性<br>寄生组合式继承，这名字不是很贴切，和寄生式继承关系并不是特别大</p>
<h2 id="原型式"><a href="#原型式" class="headerlink" title="原型式"></a>原型式</h2><p>其实介绍完上面的完美方案就可以结束了，但从组合继承到完美方案好像有一段不小的思维跳跃，有必要把故事说清楚</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return 一个新的 function 原型复制为参数原型</span></span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到父类对象</span></span><br><span class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="comment">// 生孩子</span></span><br><span class="line"><span class="keyword">var</span> sub = beget(sup); <span class="comment">// 核心</span></span><br><span class="line"><span class="comment">// 增强</span></span><br><span class="line">sub.attr1 = <span class="number">1</span>;</span><br><span class="line">sub.attr2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//sub.attr3...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub.val); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sub.arr); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sub.attr1); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值（es6）(未完待续)</title>
    <url>/blog/es6/es6-rest.html</url>
    <content><![CDATA[<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p><code>解构赋值</code>语法是一个 Javascript 表达式，这使得可以将值从<strong>数组或属性</strong>从对象提取到不同的变量中。</p>
<a id="more"></a>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a, b, rest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* array 解构赋值 */</span></span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">[a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// 3, 4, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* object 解构赋值 */</span></span><br><span class="line">(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES7 - 试验性 (尚未标准化)</span></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token ...</span></span><br><span class="line">(&#123; a, b, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>剩余元素必须是解构赋值表达式中的最后一个元素</strong></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>对象字面量和数组字面量提供了一种简单的定义一个特定的数据组的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>结构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> [y, z] = x;</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(z); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>解构赋值的作用类似于 perl 和 Python 语言中的相似特性。</p>
<h2 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h2><h3 id="基本变量赋值"><a href="#基本变量赋值" class="headerlink" title="基本变量赋值"></a>基本变量赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>];</span><br><span class="line"><span class="keyword">var</span> [one, two, three] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// "one"</span></span><br><span class="line"><span class="built_in">console</span>.log(two); <span class="comment">// "two"</span></span><br><span class="line"><span class="built_in">console</span>.log(three); <span class="comment">// "three"</span></span><br></pre></td></tr></table></figure>
<h3 id="声明赋值分离"><a href="#声明赋值分离" class="headerlink" title="声明赋值分离"></a>声明赋值分离</h3><p>通过解构分离变量的声明，可以为一个变量赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>为了防止从数组中去一个值为 undefined 的对象，可以为这个对象设置默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">[a = <span class="number">5</span>, b = <span class="number">7</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><p>在一个解构表达式中可以交换两个变量的值。<br>没有解构值情况下，交换两个变量需要一个临时变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="解析一个从函数返回的数组"><a href="#解析一个从函数返回的数组" class="headerlink" title="解析一个从函数返回的数组"></a>解析一个从函数返回的数组</h3><p>从一个函数返回一个数组是十分常见的情况.。解构使得处理返回值为数组时更加方便。<br>在下面例子中，[1, 2] 作为函数的 f() 的输出值，可以使用解构用一句话完成解析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">[a, b] = f();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>感谢解构赋值，函数现在可以返回多个值了。尽管函数一直都可以返回一个数组，但现在这样做有更多的灵活性。</p>
<h3 id="忽略某些返回值"><a href="#忽略某些返回值" class="headerlink" title="忽略某些返回值"></a>忽略某些返回值</h3><p>你也可以忽略你不感兴趣的返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, , b] = f();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>你也可以忽略全部返回值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[, ,] = f();</span><br></pre></td></tr></table></figure>
<h3 id="将剩余数组赋值给一个变量"><a href="#将剩余数组赋值给一个变量" class="headerlink" title="将剩余数组赋值给一个变量"></a>将剩余数组赋值给一个变量</h3><p>当解构一个数组时，可以使用剩余模式，将数组剩余部分赋值给一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<p>注意：如果剩余元素右侧有一个逗号，会抛出语法错误的异常，因为剩余元素必须是数组的最后一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ...b,] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// SyntaxError: rest element may not have a trailing comma</span></span><br></pre></td></tr></table></figure>
<h2 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; p, q &#125; = o;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(q); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 用新变量名赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">p</span>: foo, <span class="attr">q</span>: bar &#125; = o;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>框架选型</title>
    <url>/blog/other/Frame-selection.html</url>
    <content><![CDATA[<h2 id="框架和库"><a href="#框架和库" class="headerlink" title="框架和库"></a>框架和库</h2><p> 库(lib)具有一下三个特点：<br> 1、是针对特定问题的解答，具有专业性<br> 2、你控制应用的流程<br> 3、被动的被调用<br> 框架(framework)具有以下三个特点：<br> 1、具有控制反转(inverse of control)的功能<br> 2、决定应用程序的声明周期<br> 3、一般来说,集成了大量的库<br> 如下图所示，框架会在特定的时间要求程序执行某段代码。框架决定了什么时候调用库，决定了什么时候要求代码去执行特定功能<br> <img src="../../images/Frame-selection1.png" alt="框架流程图"><br> 而实际上，一个库有事也可以称之为框架，而库里面继承的方法称之为库<br> 框架和库的区别不是由实际大小决定，而是有思考角度来决定。框架和库世界上可以统称为解决方案</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p> 前端开发中的解决方案主要用于解决以下7各方面的问题：<br> 1、DOM<br> 2、Communication(通信)<br> 3、Utililty(工具库)<br> 4、Templating(模版集成)<br> 5、Component(组件)<br> 6、Routing(router路由)<br> 7、architecture(架构)<br> 为什么使用外部的解决方案<br> 1、提高开发效率<br> 2、可靠性高(浏览器兼容性，测试覆盖)<br> 3、配备优良，如文档、demo及工具等<br> 4、代码设计合理、更优雅<br> 5、专业性高<br> 如果问题过于简单，或者备选框架的质量和可靠性无法保证，再或者无法满足业务需求，则不应该选择外部的框架。如果团队中已经有相关的累积，就更不需要使用了<br> 一般地，解决方案要实际开发中有以下3种使用方式：<br> 1、开放式：基于外部模块系统，并自由组合<br> 2、半开放式：基于一个定制的模块系统，内部外部解决方案共存<br> 3、封闭式：深度定制的模块系统，很少需要引入外部模块</p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>  接下来，将针对解决方案中提到的7个问题进行分别介绍，首先是DOM<br>  关于DOM，主要包括Selector(选择器)、Manipulation(DOM操作)、Event(事件)、Animation(动画)这四个部分<br>  DOM相关的解决方案主要用于提供以下操作　<br>　1、提供便利的 DOM 查询、操作、移动等操作<br>　2、提供事件绑定及事件代理支持<br>　3、提供浏览器特性检测及 UserAgent 侦测<br>　4、提供节点属性、样式、类名的操作<br>　5、保证目标平台的跨浏览器支持</p>
<h4 id="【常用方案】"><a href="#【常用方案】" class="headerlink" title="【常用方案】"></a>【常用方案】</h4><pre><code>常用的DOM解决方案有 jQuery、zepto.JS、MOOTOO.JS等
</code></pre><p>　　jQuery是曾经风靡一时的最流行的前端解决方案，jQuery特有的链式调用的方式简化了javascript的复杂操作，而且使人们不再需要关心兼容性，并提供了大量的实用方法<br>　　zepto是jQuery的精简版，针对移动端去除了大量jQuery的兼容代码，提供了简单的手势，部分API的实现方式不同<br>　　mootools源码清晰易懂，严格遵循Command-Query(命令-查询)的接口规范，没有诸如jQuery的两义性接口。还有一个不得不提的特点是，使用选择器获取的是DOM原生对象，而不是被包装过的对象。而它支持的诸多方法则是通过直接扩展DOM原生对象实现的，这也是它的争议所在<br>　　相比较而言，最稳妥的DOM解决方案是jQuery</p>
<h4 id="【专业领域】"><a href="#【专业领域】" class="headerlink" title="【专业领域】"></a>【专业领域】</h4><p>   上面的解决方案用于解决DOM一般的通用问题。随着技术的发展，DOM的专业领域出现一些小而精致的解决方案<br>　　1、手势<br>　　Hammer.JS包括了常见手势封装（Tab、Hold、Transform、Swifp）并支持自定义扩展<br>　　2、局部滚动<br>　　iscroll.JS是移动端position:fix + overflow:scroll的救星<br>　　3、高级动画<br>　　Velocity.JS可以复杂动画序列实现，不仅局限于 DOM<br>　　4、视频播放<br>　　Video.JS类似原生 video 标签的使用方式，对低级浏览器使用 flash 播放器</p>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>  关于通信，主要包括XMLHttpRequest、Form、JSONP、Socket等<br>　　通信相关的解决方案主要用于提供以下操作<br>　　1、处理与服务器的请求与相应<br>　　2、预处理请求数据与响应数据 Error/Success 的判断封装<br>　　3、多类型请求，统一接口（XMLHttpRequest1/2、JSONP、iFrame）<br>　　4、处理浏览器兼容性</p>
<h4 id="【常用方案】-1"><a href="#【常用方案】-1" class="headerlink" title="【常用方案】"></a>【常用方案】</h4><pre><code>除了jQuery等，其他常用的通信解决方案有Reqwest、qwest等
</code></pre><p>　　Reqwest支持JSONP，稳定性高，IE6+支持，CORS 跨域，Promise/A 支持<br>　　qwest代码少、支持XMLHttpRequest2、CORS 跨域、支持高级数据类型（ArrayBuffer、Blob、FormData）</p>
<h4 id="【专业领域】-1"><a href="#【专业领域】-1" class="headerlink" title="【专业领域】"></a>【专业领域】</h4><p>　　对于实时性要求较高的需求可以使用socket.io，它实时性高，支持二进制数据流，智能自动回退支持，且支持多种后端语言</p>
<h3 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h3><p> 工具包(Utililty)的主要职责包括以下：<br>　　1、提供 JavaScript 原生不提供的功能<br>　　2、包装原生方法，使其便于使用<br>　　3、异步队列及流程控制</p>
<h4 id="【常用方案】-2"><a href="#【常用方案】-2" class="headerlink" title="【常用方案】"></a>【常用方案】</h4><p> 常用的工具包解决方案有es5-shim、es6-shim、underscore、Lodash等　　<br>　　上面提到的shim，也是经常听到的一个词，翻译过来是垫片的意思。对于es5、es6等标准包括的一些新方法，由于浏览器兼容性不高，所以无法直接使用它们。这时，就需要在保证实现与规范一致的基础上，来扩展原型方法，这种做法就叫做shim。好处在于，实际上就是在使用javascript的语法，但不用去考虑低版本浏览器的兼容性问题<br>　　es5-shim 提供 ES3 环境下的 ES5 支持<br>　　es6-shim 提供 ES5 环境下的 ES6支持<br>　　underscore 提供兼容 IE6+ 的扩展功能函数<br>　　Lodash是underscore 的高性能版本，方法多为 runtime 编译出来的</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p> 模板主要包括三类：基于字符串的模板(String-based)、基于DOM的模板(DOM-based)、活动模板(Living Template)<br>　　1、基于字符串的模板(String-based)，解决方案包括(dustjs、hogan.js、dot.js)<br>   <img src="../../images/Frame-selection2.jpg" alt="模版的组成"><br>   原理如下：输入一段模板字符串，通过编译之后 ，生成一段Function，通过Function的render或类render函数渲染输入的数据data，输出模板字符串，字符串通过innerHTML或类似的方式渲染成最后的DOM结构。这类模板的问题在于通过字符串生成DOM之后就不再变化，如果在改变输入的数据data，需要重新render，重新生成一个全新的DOM结构，性能较差。但该模板可以在服务器端运行<br>   <img src="../../images/Frame-selection3.png" alt="模版的组成"><br>   2、基于DOM的模板(DOM-based)，解决方案包括(angularjs、vuejs、knockout)<br>   <img src="../../images/Frame-selection4.jpg" alt="模版的组成"><br>   原理如下：将输入的字符串模板通过innerHTML转换为一个无状态DOM树，然后遍历该节点树，去抓取关键属性或语句，来进行相关的绑定，进而变成了有状态的DOM树，最终导致DOM树会与数据模型model进行绑定。这类模板的特点是修改数据时，会使有状态的DOM树实时更新，运行时性能更好，也会保留 DOM 中的已有事件<br>   <img src="../../images/Frame-selection5.png" alt="模版的组成"><br>   3、活动模板(Living Template)，解决方案包括(RegularJS、RactiveJS、htmlbar)<br>   <img src="../../images/Frame-selection6.jpg" alt="模版的组成"><br>   原理如下：活动模板融合了字符串模板和DOM模板的技术，模板字符串string通过自定义的解析器DSL-based Parse解析成AST(抽象语法树)，通过遍历AST，使用createElement()、setAttribute()等原生DOM方法，生成DOM树，最终导致DOM树会与数据模型model进行绑定。由于其内部完全不使用innerHTML，所以安全性较高<br>   <img src="../../images/Frame-selection7.png" alt="模版的组成"></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>  组件(Component)的主要职责包括以下：<br>　　1、提供基础的 CSS 支持<br>　　2、提供常见的组件，如slider、Modal等<br>　　3、提供声明式的调用方式（类似 Bootstrap）</p>
<h4 id="【常用方案】-3"><a href="#【常用方案】-3" class="headerlink" title="【常用方案】"></a>【常用方案】</h4><p>  常用的组件解决方案有Bootstrap、Foundation等，两者具有移动端first的流式栅格系统，由sass组织，可定制UI<br>  Bootstrap封装了常用的组件，是目前最火的组件解决方案<br>　Foundation在国内知名度不高</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p> 路由在单页系统中非常重要，主要职责如下<br>　　1、监听 URL 变化，并通知注册的模块<br>　　2、通过 JavaScript 进行主动跳转<br>　　3、历史管理<br>　　4、对目标浏览器的兼容性支持<br>　　无论什么框架，在完成配置之后，内部都有如下图所示的类似的路由表。<br><img src="../../images/Frame-selection8.png" alt="模版的组成"></p>
<h4 id="【常用方案】-4"><a href="#【常用方案】-4" class="headerlink" title="【常用方案】"></a>【常用方案】</h4><pre><code>常用的路由解决方案有page.JS、Director.JS、Stateman、crossroad.JS等
</code></pre><p>　　page.JS类似 Express.Router 的路由规则的前端路由库<br>　　Director.JS可以前后端使用同一套规则定义路由<br>　　Stateman处理深层复杂路由的独立路优库<br>　　crossroad.JS老牌路由库，API 功能较为繁琐</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>所有的架构(architecture)都是一个目的，就是解耦。解耦有很多方式，可以通过事件、分层等<br>市面上，有很多架构模式，包括MVC、MVVM、MV*等<br>　　架构的职责主要包括以下：<br>　　1、提供一种范式帮助（强制）开发者进行模块解耦<br>　　2、视图与模型分离<br>　　3、容易进行单元测试<br>　　4、容易实现应用扩展<br>　　以MVVM为例，如下图所示。它包括Model(数据层或模型层)、View(视图层)、ViewModel(控制层)<br>　　Model(数据层或模型层)表示数据实体，它们用于记录应用程序的数据<br>　　View(视图层)用于展示界面，界面是数据定制的反映，它包含样式结构定义以及VM享有的声明式数据以及数数据绑定<br>ViewModel(控制层)是View与Model的粘合，它通过绑定事件与View交互并可以调用Service处理数据持久化，也可以通过数据绑定将Model的变动反映到View中<br><img src="../../images/Frame-selection9.png" alt="模版的组成"></p>
<h4 id="【SPA】"><a href="#【SPA】" class="headerlink" title="【SPA】"></a>【SPA】</h4><pre><code>要特点注意的是，MV* !== SPA(单页系统)
</code></pre><p>　　SPA应用程序的逻辑比较复杂，需要一种模式来进行解耦，但并不一定是MV*模式</p>
<p>####<br>最后推荐一个框架选型网站<a href="https://www.javascripting.com，该网站根据不同的需求的选择，给出当下流行的框架选型" target="_blank" rel="noopener">https://www.javascripting.com，该网站根据不同的需求的选择，给出当下流行的框架选型</a></p>
]]></content>
      <categories>
        <category>框架选型</category>
      </categories>
      <tags>
        <tag>框架选型</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli构建项目 npm run build后应该怎么运行在本地查看效果 (未完待续)</title>
    <url>/blog/vue/vue-run-build.html</url>
    <content><![CDATA[<h2 id="运行npm-run-build-本地查看页面效果"><a href="#运行npm-run-build-本地查看页面效果" class="headerlink" title="运行npm run build 本地查看页面效果"></a>运行npm run build 本地查看页面效果</h2><h3 id="本文以vue官方脚手架vue-cli构建的项目为例"><a href="#本文以vue官方脚手架vue-cli构建的项目为例" class="headerlink" title="本文以vue官方脚手架vue-cli构建的项目为例"></a>本文以vue官方脚手架vue-cli构建的项目为例</h3><p> 这时如果直接运行npn run build是可以运行并打包你的代码的，不会报任何异常或错误，但是你会看到你的命令行打包完成有这样一句提示：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Build complete.</span><br><span class="line">Tip: built files are meant to be served over an HTTP server.</span><br><span class="line">Opening index.html over file:<span class="comment">// won\'t work</span></span><br></pre></td></tr></table></figure></p>
<p> 运行完npm run build,打开项目中的dist目录下的index.html文件！<br> 看到index.html的 <font color="#ff502c">控制台</font>会出现一片<font color="#ff502c">404</font> 如下图：<br> <img src="../../images/run_build1.jpg" alt="run_build_console_error"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>  因为<font color="#ff502c"> config </font>目录下的<font color="#ff502c"> index.js </font>中的<font color="#ff502c"> build </font>配置的<font color="#ff502c"> assetsPublicPath </font>为<font color="#ff502c"> / </font>绝对路径,所以找不到打包以后的资源<br>  我们只要报<font color="#ff502c"> build </font>中的<font color="#ff502c"> assetsPublicPath </font>改为<font color="#ff502c"> ./ </font>就可以了，在运行一次npm run build,再打开index.html就可以在本地看了</p>
]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>css3transfrom3D</title>
    <url>/blog/css/css3-transfrom3D.html</url>
    <content><![CDATA[<h2 id="css3-3d-transfrom"><a href="#css3-3d-transfrom" class="headerlink" title="css3 3d transfrom"></a>css3 3d transfrom</h2><hr>
<p>参考 &gt; <a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/</a></p>
<h3 id="3D-变化示意图"><a href="#3D-变化示意图" class="headerlink" title="3D 变化示意图"></a>3D 变化示意图</h3><p><img src="../../images/3d_axes.png" alt="css3 3d transfrom"></p>
<h3 id="认识-rotate"><a href="#认识-rotate" class="headerlink" title="认识 rotate"></a>认识 rotate</h3><ul>
<li>rotateX() 以 x 轴为中心旋转<br><img src="../../images/rotateX.png" alt="css rotateX"></li>
<li>rotateY() 以 Y 轴为中心旋转<br><img src="../../images/rotateX.png" alt="css rotateX"></li>
<li>rotateZ() 以 Z 轴为中心旋转<br><img src="../../images/rotateX.png" alt="css rotateX"></li>
</ul>
<h3 id="perspective-属性"><a href="#perspective-属性" class="headerlink" title="perspective 属性"></a>perspective 属性</h3><p>perspective 的意思是：透视,远景<br>CSS3 3D transform 的透视点是在浏览器的前方！<br>显示器中 3D 效果元素的透视点在显示器的上方（不是后面），近似就是我们眼睛所在方位！</p>
<h3 id="translateZ-帮你寻找透视位置"><a href="#translateZ-帮你寻找透视位置" class="headerlink" title="translateZ 帮你寻找透视位置"></a>translateZ 帮你寻找透视位置</h3><p>如果说 rotateX/rotateY/rotateZ 可以帮助理解三维坐标，则 translateZ 则可以帮你理解透视位置。<br>我们都知道近大远小的道理，对于没有 rotateX 以及 rotateY 的元素，translateZ 的功能就是让元素在自己的眼前或近或远。比方说，我们设置元素 perspective 为 201 像素，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">perspective</span>: 201<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p>则其子元素，设置的 translateZ 值越小，则子元素大小越小（因为元素远去，我们眼睛看到的就会变小）;<br>可参考 &gt; <a href="http://www.zhangxinxu.com/study/201209/transform-perspective-translateZ.html" target="_blank" rel="noopener">http://www.zhangxinxu.com/study/201209/transform-perspective-translateZ.html</a></p>
<h3 id="反转效果"><a href="#反转效果" class="headerlink" title="反转效果"></a>反转效果</h3><p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flip-container</span> &#123;</span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flip-container</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.flipper</span>,</span><br><span class="line"><span class="selector-class">.flip-container</span><span class="selector-class">.hover</span> <span class="selector-class">.flipper</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flip-container</span>,</span><br><span class="line"><span class="selector-class">.front</span>,</span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">320px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">480px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flipper</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.front</span>,</span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">  <span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.front</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flip-container</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-perspective</span>: <span class="number">1000</span>;</span><br><span class="line">  <span class="attribute">-moz-perspective</span>: <span class="number">1000</span>;</span><br><span class="line">  <span class="attribute">-ms-perspective</span>: <span class="number">1000</span>;</span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">1000</span>;</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">perspective</span>(1000px);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">perspective</span>(1000px);</span><br><span class="line">  <span class="attribute">-moz-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">-ms-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flip-container</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.back</span><span class="selector-class">.flip</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flip-container</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.front</span><span class="selector-class">.flip</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(180deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flipper</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">-ms-transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">perspective</span>(1000px);</span><br><span class="line">  <span class="attribute">-moz-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">-ms-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.front</span>,</span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-backface-visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">-moz-backface-visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">-ms-backface-visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">-moz-transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">-moz-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">-o-transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">-o-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">-ms-transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">-ms-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.6s</span>;</span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.front</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">rotateY</span>(0deg);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateY</span>(-180deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateY</span>(-180deg);</span><br><span class="line">  <span class="attribute">-o-transform</span>: <span class="built_in">rotateY</span>(-180deg);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">rotateY</span>(-180deg);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(-180deg);</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flip-container"</span> <span class="attr">ontouchstart</span>=<span class="string">"this.classList.toggle('hover');"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flipper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"front"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 前面内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"back"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 背面内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中let、const和var之间的关联、区别</title>
    <url>/blog/es6/es6-let-const-var.html</url>
    <content><![CDATA[<h2 id="let、const、var-的区别（let、const-为-es5-新添加的）"><a href="#let、const、var-的区别（let、const-为-es5-新添加的）" class="headerlink" title="let、const、var 的区别（let、const 为 es5 新添加的）"></a>let、const、var 的区别（let、const 为 es5 新添加的）</h2><p>let 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。<br>var 声明的变量只能是全局或者整个函数块的。<br>const 伪常量 本身的值不能改变 d</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="let-const-暂时性死区-（temporal-dead-zone，简称-TDZ）"><a href="#let-const-暂时性死区-（temporal-dead-zone，简称-TDZ）" class="headerlink" title="let const 暂时性死区 （temporal dead zone，简称 TDZ）"></a>let const 暂时性死区 （temporal dead zone，简称 TDZ）</h3><h4 id="只要块级作用域内存在-let-命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。"><a href="#只要块级作用域内存在-let-命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。" class="headerlink" title="只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。"></a>只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">"abc"</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="必须在声明以后才能使用"><a href="#必须在声明以后才能使用" class="headerlink" title="必须在声明以后才能使用"></a>必须在声明以后才能使用</h4><p>ES6 规定暂时性死区和 let、const 语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。<br>参考 &gt; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let</a> 兼容性查询</p>
<h3 id="let-不允许被重复声明"><a href="#let-不允许被重复声明" class="headerlink" title="let 不允许被重复声明"></a>let 不允许被重复声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Uncaught SyntaxError: Identifier 'q' has already been declared</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三点注意"><a href="#三点注意" class="headerlink" title="三点注意"></a>三点注意</h3><pre><code>允许在块级作用域内声明函数。
函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
同时，函数声明还会提升到所在的块级作用域的头部。
上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
</code></pre>]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端注意事项 (未完待续)</title>
    <url>/blog/moblie/mobile-all.html</url>
    <content><![CDATA[<h2 id="一些问题阐述-未完待续"><a href="#一些问题阐述-未完待续" class="headerlink" title="一些问题阐述 (未完待续)"></a>一些问题阐述 <font color="#ff502c">(未完待续)</font></h2><ul>
<li>设备更新换代快 + 浏览器厂商不统一———— 兼容问题多</li>
<li>网络更复杂——弱网络，低端机性能差————页面打开慢</li>
<li>未知问题——坑多  <a id="more"></a>
<h2 id="meta基础知识"><a href="#meta基础知识" class="headerlink" title="meta基础知识"></a>meta基础知识</h2><ul>
<li>H5页面窗口自动调整到设备宽度，并禁止用户缩放页面<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</code></li>
<li>忽略将页面中的数字识别为电话号码<br><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</code></li>
<li>忽略Android平台中对邮箱地址的识别<br><code>&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;</code></li>
<li>当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari<br><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</code><br><code>&lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt;</code></li>
<li>viewport模板 ———— 通用</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"yes"</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"black"</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"email=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"index.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    这里开始内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="移动端如何定义字体font-family"><a href="#移动端如何定义字体font-family" class="headerlink" title="移动端如何定义字体font-family"></a>移动端如何定义字体font-family</h3><p>中文字体使用系统默认即可，英文用Helvetica<br><code>/* 移动端定义字体的代码 */</code><br><code>body{font-family:Helvetica;}</code></p>
<h3 id="移动端字体单位font-size选择px还是rem"><a href="#移动端字体单位font-size选择px还是rem" class="headerlink" title="移动端字体单位font-size选择px还是rem"></a>移动端字体单位font-size选择px还是rem</h3><p>对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可<br>对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备<br>/<em> 长宽占位 rem算法, 根据root的rem来计算各元素相对rem, 默认html 750/10 = 75px </em>/<br>可以参考 &gt; <a href="http://www.cnblogs.com/well-nice/p/5509589.html" target="_blank" rel="noopener">http://www.cnblogs.com/well-nice/p/5509589.html</a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updataHtml();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updataHtml</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> w = <span class="built_in">document</span>.documentElement.offsetWidth;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontSize = w / <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    updataHtml();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="移动端click屏幕产生200-300-ms的延迟响应"><a href="#移动端click屏幕产生200-300-ms的延迟响应" class="headerlink" title="移动端click屏幕产生200-300 ms的延迟响应"></a>移动端click屏幕产生200-300 ms的延迟响应</h3><p>在IOS safari下，大概为300毫秒，IOS 自带的双击页面放大，点击完成第一次时，会等待第二次点击，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理</p>
<ul>
<li>fastclick可以解决在手机上点击事件的300ms延迟</li>
<li>zepto的touch模块，tap事件也是为了解决在click的延迟问题  </li>
</ul>
<h3 id="触摸事件的响应顺序"><a href="#触摸事件的响应顺序" class="headerlink" title="触摸事件的响应顺序"></a>触摸事件的响应顺序</h3><p><code>ontouchstart</code><br><code>ontouchmove</code><br><code>ontouchend</code><br><code>onclick</code><br>解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应</p>
<h3 id="什么是Retina-显示屏，带来了什么问题"><a href="#什么是Retina-显示屏，带来了什么问题" class="headerlink" title="什么是Retina 显示屏，带来了什么问题"></a>什么是Retina 显示屏，带来了什么问题</h3><p>retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个<br>在高清显示屏中的位图被放大，图片会变得模糊，<font color="#ff502c">因此移动端的视觉稿通常会设计为传统PC的2倍</font><br>设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//例如图片宽高为：200px*200px，那么写法如下</span><br><span class="line"><span class="selector-class">.css</span>&#123;<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">background-size</span>:<span class="number">100px</span> <span class="number">100px</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css</span>&#123;<span class="attribute">font-size</span>:<span class="number">20px</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉"><a href="#ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉" class="headerlink" title="ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉"></a>ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉</h3><p>ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>&#123;<span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0,0,0,0;)&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="部分android系统中元素被点击时产生的边框怎么去掉"><a href="#部分android系统中元素被点击时产生的边框怎么去掉" class="headerlink" title="部分android系统中元素被点击时产生的边框怎么去掉"></a>部分android系统中元素被点击时产生的边框怎么去掉</h3><p>android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0,0,0,0;)</span><br><span class="line">    -webkit-user-modify:read-write-plaintext-only; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>兼容性不是很好</p>
<h3 id="winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉、"><a href="#winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉、" class="headerlink" title="winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉、"></a>winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉、</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-tap-highlight"</span> <span class="attr">content</span>=<span class="string">"no"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="webkit表单元素的默认外观怎么重置"><a href="#webkit表单元素的默认外观怎么重置" class="headerlink" title="webkit表单元素的默认外观怎么重置"></a>webkit表单元素的默认外观怎么重置</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css</span>&#123;<span class="attribute">-webkit-apperarance</span>:none&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#ff502c">把各个浏览器表单的默认样式重置</font></p>
<h3 id="伪元素改变number类型input框的默认样式"><a href="#伪元素改变number类型input框的默认样式" class="headerlink" title="伪元素改变number类型input框的默认样式"></a>伪元素改变number类型input框的默认样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=number]</span><span class="selector-pseudo">::-webkit-textfield-decoration-container</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=number]</span><span class="selector-pseudo">::-webkit-inner-spin-button</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=number]</span><span class="selector-pseudo">::-webkit-outer-spin-button</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>大家好</title>
    <url>/blog/other/Hello.html</url>
    <content><![CDATA[<h3 id="每周两篇bolg-最后整理合并，分类，总结"><a href="#每周两篇bolg-最后整理合并，分类，总结" class="headerlink" title="每周两篇bolg,最后整理合并，分类，总结"></a>每周两篇bolg,最后整理合并，分类，总结</h3>]]></content>
  </entry>
</search>
