<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript了解JS中的位运算符</title>
    <url>/blog/javascript/docs/bitwise-operators.html</url>
    <content><![CDATA[<h2 id="JavaScript中的按位操作符"><a href="#JavaScript中的按位操作符" class="headerlink" title="JavaScript中的按位操作符"></a>JavaScript中的按位操作符</h2><p>JavaScript提供了几种运算符，可以对一些简单的值进行基本操作，比如<code>算术运算符</code>、<code>赋值运算符</code>、<code>逻辑运算符</code>、<code>按位操作符</code>等。其他的操作运算符都是经常用到的，比如算数运算符的<code>+、-、*、/</code>；赋值运算符的<code>=、+=、-=</code>；逻辑运算符的<code>||、&amp;&amp;、!</code>等等。但是<code>按位操作符</code>操作符是比较来说不常用的，很多人也不知道都有什么<code>按位操作符</code>?</p>
<p>本章内容大致分为：</p>
<ul>
<li>有哪些<code>按位操作符</code>?简单的应用</li>
<li>在日常开发是<code>按位操作符</code>可以做哪些事情？</li>
</ul>
<p>会一步一步从了解<code>按位操作符</code>到能把它运用到项目中来，以使自己的编码更简洁、更方便。</p>
<h2 id="简单了解按位操作符"><a href="#简单了解按位操作符" class="headerlink" title="简单了解按位操作符"></a>简单了解按位操作符</h2><p>首先来了解一下<code>按位操作符</code>的定义是什么： <strong><code>按位操作符（Bitwise operators） 将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值</code></strong>。其实<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">mdn 中 按位操作符</a>讲的有点晦涩，不太好理解通过对下面的介绍可能会好理解一点。</p>
<p>JavaScript内部<code>Number</code>是以<code>64位浮点数</code>的形式储存，但是做位运算的时候，是以<code>32位带符号的整数</code>进行运算的，并且返回值也是一个<code>32位带符号的整数</code>。</p>
<p>JavaScript中有七中按位操作符，如下表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">用法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">按位与（ AND）</td>
<td style="text-align:center">a &amp; b</td>
<td style="text-align:center">对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。</td>
</tr>
<tr>
<td style="text-align:center">按位或（OR）</td>
<td style="text-align:center">a 丨 b</td>
<td style="text-align:center">对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。</td>
</tr>
<tr>
<td style="text-align:center">按位异或（XOR）</td>
<td style="text-align:center">a ^ b</td>
<td style="text-align:center">对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。</td>
</tr>
<tr>
<td style="text-align:center">按位非（NOT）</td>
<td style="text-align:center">~ a</td>
<td style="text-align:center">反转操作数的比特位，即0变成1，1变成0。</td>
</tr>
<tr>
<td style="text-align:center">左移（Left shift）</td>
<td style="text-align:center">a &lt;&lt; b</td>
<td style="text-align:center">将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用0填充。</td>
</tr>
<tr>
<td style="text-align:center">有符号右移</td>
<td style="text-align:center">a &gt;&gt; b</td>
<td style="text-align:center">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。</td>
</tr>
<tr>
<td style="text-align:center">无符号右移</td>
<td style="text-align:center">a &gt;&gt;&gt; b</td>
<td style="text-align:center">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。</td>
</tr>
</tbody>
</table>
<h2 id="简单了解二进制"><a href="#简单了解二进制" class="headerlink" title="简单了解二进制"></a>简单了解二进制</h2><p>已经知道计算机中，所有数据最终都是使用二进制数表达。<br><code>10进制</code>转换为<code>2进制</code>or<code>16进制</code>如下图所示：</p>
<p><img src="../../../images/javascript/btye-1.webp" alt="二进制"></p>
<p><strong>原码</strong>: <code>一个整数，按照绝对值大小转换成的二进制数，称为原码。</code><br>其实就是一个数值的二进制比特位码，比如说<code>5</code>转换成二制是<code>101</code>, <code>Number/Int</code>类型的数占用<code>4字节(32位)</code>，它们为会默认填充<code>0</code>,所以<code>5</code>的二进制位<code>00000000 00000000 00000000 00000101</code>。</p>
<p><strong>反码</strong>: <code>将二进制数按位取反，所得的新二进制数称为原二进制数的反码。</code><br>取反操作指：原为<code>1</code>取反为<code>0</code>；原为<code>0</code>取反为<code>1</code>.<br>比如：将<code>00000000 00000000 00000000 00000101</code>每一位取反，得<code>11111111 11111111 11111111 11111010</code>。<br>称：<code>11111111 11111111 11111111 11111010</code>是 <code>00000000 00000000 00000000 00000101</code> 的反码。<br>反码是相互的，所以也可称：<br><code>11111111 11111111 11111111 11111010</code> 和<code>00000000 00000000 00000000 00000101</code> 互为反码。</p>
<p><strong>补码</strong>：<code>反码加1称为补码。</code><br>也就是说，要得到一个数的<code>补码</code>，先得到<code>反码</code>，然后将<code>反码加上1</code>，所得数称为<code>补码</code>。<br>比如：<code>00000000 00000000 00000000 00000101</code>的反码是：<code>11111111 11111111 11111111 11111010</code>。<br>那么，补码为：<br><code>11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011</code><br>所以，-5 在计算机中表达为：<code>11111111 11111111 11111111 11111011</code>。<br>转换为十六进制：<code>0xFFFFFFFB</code>。</p>
<p><strong>负值在二进制中</strong>： 二进制为了区分<code>正数</code>和<code>负数</code>，在<code>最高位</code>拿出来当作<code>符号位</code>，<code>0表示正数，1表示负数</code>。</p>
<p>比如我们就拿<code>-1</code>来做一下分析：</p>
<ul>
<li><code>1</code>的原码为：<code>00000000 00000000 00000000 00000001</code></li>
<li><code>1</code>的反码为：<code>11111111 11111111 11111111 11111110</code></li>
<li><code>1</code>的补码为：<code>11111111 11111111 11111111 11111110 + 1 = 11111111 11111111 11111111 11111111</code>，也就是<code>-1</code>的二进制</li>
</ul>
<h2 id="JavaScript中七中操作符"><a href="#JavaScript中七中操作符" class="headerlink" title="JavaScript中七中操作符"></a>JavaScript中七中操作符</h2><h3 id="按位与（-AND）-amp"><a href="#按位与（-AND）-amp" class="headerlink" title="按位与（ AND）&amp;"></a>按位与（ AND）<code>&amp;</code></h3><p><code>&amp;</code>以特定的方式组合操作<code>二进制</code>数中对应的位，如果对应的位都为<code>1</code>，那么结果就是<code>1</code>， 如果任意一个位是<code>0</code> 则结果就是<code>0</code>。请看下面示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1的二进制表示为: 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 2的二进制表示为: 00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 3的二进制表示为: 00000000 00000000 00000000 00000011</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>&amp;<span class="number">2</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>&amp;<span class="number">3</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><strong>1&amp;2对比过程</strong>: 因为<code>1</code>和<code>2</code>它们的比特位没有相同的位置都为<code>1</code>，所以会返回一个<code>00000000 00000000 00000000 00000000</code>的<code>32位二进制</code>，转换位10进制就是<code>0</code><br><strong>1&amp;3对比过程</strong>: 因为<code>1</code>和<code>3</code>它们的最低位比特位都为<code>1</code>，所以会返回一个<code>00000000 00000000 00000000 00000001</code>的<code>32位二进制</code>，转换位10进制就是<code>1</code></p>
<h3 id="按位或-OR"><a href="#按位或-OR" class="headerlink" title="按位或(OR)|"></a>按位或(OR)<code>|</code></h3><p><code>|</code> 运算符跟 <code>&amp;</code> 的区别在于如果对应的位中<code>任一个</code>比特位为<code>1</code> 那么结果就是<code>1</code>。请看下面示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1的二进制表示为: 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 2的二进制表示为: 00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 3的二进制表示为: 00000000 00000000 00000000 00000011</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>|<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>|<span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>1|2对比过程</strong>: 因为<code>1</code>和<code>2</code>它们的比特位为<code>1</code>的并集就是<code>00000000 00000000 00000000 00000011</code>的<code>32位二进制</code>，转换位10进制就是<code>3</code><br><strong>1|3对比过程</strong>: 因为<code>1</code>和<code>3</code>它们的比特位为<code>1</code>的并集就是<code>00000000 00000000 00000000 00000011</code>的<code>32位二进制</code>，转换位10进制就是<code>3</code></p>
<h3 id="按位异或-XOR"><a href="#按位异或-XOR" class="headerlink" title="按位异或(XOR)^"></a>按位异或(XOR)<code>^</code></h3><p><code>^</code>如果对应两个操作位有且仅有一个<code>1</code>时结果为<code>1</code>，其他都是<code>0</code>。请看下面示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1的二进制表示为: 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 2的二进制表示为: 00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 3的二进制表示为: 00000000 00000000 00000000 00000011</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>^<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>^<span class="number">3</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>1^2对比过程</strong>: 因为<code>1</code>和<code>2</code>它们的比特位中只有其中一个为<code>1</code>的组合出来是<code>00000000 00000000 00000000 00000011</code>的<code>32位二进制</code>，转换位10进制就是<code>3</code><br><strong>1^3对比过程</strong>: 因为<code>1</code>和<code>3</code>它们的比特位中只有其中一个为<code>1</code>的组合出来<code>00000000 00000000 00000000 00000010</code>的<code>32位二进制</code>，转换位10进制就是<code>2</code></p>
<h3 id="按位非-NOT"><a href="#按位非-NOT" class="headerlink" title="按位非(NOT)~"></a>按位非(NOT)<code>~</code></h3><p><code>~</code>运算符是对位求反，<code>1</code>变<code>0</code>, <code>0</code>变<code>1</code>，也就是求二进制的反码。请看下面示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1的二进制表示为: 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">1</span>) <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>1</code>的二进制反码表示为<code>11111111 11111111 11111111 11111110</code>.</li>
<li>因为<code>1</code>的<code>反码`</code>最高位为1<code>表示它是</code>负数<code>，</code>负数<code>又是以</code>补码<code>形式存储的，所以我们要反推一下</code>补码`</li>
<li>那么<code>1</code>的<code>反码 - 1</code>为<code>11111111 11111111 11111111 11111101</code>，我们要再把得到的<code>反码 - 1</code>再取<code>反码</code>为<code>00000000 00000000 00000000 00000010</code>,同时要加上一个负号<code>-</code>，最后转换为<code>10进制</code>就是<code>-2</code></li>
</ul>
<p>如果不理解<code>反码</code>、<code>原码</code>、<code>补码</code>可以看本篇文章上面的章节。</p>
<h3 id="左移（Left-shift）-lt-lt"><a href="#左移（Left-shift）-lt-lt" class="headerlink" title="左移（Left shift）&lt;&lt;"></a>左移（Left shift）<code>&lt;&lt;</code></h3><p><code>&lt;&lt;运算符</code>使指定值的二进制数<code>所有位都左移指定次数</code>，其移动规则：<code>丢弃高位</code>，低位<code>补0</code>即按二进制形式把所有的数字向<code>左移动对应的位数，高位移出(舍弃)，低位的空位补零</code>。请看下面示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1的二进制表示为: 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 2的二进制表示为: 00000000 00000000 00000000 00000010</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="有符号右移-gt-gt"><a href="#有符号右移-gt-gt" class="headerlink" title="有符号右移 &gt;&gt;"></a>有符号右移 <code>&gt;&gt;</code></h3><p><code>&gt;&gt;该操作符</code>会将指定操作数的二进制位<code>向右移动指定的位数</code>。<code>向右被移出的位被丢弃，拷贝最左侧的位以填充左侧</code>。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“<code>符号传播</code>”。请看下面示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1的二进制表示为: 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 2的二进制表示为: 00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 3的二进制表示为: 00000000 00000000 00000000 00000011</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> &gt;&gt; <span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移&gt;&gt;&gt;"></a>无符号右移<code>&gt;&gt;&gt;</code></h3><p><code>&gt;&gt;&gt;该操作符</code>会将第一个操作数向右移动指定的位数。<code>向右被移出的位被丢弃，左侧用0填充</code>。因为符号位变成了 0，所以结果<code>总是非负</code>的。（译注：即便<code>右移 0 个比特，结果也是非负的</code>。）<br>对于非负数，有符号右移和无符号右移总是返回相同的结果。例如， <code>9 &gt;&gt;&gt; 2</code>得到 <code>2</code> 和 <code>9 &gt;&gt; 2</code> 相同。</p>
<h2 id="位操作符使用技巧"><a href="#位操作符使用技巧" class="headerlink" title="位操作符使用技巧"></a>位操作符使用技巧</h2><h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><p>通过<code>按位与（ AND） &amp;</code>来判断奇偶性 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span> (<span class="params">int</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (int &amp; <span class="number">1</span>) === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span> (<span class="params">int</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (int &amp; <span class="number">1</span>) === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isOdd(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isOdd(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isEven(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isEven(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>我们就拿<code>1 &amp; 1</code>和<code>1 &amp; 2</code>来分析它是什么执行对比的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1的二进制表示为: 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 2的二进制表示为: 00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 3的二进制表示为: 00000000 00000000 00000000 00000011</span></span><br><span class="line">(<span class="number">1</span> &amp; <span class="number">3</span>) === <span class="number">1</span> <span class="literal">true</span></span><br><span class="line">(<span class="number">1</span> &amp; <span class="number">2</span>) === <span class="number">0</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>(1 &amp; 1)</code>:  <code>1</code>的二进制简写为<code>01</code>，<code>3</code>的二进制简写为<code>11</code>，因为它们的<code>最低位</code>都为<code>1</code>，所以<code>按位与（ AND） &amp;</code>的结果就是<code>00000000 00000000 00000000 00000001</code>，最后转换为10进制<code>1</code>.<br><code>(1 &amp; 2)</code>: <code>1</code>的二进制简写为<code>01</code>，<code>2</code>的二进制简写为<code>10</code>，它们没有相同比特位为<code>1</code>，所以<code>按位与（ AND） &amp;</code>的结果就是<code>00000000 00000000 00000000 00000000</code>，最后转换为10进制<code>0</code>.</p>
<h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><p><code>&gt;&gt;，&lt;&lt;，|，~~</code>取整：它们无论是正数还是负数都不会受到影响，同时它们都是向下取整。<br><code>&gt;&gt;&gt;</code>取整：<code>&gt;&gt;&gt;</code>它只能对正数向下取整。</p>
<h4 id="gt-gt-，-lt-lt-，-，"><a href="#gt-gt-，-lt-lt-，-，" class="headerlink" title="&gt;&gt;，&lt;&lt;，|，~~"></a>&gt;&gt;，&lt;&lt;，|，~~</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">4.5</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">-4.5</span>) <span class="comment">// -5</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">4.5</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">-4.5</span>) <span class="comment">// -4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 &gt;&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">24.6</span> &gt;&gt; <span class="number">0</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">24.3</span> &gt;&gt; <span class="number">0</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-24.6</span> &gt;&gt; <span class="number">0</span>) <span class="comment">// -24 向上取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-24.3</span> &gt;&gt; <span class="number">0</span>) <span class="comment">// -24 向上取整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 &lt;&lt;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">24.6</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">24.3</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-24.6</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// -24 向上取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-24.3</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// -24 向上取整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 |</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">24.6</span> | <span class="number">0</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">24.3</span> | <span class="number">0</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-24.6</span> | <span class="number">0</span>) <span class="comment">// -24 向上取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-24.3</span> | <span class="number">0</span>) <span class="comment">// -24 向上取整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">24.6</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">24.3</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">-24.6</span>) <span class="comment">// -24 向上取整</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">-24.3</span>) <span class="comment">// -24 向上取整</span></span><br></pre></td></tr></table></figure>
<p><code>&gt;&gt;，&lt;&lt;，|</code>无论是正负数都会向下取整。</p>
<h4 id="gt-gt-gt-，"><a href="#gt-gt-gt-，" class="headerlink" title="&gt;&gt;&gt;，~~"></a><code>&gt;&gt;&gt;，~~</code></h4><p><strong>&gt;&gt;&gt;</strong>: 它只能对<code>正数</code>做向下取整，不能用于对<code>负数</code>取整。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用 &gt;&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">24.6</span> &gt;&gt;&gt; <span class="number">0</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">24.3</span> &gt;&gt;&gt; <span class="number">0</span>) <span class="comment">// 24 向下取整</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-24.6</span> &gt;&gt;&gt; <span class="number">0</span>) <span class="comment">// 4294967272</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-24.3</span> &gt;&gt;&gt; <span class="number">0</span>) <span class="comment">// 4294967272</span></span><br></pre></td></tr></table></figure>
<h3 id="交换值"><a href="#交换值" class="headerlink" title="交换值"></a>交换值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1的二进制表示为: 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 2的二进制表示为: 00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 3的二进制表示为: 00000000 00000000 00000000 00000011</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">a = a ^ b; <span class="comment">// 00000000 00000000 00000000 00000011 为 3 a = 3</span></span><br><span class="line">b = a ^ b; <span class="comment">// 00000000 00000000 00000000 00000001 为 1 b = 1</span></span><br><span class="line">a = a ^ b; <span class="comment">// 00000000 00000000 00000000 00000010 为 2 a = 2</span></span><br></pre></td></tr></table></figure>
<p>我们简单分析一下执行过程：<br><code>a = a ^ b</code>: 现在<code>a = 1; b = 2</code>我们知道<code>1</code>和<code>2</code>的二进制，通过<code>^(相同的比特位只有一个为1，就会返回1，否则返回0)</code>计算得出<code>00000000 00000000 00000000 00000011</code>，转换为<code>10进制</code>的话就是<code>3</code>，所以现在<code>a = 3</code>。<br><code>b = a ^ b</code>: 现在<code>a = 3; b = 2</code>我们知道<code>2</code>和<code>3</code>的二进制，通过<code>^(相同的比特位只有一个为1，就会返回1，否则返回0)</code>计算得出<code>00000000 00000000 00000000 00000001</code>，转换为<code>10进制</code>的话就是<code>1</code>，所以现在<code>b = 1</code>。<br><code>a = a ^ b</code>: 现在<code>a = 3; b = 1</code>我们知道<code>1</code>和<code>3</code>的二进制，通过<code>^(相同的比特位只有一个为1，就会返回1，否则返回0)</code>计算得出<code>00000000 00000000 00000000 00000010</code>，转换为<code>10进制</code>的话就是<code>2</code>，所以现在<code>a = 2</code>。<br>最后就是<code>a = 2; b = 1</code></p>
<h3 id="HEX-lt-gt-RGB-互转"><a href="#HEX-lt-gt-RGB-互转" class="headerlink" title="HEX &lt;=&gt; RGB 互转"></a>HEX &lt;=&gt; RGB 互转</h3><h4 id="颜色转换：RGB转为十六进制"><a href="#颜色转换：RGB转为十六进制" class="headerlink" title="颜色转换：RGB转为十六进制"></a>颜色转换：RGB转为十六进制</h4><p><code>左移位（&lt;）运算符</code>的一个非常有用的应用程序是将颜色从<code>RGB</code>表示转换为<code>十六进制</code>表示。<br><code>RGB颜色</code>的每个组件的<code>颜色值</code>在<code>0-255</code>之间。简单地说，每个颜色值可以用<code>8位</code>完美地表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> =&gt; <span class="number">0b00000000</span> (<span class="number">2</span>进制) =&gt; <span class="number">0x00</span> (<span class="number">16</span>进制)</span><br><span class="line"><span class="number">255</span> =&gt; <span class="number">0b11111111</span> (<span class="number">2</span>进制) =&gt; <span class="number">0xff</span> (<span class="number">16</span>进制)</span><br></pre></td></tr></table></figure>
<p>因此，颜色本身可以完美地用<code>24位</code>来表示（<code>红色、绿色和蓝色分量各8位</code>）。从<code>右边</code>开始的前<code>8位</code>表示<code>蓝色</code>分量，接下来的<code>8位</code>表示<code>绿色</code>分量，之后的<code>8位</code>表示<code>红色</code>分量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(binary) =&gt; <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span></span><br><span class="line">(red) =&gt; <span class="number">11111111</span> =&gt; <span class="function"><span class="params">ff</span> =&gt;</span> <span class="number">255</span></span><br><span class="line">(green) =&gt; <span class="number">00100011</span> =&gt; <span class="number">23</span> =&gt; <span class="number">35</span></span><br><span class="line">(blue) =&gt; <span class="number">00010100</span> =&gt; <span class="number">14</span> =&gt; <span class="number">20</span></span><br><span class="line">(hex) =&gt; ff2314</span><br></pre></td></tr></table></figure>
<p>既然我们已经了解了如何将<code>颜色表示为24位序列</code>，那么让我们来看看如何从颜色的各个组件的值组成<code>颜色的24位</code>。假设我们有一个用<code>RGB（255、35、20）</code>表示的颜色。以下是我们如何组合这些位：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(red) =&gt; <span class="number">255</span> =&gt; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">(green) =&gt;  <span class="number">35</span> =&gt; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00100011</span></span><br><span class="line">(blue) =&gt;  <span class="number">20</span> =&gt; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00010100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们使用`&lt;&lt;` 左移动符把 red 的二进制 向高位移动 16位</span></span><br><span class="line">(red) =&gt; <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="comment">// 我们使用`&lt;&lt;` 左移动符把 green 的二进制 向高位移动 8位</span></span><br><span class="line">(green) =&gt; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00100011</span> <span class="number">00000000</span></span><br><span class="line"><span class="comment">// blue不动</span></span><br><span class="line">(blue) =&gt;  <span class="number">20</span> =&gt; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00010100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让后我们再通过`|按位或（OR）`合并 red | green | blue.  执行结果如下：</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">| <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00100011</span> <span class="number">00000000</span></span><br><span class="line">| <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00010100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到最终的二进制，再通过toString(16)转为16进制</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span></span><br></pre></td></tr></table></figure>
<p>下面我们封装一个函数来实现上面的伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RGBToHex</span>(<span class="params">[red = <span class="number">0</span>, green = <span class="number">0</span>, blue = <span class="number">0</span>] = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`#<span class="subst">$&#123;(red &lt;&lt; <span class="number">16</span> | green &lt;&lt; <span class="number">8</span> | blue).toString(<span class="number">16</span>)&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">RGBToHex([<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]) <span class="comment">// #ffffff</span></span><br><span class="line">RGBToHex([<span class="number">255</span>, <span class="number">21</span>, <span class="number">32</span>]) <span class="comment">// #ff1520</span></span><br></pre></td></tr></table></figure>
<h4 id="颜色转换：十六进制转为RGB"><a href="#颜色转换：十六进制转为RGB" class="headerlink" title="颜色转换：十六进制转为RGB"></a>颜色转换：十六进制转为RGB</h4><p>简单来说就是通过<code>右移（&gt;&gt;）运算符</code>逆推还原原来的颜色值，下面用伪代码大致整理一下思路。<br><code>有符号右移（&gt;&gt;）运算符</code>的一个非常好的应用是从颜色中<code>提取RGB颜色值</code>。当颜色以RGB表示时，很容易区分<code>红色</code>、<code>绿色</code>和<code>蓝色</code>颜色分量值。但是，对于以十六进制表示的颜色，这将花费更多的精力。</p>
<p>假设我们有一个用<code>十六进制</code>表示法<code>#ff2314</code>表示的颜色。下面是颜色的储存为<code>二进制</code>的编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(color) =&gt; ff2314 (hexadecimal) =&gt; <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span> (binary)</span><br><span class="line"><span class="comment">// 32-bit representation of color</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span></span><br></pre></td></tr></table></figure>
<p>为了获得单个部分，我们将根据需要将颜色位<code>按8的倍数右移</code>，直到从右边得到目标组件位作为<code>前8位</code>。由于颜色的32位中的符号标志位是0，因此我们可以安全地使用符号传播<code>右移位（&gt;&gt;）运算符</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">color =&gt; <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span></span><br><span class="line"><span class="comment">// 我们使用`&gt;&gt;` 右移动符把 red 的二进制 向低位移动 16位</span></span><br><span class="line">red =&gt; color &gt;&gt; <span class="number">16</span></span><br><span class="line">    =&gt; <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span> &gt;&gt; <span class="number">16</span></span><br><span class="line">    =&gt; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line"><span class="comment">// 我们使用`&gt;&gt;` 右移动符把 green 的二进制 向低位移动 8位</span></span><br><span class="line">green =&gt; color &gt;&gt; <span class="number">8</span></span><br><span class="line">    =&gt; <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span> &gt;&gt; <span class="number">8</span></span><br><span class="line">    =&gt; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span></span><br><span class="line"><span class="comment">// blue不需要位移</span></span><br><span class="line">blue =&gt; color &gt;&gt; <span class="number">0</span> =&gt; color</span><br><span class="line">    =&gt; <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span></span><br></pre></td></tr></table></figure>
<p>现在我们将目标颜色位作为<code>右前8位</code>，我们需要一种方法来屏蔽除<code>前8位之外</code>的所有其他位。这使我们回到和<code>（&amp;）运算符</code>。请记住，<code>&amp;运算符</code>可用于确保关闭某些位。<br>让我们从创建所需的位掩码开始。就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mask =&gt; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">  =&gt; <span class="number">0b11111111</span> (binary)</span><br><span class="line">  =&gt; <span class="number">0xff</span> (hexadecimal)</span><br></pre></td></tr></table></figure>
<p>准备好位掩码后，我们可以对上<code>一次右移</code>操作的每个<code>结果执行与（&amp;）操作</code>，使用位掩码提取目标颜色。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">color =&gt; <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上一步 color &gt;&gt; 16 执行结果为 00000000 00000000 00000000 11111111</span></span><br><span class="line"><span class="comment">// 在(color &gt;&gt; 16)执行的结果上 再执行 00000000 00000000 00000000 11111111 &amp; 0xff (00000000 00000000 00000000 11111111)  得到 (00000000 00000000 00000000 11111111)</span></span><br><span class="line">red =&gt; color &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span></span><br><span class="line">    =&gt;   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">    =&gt; &amp; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">    =&gt; = <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">    =&gt;   <span class="number">255</span> (decimal) <span class="comment">// 转为10进制</span></span><br><span class="line"><span class="comment">// 在上一步 color &gt;&gt; 8 执行结果为 00000000 00000000 11111111 00100011</span></span><br><span class="line"><span class="comment">// 在(color &gt;&gt; 8)执行的结果上 再执行 00000000 00000000 11111111 00100011 &amp; 0xff (00000000 00000000 00000000 11111111) 得到 (00000000 00000000 00000000 00100011)</span></span><br><span class="line">green =&gt; color &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span></span><br><span class="line">    =&gt;   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span></span><br><span class="line">    =&gt; &amp; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">    =&gt; = <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00100011</span></span><br><span class="line">    =&gt;   <span class="number">35</span> (decimal) <span class="comment">// 转为10进制</span></span><br><span class="line"><span class="comment">// 直接执行 00000000 11111111 00100011 00010100 &amp; 0xff (00000000 00000000 00000000 11111111) 得到 (00000000 00000000 00000000 00010100)</span></span><br><span class="line"> blue =&gt; color &amp; <span class="number">0xff</span></span><br><span class="line">    =&gt;   <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00100011</span> <span class="number">00010100</span></span><br><span class="line">    =&gt; &amp; <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">    =&gt; = <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00010100</span></span><br><span class="line">    =&gt;   <span class="number">20</span> (decimal) <span class="comment">// 转为10进制</span></span><br></pre></td></tr></table></figure>
<p>基于上面的伪代码，下面下面实现一个简单的函数，它会把传入的<code>hex 16进制颜色值</code>转换为<code>rgb颜色值组</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hex 16进制转换 =》 rgb 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HEXToRGB</span> (<span class="params">hex</span>) </span>&#123;</span><br><span class="line">  hex = hex.replace(<span class="regexp">/^#?([0-9a-f]&#123;6&#125;)$/i</span>, <span class="string">'$1'</span>);</span><br><span class="line">  hex = <span class="built_in">Number</span>(<span class="string">`0x<span class="subst">$&#123;hex&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    red: hex &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>,</span><br><span class="line">    green: hex &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>,</span><br><span class="line">    blue: hex &amp; <span class="number">0xff</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">HEXToRGB(<span class="string">'#ffffff'</span>) <span class="comment">// &#123;red: 255, green: 255, blue: 255&#125;</span></span><br><span class="line">HEXToRGB(<span class="string">'#000000'</span>) <span class="comment">// &#123;red: 0, green: 0, blue: 0&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为一道面试题引申出来的<code>JavaScript</code>中的按位操作符，才有了这篇文章记录JavaScript中的<code>按位操作符</code>和它们具体用来做什么。当然这个只是最简单的使用，在通信、加密中它们得到更多的应用。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中交换变量a/b的多种方法</title>
    <url>/blog/interview-question/javascript/javascirpt-exchange-variable.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>问题是有一个变量<code>a</code>、<code>b</code>要怎么交换它们的值，有多少种方法，那种方法比较好比较省时省力。我们尽量使用最少的代码和内存空间来实现变量的交换。<br>下面我们分别使用五种类型的方法实现变量交换，它们都有自己的优缺点，五种方法如下：</p>
<ul>
<li><code>借助临时变量</code></li>
<li><code>ES实现方法</code></li>
<li><code>通过加减法</code></li>
<li><code>按位异或</code></li>
<li><code>利用逗号操作符</code></li>
</ul>
<h2 id="借助临时变量"><a href="#借助临时变量" class="headerlink" title="借助临时变量"></a>借助临时变量</h2><p>首先来一个最简单的实现方式代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="comment">// 临时变量</span></span><br><span class="line"><span class="keyword">var</span> temporary = b;</span><br><span class="line">b = a;</span><br><span class="line">a = temporary;</span><br><span class="line">temporary = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这个我们多使用了一个变量<code>temporary</code>，这种方法也是我们经常用的。如果我们不声明一个临时变量怎么实现呢。</p>
<p><strong>本方法优点是实现简单，缺点是多声明一个变量，在执行期间多占用内存，并且要记得在最后执行完成记得清空变量</strong></p>
<h2 id="ES-实现方法"><a href="#ES-实现方法" class="headerlink" title="ES 实现方法"></a>ES 实现方法</h2><p>我们可以使用<code>ES6</code>中的<code>解构</code>特性，这个应该也是比较常用的方法。但是兼容性没有上面的方法好，但是在<code>Vue</code>、<code>React</code>中经常用到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line">[a, b] = [b, a];</span><br></pre></td></tr></table></figure>
<p><strong>本方法优点代码简洁并且没有声明多余变量，缺点是兼容性并不太理想</strong></p>
<p>如果不使用<code>ES6</code>中的特性，实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line">a = &#123; <span class="attr">a</span>: b, <span class="attr">b</span>: a &#125;;</span><br><span class="line">b = a.b;</span><br><span class="line">a = a.a;</span><br></pre></td></tr></table></figure>
<p>我们通过把<code>a</code>设置为一个对象用来保存<code>a</code>、<code>b</code>的值，然后再分别取出。<strong>通过把对象替换为数组也是可以实现</strong>，这里就不做演示了。</p>
<p><strong>本方法优点并且没有声明多余变量，缺点是改变变量的类型在执行期间多使用内存</strong></p>
<h2 id="通过加减法"><a href="#通过加减法" class="headerlink" title="通过加减法"></a>通过加减法</h2><p>通过加减法也是可以实现的，首先是通过<code>加法</code>实现，代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 初始值 a</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>; <span class="comment">// 初始值 b</span></span><br><span class="line">a = a + b; <span class="comment">// a 的值为 a(100) + b(200) = 300</span></span><br><span class="line">b = a - b; <span class="comment">// b 为 a(300) - b(200) 为 100</span></span><br><span class="line">a = a - b; <span class="comment">// 因为在这次执行的时候b已经为上面的值100 a 为 a(300) - b(100) 为 200</span></span><br></pre></td></tr></table></figure>
<p>但是这种方式可能会导致数字溢出，所以我们可以通过<code>减法</code>来实现更安全。下面看代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 初始值 a</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>; <span class="comment">// 初始值 b</span></span><br><span class="line">a = a - b; <span class="comment">// a 的值为 a(100) - b(200) = -100</span></span><br><span class="line">b = b + a; <span class="comment">// b 为 a(-100) + b(200) 为 100</span></span><br><span class="line">a = b - a; <span class="comment">// 因为在这次执行的时候b已经为上面的值100 a 为 b(100) - a(-100) 为 200</span></span><br></pre></td></tr></table></figure>
<p><strong>加法的实现更好理解，但是存在整数溢出的风险；减法的实现不太好理解，但是并不会存在整数溢出的风险</strong></p>
<h2 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h2><p>首先我们要了解一下什么是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR" target="_blank" rel="noopener">按位异或</a>，它的定义是<strong>按位异或（XOR）：<code>a ^ b对于每一个比特位(二进制 base 2)，当两个操作数相应的比特位(二进制 base 2)有且只有一个1时，结果为1，否则为0。</code></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">a XOR b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>可能看到上面还是有点懵逼，那么可以看我另外一篇的博客<a href="/blog/javascript/dom/bitwise-operators.html">了解 JS 中的位运算符</a><br>我们通过上面的表格知道<code>a ^ a</code>为<code>0</code>，那么<code>a ^ a ^ b</code> 就相当于<code>0 ^ b</code>的出来的值为<code>b</code>的值。代码如下实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 初始值 a</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>; <span class="comment">// 初始值 b</span></span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<p><strong>按位异或：实现方式最好，直接通过二进制对比实现、代码简洁，但是转换过程不可知</strong></p>
<h2 id="利用逗号操作符"><a href="#利用逗号操作符" class="headerlink" title="利用逗号操作符"></a>利用逗号操作符</h2><p>也可以通过一些特殊的技巧来实现，<code>逗号操作符</code>结合<code>()</code>或者<code>[]</code>来实现交换位置。</p>
<p>我们简单了解一下<code>逗号操作符：对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</code>，来一个简单的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>; <span class="comment">// 初始值 x = 1</span></span><br><span class="line">x = [x++, x + <span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1. 因为有`=`复制符 要从右面开始执行，根据逗号操作符的定义我们先执行 x++; x = 2</span></span><br><span class="line"><span class="comment">// 2. 再执行 x + 1; x = 3</span></span><br><span class="line"><span class="comment">// 3. 再通过[2, 3][1]提取数组下标为1的值 x = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">1</span>; <span class="comment">// 初始值 y = 1</span></span><br><span class="line">y = y + (<span class="number">0</span>, y++); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>我们以对象为示例大致分析一下它的执行顺序，以便于更好的理解<code>JavaScript</code>的执行顺序:</p>
<ol>
<li>声明变量<code>y</code>,并且给<code>y</code>赋值为<code>1</code></li>
<li><code>()</code>的优先级是最高的，然后是<code>++</code> &gt; <code>+</code>优先级次之，再是<code>=</code> &gt; <code>,</code>。执行优先级如下表格所示。</li>
<li>所以会先执行外部的<code>()</code>, 执行内部的代码，遇到<code>,</code>符从左开始执行<code>(0, (y++))</code>，遇到内部的<code>(y++)</code>这个时候因为<code>()</code>的优先比<code>++</code>的优先级高，所以执行结果就是<code>(0, 1)</code>。再执行<code>,</code>符他返回了一个<code>1</code>.</li>
<li>再执行外部的<code>y = y + 1</code>,它们的优先级为<code>+ &gt; =</code>，先执行<code>y + 1</code>再执行<code>y = 2</code>，所以最后<code>y</code>为<code>2</code>。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">运算类型</th>
<th style="text-align:center">关联性</th>
<th style="text-align:center">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">圆括号</td>
<td style="text-align:center">n/a（不相关）</td>
<td style="text-align:center">( … )</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">后置递增(运算符在后)</td>
<td style="text-align:center">n/a</td>
<td style="text-align:center">… ++</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">一元加法</td>
<td style="text-align:center">从右到左</td>
<td style="text-align:center">+ …</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">一元加法</td>
<td style="text-align:center">从右到左</td>
<td style="text-align:center">… = …</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">赋值</td>
<td style="text-align:center">从左到右</td>
<td style="text-align:center">… , …</td>
</tr>
</tbody>
</table>
<p>下面我们就通过<code>逗号操作符</code>来实现两值交换，通过<code>数组实现</code>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 初始值 a</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>; <span class="comment">// 初始值 b</span></span><br><span class="line">a = [b, (b = a)][<span class="number">0</span>];</span><br><span class="line"><span class="comment">// a 200</span></span><br><span class="line"><span class="comment">// b 100</span></span><br></pre></td></tr></table></figure>
<p><code>方法()</code>实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 初始值 a</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>; <span class="comment">// 初始值 b</span></span><br><span class="line">a = b + ((b = a), <span class="number">0</span>);</span><br><span class="line"><span class="comment">// a 200</span></span><br><span class="line"><span class="comment">// b 100</span></span><br></pre></td></tr></table></figure>
<p><strong>优点实现简洁，更灵活，数组的操作还是容易理解一点，但是”,”操作符不太好了解</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面 5 种方法我们开扩了自己的思路，即复习了<code>ES6</code>也了解<code>执行优先级</code>、<code>按位操作符</code>、<code>,</code>等等。所以是比较有趣的，如果你有更好的解法请留言，大家一起进步。个人认为最好的方法是<code>按位操作符</code>、<code>减法实现</code>是比较好的实现方法。</p>
]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Menu组件(高级难度)</title>
    <url>/blog/vue/ui/vue-ui-menu-two.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 DropDown(初级难度)</title>
    <url>/blog/vue/ui/vue-ui-menu.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Selected组件(二)(中级难度)</title>
    <url>/blog/vue/ui/vue-ui-selectedTwo.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Selected组件(一)(中级难度)</title>
    <url>/blog/vue/ui/vue-ui-selected.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Input组件/InputNumber(中级难度)</title>
    <url>/blog/vue/ui/vue-ui-Input.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Rate组件(初级难度)</title>
    <url>/blog/vue/ui/vue-ui-rate.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Col组件(初级难度)</title>
    <url>/blog/vue/ui/vue-ui-col.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Switch组件(初级难度)</title>
    <url>/blog/vue/ui/vue-ui-switch.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Checkbox组件(初级难度)</title>
    <url>/blog/vue/ui/vue-ui-checkbox.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Radio组件(初级难度)</title>
    <url>/blog/vue/ui/vue-ui-radio.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Pagination组件(初级难度)</title>
    <url>/blog/vue/ui/vue-ui.pagination.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui框架 手写实现一个Ui框架级别的 Button组件(初级难度)</title>
    <url>/blog/vue/ui/vue-ui-button.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们开始只关注组件的功能实现，不考虑 css 分装、webpack 配置、整体结构设计、单元测试等等，因为在后面会一步一步完善。让大家一起进步，实现一套简单的组件库。</p>
<p><code>Button</code>组件也是经常用到的，首先我么也要了解<code>Button</code>都有什么功能，一样的可以参考<code>element/iview</code>中<code>button</code>功能。再结合我们的业务场景定制一些，适合自己项目的通用组件库。最后我们会把写好的 UI 框架库发布到 npm 中。</p>
<p>本组件的开发步骤和前面<a href="/blog/vue/ui/vue-ui-breadcrumb.html">breadcrumb</a>基本上一至，因为它们都是比较简单的组件，不需要分成多个模块来编写。大致步骤如下：</p>
<ol>
<li>分析<code>button</code>组件功能</li>
<li>构思代码、编写代码</li>
<li>测试组件效果，(编写单元测试)</li>
</ol>
<h2 id="分析组件功能"><a href="#分析组件功能" class="headerlink" title="分析组件功能"></a>分析组件功能</h2><p>首先要明确的了解要写的<code>button</code>组件要包含哪些功能，这样更有利于组件整体的构思和实现。如下图所示：</p>
<p><img src="../../../images/vue-ui/button-1.png" alt="button"></p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>在很多<code>ui框架</code>中可以看到它们的<code>button</code>都是有(状态/类型)的，结合自己使用的场景大致分为<code>defalut</code>、<code>primary</code>、<code>success</code>、<code>warning</code>、<code>info</code>、<code>error</code>这个都可以通过通过一个<code>type</code>传入我们的<code>button</code>组件以切换我们组件的状态。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>同时有不同类型的按钮类型比如<code>dashed</code>、<code>ghost</code>、<code>text</code>、<code>icon</code>、<code>round</code>、<code>circle</code>、<code>loading</code>、<code>disabled</code>类型。</p>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>支持设置大小<code>lg</code>、<code>md</code>、<code>sm</code>、<code>xs</code></p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>支持路由跳转<code>to</code>,支持<code>replace</code>跳转,支持自动获取原生<code>type</code>属性，同时支持<code>icon</code>传入和自定义<code>icon</code>图标。下面我们就根据上面的的计划一步一步实现功能。</p>
<p>支持设置<code>html标签</code>为<code>a</code>标签。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先实现简单的<code>type类型</code></p>
]]></content>
      <categories>
        <category>HP</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Ui 手写实现以下breadcrumb面包屑组件(初级难度)</title>
    <url>/blog/vue/ui/vue-ui-breadcrumb.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们开始只关注组件的功能实现，不考虑 css 分装、webpack 配置、整体结构设计、单元测试等等，因为在后面会一步一步完善。让大家一起进步，实现一套简单的组件库。</p>
<p>在日常我们开发 PC 页面时经常会用到一个面包屑导航的功能，其实这个功能算是比较简单的功能，基本上用过<code>Vue</code>这个框架的人都能自己写出来。但是既然要写一个通用的可能就不是那么容易实现，我们首先要了解<code>breadcrumb</code>它都有什么功能。下面我们就先分析它都有什么功能，可以参考<code>element/iview</code>这种流行的<code>Ui框架</code>。</p>
<ol>
<li>分析<code>breadcrumb</code>组件功能</li>
<li>构思代码、编写代码</li>
<li>测试组件效果，(编写单元测试)</li>
</ol>
<p>按照上面的三步一步一步的实现自己一个自己<code>breadcrumb</code>组件，废话不多说直接开干。</p>
<h2 id="分析组件功能"><a href="#分析组件功能" class="headerlink" title="分析组件功能"></a>分析组件功能</h2><p>我们可以去<code>element/iview</code>官方网去阅读一下他们的<a href="https://element.eleme.cn/2.13/#/zh-CN/component/breadcrumb" target="_blank" rel="noopener">文档</a>，在去<code>github</code>中看一下他们的源码。首先看一下他们是怎么使用，下面以<code>element</code>为例。<br><strong>示例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">"&#123; path: '/' &#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>活动管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>活动列表<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>活动详情<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="../../../images/vue-ui/breadcrumb-1.png" alt="breadcrumb"></p>
<p>根据上面和代码我们可以看出<code>breadcrumb</code>有两个组件，分别为：</p>
<p><code>breadcrumb</code>组件，并且它接受两个<code>props</code>属性：</p>
<ul>
<li><code>sparator(props)</code>: 它是用来替换默认<code>/</code>分隔符的，并且它的类型为<code>String</code>类型。默认<code>/</code></li>
<li><code>sparatorClass(props)</code>: 它是用来给填充<code>iconfont</code>这种的图标分隔符，并且它的类型为<code>String</code>类型。没有默认值</li>
</ul>
<p><code>breadcrumb-item</code>组件，它是被<code>breadcrumb</code>包裹的组件，它也接受两个<code>props</code>属性：</p>
<ul>
<li><code>to(props)</code>: 路由跳转对象，同 <code>vue-router</code> 的 <code>to</code>, 并且它的类型为<code>String/Object</code>类型。没有默认值</li>
<li><code>replace(props)</code>: 在使用 <code>to</code> 进行路由跳转时，启用 <code>replace</code> 将不会向 <code>history</code> 添加新记录, 类型是<code>Boolean</code>。默认<code>false</code></li>
</ul>
<p>我们大致知道了有两个组件，组件之间有嵌套关系，并且分别都支持两个<code>props</code>参数。并且有的<code>props</code>还有默认参数。下面我们就来一步一步实现自己已经知道的功能和配置。</p>
<h2 id="实现组件"><a href="#实现组件" class="headerlink" title="实现组件"></a>实现组件</h2><p>这里面有两个比较重要的知识点：</p>
<ul>
<li><code>breadcrumb-item</code>可以通过<code>slot</code>传入<code>breadcrumb</code>，同时<code>breadcrumb-item</code>中的内容也通过<code>slot</code>传入内容</li>
<li><code>breadcrumb</code>中接受的两个<code>props</code>怎么传入<code>breadcrumb-item</code>。 当然可以通过<code>props</code>一层一层传入，但是我们要写的好一点，这个里可以通过两种方式实现。<code>provide/inject</code>和<code>this.$children</code>来实现，这两种实现方式分别是<code>element</code>、<code>iview</code>实现方式，个人认为<code>provide/inject</code>更简洁一点。</li>
</ul>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>一个简单的组件<code>**breadcrumb**</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"breadcrumb"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'breadcrumb'</span>,</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 分隔符</span></span></span><br><span class="line">      separator: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">'/'</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">// 分隔符</span></span></span><br><span class="line">      separatorClass: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">''</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * TODO: 通过provide注入当前组件实例</span><br><span class="line"><span class="javascript">     * @<span class="keyword">return</span> &#123;<span class="built_in">Object</span>&#125; 返回一个对象</span></span><br><span class="line">     */</span><br><span class="line">    provide() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        breadcrumbEl: <span class="keyword">this</span></span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span> &#123;</span></span><br><span class="line"><span class="css">    &amp;<span class="selector-pseudo">::after</span>,</span></span><br><span class="line"><span class="css">    &amp;<span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">      content: '';</span><br><span class="line">      display: table;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    &amp;<span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.breadcrumb</span> &#123;</span></span><br><span class="line">    font-size: 14px;</span><br><span class="line">    line-height: 1;</span><br><span class="line"><span class="css">    @<span class="keyword">extend</span> .clearfix;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另一个组件<code>**breadcrumb-item**</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"breadcrumb-item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">:class</span>=<span class="string">"['breadcrumb-inner']"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"breadcrumb-separator"</span>&gt;</span></span><br><span class="line">      &#123;&#123; separator &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'breadcrumbItem'</span>,</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 跳转路径</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// eslint-disable-next-line vue/require-default-prop</span></span></span><br><span class="line"><span class="javascript">      to: [<span class="built_in">String</span>, <span class="built_in">Object</span>],</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 是否使用repalce替换push跳转</span></span></span><br><span class="line"><span class="javascript">      replace: <span class="built_in">Boolean</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// <span class="doctag">TODO:</span> 接受父组件传入的 分隔符</span></span></span><br><span class="line"><span class="javascript">        separator: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// <span class="doctag">TODO:</span> 接受父组件传入的 分隔符 class</span></span></span><br><span class="line"><span class="javascript">        separatorClass: <span class="string">''</span></span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// <span class="doctag">TODO:</span> 通过inject接受父组件注入的对象</span></span></span><br><span class="line"><span class="javascript">    inject: [<span class="string">'breadcrumbEl'</span>],</span></span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.separator = <span class="keyword">this</span>.breadcrumbEl.separator;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.separatorClass = <span class="keyword">this</span>.breadcrumbEl.separatorClass;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'this.breadcrumbEl: '</span>, <span class="keyword">this</span>.breadcrumbEl);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.breadcrumb</span> &#123;</span></span><br><span class="line"><span class="css">    @<span class="keyword">at</span>-<span class="keyword">root</span> #&#123;&amp;&#125;<span class="selector-tag">-item</span> &#123;</span></span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    @<span class="keyword">at</span>-<span class="keyword">root</span> #&#123;&amp;&#125;<span class="selector-tag">-separator</span> &#123;</span></span><br><span class="line">      margin: 0 9px;</span><br><span class="line">      font-weight: 700;</span><br><span class="line"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-id">#c0c4cc</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到此我们至少实现了基本的功能，如下图所示：<br><img src="../../../images/vue-ui/breadcrumb-2.png" alt="breadcrumb"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>但是我们观察这个图片可以看到，我们还是有一部分功能没有实现，如下几点：</p>
<ul>
<li>组件的后面多了一个<code>/</code></li>
<li>当前的组件不能跳转，增加跳转</li>
<li>添加属性无障碍阅读</li>
</ul>
<p>我们在<code>breadcrumb</code>组件中添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增代码</span></span><br><span class="line">mounted () &#123;</span><br><span class="line">  <span class="comment">// 获取所有的面包屑子项</span></span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">this</span>.$el.querySelectorAll(<span class="string">'.breadcrumb-item'</span>)</span><br><span class="line">  <span class="comment">// 判断子节点的长度</span></span><br><span class="line">  <span class="keyword">if</span> (items.length) &#123;</span><br><span class="line">    <span class="comment">// 如果最后一个添加aria 属性</span></span><br><span class="line">    items[items.length - <span class="number">1</span>].setAttribute(<span class="string">'aria-current'</span>, <span class="string">'page'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<code>breadcrumb-item</code>组件中添加如下代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"breadcrumb-item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">"link"</span> <span class="attr">:class</span>=<span class="string">"['breadcrumb-inner', to ? 'is-link': '']"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-if</span>=<span class="string">"separatorClass"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"breadcrumb-separator"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:class</span>=<span class="string">"separatorClass"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"breadcrumb-separator"</span> <span class="attr">role</span>=<span class="string">"presentation"</span>&gt;</span></span><br><span class="line">      &#123;&#123; separator &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'breadcrumbItem'</span>,</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 跳转路径</span></span></span><br><span class="line"><span class="javascript">      to: [<span class="built_in">String</span>, <span class="built_in">Object</span>],</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 是否使用repalce替换push跳转</span></span></span><br><span class="line"><span class="javascript">      replace: <span class="built_in">Boolean</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// <span class="doctag">TODO:</span> 接受父组件传入的 分隔符</span></span></span><br><span class="line"><span class="javascript">        separator: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// <span class="doctag">TODO:</span> 接受父组件传入的 分隔符 class</span></span></span><br><span class="line"><span class="javascript">        separatorClass: <span class="string">''</span></span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// <span class="doctag">TODO:</span> 通过inject接受父组件注入的对象</span></span></span><br><span class="line"><span class="javascript">    inject: [<span class="string">'breadcrumbEl'</span>],</span></span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.separator = <span class="keyword">this</span>.breadcrumbEl.separator;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.separatorClass = <span class="keyword">this</span>.breadcrumbEl.separatorClass;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 获取当前Link实例</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> linkEl = <span class="keyword">this</span>.$refs.link;</span></span><br><span class="line"><span class="javascript">      linkEl.setAttribute(<span class="string">'role'</span>, <span class="string">'link'</span>);</span></span><br><span class="line"><span class="javascript">      linkEl.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> &#123; to, replace, $router &#125; = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 判断是否传入to 是否存在$router不存在直接返回</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!to || !$router) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">// 根据replace的值，调用push or replace</span></span></span><br><span class="line">        replace ? $router.replace(to) : $router.push(to);</span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'this.breadcrumbEl: '</span>, <span class="keyword">this</span>.breadcrumbEl);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.breadcrumb</span> &#123;</span></span><br><span class="line"><span class="css">    @<span class="keyword">at</span>-<span class="keyword">root</span> #&#123;&amp;&#125;<span class="selector-tag">-item</span> &#123;</span></span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    @<span class="keyword">at</span>-<span class="keyword">root</span> #&#123;&amp;&#125;<span class="selector-tag">-separator</span> &#123;</span></span><br><span class="line">      margin: 0 9px;</span><br><span class="line">      font-weight: 700;</span><br><span class="line"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-id">#c0c4cc</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    @<span class="keyword">at</span>-<span class="keyword">root</span> #&#123;&amp;&#125;<span class="selector-tag">-inner</span> &#123;</span></span><br><span class="line"><span class="css">      &amp;<span class="selector-class">.is-link</span><span class="selector-pseudo">:hover</span>,</span></span><br><span class="line"><span class="css">      &amp; <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#409eff</span>;</span></span><br><span class="line">        cursor: pointer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    &amp; <span class="selector-class">.breadcrumb-item</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.breadcrumb-separator</span> &#123;</span></span><br><span class="line">        display: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们通过<code>breadcrumb-item:last-child</code>把最后一个<code>/</code>隐藏掉。<br>我们通过获取<code>this.$refs.link</code>实例，设置无障碍阅读<code>role</code>属性，设置无障碍阅读。并且绑定跳转事件，根据传入的<code>repalce</code>属性判断跳转方式。<br>到此我们就实现了一个自己可用的<code>Breadcrum</code>组件。</p>
<p>在线代码：</p>
<iframe src="https://codesandbox.io/embed/awesome-worker-wvecw?fontsize=14&hidenavigation=1&theme=dark" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="awesome-worker-wvecw" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇文章中即实现了自己的 ui 组件<code>breadcrumb</code>，又学习了两个比较常用的<code>Vue</code>知识点。如果不了解<a href="https://cn.vuejs.org/v2/api/?#slot" target="_blank" rel="noopener">solt</a>可以去看<code>vue</code>官方文档。另一个<a href="https://cn.vuejs.org/v2/api/?#provide-inject" target="_blank" rel="noopener">provide/inject</a>它类似于<code>react</code>中的<code>context</code>，如果想了解<code>vue</code>中其他好玩的<code>属性</code>、<code>内置组件</code>、<code>修饰符</code>可以关注我。</p>
]]></content>
      <categories>
        <category>HP</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>HP</tag>
      </tags>
  </entry>
  <entry>
    <title>setTimeout实现原理和EventLoop的关系</title>
    <url>/blog/javascript/eventloop/mode_setTimeout.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/GI6entTJl2EtP5rRzmQFTw" target="_blank" rel="noopener">setTimeout 的实现原理和使用注意</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Principle</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列 ———— 单例模式和设计模式的作用</title>
    <url>/blog/design-patterns/docs/mode_simple_des.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/7QDxcAVFmLVGbKGdtE7dRg" target="_blank" rel="noopener">深入理解 JavaScript 的设计模式</a></p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>lighthouse的使用</title>
    <url>/blog/monitor/perfromance/performance-lighthouse.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/EuFDLOCg53IxvieaQDeYug" target="_blank" rel="noopener">网易云音乐前端性能监控实践</a></p>
]]></content>
      <categories>
        <category>Perfromance</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Browser</tag>
        <tag>Perfromance</tag>
      </tags>
  </entry>
  <entry>
    <title>typeScript中的interface</title>
    <url>/blog/typescript/docs/typeScript_decorator.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/06iBhb4ye6-1cAxgLX7ybA" target="_blank" rel="noopener">TypeScript 真香系列——接口篇</a></p>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>react中使用useState</title>
    <url>/blog/react/hooks/react-useState.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/ydApE7akeJ0VO3R1r365mQ" target="_blank" rel="noopener">简单易懂的 React useState() Hook 指南（长文建议收藏）</a></p>
]]></content>
      <categories>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>node中的线程和进程，父子进程的关联</title>
    <url>/blog/node/docs/node_process.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/VzXnnfn4gCBMd5wea3LRIg" target="_blank" rel="noopener">深入理解 Node.js 进程与线程</a></p>
]]></content>
      <categories>
        <category>Node</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>typeScript中的interface</title>
    <url>/blog/typescript/docs/typeScript_interface.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/06iBhb4ye6-1cAxgLX7ybA" target="_blank" rel="noopener">TypeScript 真香系列——接口篇</a></p>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列 ———— mvc和mvvm到底是什么</title>
    <url>/blog/design-patterns/interview-question/mode-mvc-mvvm.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>DesignPatterns</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝系列 ———— 分析lodash中的deepcopy</title>
    <url>/blog/javascript/deep-clone/javascript-loadsh-deepcopy.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepClone</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝系列 ———— 自己通过递归实现一个深拷贝</title>
    <url>/blog/javascript/deep-clone/javascript-deepcopy.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上篇文章中我们深入了解了<code>JSON.parse/JSON.stringify</code>，并且自己实现了一个<code>JSON.parse/JSON.stringify</code>，在这篇文章中我们要自己实现一个<strong>深拷贝</strong>，并且解决<code>JSON.parse/JSON.stringify</code>中出现的问题。</p>
<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p><strong>实现目标</strong></p>
<ul>
<li>我们通过递归实现一个简单的深拷贝</li>
<li>判断<code>Object</code>和<code>Array</code></li>
</ul>
<p><strong>实现步骤</strong></p>
<ul>
<li>提前声明一个判断类型函数<code>getType</code></li>
<li>声明函数<code>cloneDeep</code>，首先判断<code>原对象</code>是否为<code>object</code>类型，如果不是直接返回原值</li>
<li>声明一个新的目标对象<code>newTarget</code>，它的类型根据入参决定<code>（Array、Object）</code></li>
<li>通过<code>for...in</code>循环<code>原对象</code>，并且通过<code>hasOwnProperty</code>判断属性是否为本身属性</li>
<li>如果是本身属性递归调用<code>cloneDeep</code></li>
<li>最后返回新对象<code>newTarget</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">  <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否传入类型为Object</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明新对象</span></span><br><span class="line">  <span class="keyword">let</span> newTarget = getType(target) === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">// 循环对象 递归复制给新对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">      newTarget[key] = cloneDeep(target[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新对象</span></span><br><span class="line">  <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  val1: <span class="number">1</span>,</span><br><span class="line">  val2: <span class="literal">undefined</span>,</span><br><span class="line">  val4: <span class="string">'target'</span>,</span><br><span class="line">  val5: &#123;</span><br><span class="line">    name: <span class="string">'target'</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> targetArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123; <span class="attr">name</span>: <span class="string">'123'</span>, <span class="attr">age</span>: <span class="number">789</span> &#125;];</span><br><span class="line"><span class="built_in">console</span>.log(cloneDeep(target));</span><br><span class="line"><span class="built_in">console</span>.log(cloneDeep(targetArray));</span><br></pre></td></tr></table></figure>
<p>测试效果图如下：</p>
<p><img src="./javascript-deepcopy/javascript-clone-deep-1-1.png" width="80%" height="60%"></p>
<p>在上面的代码中，已经解决了<code>JSON.stringify/JSON.parse</code>中的忽略<code>undefined/function</code>的问题，下面会逐渐解决问题，并且优化到类似与<code>lodash</code>库中的问题。</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p><strong>实现目标</strong></p>
<ul>
<li>解决循环引用对象问题</li>
<li>解决引用丢失问题</li>
</ul>
<p><strong>实现步骤</strong></p>
<ul>
<li>首先了解<code>Map</code>、<code>WeakMap</code>是什么</li>
<li>通过<code>Map</code>、<code>WeakMap</code>、<code>Array</code>储存属性对象</li>
<li>如果再次使用，直接从<code>Map</code>、<code>WeakMap</code>中取出(这样既解决了循环引用，又解决了引用丢失)</li>
</ul>
<p>测试循环引用代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  val1: <span class="number">1</span>,</span><br><span class="line">  val2: <span class="literal">undefined</span>,</span><br><span class="line">  val4: <span class="string">'target'</span>,</span><br><span class="line">  val5: &#123;</span><br><span class="line">    name: <span class="string">'target'</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;</span><br><span class="line"><span class="built_in">console</span>.log(cloneDeep(target));</span><br></pre></td></tr></table></figure>
<p>执行效果如下图所示：<br><img src="./javascript-deepcopy/javascript-clone-deep-1-2.png" alt="深拷贝/浅拷贝"></p>
<h3 id="Map-weakMap"><a href="#Map-weakMap" class="headerlink" title="Map/weakMap"></a>Map/weakMap</h3><p><code>Map</code>和<code>WeakMap</code>都是 ES6 中的新出的数据类型。如果有兴趣可以去<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">WeakMap mdn</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">Map mdn</a>，或者<a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">Set 和 Map 数据结构</a>去了解它们的<code>api</code>和<code>使用场景</code>等。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code>对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p><strong>语法</strong></p>
<p><code>new Map([iterable])</code></p>
<ul>
<li><code>iterable</code>: <code>Iterable</code> 可以是一个<code>数组</code>或者其他 <code>iterable 对象</code>，其元素为键值对(两个元素的数组，例如: <code>[[ 1, &#39;one&#39; ],[ 2, &#39;two&#39; ]]</code>)。 每个键值对都会添加到新的<code>Map</code>。<code>null</code> 会被当做 <code>undefined</code>。</li>
</ul>
<p><strong>常用方法</strong></p>
<ul>
<li><code>Map.prototype.get(key)</code>: 返回键对应的值，如果不存在，则返回<code>undefined</code>。</li>
<li><code>Map.prototype.set(key, value)</code>: 设置<code>Map</code>对象中键的值。返回该<code>Map对象</code>。</li>
<li><code>Map.prototype.has(key)</code>: 返回一个<code>布尔值</code>，表示<code>Map实例</code>是否包含键对应的值。</li>
<li><code>Map.prototype.delete(key)</code>: 如果 <code>Map对象</code>中存在该元素，则移除它并返回 <code>true</code>；否则如果该元素不存在则返回 <code>false</code>。</li>
</ul>
<p>这里只介绍了常用的<code>操作方法</code>，<code>Map</code>还有<code>循环方法</code>、<code>其他方法</code>等等。</p>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oneMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;</span><br><span class="line">  name: <span class="string">'keyObj'</span></span><br><span class="line">&#125;;</span><br><span class="line">oneMap.set(<span class="string">'name'</span>, <span class="string">'test'</span>); <span class="comment">// &#123;"name" =&gt; "test"&#125;</span></span><br><span class="line">oneMap.set(keyObj, <span class="string">'keyObj'</span>); <span class="comment">// &#123;"name" =&gt; "test", keyObj =&gt; "keyObj"&#125; 这里的keyObj是上面声明的对象</span></span><br><span class="line"></span><br><span class="line">oneMap.get(<span class="string">'name'</span>); <span class="comment">// "test"</span></span><br><span class="line">oneMap.get(keyObj); <span class="comment">// "keyObj"</span></span><br><span class="line"></span><br><span class="line">oneMap.has(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">oneMap.has(keyObj); <span class="comment">// true</span></span><br><span class="line">oneMap.has(<span class="string">'age'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">oneMap.delete(<span class="string">'name'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p><code>WeakMap</code> 对象是一组<code>键/值对</code>的集合，其中的键是<code>弱引用</code>的。其键<code>必须是对象</code>，而值可以是<code>任意</code>的。</p>
<p>它的语法、参数与<code>Map</code>是一至的，只有两点区别：</p>
<ul>
<li><code>WeakMap</code>只接受<code>对象</code>作为<code>键</code>名（<code>null除外</code>），<code>不接受其他类型的值作为键名</code>。</li>
<li><code>WeakMap</code> <code>弱引用</code>的<code>只是键名</code>，而<code>不是键值</code>。<code>键值</code>依然是<code>正常引用</code>。</li>
</ul>
<p>同时<code>WeakMap</code>只有上面<code>get/set/has/delete</code>四种方法，其它的方法它都是没有的。</p>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key);</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里就不测试它的操作方法了，它的操作方法与<code>Map</code>一至。</p>
<h3 id="通过-Map-解决"><a href="#通过-Map-解决" class="headerlink" title="通过 Map 解决"></a>通过 Map 解决</h3><p>在这里我们通过<code>Map</code>来解决循环引用，修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否传入类型为Object</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明新对象</span></span><br><span class="line">  <span class="keyword">let</span> newTarget = getType(target) === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &lt;!------新增代码开始------!&gt;</span></span><br><span class="line">  <span class="comment">// 查询map中是否有存在原对象（target），如果存在直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果map中不存在原对象（target），则储存进map中</span></span><br><span class="line">  map.set(target, newTarget);</span><br><span class="line">  <span class="comment">// &lt;!------新增代码结束------!&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环对象 递归复制给新对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">      newTarget[key] = cloneDeep(target[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新对象</span></span><br><span class="line">  <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行测试代码如下：<br><img src="./javascript-deepcopy/javascript-clone-deep-1-3.png" width="80%" height="60%"></p>
<p>我们可以看到<code>target</code>变为一个<code>Circular</code>类型的对象，这个是在<code>node环境</code>中运行的，如果在<code>浏览器</code>对还是会<code>报错（爆栈）</code>。<br>到这里我们只做到了让他没有报错，但是也并没有完美的解决循环引用的问题，下面就要到<code>WeakMap</code>登场了。</p>
<h3 id="WeakMap-解决"><a href="#WeakMap-解决" class="headerlink" title="WeakMap 解决"></a>WeakMap 解决</h3><p>上面我们已经讲解过<code>Map</code>和<code>WeakMap</code>的不同点和相同点，为什么说<code>WeakMap</code>在解决循环引用会比<code>Map</code>好很多呢，就是因为<code>WeakMap</code>它的<code>键值</code>是弱引用的。<br>什么是弱引用，即<code>垃圾回收机制</code>不考虑 <code>WeakMap</code> 对该对象的引用，也就是说，如果其他对象都<code>不再引用</code>该对象，那么<code>垃圾回收机制</code>会<code>自动回收</code>该对象所占用的<code>内存</code>，不考虑该对象还存在于 <code>WeakMap</code> 之中。<br>要深入理解<code>弱引用</code>这个又会涉及到<code>Node</code>和<code>JavaScript</code>底层垃圾回收机制，因为它们的垃圾回收机制都是使用的<code>标记法</code>，又分为<code>新生代</code>和<code>老生代</code>，所以这里就不多做赘述了。后面会有一系列文章来讲述<code>Node</code>和<code>JavaScript</code>中的相同和异同点。</p>
<p>修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只是把Map修改为WeakMap</span></span><br><span class="line">map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br></pre></td></tr></table></figure>
<p>这样无论是在<code>浏览器端</code>还是<code>node</code>中都可以正常的运行。</p>
<h2 id="类型问题"><a href="#类型问题" class="headerlink" title="类型问题"></a>类型问题</h2><p>我们在上面只考虑了<code>Array/Object</code>其实就是<code>Object</code>类型的数据处理，其他的数据都是走的直接返回。</p>
<ul>
<li>改写<code>Object</code>的判断，并且分别处理<code>Array/Object</code>方法</li>
<li>处理<code>Function</code></li>
<li>处理<code>Symbol</code></li>
<li>处理<code>不可循环类型（Number/String/Date/Boolean）</code></li>
<li>处理<code>RegExp/Map/Set</code></li>
</ul>
<p>我们就按上面的步骤一步一步分拆不同类型走不同的处理，已解决在<code>JSON.stringify</code>遇到的问题。</p>
<h3 id="Object-类型判断"><a href="#Object-类型判断" class="headerlink" title="Object 类型判断"></a>Object 类型判断</h3><p>在上面的代码中我们只是简单的判断了<code>Object</code>，如果不是<code>Object</code>直接返回，其实是没有考虑到<code>null</code>这个特殊情况的。我们现在就要加上<code>null</code>的怕判断并且后面也要独立处理<code>Function</code>类型的<code>copy</code>。</p>
<p><strong>实现目标</strong>：</p>
<ul>
<li><code>null</code>的判断</li>
<li><code>function</code>的判断</li>
<li><code>Array/Object</code>的分别处理</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增判断属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 储存传入值的类型</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="comment">// 过滤null</span></span><br><span class="line">  <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否传入类型为Object</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 。。。省略代码</span></span><br><span class="line">  <span class="comment">// 其实还可以通过Array.isArray()来检测是否为数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><strong>function</strong>处理：</p>
<p>其实即使<code>function</code>指向同一个内存地址，他也是没有任何问题的，所以可以直接可以返回<code>return value</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span>;</span><br><span class="line"><span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>数据类型 <code>“symbol”</code> 是一种原始数据类型，该类型的性质在于这个类型的值可以用来<code>创建匿名的对象属性</code>。<br>我们可以拷贝<code>symbol</code>类型的属性名？</p>
<p>首先我们可以通过<code>typeof、Object.prototype.toString.call()</code>来检测<code>symbol</code>的类型，但是我们怎么获取到<code>symbol</code>.</p>
<p><strong>示例</strong>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">Symbol</span>(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">typeof</span> test; <span class="comment">// symbol</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(test); <span class="comment">// [object Symbol]</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过两种方法获取的到<code>symbol</code>.</p>
<ul>
<li><code>Object.getOwnPropertySymbols(...)</code>: <code>Object.getOwnPropertySymbols(...)</code>可以查找一个给定对象的符号属性时返回一个 <code>symbol</code> 类型的数组。</li>
<li><code>Reflect.ownKeys(...)</code>: 返回一个由目标对象自身的<code>属性键</code>组成的数组。</li>
</ul>
<blockquote>
<p>注意： 每个初始化的对象都是没有自己的 symbol 属性的，因此这个数组可能为空，除非你已经在对象上设置了 symbol 属性。<br><code>Reflect.ownKeys(...)</code>的返回值等同于<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>。</p>
</blockquote>
<p><strong>示例</strong>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sName = <span class="built_in">Symbol</span>(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">var</span> age = <span class="built_in">Symbol</span>(<span class="string">'age'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testObj = &#123;</span><br><span class="line">  firstSex: <span class="string">'man'</span></span><br><span class="line">&#125;;</span><br><span class="line">testObj[sName] = <span class="string">'name'</span>;</span><br><span class="line">testObj[age] = <span class="number">19</span>;</span><br><span class="line">testObj.lastSex = <span class="string">'girl'</span>;</span><br><span class="line"></span><br><span class="line">objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(testObj);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols); <span class="comment">// [Symbol('name'), Symbol('age')]</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols[<span class="number">0</span>]); <span class="comment">// Symbol('name')</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(testObj); <span class="comment">// ["firstSex", "lastSex", Symbol(name), Symbol(age)]</span></span><br><span class="line"><span class="comment">// 注意顺序</span></span><br></pre></td></tr></table></figure>
<p>这个只能获取到当前的值，但是我们怎么拷贝这个属性呢？</p>
<p>我们可以通过<code>valueOf</code>来获取<code>symbol</code>的原始值，然后再复制当前的属性和值。<br><code>valueOf()</code>方法返回当前 <code>symbol</code> 对象所包含的 <code>symbol</code> 原始值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存方法</span></span><br><span class="line">  <span class="keyword">const</span> symbolValueOf = <span class="built_in">Symbol</span>.prototype.valueOf;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(symbolValueOf.call(symbol));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不可循环类型"><a href="#不可循环类型" class="headerlink" title="不可循环类型"></a>不可循环类型</h3><p>我们常用的不可循环的类型，比如<code>Number/String/Date/Boolean</code>，如果是一些字面量<strong>直接赋值</strong>给新的对象也是没有问题，但是我们通过创建一个新的对象自然更好。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneStatic</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取构造函数</span></span><br><span class="line">  <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">  <span class="comment">// 实例化一个同类型的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RegExp-Map-Set"><a href="#RegExp-Map-Set" class="headerlink" title="RegExp/Map/Set"></a>RegExp/Map/Set</h3><p>首先处理<code>RegExp</code>正则，我们这里直接使用<code>lodash</code>中的，其实和静态的方法类似，都是生成一个新的<code>RegExp</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">regexp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> regexp.constructor(regexp.source, reFlags.exec(regexp));</span><br><span class="line">  result.lastIndex = regexp.lastIndex;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map/Set"></a>Map/Set</h4><p>我们要考虑<code>Map/Set</code>类型的处理，因为它们也是可以循环的，并且他们可以的<code>key-value</code>也可以为可循环的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneMap</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个新的Map</span></span><br><span class="line">  <span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="comment">// 循环复制到新Map</span></span><br><span class="line">  target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 因为值有可能是一个对象、数组，所以要递归调用</span></span><br><span class="line">    newMap.set(key, cloneDeep);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newMap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSet</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个新的Set</span></span><br><span class="line">  <span class="keyword">let</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">// 循环复制到新Set</span></span><br><span class="line">  target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 因为值有可能是一个对象、数组，所以要递归调用</span></span><br><span class="line">    newSet.add(key, cloneDeep);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们考虑了大部分类型的实现，下面是完整的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;!------------工具函数开始----------------------------!&gt;</span></span><br><span class="line"><span class="comment">// 创建数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createData</span>(<span class="params">deep, breadth</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> temp = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deep; i++) &#123;</span><br><span class="line">    temp = temp[<span class="string">'data'</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; breadth; j++) &#123;</span><br><span class="line">      temp[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">  <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否为引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 储存传入值的类型</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="comment">// 过滤null</span></span><br><span class="line">  <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 克隆function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunc</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span>;</span><br><span class="line">  <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆symbol</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存方法</span></span><br><span class="line">  <span class="keyword">const</span> symbolValueOf = <span class="built_in">Symbol</span>.prototype.valueOf;</span><br><span class="line">  <span class="comment">// 返回key</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(symbolValueOf.call(symbol));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆RegExp</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">regexp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> regexp.constructor(regexp.source, reFlags.exec(regexp));</span><br><span class="line">  result.lastIndex = regexp.lastIndex;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可循环的类型 Number/String/Date/Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneStatic</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取构造函数</span></span><br><span class="line">  <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">  <span class="comment">// 实例化一个同类型的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;!------------工具函数结束----------------------------!&gt;</span></span><br><span class="line"><span class="comment">// &lt;!------------克隆逻辑开始----------------------------!&gt;</span></span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="comment">// console.log(isObject(target));</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(111);</span></span><br><span class="line">  <span class="keyword">let</span> newTarget = &#123;&#125;;</span><br><span class="line">  <span class="keyword">switch</span> (getType(target)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Number'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'String'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Boolean'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Date'</span>:</span><br><span class="line">      <span class="keyword">return</span> cloneStatic(target);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'RegExp'</span>:</span><br><span class="line">      <span class="keyword">return</span> cloneRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Function'</span>:</span><br><span class="line">      <span class="keyword">return</span> cloneFunc(target);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Array'</span>:</span><br><span class="line">      newTarget = [];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Map'</span>:</span><br><span class="line">      newTarget = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Set'</span>:</span><br><span class="line">      newTarget = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询map中是否有存在原对象（target），如果存在直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (map.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果map中不存在原对象（target），则储存进map中</span></span><br><span class="line">  map.set(target, newTarget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝Map</span></span><br><span class="line">  <span class="keyword">if</span> (getType(target) === <span class="string">'Map'</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环复制到新Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 因为值有可能是一个对象、数组，所以要递归调用</span></span><br><span class="line">      newTarget.set(key, cloneDeep(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newTarget;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拷贝Set</span></span><br><span class="line">  <span class="keyword">if</span> (getType(target) === <span class="string">'Set'</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环复制到新Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 因为值有可能是一个对象、数组，所以要递归调用</span></span><br><span class="line">      newTarget.add(key, cloneDeep(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环对象 递归复制给新对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">      newTarget[key] = cloneDeep(target[key], map); <span class="comment">// &lt;!------新增代码 参数map------!&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新对象</span></span><br><span class="line">  <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;!------------克隆逻辑结束----------------------------!&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化symbol</span></span><br><span class="line"><span class="keyword">let</span> oneSymbol = <span class="built_in">Symbol</span>(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">// 实例化Map</span></span><br><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">newMap.set(<span class="string">'name'</span>, &#123; <span class="attr">name</span>: <span class="string">'everybody'</span> &#125;);</span><br><span class="line"><span class="comment">// 实例化Set</span></span><br><span class="line"><span class="keyword">let</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">newSet.add(<span class="string">'age'</span>, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  val1: <span class="number">1</span>,</span><br><span class="line">  val2: <span class="literal">undefined</span>,</span><br><span class="line">  val4: <span class="string">'target'</span>,</span><br><span class="line">  val5: &#123;</span><br><span class="line">    name: <span class="string">'target'</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'永远18岁'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  val32: <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>),</span><br><span class="line">  val23: <span class="keyword">new</span> <span class="built_in">String</span>(<span class="literal">true</span>),</span><br><span class="line">  val443: <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="literal">true</span>),</span><br><span class="line">  date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  reg: <span class="regexp">/\d+/</span>,</span><br><span class="line">  empty: <span class="literal">null</span>,</span><br><span class="line">  newMap,</span><br><span class="line">  newSet,</span><br><span class="line">  arrowFunc: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test111'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  deepObj: createData(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">&#125;;</span><br><span class="line">target[oneSymbol] = <span class="string">'name'</span>;</span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> ss = cloneDeep(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ss);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="./javascript-deepcopy/javascript-clone-deep-1-4.png" width="80%" height="60%"></p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>在上面我们使用的循环是<code>for...in</code>，但是他的性能并不是最高的，我们现在来对比一下<code>for...in</code>、<code>for</code>、<code>while</code>、<code>forEach</code>三个循环谁的速度更快。<br>我们可以通过每个循环<code>100000</code>次，在浏览器端通过<code>console.time()</code>、<code>console.timeend()</code>统计当前执行的循环效率。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成数据</span></span><br><span class="line"><span class="keyword">let</span> initData = [];</span><br><span class="line"><span class="keyword">var</span> len = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> item = &#123;</span><br><span class="line">    name: <span class="string">'name'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'man'</span>,</span><br><span class="line">    class: 'first'</span><br><span class="line">  &#125;;</span><br><span class="line">  initData.push(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录for循环时间</span></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  sum += initData[i].age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录for...in循环时间</span></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> initData) &#123;</span><br><span class="line">  sum += initData[item];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录while循环时间</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">  sum += initData[i].age;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"><span class="comment">// 记录forEach循环时间</span></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line">initData.forEach(<span class="function">(<span class="params">item, index, soruce</span>) =&gt;</span> &#123;</span><br><span class="line">  sum += item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br></pre></td></tr></table></figure>
<p>多次执行效果相差不多，执行效果如下：<br><img src="./javascript-deepcopy/javascript-clone-deep-1-5.png" width="80%" height="60%"></p>
<p>图上的四个时间分别对应的顺序是：</p>
<ul>
<li><code>for</code>: 2.8ms</li>
<li><code>for...in</code>: 17.7ms</li>
<li><code>while</code>: 4.4ms</li>
<li><code>forEach</code>: 45.2ms</li>
</ul>
<p>这个测试环境是在<code>mac pro i7 16G</code>、<code>Chrome 78.0.3904.87</code>这个进行的只是简单测试，大致结果<code>for &gt; while &gt; for...in &gt; forEach</code>。</p>
<p>但是我看到<code>lodash</code>中是用的<code>while</code>，并且别人测试的是和我测试相反的。这里就不再多做追究了，免的喧宾夺主后面会独立一篇文章好好探讨一下谁的速度更快。<br>我们也通过<code>while</code>改写代码吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 获取数组长度</span></span><br><span class="line">  <span class="keyword">const</span> length = array.length;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    <span class="comment">// 执行回调</span></span><br><span class="line">    <span class="keyword">if</span> (iteratee(array[index], index, array) === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改循环逻辑的代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原代码如下</span></span><br><span class="line"><span class="comment">// 循环对象 递归复制给新对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">  <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">  <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    newTarget[key] = cloneDeep(target[key], map); <span class="comment">// &lt;!------新增代码 参数map------!&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = getType(target) === <span class="string">'Array'</span> ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">arrayEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">    key = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">    newTarget[key] = cloneDeep(target[key], map); <span class="comment">// &lt;!------新增代码 参数map------!&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化symbol</span></span><br><span class="line"><span class="keyword">let</span> oneSymbol = <span class="built_in">Symbol</span>(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">// 实例化Map</span></span><br><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">newMap.set(<span class="string">'name'</span>, &#123; <span class="attr">name</span>: <span class="string">'everybody'</span> &#125;);</span><br><span class="line"><span class="comment">// 实例化Set</span></span><br><span class="line"><span class="keyword">let</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">newSet.add(<span class="string">'age'</span>, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  val1: <span class="number">1</span>,</span><br><span class="line">  val2: <span class="literal">undefined</span>,</span><br><span class="line">  val4: <span class="string">'target'</span>,</span><br><span class="line">  val5: &#123;</span><br><span class="line">    name: <span class="string">'target'</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'永远18岁'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  val32: <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>),</span><br><span class="line">  val23: <span class="keyword">new</span> <span class="built_in">String</span>(<span class="literal">true</span>),</span><br><span class="line">  val443: <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="literal">true</span>),</span><br><span class="line">  date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  reg: <span class="regexp">/\d+/</span>,</span><br><span class="line">  empty: <span class="literal">null</span>,</span><br><span class="line">  newMap,</span><br><span class="line">  newSet,</span><br><span class="line">  arrowFunc: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test111'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  deepObj: createData(<span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;;</span><br><span class="line">target[oneSymbol] = <span class="string">'name'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log('');</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> ss1 = cloneDeepTwo(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> ss = clone(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br></pre></td></tr></table></figure>
<p>分开测试执行时间相差是<code>1ms-2ms</code>，其实并不相差太大，不能一起测试，因为一起测试的话，第一次执行的一些变量会被储存在内存中，第二次执行的速度自然会很快，所以一起测试的时间并不准确。</p>
<h3 id="递归爆栈"><a href="#递归爆栈" class="headerlink" title="递归爆栈"></a>递归爆栈</h3><p>我们测试使用的数据深度为<code>100</code>，广度为<code>1000</code>，这样还是不会造成递归爆栈，但是当我们把深度广度都提升到<code>10000</code>次就会造成递归爆栈。<br>解决递归爆栈的方法有三种：</p>
<ul>
<li>加大阈值</li>
<li>循环改写</li>
<li>尾递归优化</li>
</ul>
<p>因为<code>JavaScript</code>是会运行在浏览器端的，我们不能加大它的内存占用。</p>
<p>以前在<code>V8</code>中是已经是实现了<code>尾递归</code>的，但是它会影响<code>JavaScript</code>的栈的调用顺序，所以最后又删除掉了。<br>如果有兴趣可以去看我另一篇文章<a href="/blog/algorithm/algorithm-tailCall.html">尾递归</a></p>
<p>我们这里只用循环实现防止递归爆栈。</p>
<p>当我们的对象层级特别深事，我们通过递归循环时，会造成递归爆栈，因为一些临时变量会储存在堆栈中，通多深层递归调用，它们的不会被回收，当调用的层级越深自然储存的就越多，最后会导致栈储存不下，也就会造成递归爆栈。</p>
<p>我们可通过自己<code>创建一个栈</code>，<code>栈</code>中储存当前要拷贝的节点，一层一层往下拷贝，所以是一个深度优先的优化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneLoop</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈</span></span><br><span class="line">  <span class="keyword">const</span> loopList = [</span><br><span class="line">    &#123;</span><br><span class="line">      parent: root,</span><br><span class="line">      key: <span class="literal">undefined</span>,</span><br><span class="line">      data: x</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (loopList.length) &#123;</span><br><span class="line">    <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">    <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">    <span class="keyword">const</span> key = node.key;</span><br><span class="line">    <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">    <span class="keyword">let</span> res = parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      res = parent[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="comment">// 下一次循环</span></span><br><span class="line">          loopList.push(&#123;</span><br><span class="line">            parent: res,</span><br><span class="line">            key: k,</span><br><span class="line">            data: data[k]</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          res[k] = data[k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细内容见<a href="https://mp.weixin.qq.com/s/iDbDyWeSDgShqR_nQ1po_g" target="_blank" rel="noopener">深拷贝的终极探索</a></p>
<p>到此就一个<code>深拷贝</code>就结束了</p>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>我们是在原来的基础上一步一步优化我们自己的<code>深拷贝</code>实现，但是最后的<code>递归爆栈</code>如果在当前文章书写的话，会让当前文章很乱，所以会独立出来一篇文章来记录什么是<code>斐波拉契数列</code>相关的。</p>
<p>我们的大致实现步骤是：</p>
<ul>
<li>用递归实现一个简单的深拷贝</li>
<li>考虑循环引用问题，通过<code>WeakMap</code>解决</li>
<li>考虑类型问题，处理<code>Function、Map、Set</code>等等</li>
<li>考虑性能问题，递归爆栈问题</li>
</ul>
<p>到此基本上就实现一个可以使用的<strong>深拷贝</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/lodash/lodash/blob/master/cloneDeep.js" target="_blank" rel="noopener">lodash cloneDeep</a><br><a href="https://muyiy.cn/blog/4/4.1.html#%E4%B8%80%E3%80%81%E8%B5%8B%E5%80%BC%EF%BC%88copy%EF%BC%89" target="_blank" rel="noopener">深浅拷贝原理</a><br><a href="https://mp.weixin.qq.com/s/gQhfwoaxqHh4hRG1BQqKow" target="_blank" rel="noopener">如何写出一个惊艳面试官的深拷贝</a><br><a href="https://mp.weixin.qq.com/s/iDbDyWeSDgShqR_nQ1po_g" target="_blank" rel="noopener">深拷贝的终极探索</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝系列 ———— 自己实现一个JSON.stringify和JSON.parse</title>
    <url>/blog/javascript/deep-clone/javascript-paser-stringify.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上篇文章我们已经了解什么是<strong>深拷贝</strong>和<strong>浅拷贝</strong>，也着重介绍了<strong>浅拷贝</strong>相关的一下实现方法，或者自己实现一个浅拷贝等等。本篇文章主要介绍深拷贝的一种简单实现方式<code>JSON.parse/JSON.stringify</code>。在平常开发时我们可以经常的看到别人使用，或者在不那么了解深拷贝时自己也有使用。</p>
<p><strong>JSON.parse/JSON.stringify</strong>其实是用来序列化 JSON 格式的数据的方法。那它为什么能实现一个简单的深拷贝呢？<br>在执行<code>JSON.stringify</code>会把我们的一个对象序列化为字符串，而字符串是基本类型。<br>再通过<code>JSON.parse</code>时，把字符串类型反序列化为对象，这个时候因为在反序列化之前它是基本类型所以他会指向一个新的地址，在反序列化之后它是一个对象会再分配内存空间。<br>所以<strong>JSON.parse/JSON.stringify</strong>可以实现一个简单的<strong>深拷贝</strong>。</p>
<p>本篇文章首先实现一个<code>JSON.stringify/JSON.parse</code>，下一篇文章实现一个比较完整的<strong>深拷贝</strong>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>直接上代码验证一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明原始对象</span></span><br><span class="line"><span class="keyword">var</span> old = &#123;</span><br><span class="line">  name: <span class="string">'old'</span>,</span><br><span class="line">  attr: &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'man'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  title: [<span class="string">'M1'</span>, <span class="string">'P6'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个新对象，通过SON.parse/JSON.stringify 实现对原始对象深拷贝，并且赋值给新对象</span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(old));</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始对象的name，新对象不受影响</span></span><br><span class="line">old.name = <span class="string">'new'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(old); <span class="comment">// &#123;name: "new", attr: &#123;age: 18, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始对象的引用类型，新对象也不受影响</span></span><br><span class="line">old.attr.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(old); <span class="comment">// &#123;name: "new", attr: &#123;age: 20, sex: "man"&#125;, title: [['M1', 'P6']]&#125;</span></span><br></pre></td></tr></table></figure>
<p>其实是不是以为用这个就可以了，并没有什么问题啊，下面我们就来一点点揭开它的面纱。</p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>其实<code>JSON.parse/JSON.stringify</code>还是有很多局限性，大致如下：</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>Symbol</code></li>
<li>无法序列化<code>function</code>，也会忽略</li>
<li>无法解决循环引用，会报错</li>
<li>深层对象转换爆栈</li>
</ul>
<p>直接上代码验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个包含undefined、null、symbol、function的对象</span></span><br><span class="line"><span class="keyword">var</span> oldObj = &#123;</span><br><span class="line">  name: <span class="string">'old'</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  sex: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>),</span><br><span class="line">  title: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  lastName: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br><span class="line"><span class="comment">// 可以看到会忽略undefined、symbol、function的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">// &#123;name: "old", lastName: null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstObj = &#123;</span><br><span class="line">  name: <span class="string">'firstObj'</span></span><br><span class="line">&#125;;</span><br><span class="line">firstObj.newKey = firstObj;</span><br><span class="line"><span class="comment">// Converting circular structure to JSON</span></span><br><span class="line"><span class="keyword">var</span> newFirstObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(firstObj));</span><br></pre></td></tr></table></figure>
<p>如果循环引用报错如下图所示：<br><img src="../../../images/es/es-assign-1-4.png" alt="JSON.parse/JSON.stringify"></p>
<p>一个生成<strong>任意深度、广度</strong>对象方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createData</span>(<span class="params">deep, breadth</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> temp = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deep; i++) &#123;</span><br><span class="line">    temp = temp[<span class="string">'data'</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; breadth; j++) &#123;</span><br><span class="line">      temp[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证<code>JSON.stringify</code>递归爆栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(createData(<span class="number">10000</span>));</span><br><span class="line"><span class="comment">// VM97994:1 Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<h2 id="自己实现-JSON-stringify"><a href="#自己实现-JSON-stringify" class="headerlink" title="自己实现 JSON.stringify"></a>自己实现 JSON.stringify</h2><ul>
<li><strong>首先一个简单的递归</strong></li>
<li>区分<code>String</code>与<code>Boolean</code>、<code>Number</code>、<code>null</code></li>
<li>过滤<code>undefined</code>、<code>symbol</code>、<code>function</code><!-- - 递归爆栈提示 --></li>
<li>循环引用警告</li>
</ul>
<h3 id="一个简单的递归"><a href="#一个简单的递归" class="headerlink" title="一个简单的递归"></a>一个简单的递归</h3><p><strong>实现目标</strong></p>
<ul>
<li>递归调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据类型判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">  <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是非object类型 or null的类型直接返回 原值的String</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || getType(obj) === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明一个数组</span></span><br><span class="line">  <span class="keyword">let</span> json = [];</span><br><span class="line">  <span class="comment">// 判断当前传入参数是对象还是数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = obj ? getType(obj) === <span class="string">'Array'</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 循环对象属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 获取属性并且判断属性值类型</span></span><br><span class="line">      <span class="keyword">let</span> item = obj[key];</span><br><span class="line">      <span class="comment">// 如果为object类型递归调用</span></span><br><span class="line">      <span class="keyword">if</span> (getType(obj) === <span class="string">'Object'</span>) &#123;</span><br><span class="line">        <span class="comment">// consoarrle.log(item)</span></span><br><span class="line">        item = StringIfy(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 拼接数组字段</span></span><br><span class="line">      json.push((arr ? <span class="string">'"'</span> : <span class="string">'"'</span> + key + <span class="string">'": "'</span>) + <span class="built_in">String</span>(item) + <span class="string">'"'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="built_in">String</span>(json));</span><br><span class="line">  <span class="comment">// 转换数组字段为字符串</span></span><br><span class="line">  <span class="keyword">return</span> (arr ? <span class="string">'['</span> : <span class="string">'&#123;'</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">']'</span> : <span class="string">'&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">StringIfy(&#123; <span class="attr">name</span>: &#123; <span class="attr">name</span>: <span class="string">'abc'</span> &#125; &#125;); <span class="comment">// "&#123;"name": "&#123;"name": "abc"&#125;"&#125;"</span></span><br><span class="line">StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]); <span class="comment">// "["1","2","4"]"</span></span><br></pre></td></tr></table></figure>
<p>在上面代码中我们基本的<code>JSON序列化</code>，可以序列化<strong>引用类型</strong>和<strong>基本类型</strong>。</p>
<h3 id="区分数据类型"><a href="#区分数据类型" class="headerlink" title="区分数据类型"></a>区分数据类型</h3><p>我说的区分的类型，是<code>JSON.stringify</code>再序列化时，像<code>Number</code>、<code>Boolean</code>、<code>null</code>它是不会加上<code>双引号</code>的，只有在<code>String</code>类型或者<code>Object中的key</code>才会带<code>双引号</code>。</p>
<ul>
<li>增加一个判断当前属性类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 。。。省略代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 。。。省略代码</span></span><br><span class="line">  <span class="keyword">let</span> IsQueto =</span><br><span class="line">    getType(item) === <span class="string">'Number'</span> ||</span><br><span class="line">    getType(item) === <span class="string">'Boolean'</span> ||</span><br><span class="line">    getType(item) === <span class="string">'Null'</span></span><br><span class="line">      ? <span class="string">''</span></span><br><span class="line">      : <span class="string">'"'</span>;</span><br><span class="line">  <span class="comment">// 拼接数组字段</span></span><br><span class="line">  json.push((arr ? IsQueto : <span class="string">'"'</span> + key + <span class="string">'": "'</span>) + <span class="built_in">String</span>(item) + IsQueto);</span><br><span class="line">  <span class="comment">// 。。。省略代</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">StringIfy(&#123; <span class="attr">name</span>: &#123; <span class="attr">name</span>: <span class="string">'abc'</span> &#125; &#125;); <span class="comment">// "&#123;"name": "&#123;"name": "abc"&#125;"&#125;"</span></span><br><span class="line">StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]); <span class="comment">// "[1,2,4]"</span></span><br></pre></td></tr></table></figure>
<h3 id="不处理部分值"><a href="#不处理部分值" class="headerlink" title="不处理部分值"></a>不处理部分值</h3><ul>
<li>通过正则判断过滤<code>Symbol|Function|Undefined</code></li>
<li>跳过当前循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/Symbol|Function|Undefined/</span>.test(getType(item))) &#123;</span><br><span class="line">  <span class="keyword">delete</span> obj[key];</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">'name'</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test);</span><br><span class="line"><span class="built_in">console</span>.log(newTest); <span class="comment">// &#123;"name": "name"&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="循环引用警告"><a href="#循环引用警告" class="headerlink" title="循环引用警告"></a>循环引用警告</h3><ul>
<li>处理循环引用，警告并且退出循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (item === obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Converting circular structure to JSON'</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSON-stingify-其他参数"><a href="#JSON-stingify-其他参数" class="headerlink" title="JSON.stingify 其他参数"></a>JSON.stingify 其他参数</h3><p><code>JSON.stringify</code>它可以传入三个参数。</p>
<p><strong>语法</strong>： <code>JSON.stringify(value[, replacer [, space]])</code></p>
<p><strong>参数</strong></p>
<ul>
<li><code>value</code>：将要序列化成 一个 JSON 字符串的值。</li>
<li><code>replacer(可选)</code>：如果该参数是一个<code>函数</code>，则在序列化过程中，被序列化的值的<code>每个属性都会</code>经过该函数的<code>转换和处理</code>；如果该参数是一个<code>数组</code>，则<code>只有包含</code>在这个数组中的<code>属性名</code>才会被序列化到最终的 <code>JSON</code> 字符串中；</li>
<li><code>space</code>：指定缩进用的<code>空白字符串</code>，用于<code>美化输出（pretty-print）</code>；</li>
</ul>
<p>这里主要记录<code>replacer</code>的实现，首先我们要知道<code>replacer</code>参数的使用才能自己实现。</p>
<p><strong>replacer</strong>实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oJson = &#123;</span><br><span class="line">  name: <span class="string">'oJson'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  sex: <span class="string">'man'</span>,</span><br><span class="line">  calss: <span class="string">'one'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(oJson, [<span class="string">'sex'</span>, <span class="string">'name'</span>]); <span class="comment">// "&#123;"sex":"man","name":"oJson"&#125;"</span></span><br><span class="line"><span class="comment">// 两个参数 key/value的形式</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(oJson, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;); <span class="comment">// "&#123;"age":20&#125;"</span></span><br></pre></td></tr></table></figure>
<p><strong>实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj, replacer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是非object类型 or null的类型直接返回 原值的String</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || getType(obj) === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明一个数组</span></span><br><span class="line">  <span class="keyword">let</span> json = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断当前传入参数是对象还是数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = obj ? getType(obj) === <span class="string">'Array'</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 循环对象属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否可枚举</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// console.log(key, item);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取属性并且判断属性值类型</span></span><br><span class="line">      <span class="keyword">let</span> item = obj[key];</span><br><span class="line">      <span class="comment">// &lt;!-------修改开始-------!&gt;</span></span><br><span class="line">      <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 处理第二个参数</span></span><br><span class="line">      <span class="keyword">if</span> (replacer) &#123;</span><br><span class="line">        <span class="comment">// 判断第二个参数类型</span></span><br><span class="line">        <span class="keyword">switch</span> (getType(replacer)) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'Function'</span>:</span><br><span class="line">            <span class="comment">// 如果为函数执行</span></span><br><span class="line">            flag = replacer(key, item);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'Array'</span>:</span><br><span class="line">            <span class="comment">// 如果为数组</span></span><br><span class="line">            flag = replacer.indexOf(key) !== <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断返回结果</span></span><br><span class="line">      <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// &lt;!-------修改结束-------!&gt;</span></span><br><span class="line">      <span class="keyword">if</span> (item === obj) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Converting circular structure to JSON'</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/Symbol|Function|Undefined/</span>.test(getType(item))) &#123;</span><br><span class="line">        <span class="keyword">delete</span> obj[key];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果为object类型递归调用</span></span><br><span class="line">      <span class="keyword">if</span> (getType(item) === <span class="string">'Object'</span>) &#123;</span><br><span class="line">        <span class="comment">// consoarrle.log(item)</span></span><br><span class="line">        item = StringIfy(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> IsQueto =</span><br><span class="line">        getType(item) === <span class="string">'Number'</span> ||</span><br><span class="line">        getType(item) === <span class="string">'Boolean'</span> ||</span><br><span class="line">        getType(item) === <span class="string">'Null'</span></span><br><span class="line">          ? <span class="string">''</span></span><br><span class="line">          : <span class="string">'"'</span>;</span><br><span class="line">      <span class="comment">// 拼接数组字段</span></span><br><span class="line">      json.push((arr ? IsQueto : <span class="string">'"'</span> + key + <span class="string">'": "'</span>) + <span class="built_in">String</span>(item) + IsQueto);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="built_in">String</span>(json));</span><br><span class="line">  <span class="comment">// 转换数组字段为字符串</span></span><br><span class="line">  <span class="keyword">return</span> (arr ? <span class="string">'['</span> : <span class="string">'&#123;'</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">']'</span> : <span class="string">'&#125;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们新增第二个参数的处理，第三个参数暂时就忽滤了，主要用于设置<code>space</code>的，下面直接测试上面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">'name'</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>),</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(StringIfy(test, [<span class="string">'name'</span>, <span class="string">'sex'</span>])); <span class="comment">// &#123;"name": "name","sex": "man"&#125;</span></span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newTest); <span class="comment">// &#123;"age": "30&#125;</span></span><br></pre></td></tr></table></figure>
<p>到此<code>StringIfy</code>的实现到此结束。</p>
<h3 id="Stringify-总结"><a href="#Stringify-总结" class="headerlink" title="Stringify 总结"></a>Stringify 总结</h3><p>到此自己实现<code>JSON.stringify</code>到此结束了，完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据类型判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">  <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是非object类型 or null的类型直接返回 原值的String</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || getType(obj) === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明一个数组</span></span><br><span class="line">  <span class="keyword">let</span> json = [];</span><br><span class="line">  <span class="comment">// 判断当前传入参数是对象还是数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = obj ? getType(obj) === <span class="string">'Array'</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 循环对象属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// console.log(key, item);</span></span><br><span class="line">      <span class="comment">// 获取属性并且判断属性值类型</span></span><br><span class="line">      <span class="keyword">let</span> item = obj[key];</span><br><span class="line">      <span class="keyword">if</span> (item === obj) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Converting circular structure to JSON'</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/Symbol|Function|Undefined/</span>.test(getType(item))) &#123;</span><br><span class="line">        <span class="keyword">delete</span> obj[key];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果为object类型递归调用</span></span><br><span class="line">      <span class="keyword">if</span> (getType(item) === <span class="string">'Object'</span>) &#123;</span><br><span class="line">        <span class="comment">// consoarrle.log(item)</span></span><br><span class="line">        item = StringIfy(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> IsQueto =</span><br><span class="line">        getType(item) === <span class="string">'Number'</span> ||</span><br><span class="line">        getType(item) === <span class="string">'Boolean'</span> ||</span><br><span class="line">        getType(item) === <span class="string">'Null'</span></span><br><span class="line">          ? <span class="string">''</span></span><br><span class="line">          : <span class="string">'"'</span>;</span><br><span class="line">      <span class="comment">// 拼接数组字段</span></span><br><span class="line">      json.push((arr ? IsQueto : <span class="string">'"'</span> + key + <span class="string">'": "'</span>) + <span class="built_in">String</span>(item) + IsQueto);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="built_in">String</span>(json));</span><br><span class="line">  <span class="comment">// 转换数组字段为字符串</span></span><br><span class="line">  <span class="keyword">return</span> (arr ? <span class="string">'['</span> : <span class="string">'&#123;'</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">']'</span> : <span class="string">'&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aa = StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">'name'</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test);</span><br><span class="line"><span class="built_in">console</span>.log(aa, newTest);</span><br><span class="line"><span class="keyword">var</span> firstObj = &#123;</span><br><span class="line">  name: <span class="string">'firstObj'</span></span><br><span class="line">&#125;;</span><br><span class="line">firstObj.newKey = firstObj;</span><br><span class="line">StringIfy(firstObj);</span><br></pre></td></tr></table></figure>
<h2 id="JSON-parse-实现"><a href="#JSON-parse-实现" class="headerlink" title="JSON.parse 实现"></a>JSON.parse 实现</h2><p>有两种方法实现<code>parse</code>效果，第一种是<code>eval</code>实现，另一种是<code>Function</code>实现，下面直接开始。</p>
<h3 id="eval-实现"><a href="#eval-实现" class="headerlink" title="eval 实现"></a>eval 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParseJson</span>(<span class="params">opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">'('</span> + opt + <span class="string">')'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aa = StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">ParseJson(aa); <span class="comment">// [1, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">'name'</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test);</span><br><span class="line"><span class="built_in">console</span>.log(ParseJson(newTest)); <span class="comment">// &#123;name: "name"&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到上面的代码可以实现基本的反序列化。</p>
<blockquote>
<p>避免在不必要的情况下使用 eval，eval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用 eval()运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。</p>
</blockquote>
<h3 id="Function-实现"><a href="#Function-实现" class="headerlink" title="Function 实现"></a>Function 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParseJsonTwo</span>(<span class="params">opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return '</span> + opt)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aa = StringIfy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">ParseJson(aa); <span class="comment">// [1, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  name: <span class="string">'name'</span>,</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">'setter'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newTest = StringIfy(test);</span><br><span class="line"><span class="built_in">console</span>.log(ParseJson(newTest)); <span class="comment">// &#123;name: "name"&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>eval</code> 与 <code>Function</code> 都有着<code>动态编译js代码</code>的作用，但是在实际的编程中并不推荐使用。</p>
<h3 id="处理-XSS"><a href="#处理-XSS" class="headerlink" title="处理 XSS"></a>处理 XSS</h3><p><strong>它会执行 JS 代码，有 XSS 漏洞。</strong></p>
<p><strong>如果你只想记这个方法，就得对参数 json 做校验。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">	rx_one.test(</span><br><span class="line">		json.replace(rx_two, <span class="string">"@"</span>).replace(rx_three, <span class="string">"]"</span>).replace(rx_four, <span class="string">""</span>)</span><br><span class="line">	);</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="keyword">var</span> obj = ParseJson(json); <span class="comment">// ParseJson(json) or ParseJsonTwo(json)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Parse-总结"><a href="#Parse-总结" class="headerlink" title="Parse 总结"></a>Parse 总结</h3><p>其实无论在什么时候都不太推荐<code>eval</code>和<code>function</code>，因为它很容造成入侵。<br>如果有兴趣可以去看一下<a href="https://juejin.im/entry/5a98f1ef518825558001a859" target="_blank" rel="noopener">JSON.parse 三种实现方式</a>，它有涉及到递归实现，状态机实现，讲的也不错。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要讲解了<code>JSON.parse/JSON.stringify</code>是怎么实现的<strong>深拷贝</strong>，并且深入了解一下<code>JSON.parse/JSON.stringify</code>在<strong>深拷贝</strong>上的实现，其实还有怎么加速<code>JSON</code>序列化的速度，会在另一篇文章中讲解。最后自己也简单实现了一个<code>ParseJson/StringIfy</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDEyMzA2NQ==&amp;mid=2247484039&amp;idx=1&amp;sn=a2adb13a072b889eec096523ef14ea98&amp;chksm=c0252fd1f752a6c7b56b1fa268c34194a76d72e2be09bb4aa92b630bd7ffac120d82c50011e9&amp;mpshare=1&amp;scene=1&amp;srcid=0817FYhsdmgAzbulSCdGAfOd&amp;sharer_sharetime=1566046217540&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b#rd" target="_blank" rel="noopener">无敌秘籍之 — JavaScript 手写代码</a><br><a href="https://juejin.im/entry/5a98f1ef518825558001a859" target="_blank" rel="noopener">JSON.parse 三种实现方式</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepClone</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝系列 ———— 什么是深拷贝、浅拷贝、Object.assign</title>
    <url>/blog/es/docs/es6-assign.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先我们要了解什么是<code>深拷贝</code>、<code>浅拷贝</code>，要了解<code>深拷贝/浅拷贝</code>首先要了解浅拷贝<code>JavaScript</code>中的数据类型。</p>
<p><code>JavaScript</code>中的数据类型分为两类：</p>
<ul>
<li><code>值类型/原始类型/基本类型：String、Number、Boolean、null、undefined、Symbol</code></li>
<li><code>引用类型/“指针”类型：Object、Array、Window等等</code></li>
</ul>
<p><code>基本类型</code>是储存在栈(stack)中的数据。<br><code>引用类型</code>真实数据是储存在堆中的，而它的引用地址储存在栈中。</p>
<p><img src="./es6-assign/es-assign-1-1.png" alt="深拷贝/浅拷贝"></p>
<p>如果有兴趣了解<code>JavaScript</code>中的类型的话，可以看一下我往期的文章<a href="/blog/javascript/javascript-Type-conversion.html">JavaScript 数据类型（一） 常见数据类型</a>，这个只是其中的一篇，有关<code>JavaScript</code>类型的常见的概念基本上都有提及。</p>
<p><code>基本类型</code>是不存在<code>深拷贝</code>和<code>浅拷贝</code>的，因为<code>基本类型</code>是不可变的，无论是<code>修改</code>、<code>重新赋值</code>、<code>赋值给别的变量</code>都是一个新的值，和原来的值再无关联。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>,</span><br><span class="line">  b = a;</span><br><span class="line">b = <span class="string">'abcd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// abc, abcd</span></span><br></pre></td></tr></table></figure>
<p><code>引用类型</code>因为是地址引用，所以会存在<code>深拷贝</code>和<code>浅拷贝</code>，下面就开始介绍。</p>
<ul>
<li><code>浅拷贝简介</code>: 创建一个新对象，这个对象有着<code>原始对象属性值</code>的一份精确拷贝。如果属性是基本类型，拷贝的就是<code>基本类型的值</code>，如果属性是引用类型，拷贝的就是<code>内存地址</code> ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>
</ul>
<p><img src="./es6-assign/es-assign-1-2.png" alt="深拷贝/浅拷贝"></p>
<ul>
<li><code>深拷贝</code>: 创建一个新的对象把原始对象的<code>所有属性</code>的拷贝一份，并且<code>引用类型的引用地址和内存空间都会被拷贝一份，重新分配内存空间</code>。<code>修改新对象不会影响原始对象</code>。</li>
</ul>
<p><img src="./es6-assign/es-assign-1-3.png" alt="深拷贝/浅拷贝"></p>
<p>本章主要记录<code>深拷贝/浅拷贝</code>，主要讲解浅拷贝相关的如<code>assign、解构、扩展运算符、slice</code>等等，后面的文章会<code>由浅到深的</code>的介绍<code>深拷贝</code>相关的。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>虽然看着<code>浅拷贝</code>比较简单，其实它就是比较简单，但是它相关的东西也不少，下面就开始吧。</p>
<ul>
<li>Object.assign() &amp; 自己实现一个 Object.assign()</li>
<li>Array.prototype.slice()</li>
<li>Array.prototype.concat()</li>
<li>解构</li>
<li>…扩展运算符</li>
<li>jquery.extend()</li>
<li>自己实现一个浅拷贝</li>
</ul>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>语法</code>: <code>Object.assign(target, ...sources)</code>;<br><code>返回值</code>: <code>target对象</code></p>
<p>ES6 中拷贝对象的方法，接受的第一个参数是拷贝的<code>目标target</code>，剩下的参数是拷贝的<code>源对象sources</code>（<code>可以是多个</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">firstname</span>: <span class="string">'target'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">lastname</span>: <span class="string">'source'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> newtarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="comment">// target与newtarget指向同一个内存地址</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget === target); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改newtarget的age属性，target属性也跟着变化，而source不会变化</span></span><br><span class="line">newtarget.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123; lastname: 'source', age: 21 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Object.assgin()第一个传入一个空对象，结果和上方相同</span></span><br><span class="line"><span class="keyword">const</span> newSource = <span class="built_in">Object</span>.assign(&#123;&#125;, source);</span><br><span class="line"><span class="built_in">console</span>.log(newSource); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"></span><br><span class="line">newSource.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newSource); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们可以看到通过<code>Object.assign(target, source);</code>会返回一个新的值<code>newtarget</code>，这个值的引用地址与<code>target</code>是同一个地址，所以修改<code>newtarget.age = 22;</code>后<code>target</code>和<code>newtarget</code>都会变化。<br><code>Object.assign({}, source)</code>返回的<code>newSource</code>它被修改不会影响到<code>source</code>的变化，因为他的<code>target</code>传入的是一个空对象。</p>
<h3 id="自己实现一个-assgin"><a href="#自己实现一个-assgin" class="headerlink" title="自己实现一个 assgin"></a>自己实现一个 assgin</h3><p><strong>实现目标</strong></p>
<ul>
<li>第一个<code>target</code></li>
<li>支持多个对象合并</li>
<li>与 Object.assign 表现一至</li>
</ul>
<p>大致分为下面几步：</p>
<ul>
<li>判断传入<code>target</code>如果不为对象，或者 传入为<code>null</code>时直接返回<code>Object(target)</code></li>
<li>获取所有参数，参数列表转为<code>Array</code>类型</li>
<li>循环上一步生成数组，获取每一个传入的对象</li>
<li>通过 <code>for...in</code>循环上一步获取的对象，并且通过<code>hasOwnProperty</code>判断当前属性是否是本身上的属性（不是原型上的）</li>
<li>上一步通过判断的属性，赋值给<code>target</code>对象</li>
<li>最后返回<code>target</code>对象</li>
</ul>
<p><strong>函数版本</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assign</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 验证第一个参数是否为object</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// arguments转为数组</span></span><br><span class="line">  <span class="keyword">let</span> copyList = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> len = copyList.length;</span><br><span class="line">  <span class="comment">// 循环复制多个对象的属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = copyList[i];</span><br><span class="line">    <span class="comment">// 获取当前对象的属性</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> item) &#123;</span><br><span class="line">      <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">      <span class="keyword">if</span> (item.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="comment">// 复制给目标对象</span></span><br><span class="line">        target[key] = item[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回目标对象</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证assign代码</span></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">firstname</span>: <span class="string">'target'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">lastname</span>: <span class="string">'source'</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> newtarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="comment">// target与newtarget指向同一个内存地址</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget === target); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改newtarget的age属性，target属性也跟着变化，而source不会变化</span></span><br><span class="line">newtarget.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newtarget); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123; lastname: 'source', age: 21 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Object.assgin()第一个传入一个空对象，结果和上方相同</span></span><br><span class="line"><span class="keyword">const</span> newSource = <span class="built_in">Object</span>.assign(&#123;&#125;, source);</span><br><span class="line"><span class="built_in">console</span>.log(newSource); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"></span><br><span class="line">newSource.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123;firstname: "target", age: 21, lastname: "source"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newSource); <span class="comment">// &#123;firstname: "target", age: 22, lastname: "source"&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.defineProperty</strong>版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.newAssign !== <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">'newAssign'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumberable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 验证第一个参数是否为object</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>(target);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// arguments转为数组</span></span><br><span class="line">      <span class="keyword">let</span> copyList = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">let</span> len = copyList.length;</span><br><span class="line">      <span class="comment">// 循环复制多个对象的属性</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = copyList[i];</span><br><span class="line">        <span class="comment">// 获取当前对象的属性</span></span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> item) &#123;</span><br><span class="line">          <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">          <span class="keyword">if</span> (item.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 复制给目标对象</span></span><br><span class="line">            target[key] = item[key];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回目标对象</span></span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">Object</span>.newAssign(<span class="string">'abc'</span>, <span class="literal">false</span>); <span class="comment">// String &#123;"abc"&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="string">'abc'</span>, <span class="literal">false</span>); <span class="comment">// String &#123;"abc"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.newAssign(&#123;&#125;, <span class="string">'abc'</span>); <span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, <span class="string">'abc'</span>); <span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.newAssign(&#123;&#125;, <span class="string">'abc'</span>, <span class="literal">false</span>, <span class="number">123</span>); <span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, <span class="string">'abc'</span>, <span class="literal">false</span>, <span class="number">123</span>); <span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h3><p><code>slice()</code> 方法返回一个新的<code>数组对象</code>，这一对象是一个由 <code>begin</code>和 <code>end</code>（不包括 end）决定的原数组的<code>浅拷贝</code>。原始数组不会被改变。<br><code>slice()</code> 它的定义其实是复制一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> old = [<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'c'</span>, <span class="string">'d'</span>]];</span><br><span class="line"><span class="comment">// 通过slice复制当前数组</span></span><br><span class="line"><span class="keyword">let</span> newValue = old.slice(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// ['a', 'b', ['c', 'd']];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原数组的下标为0的值，新对象没有受到影响，因为下标为0的是基本类型，它们的内存地址是不同的</span></span><br><span class="line">old[<span class="number">0</span>] = <span class="string">'f'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// ['a', 'b', ['c', 'd']];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原数组的下标为2的值，新对象受到影响，因为下标为2的是引用类型，它们的值指向同一个内存地址</span></span><br><span class="line">old[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// ['a', 'b', ['', 'd']];</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h3><p><code>concat()</code> 方法用于<strong>合并两个或多个数组</strong>。此方法<strong>不会更改</strong>现有数组，而是返回一个<strong>新数组</strong>。</p>
<p><strong>语法</strong></p>
<p><code>var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])</code></p>
<p><strong>返回值</strong><br>新的 Array 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> old = [<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'c'</span>, <span class="string">'d'</span>]];</span><br><span class="line"><span class="comment">// 通过concat返回一个新的Array实例</span></span><br><span class="line"><span class="keyword">var</span> newArr = <span class="built_in">Array</span>.prototype.concat([], old);</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// ['a', 'b', ['c', 'd']];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原数组的下标为0的值，新对象没有受到影响，因为下标为0的是基本类型，它们的内存地址是不同的</span></span><br><span class="line">old[<span class="number">0</span>] = <span class="string">'f'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// ['a', 'b', ['c', 'd']];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原数组的下标为2的值，新对象受到影响，因为下标为2的是引用类型，它们的值指向同一个内存地址</span></span><br><span class="line">old[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// ['a', 'b', ['', 'd']];</span></span><br></pre></td></tr></table></figure>
<p><code>concat()</code>它的效果是和<code>slice()</code>相同的。</p>
<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p><strong>解构</strong>是<strong>ES6</strong>中的新特性，它可以方便的<strong>浅复制</strong>一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个对象</span></span><br><span class="line"><span class="keyword">var</span> old = &#123;</span><br><span class="line">  name: <span class="string">'old'</span>,</span><br><span class="line">  attr: &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'man'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过解构复制attr出来，它只复制了内存地址</span></span><br><span class="line"><span class="keyword">var</span> &#123; attr &#125; = old;</span><br><span class="line"><span class="built_in">console</span>.log(attr); <span class="comment">// &#123;age: 18, sex: "man"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原对象的attr值，新对象受到影响</span></span><br><span class="line">old.attr.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(attr); <span class="comment">// &#123;age: 20, sex: "man"&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="…扩展运算符"><a href="#…扩展运算符" class="headerlink" title="…扩展运算符"></a>…扩展运算符</h3><p><code>...扩展运算符</code>也是<strong>ES6</strong>中的新特性，它可以方便的<strong>浅复制</strong>一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个对象</span></span><br><span class="line"><span class="keyword">var</span> old = &#123;</span><br><span class="line">  name: <span class="string">'old'</span>,</span><br><span class="line">  attr: &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'man'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过...扩展运算符，它只复制了内存地址</span></span><br><span class="line"><span class="keyword">var</span> newValue = &#123; ...old &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原对象的attr.age值，新对象受到影响</span></span><br><span class="line">old.attr.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 20, sex: "man"&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="jquery-extend"><a href="#jquery-extend" class="headerlink" title="jquery.extend"></a>jquery.extend</h3><p><code>jquery.extend()</code>是一个浅拷贝，这个在这里就不多做赘述了，如果想看实现原理的话，可以去看<code>jquery</code>github 上的源码实现。</p>
<h3 id="自己实现一个浅拷贝"><a href="#自己实现一个浅拷贝" class="headerlink" title="自己实现一个浅拷贝"></a>自己实现一个浅拷贝</h3><p>实现一个<strong>浅拷贝</strong>其实很简单，大致步骤如下：</p>
<ul>
<li>声明一个新对象</li>
<li>旧对象的属性赋值给新对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">oldObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明新对象</span></span><br><span class="line">  <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 判断传入是否为对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> oldObj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请传入对象'</span>);</span><br><span class="line">    <span class="keyword">return</span> oldObj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环获取传入对象属性</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (oldObj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 把属性复制给新对象</span></span><br><span class="line">      newObj[key] = oldObj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新对象</span></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个对象</span></span><br><span class="line"><span class="keyword">var</span> old = &#123;</span><br><span class="line">  name: <span class="string">'old'</span>,</span><br><span class="line">  attr: &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'man'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 通过shallowCopy</span></span><br><span class="line"><span class="keyword">var</span> newValue = shallowCopy(old);</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始对象的基本类型属性，新对象不受影响</span></span><br><span class="line">old.name = <span class="string">'new'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 18, sex: "man"&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始对象引用类型属性，新对象受到影响</span></span><br><span class="line">old.attr.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newValue); <span class="comment">// &#123;name: "old", attr: &#123;age: 20, sex: "man"&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中我们分别介绍了<strong>深拷贝</strong>、<strong>浅拷贝</strong>是什么。着重介绍了我们日常使用的<strong>浅拷贝</strong>，并且自己实现了一个<code>assign()</code>和一个<code>shallowCopy</code>来加深对浅拷贝的理解，下一篇文件会介绍一个<strong>深拷贝</strong>相关的<code>JSON.stringify()/JSON.parse()</code>并且自己实现一个。</p>
<p>通过上面的实例，可以验证我们对<strong>浅拷贝</strong>的理解是对的，如果是<strong>基本类型</strong>浅拷贝可以把它的值拷贝到新对象中，如果是<strong>引用类型</strong>浅拷贝只能拷贝引用类型的引用地址。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice</a><br><a href="https://mp.weixin.qq.com/s/bvYqA16mU_rRYT1G37onug" target="_blank" rel="noopener">一文搞懂 JS 中的赋值·浅拷贝·深拷贝</a></p>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES系列 ———— Object.defineProperty和Proxy的对比</title>
    <url>/blog/es/docs/es-defineproperty-proxy.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在前两篇文章中分别介绍了<code>Object.defineProperty</code>和<code>Proxy</code>两个新的特性，其实看起来<code>Proxy</code>更像是对<code>Object.defineProperty</code>的一种补充和完善(个人见解)。当然不是说<code>Object.defineProperty</code>很差，感觉更像是一开始的定位是为了处理对象的特定属性，但是在<code>Vue</code>等等框架的中被用来劫持整个对象属性，所以后面就出来了<code>Proxy</code>，更强大的劫持功能。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>根据上面两篇文章的介绍，大致优缺点如下：</p>
<p><strong><em>Proxy 相对于 defineProperty 的优点</em></strong></p>
<ul>
<li>对于对象已有属性：<code>Object.defineProperty</code>只能劫持对象的单个属性，如果想劫持整个对象就要<strong>循环递归</strong>调用<code>Object.defineProperty</code>。而<code>Proxy</code>拦截整个对象，并且返回一下新的对象。</li>
<li>对于对象新增属性：<code>Proxy</code>劫持整个对象，对于新增的属性自动拦截。而<code>Object.defineProperty</code>需要<strong>重新劫持</strong>新增的属性</li>
<li>对于数组操作： <code>Object.defineProperty</code>无法监控到数组下标的变化。而<code>Proxy</code>可以监听数组变化。</li>
<li>拦截或劫持方法： <code>Object.defineProperty</code>描述符基本上分为两类<strong>数据描述符</strong>、<strong>存取描述符</strong>、<strong>通用描述符</strong>三种。而<code>Proxy</code>中有<strong>13</strong>种<strong>traps</strong>方法供你选择。</li>
<li>是否支持取消劫持： <code>Object.defineProperty</code>如果想取消劫持，只能<strong>重写</strong>描述符，但是<strong>configurable: false</strong>时就<strong>不能重写</strong>描述符了。而<code>Proxy</code>可以通过<code>Proxy.revocable</code>返回一个可取消的 <code>Proxy</code> 实例。</li>
<li>浏览器对劫持或拦截的支持： <code>Proxy</code>在后续应该会有更好的支持，不然<code>Vue</code>也不会修改核心代码。</li>
<li>性能： <code>Proxy</code>性能是比<code>Object.defineProperty</code>高的，在多个对象属性中。</li>
</ul>
<p><strong>Proxy 相对于 defineProperty 的缺点</strong></p>
<ul>
<li><code>this指向</code>： <code>defineProperty</code>因为只绑定对象的属性，一般不会涉及到<code>this问题</code>。而<code>Proxy</code>返回的对象的<code>this</code>和<code>target</code>的<code>this</code>不相同。</li>
<li><code>使用难度</code>: 相对于<code>Proxy</code>的<strong>api</strong>，反而<code>defineProperty</code>上手更容易。</li>
</ul>
<p><strong>Proxy 和 defineProperty 的一些注意事项</strong></p>
<ul>
<li><code>对象冻结</code>：无论是<code>defineProperty</code>、<code>Object.freeze</code>、<code>Object.seal（密封）</code>都不是深度冻结，如果想深度冻结只能递归实现。</li>
<li><code>this问题</code>： <code>Proxy</code>在使用是要注意<code>this</code>指向问题。</li>
</ul>
<h2 id="各自实现双向绑定"><a href="#各自实现双向绑定" class="headerlink" title="各自实现双向绑定"></a>各自实现双向绑定</h2><p>现在的三大框架非常的流行，在数据流中分为两派<code>React</code>的单项数据流，<code>Angluar/Vue</code>的双向数据流。其实<code>React</code>也是实现了的<strong>双向数据绑定</strong>的，只不过要通过<code>setState</code>来触发。</p>
<p>在不同框架中实现<strong>双向数据绑定</strong>也是不相同的，大致如下图所示：</p>
<p><a href="../../images/es/es-defineProperty.png">双向绑定</a></p>
<p><code>Object.defineProperty</code>和<code>proxy</code>都是<code>Vue</code>不同版本的重要组成部分，它们都是可以实现双向绑定中的<strong>数据劫持</strong>，其实也就是响应式对象，在以前的文章有<a href="/blog/vue/vue-definedProperty.html">深入 Vue 系列 Vue 中的响应式对象</a>、<br><a href="/blog/vue/vue-dep.html">深入 Vue 系列 Vue 中的依赖收集</a>、<a href="/blog/vue/vue-notify.html">深入 Vue 系列 Vue 中的派发更新</a>，如果感兴趣的可以去看看。</p>
<p>依照<code>Vue</code>代码中的双向绑定思路，大致分为以下三步：</p>
<ul>
<li>把普通对象通过<code>Object.defineProperty</code>变为响应式对象</li>
<li>同时<code>getter</code>中收集依赖，也就是渲染<code>wather</code></li>
<li>在<code>setter</code>中派发更行</li>
</ul>
<p>下面写的实例不会这么复杂，当然也会仿照<code>Vue</code>源码中的<code>mvvm</code>去写。</p>
<h2 id="Object-defineProperty-实现双向绑定"><a href="#Object-defineProperty-实现双向绑定" class="headerlink" title="Object.defineProperty 实现双向绑定"></a>Object.defineProperty 实现双向绑定</h2><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><ul>
<li>劫持对象的<code>get、set</code>属性</li>
<li><code>input</code>事件更新对象值</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Static Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"mv"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"vm"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 对象配置描述符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'value'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get value'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set value'</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'mv'</span>).value = newVal;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'vm'</span>).innerHTML = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// input绑定时间更行对象中的value值</span></span><br><span class="line"><span class="keyword">const</span> InputDom = <span class="built_in">document</span>.getElementById(<span class="string">'mv'</span>);</span><br><span class="line">InputDom.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">  obj.value = event.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这个代码只是简单了实现最简单的效果，在<code>input</code>中输入代码，同时更新到<code>p</code>中。</p>
<h3 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h3><h2 id="Proxy-实现双向绑定"><a href="#Proxy-实现双向绑定" class="headerlink" title="Proxy 实现双向绑定"></a>Proxy 实现双向绑定</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES系列 ———— Proxy</title>
    <url>/blog/es/docs/es6-proxy.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上一篇<a href="/blog/es6/es6-definedproperty.html">ES 系列 Object.defineProperty</a>已经介绍过了<strong>Object.defineProperty</strong>相关内容，这篇文章中会介绍在<strong>Vue 3.x</strong>中代替<code>Object.defineProperty</code>的<code>Proxy</code>。<br>最后会介绍它们之间的<strong>优缺点</strong>和实现<strong>双向绑定简单实例</strong>。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>从字面上可以把<code>Proxy</code>理解为<strong>代理</strong>，但是感觉解释为类似于<strong>代理模式</strong>会更贴合一点。<strong>“阮大佬：Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。”</strong></p>
<p>首先要了解其中的<strong>术语</strong>。</p>
<ul>
<li><code>handler</code>: 包含陷阱（traps）的占位符对象。</li>
<li><code>traps</code>: 提供属性访问的方法。这类似于操作系统中捕获器的概念。</li>
<li><code>target</code>: 代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</li>
</ul>
<p><code>new Proxy(target, handler)</code>方式创建一下新的对象，参数如下：</p>
<ul>
<li><code>target (Object)</code>: 用<code>Proxy</code>包装的目标对象（可以是<strong>任何类型的对象，包括原生数组，函数，甚至另一个代理</strong>）。</li>
<li><code>handler(Object)</code>: 一个对象，其属性是当执行一个操作时定义代理的行为的函数。</li>
</ul>
<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p><code>handler</code> 对象是一个占位符对象，它包含<strong>Proxy</strong>的捕获器。同时<strong>handler</strong>对象包含了用于拦截的<strong>13</strong>种操作。如下：<br>大致可以分为一类<strong>代理对象<code>自身属性</code>操作拦截</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">拦截方法名</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>handler.get(target, property, receiver)</code></td>
<td style="text-align:center">在<strong>读取</strong>代理对象的某个<strong>属性时</strong>触发该操作，比如在执行 <code>proxy.foo</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.set(target, property, value, receiver)</code></td>
<td style="text-align:center">在给代理对象的某个<strong>属性赋值时</strong>触发该操作，比如在执行 <code>proxy.foo = 1</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.has(target, prop)</code></td>
<td style="text-align:center">在判断代理对象<strong>是否拥有某个属性时</strong>触发该操作，比如在执行 <code>&quot;foo&quot; in proxy</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.defineProperty(target, property, descriptor)</code></td>
<td style="text-align:center">在<strong>定义代理对象某个属性时的属性描述时</strong>触发该操作，比如在执行 <code>Object.defineProperty(proxy, &quot;foo&quot;, {})</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.deleteProperty(target, property)</code></td>
<td style="text-align:center">在<strong>删除代理对象的某个属性时</strong>触发该操作，即使用<code>delete</code>运算符，比如在执行 <code>delete proxy.foo</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.getOwnPropertyDescriptor(target, prop)</code></td>
<td style="text-align:center">在<strong>获取代理对象某个属性的属性描述时</strong>触发该操作，比如在执行 <code>Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;)</code> 时。</td>
</tr>
</tbody>
</table>
<!-- - `handler.get(target, property, receiver)`: 在**读取**代理对象的某个**属性时**触发该操作，比如在执行 `proxy.foo` 时。
- `handler.set(target, property, value, receiver)`: 在给代理对象的某个**属性赋值时**触发该操作，比如在执行 `proxy.foo = 1` 时。 -->
<!-- - `handler.has(target, prop)`: 在判断代理对象**是否拥有某个属性时**触发该操作，比如在执行 `"foo" in proxy` 时。 -->
<!-- - `handler.defineProperty(target, property, descriptor)`: 在**定义代理对象某个属性时的属性描述时**触发该操作，比如在执行 `Object.defineProperty(proxy, "foo", {})` 时。 -->
<!-- - `handler.deleteProperty(target, property)`: 在**删除代理对象的某个属性时**触发该操作，即使用`delete`运算符，比如在执行 `delete proxy.foo` 时。
- `handler.getOwnPropertyDescriptor(target, prop)`:在**获取代理对象某个属性的属性描述时**触发该操作，比如在执行 `Object.getOwnPropertyDescriptor(proxy, "foo")` 时。 -->
<p>另一类<strong>代理对象<code>自身</code>操作拦截</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">拦截方法名</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>handler.getPrototypeOf(target)</code></td>
<td style="text-align:center">在<strong>读取代理对象的原型时</strong>触发该操作，比如在执行 <code>Object.getPrototypeOf(proxy)</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.setPrototypeOf(target, prototype)</code></td>
<td style="text-align:center">在<strong>设置代理对象的原型时</strong>触发该操作，比如在执行 <code>Object.setPrototypeOf(proxy, null)</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.isExtensible(target)</code></td>
<td style="text-align:center">在判断一个<strong>代理对象是否是可扩展时</strong>触发该操作，比如在执行 <code>Object.isExtensible(proxy)</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.preventExtensions(target)</code></td>
<td style="text-align:center">在让一个<strong>代理对象不可扩展时</strong>触发该操作，比如在执行 <code>Object.preventExtensions(proxy)</code> 时。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.apply(target, thisArg, argumentsList)</code></td>
<td style="text-align:center">拦截 <strong>Proxy 实例作为函数调用</strong>的操作，比如<code>proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.ownKeys(target)</code></td>
<td style="text-align:center">拦截<code>Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in</code>循环，<strong>返回一个数组</strong>。该方法返回目标对象<strong>所有自身的属性的属性名</strong>，而 Object.keys()的返回结果仅包括<strong>目标对象自身的可遍历属性</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>handler.construct(target, argumentsList, newTarget)</code></td>
<td style="text-align:center">拦截 <strong>Proxy 实例作为构造函数调用</strong>的操作，比如<code>new proxy(...args)</code>。</td>
</tr>
</tbody>
</table>
<!-- - `handler.getPrototypeOf(target)`: 在**读取代理对象的原型时**触发该操作，比如在执行 `Object.getPrototypeOf(proxy)` 时。 -->
<!-- - `handler.setPrototypeOf(target, prototype)`: 在**设置代理对象的原型时**触发该操作，比如在执行 `Object.setPrototypeOf(proxy, null)` 时。 -->
<!-- - `handler.isExtensible(target)`: 在判断一个**代理对象是否是可扩展时**触发该操作，比如在执行 `Object.isExtensible(proxy)` 时。 -->
<!-- - `handler.preventExtensions(target)`: 在让一个**代理对象不可扩展时**触发该操作，比如在执行 `Object.preventExtensions(proxy)` 时。 -->
<!-- - `handler.apply(target, thisArg, argumentsList)`: 拦截 **Proxy 实例作为函数调用**的操作，比如`proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)`。 -->
<!-- - `handler.ownKeys(target)`: 拦截`Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in`循环，**返回一个数组**。该方法返回目标对象**所有自身的属性的属性名**，而Object.keys()的返回结果仅包括**目标对象自身的可遍历属性**。
- `handler.construct(target, argumentsList, newTarget)`: 拦截 **Proxy 实例作为构造函数调用**的操作，比如`new proxy(...args)`。 -->
<p>可以看到<code>Proxy</code>的拦截方法上就比<code>Object.defineProperty</code>的配置多很多，并且在最近的浏览器支持中也是各大浏览器上对<code>Proxy</code>大理支持，优化性能等等。</p>
<h2 id="代理对象自身属性操作拦截"><a href="#代理对象自身属性操作拦截" class="headerlink" title="代理对象自身属性操作拦截"></a>代理对象自身属性操作拦截</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get(target, property, receiver)</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为<strong>目标对象</strong>、<strong>属性名</strong>和 <strong>proxy 实例本身</strong>（<em>严格地说，是操作行为所针对的对象</em>），其中最后一个参数可选。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, property) &#123;</span><br><span class="line">      <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get: name'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'dangdang'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">proxy.name;</span><br><span class="line"><span class="comment">// get: name</span></span><br><span class="line"><span class="comment">// dangdang</span></span><br></pre></td></tr></table></figure>
<p>只要通过<code>proxy.xxx</code>访问了<code>proxy</code>上面的属性，就会触发<code>proxy</code>上配置的<code>get</code>拦截方法。<br>上面这个实例是最简单的实例，其实它可以做很多的事情，举几个例子：</p>
<ul>
<li>实现数组读取负数的索引。</li>
<li>链式操作。</li>
<li>一个生成各种 DOM 节点的通用函数 dom。</li>
</ul>
<h4 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h4><p>该方法会拦截目标对象的以下操作:</p>
<ul>
<li><strong>访问属性: proxy[foo]和 proxy.bar</strong></li>
<li><strong>访问原型链上的属性: Object.create(proxy)[foo]</strong></li>
<li><strong>Reflect.get()</strong></li>
</ul>
<h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li><strong>get 方法可以继承</strong>。</li>
<li><strong>get 第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</strong></li>
<li><strong>一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</strong></li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set(target, property, value, receiver)</code>方法用来拦截某个属性的<strong>赋值</strong>操作，可以接受四个参数，依次为<strong>目标对象</strong>、<strong>属性名</strong>、<strong>属性值</strong>和 <strong>Proxy 实例本身</strong>，其中<strong>最后一个参数可选</strong>。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">set</span>: function (target, property, value, receiver) &#123;</span><br><span class="line">      <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set: dangdang'</span>);</span><br><span class="line">        target[property] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">'dangdang'</span>;</span><br><span class="line"><span class="comment">// set: dangdang</span></span><br><span class="line">proxy.name; <span class="comment">// dangdang</span></span><br></pre></td></tr></table></figure>
<p>只要给<code>proxy</code>的任意属性赋值，就会触发<code>proxy</code>上配置的<code>set</code>拦截方法。<br>当然这个实例是最简单的使用方式，还有其他的用法，举例如下：</p>
<ul>
<li>校验属性是否符合格式（表单验证 validation）</li>
<li>统计函数调用次数</li>
<li>配合 get 设置内部私有属性</li>
</ul>
<h4 id="拦截-1"><a href="#拦截-1" class="headerlink" title="拦截"></a>拦截</h4><p>该方法会拦截目标对象的以下操作:</p>
<ul>
<li><strong>指定属性值: proxy[foo] = bar 和 proxy.foo = bar</strong></li>
<li><strong>指定继承者的属性值: Object.create(proxy)[foo] = bar</strong></li>
<li><strong>Reflect.set()</strong></li>
</ul>
<h4 id="其他特性-1"><a href="#其他特性-1" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li><strong>get 第三个参数，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</strong></li>
<li><strong>若目标属性是不可写及不可配置的，则不能改变它的值。</strong></li>
<li><strong>在严格模式下，若 set 方法返回 false，则会抛出一个 TypeError 异常。</strong></li>
</ul>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has(target, prop)</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。<br><code>has(target, prop)</code>方法可以接受两个参数，分别是<strong>目标对象</strong>、<strong>需查询的属性名</strong>。</p>
<p><strong>返回值</strong></p>
<p><code>has()</code> 方法返回一个 <code>boolean</code> 属性的值.</p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    has: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> proxy; <span class="comment">// true</span></span><br><span class="line"><span class="string">'age'</span> <span class="keyword">in</span> proxy; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>设置<code>has(&#39;name&#39;)</code>返回<code>true</code>再通过<code>in</code>检测时返回<code>true</code>，设置<code>has(&#39;age&#39;)</code>返回<code>false</code>再通过<code>in</code>检测时返回<code>false</code>。<br>当然这个实例是最简单的使用方式，还有其他的用法，举例如下：</p>
<ul>
<li>可以做私有属性</li>
</ul>
<h4 id="拦截-2"><a href="#拦截-2" class="headerlink" title="拦截"></a>拦截</h4><p>这个钩子可以拦截下面这些操作:</p>
<ul>
<li><strong>属性查询: foo in proxy</strong></li>
<li><strong>继承属性查询: foo in Object.create(proxy)</strong></li>
<li><strong>with 检查: with(proxy) { (foo); }</strong></li>
<li><strong>Reflect.has()</strong></li>
</ul>
<h4 id="其他特性-2"><a href="#其他特性-2" class="headerlink" title="其他特性"></a>其他特性</h4><ul>
<li><strong>如果目标对象的某一属性本身不可被配置，则该属性不能够被代理隐藏。会抛出 TypeError。</strong></li>
<li><strong>如果目标对象为不可扩展对象，则该对象的属性不能够被代理隐藏。会抛出 TypeError。</strong></li>
<li><strong>has（）方法不判断一个属性是对象自身的属性，还是继承的属性。</strong></li>
<li><strong>has（）拦截对 for…in 循环不生效。</strong></li>
</ul>
<h3 id="defineProperty（）"><a href="#defineProperty（）" class="headerlink" title="defineProperty（）"></a>defineProperty（）</h3><p><code>defineProperty(target, property, descriptor)</code>方法拦截了<code>Object.defineProperty</code>操作。<br>参数这里就不多做介绍了和<strong>Object.defineProperty</strong>相同，主要关注一下返回值。</p>
<p><strong>返回值</strong></p>
<p><code>defineProperty</code> 方法必须以一个 <code>Boolean</code> 返回，表示定义该属性的操作成功与否。</p>
<p><strong>注意</strong></p>
<ul>
<li>如果目标对象<strong>不可扩展</strong>， 将<strong>不能添加</strong>属性。</li>
<li>不能添加或者修改一个属性为不可配置的，如果它不作为一个目标对象的不可配置的属性存在的话。</li>
<li>如果目标对象存在一个对应的可配置属性，这个属性可能不会是不可配置的。</li>
<li>如果一个属性在目标对象中存在对应的属性，那么 <code>Object.defineProperty(target, prop, descriptor)</code> 将不会抛出异常。</li>
<li>在严格模式下， <code>false</code> 作为 <code>handler.defineProperty</code> 方法的返回值的话将会抛出 <code>TypeError</code> 异常.</li>
</ul>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty(target, property)</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<p><strong>返回值</strong></p>
<p><code>deleteProperty</code> 必须返回一个 <code>Boolean</code> 类型的值，表示了该属性是否被成功删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    deleteProperty: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> proxy.name; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> proxy.age; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>目标对象自身的<strong>不可配置（configurable）的属性</strong>，<strong>不能</strong>被<code>deleteProperty</code>方法删除，否则报错。</li>
</ul>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个<strong>属性描述对象</strong>或者<code>undefined</code>。</p>
<p><strong>返回值</strong></p>
<p><code>getOwnPropertyDescriptor</code> 方法必须返回一个 <code>object</code> 或 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'dangdang'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    getOwnPropertyDescriptor: <span class="function"><span class="keyword">function</span> (<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (property === <span class="string">'name'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, property);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'name'</span>); <span class="comment">// &#123;value: "dangdang", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'age'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="代理对象自身操作拦截"><a href="#代理对象自身操作拦截" class="headerlink" title="代理对象自身操作拦截"></a>代理对象自身操作拦截</h2><h3 id="getPrototypeOf-setPrototypeOf"><a href="#getPrototypeOf-setPrototypeOf" class="headerlink" title="getPrototypeOf()/setPrototypeOf()"></a>getPrototypeOf()/setPrototypeOf()</h3><p><strong>原型相关的操作拦截</strong></p>
<h4 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h4><p><code>getPrototypeOf(target)</code>方法主要用来拦截<strong>获取对象原型</strong>。具体来说，拦截下面这些操作。</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p><strong>返回值</strong></p>
<p><code>getPrototypeOf</code> 方法的返回值必须是<strong>一个对象</strong>或者 <code>null</code>。</p>
<h4 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h4><p><code>setPrototypeOf(target, obj)</code> 方法主要用来拦截 <code>Object.setPrototypeOf(target, obj)</code>。</p>
<p><strong>返回值</strong></p>
<p>如果成功修改了<code>[[Prototype]]</code>, <code>setPrototypeOf</code> 方法返回 <code>true</code>,否则返回 <code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf(target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>如果目标对象不可扩展<code>（non-extensible）</code>，<code>setPrototypeOf</code>方法不得改变目标对象的原型。</p>
<h3 id="preventExtensions-isExtensible"><a href="#preventExtensions-isExtensible" class="headerlink" title="preventExtensions/isExtensible"></a>preventExtensions/isExtensible</h3><p><strong>扩展配置拦截操作</strong></p>
<h4 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h4><p><code>preventExtensions(target)</code> 方法用于设置对<code>Object.preventExtensions()</code>的拦截。</p>
<p><strong>返回</strong></p>
<p><code>preventExtensions</code> 必须返回一个布尔值，否则会被自动转为布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    preventExtensions: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy); <span class="comment">// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    preventExtensions: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Object</span>.preventExtensions(target);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy1); <span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>如果<code>Object.isExtensible(proxy)</code>是<code>false</code>，<code>Object.preventExtensions(proxy)</code>只能返回<code>true</code>。</p>
<h4 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h4><p><code>isExtensible(target)</code> 方法用于拦截对对象的<code>Object.isExtensible()</code>。</p>
<p><strong>返回值</strong></p>
<p><code>isExtensible</code>方法必须返回一个 <code>Boolean</code>值或可转换成<code>Boolean</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    isExtensible: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'called'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//也可以return 1;等表示为true的值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(p)); <span class="comment">// "called"</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    isExtensible: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//return 0;return NaN等都会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p); <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p><code>Object.isExtensible(proxy)</code> 必须同<code>Object.isExtensible(target)</code>返回相同值。也就是必须返回<code>true</code>或者为<code>true</code>的值,返回<code>false</code>和为<code>false</code>的值都会报错。</p>
<h3 id="apply-construct"><a href="#apply-construct" class="headerlink" title="apply/construct"></a>apply/construct</h3><p><strong>改变 this 方式</strong></p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p><code>apply(target, thisArg, argumentsList)</code> 方法用于拦截<strong>函数的调用</strong>、<code>Reflect.apply</code>、<code>call</code>和<code>apply</code>操作。<br><code>apply</code>方法可以接受三个参数，分别是<strong>目标对象</strong>、<strong>被调用时的上下文对象</strong>和<strong>被调用时的参数数组</strong>数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params">target, thisArg, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called:'</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> argumentsList[<span class="number">0</span>] + argumentsList[<span class="number">1</span>] + argumentsList[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// called:1, 2, 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p><code>target</code>必须是可被调用的。也就是说，它<strong>必须是一个函数对象</strong>。</p>
<h4 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h4><p><code>construct(target, argumentsList, newTarget)</code> 方法用于拦截<code>new</code> 操作符. 为了使<code>new</code>操作符在生成的<code>Proxy</code>对象上生效，用于初始化代理的目标对象自身必须具有<code>[[Construct]]</code>内部方法（即 <code>new targe</code>t 必须是有效的）。</p>
<p><strong>参数</strong></p>
<ul>
<li><code>target</code>：目标对象</li>
<li><code>args</code>：构造函数的参数对象</li>
<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的 p）</li>
</ul>
<p><strong>返回值</strong></p>
<p><code>construct</code> 方法<strong>必须返回一个对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span> (<span class="params">target, argumentsList, newTarget</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called: '</span> + argumentsList.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: argumentsList[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> p(<span class="number">1</span>).value); <span class="comment">// "called: 1"</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p><code>ownKeys(target)</code> 方法用于拦截 <code>Reflect.ownKeys()</code>。</p>
<p><strong>返回值</strong></p>
<p><code>ownKeys</code> 方法必须返回<strong>一个可枚举对象</strong>。</p>
<h4 id="拦截-3"><a href="#拦截-3" class="headerlink" title="拦截"></a>拦截</h4><p>该拦截器可以拦截以下操作:</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>Reflect.ownKeys()</code></li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果违反了下面的约束，<code>proxy</code>将抛出错误 <code>TypeError</code>:</p>
<ul>
<li><code>ownKeys</code> 的结果必须是一个数组.</li>
<li>数组的元素类型要么是一个 <code>String</code> ，要么是一个 <code>Symbol</code>.</li>
<li>结果列表必须包含目标对象的所有不可配置<code>（non-configurable ）</code>、自有（<code>own</code>）属性的 key.</li>
<li>如果目标对象不可扩展，那么结果列表必须包含目标对象的所有自有（<code>own</code>）属性的<code>key</code>，不能有其它值。</li>
</ul>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable"></a>Proxy.revocable</h2><p><code>Proxy.revocable</code>方法返回一个可取消的 <code>Proxy</code> 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo; <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>
<p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><strong>注意</strong></p>
<p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 <code>Proxy</code> 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 <code>Proxy</code> 代理的情况下，目标对象内部的<code>this</code>关键字会指向 <code>Proxy</code> 代理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m(); <span class="comment">// false</span></span><br><span class="line">proxy.m(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，一旦<code>proxy</code>代理<code>target.m</code>，后者内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>
<p>下面是一个例子，由于<code>this</code>指向的变化，导致 <code>Proxy</code> 无法代理目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name; <span class="comment">// 'Jane'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 <code>Proxy</code> 也无法代理这些原生对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>getDate</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章记录了<code>Proxy</code>相关的的一些<code>属性访问的方法</code>，它有<strong>13</strong>种方法，大致分为两类：一类<strong>代理对象<code>自身属性</code>操作拦截</strong>，另一类<strong>代理对象<code>自身</code>操作拦截</strong>。</p>
<p>下一篇文章对比<code>defineProterty</code>和<code>Proxy</code>之间的优缺点，用它们实现简单的双线绑定。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">mdn Proxy</a></p>
</blockquote>
<blockquote>
<p><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">阮一峰 Proxy</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES系列 ———— Object.defineProperty</title>
    <url>/blog/es/docs/es6-definedproperty.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果用过<code>VUE</code>框架的话都听说过他的数据观测在<strong>2.x</strong>是是通过<code>Object.defineProperty</code>实现的，其实就是把普通的对象变为<strong>响应式对象</strong>，但是在最近<strong>3.x</strong>中作者要通过<strong>Proxy</strong>重写<code>Vue</code>中的双向绑定核心的<strong>响应式对象</strong>实现，在本篇文章中逐渐了解<code>Object.defineProperty</code>和<code>Proxy</code>是什么，它们之间的区别是什么，和它们之间的有缺点。</p>
<p>如果想了解<code>Vue</code>中的双向对象的实现，请看本站中的<strong>Vue 响应式对象</strong>、<strong>依赖收集</strong>、<strong>派发更新</strong>等等<strong>Vue 源码文章</strong>。</p>
<p>本文章目录：</p>
<ul>
<li><code>Object.defineProperty</code>使用简介</li>
<li><code>Proxy</code>使用简介</li>
<li><code>Object.defineProperty</code>和<code>Proxy</code>之间的区别和优缺点</li>
<li>为什么<code>Vue</code>要重写核心的数据观测实现</li>
<li><code>Object.defineProperty</code>和<code>Proxy</code>实现简单的双向绑定</li>
</ul>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p><strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.6" target="_blank" rel="noopener">ES5</a></strong> 提供了 <code>Object.defineProperty</code> 方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>可以通过<code>Object.defineProperty(obj, prop, descriptor)</code>使用，三个参数分别代表：</p>
<ul>
<li><code>obj(Object)</code>: 要在其上定义属性的对象。</li>
<li><code>prop(String)</code>: 要定义或修改的属性的名称。</li>
<li><code>descriptor(Object)</code>: 将被定义或修改的属性描述符。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明example并且赋值一个对象字面量</span></span><br><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="comment">// 通过Object.defineProperty 定义一个新的属性count，并且给他赋值为一个value</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出example.count的值</span></span><br><span class="line">example.count; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符和存取描述符</strong>。</p>
<p><strong>数据描述符和存取描述符均具有</strong>以下可选键值(默认值是在使用 Object.defineProperty()定义属性的情况下)：</p>
<ul>
<li><code>configurable(Boolean)</code>: 当且仅当该属性的 <code>configurable</code> 为 <code>true</code> 时，该属性<strong>描述符</strong>才能够被改变，同时该属性也能从对应的对象上被删除。<strong>默认为 false</strong>。</li>
<li><code>enumerable(Boolean)</code>: 当且仅当该属性的<code>enumerable</code>为<code>true</code>时，该属性才能够出现在对象的枚举属性中。<strong>默认为 false</strong>。</li>
</ul>
<p><strong>数据描述符同时具有以下可选键值：</strong></p>
<ul>
<li><code>value(任意有效的Javascript值)</code>： 该属性对应的值。<strong>默认为 undefined</strong>。</li>
<li><code>writable(Boolean)</code>: 当且仅当该属性的<code>writable</code>为<code>true</code>时，<code>value</code>才能被赋值运算符改变。<strong>默认为 false</strong>。</li>
</ul>
<p><strong>存取描述符同时具有以下可选键值：</strong></p>
<ul>
<li><code>get(Function 匿名函数)</code>：一个给属性提供 <code>getter</code> 的方法，如果没有 <code>getter</code> 则为 <code>undefined</code>。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入<strong>this</strong>对象（由于继承关系，这里的<strong>this</strong>并不一定是定义该属性的对象）。<strong>默认为 <code>undefined</code></strong>。</li>
<li><code>set(Function 匿名函数)</code>: 一个给属性提供 <code>setter</code> 的方法，如果没有 <code>setter</code> 则为 <code>undefined</code>。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。<strong>默认为 <code>undefined</code></strong>。</li>
</ul>
<p><strong>描述符可同时具有的键值</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>configurable</strong></th>
<th style="text-align:center"><strong>enumerable</strong></th>
<th style="text-align:center"><strong>value</strong></th>
<th style="text-align:center"><strong>writable</strong></th>
<th style="text-align:center"><strong>get</strong></th>
<th><strong>set</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>数据描述符</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>No</strong></td>
<td><strong>No</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>存取描述符</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td style="text-align:center"><strong>No</strong></td>
<td style="text-align:center"><strong>No</strong></td>
<td style="text-align:center"><strong>Yes</strong></td>
<td><strong>Yes</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意事项： 如果一个描述符同时有(<code>value</code>或<code>writable</code>)和(<code>get</code>或<code>set</code>)关键字，将会产生一个异常。</p>
</blockquote>
<p>下面一个一个描述符来通过实例来看一下它真正的效果。</p>
<h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当设置了<code>configurable</code>为<code>false</code>时，就不能在通过<code>defineProperty</code>设置属性描述了。当前的属性不能<strong>删除</strong>、<strong>修改</strong>、<strong>枚举</strong>等。下面请看实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">example.count = <span class="number">2</span>;</span><br><span class="line">example.count; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> example.count;</span><br><span class="line">example.count; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> example) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  wirtable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: count</span></span><br></pre></td></tr></table></figure>
<h3 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h3><p>当设置<code>Enumerable</code>为<code>false</code>时，当前这个属性不能被<code>for...in</code>和<code>Object.keys()</code>枚举。</p>
<h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当设置<code>writable</code>为<code>false</code>时，写入非可写属性<strong>不会改变它</strong>，也<strong>不会</strong>引发错误。</p>
<h3 id="setter-和-getter"><a href="#setter-和-getter" class="headerlink" title="setter 和 getter"></a>setter 和 getter</h3><p><code>get</code> 和 <code>set</code>两个方法在上面是存取属性描述，这两个方法又被称为<code>getter</code>和<code>setter</code>。可以简称为<strong>存取器属性</strong>。</p>
<p>当配置了<code>get</code>和<code>set</code>，就不能配置<code>value</code>和<code>writable</code>因为它们是互斥的，只能设置其中的一组。</p>
<p>当想获取一个属性的值时就会触发设置的<code>get</code>方法，当给一个属性赋值时就会触发<code>set</code>属性。</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;,</span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProterty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了 get 操作'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行了 set 操作'</span>);</span><br><span class="line">    value = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">example.count = <span class="number">1</span>; <span class="comment">// 执行了 set 操作</span></span><br><span class="line">example.count; <span class="comment">// 1 执行了 get 操作</span></span><br></pre></td></tr></table></figure>
<h2 id="其它-Object-defineProperty-相关"><a href="#其它-Object-defineProperty-相关" class="headerlink" title="其它 Object.defineProperty 相关"></a>其它 Object.defineProperty 相关</h2><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h3><p><code>Object.defineProperties()</code>可以同时设置多个<code>Object.defineProperty</code>。</p>
<p><code>Object.defineProperties(obj, props)</code> 方法直接在一个对象上定义新的属性或修改现有属性，并<strong>返回</strong>该对象。参数如下：</p>
<ul>
<li><code>obj(Object)</code>: 在其上定义或修改属性的对象。</li>
<li><code>props(Object)</code>: 一个对象包含多个<strong>属性名:descriptor</strong></li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(example, &#123;</span><br><span class="line">  count1: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  count2: &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h3><p><code>Object.getOwnPropertyNames(Object)</code>方法返回一个由指定对象的<strong>所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组</strong>。</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123; <span class="attr">num</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(example, &#123;</span><br><span class="line">  count1: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  count2: &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(example); <span class="comment">//  ["num", "count1", "count2"]</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h3><p><code>Object.getOwnPropertyDescriptor(obj, prop)</code> 方法返回指定对象上一个<strong>自有属性对应的属性描述符</strong>。<strong>（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</strong>。参数如下：</p>
<ul>
<li><code>obj(Object)</code>: 需要查找的目标对象</li>
<li><code>prop(String)</code>： 目标对象内属性名称</li>
</ul>
<p><strong>返回值</strong><br>如果指定的属性存在于对象上，则返回其属性描述符对象<code>（property descriptor）</code>，否则返回 <code>undefined</code>。</p>
<blockquote>
<p>在 <strong>ES5</strong> 中，如果该方法的第一个参数不是对象（而是原始类型），那么就会产生出现 <code>TypeError</code>。而在 <strong>ES2015</strong>，第一个的参数不是对象的话就会<strong>被强制转换为对象</strong>。</p>
</blockquote>
<h2 id="冻结相关的"><a href="#冻结相关的" class="headerlink" title="冻结相关的"></a>冻结相关的</h2><h3 id="Object-defineProperty-冻结"><a href="#Object-defineProperty-冻结" class="headerlink" title="Object.defineProperty 冻结"></a>Object.defineProperty 冻结</h3><p>当<code>Object.defineProperty(obj, name, { value: 1 })</code>这样设置实，当前属性的<strong>writable</strong>、<strong>configurable</strong>、<strong>enumerable</strong>、都默认为<code>false</code>，可以把当前这个<strong>对象属性</strong>看做是一个冻结对象，那这个对象属性是<strong>深冻结还是浅冻结</strong>呢？</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'count'</span>, &#123;</span><br><span class="line">  value: &#123;</span><br><span class="line">    num: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line">example.count = <span class="number">2</span>;</span><br><span class="line">example.count; <span class="comment">// &#123;num: 1&#125;</span></span><br><span class="line"><span class="comment">// 修改属性下的属性</span></span><br><span class="line">example.count.num = <span class="number">3</span>;</span><br><span class="line">example.count; <span class="comment">// &#123;num: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上面的实例可以判定<code>defineProperty</code>冻结的对象属性，是<strong>浅冻结</strong>对象，如果是<strong>引用类型</strong>是可以修改的。如果想实现<strong>深层冻结</strong>，就需要递归对象所有的属性设置<code>Object.defineProperty()</code>。</p>
<h3 id="Object-freeze-冻结"><a href="#Object-freeze-冻结" class="headerlink" title="Object.freeze 冻结"></a>Object.freeze 冻结</h3><p><code>Object.freeze(obj)</code> 方法可以冻结一个对象。参数如下：</p>
<ul>
<li><code>obj(Object)</code>: 要被冻结的对象。</li>
</ul>
<p>一个被冻结的对象再也<strong>不能被修改</strong>；<br>冻结了一个对象则<strong>不能</strong>向这个对象<strong>添加新的属性</strong>，<strong>不能删除已有属性</strong>，不能修改该对象已有属性的<strong>可枚举性</strong>、<strong>可配置性</strong>、<strong>可写性</strong>，以及不能修改已有属性的值。此外，冻结一个对象后该对象的<strong>原型也不能被修改</strong>。<strong>freeze() 返回和传入的参数相同的对象</strong>。</p>
<p><strong>返回值</strong></p>
<p>被冻结的对象。</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = &#123;</span><br><span class="line">  count: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  num: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(example);</span><br><span class="line"><span class="comment">// 修改值类型无效</span></span><br><span class="line">example.num = <span class="number">11</span>;</span><br><span class="line">example.num; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改引用类型生效</span></span><br><span class="line">example.count[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">example.count; <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图通过 Object.defineProperty 更改属性 抛出 TypeError.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(example, <span class="string">'num'</span>, &#123; <span class="attr">value</span>: <span class="number">11</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也不能更改原型 会抛出 TypeError.</span></span><br><span class="line">example.__proto__ = &#123; <span class="attr">x</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(example, &#123; <span class="attr">x</span>: <span class="number">20</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>通过上面代码可以看出<code>Object.freeze()</code>也是<strong>浅冻结</strong>，如果冻结的对象有多层引用类型嵌套，子属性是可以修改的。如果想实现<strong>深层冻结</strong>，就需要递归对象所有的属性设置<code>Object.freeze()</code>。</p>
<h4 id="冻结数组"><a href="#冻结数组" class="headerlink" title="冻结数组"></a>冻结数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>];</span><br><span class="line"><span class="built_in">Object</span>.freeze(a); <span class="comment">// 现在数组不能被修改了.</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// fails silently</span></span><br><span class="line">a.push(<span class="number">2</span>); <span class="comment">// fails silently</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In strict mode such attempts will throw TypeErrors</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  a.push(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fail();</span><br></pre></td></tr></table></figure>
<h4 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen"></a>Object.isFrozen</h4><p><code>Object.isFrozen(obj)</code>方法判断一个对象是否被冻结。参数如下：</p>
<ul>
<li><code>obj(Object)</code>: 被检测的对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>表示给定对象是否被冻结的<code>Boolean</code>。</p>
<blockquote>
<p><strong>在 ES5 中，如果参数不是一个对象类型，将抛出一个 TypeError 异常</strong>。<br><strong>在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回 true</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isFrozen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isFrozen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// true                          (ES2015 code)</span></span><br></pre></td></tr></table></figure>
<h4 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal"></a>Object.seal</h4><p><code>Object.seal(obj)</code>方法封闭一个对象，<strong>阻止添加新属性并将所有现有属性标记为不可配置</strong>。<strong>当前属性的值只要可写就可以改变</strong>。</p>
<ul>
<li><code>obj(Object)</code>: 将要被密封的对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>被密封的对象。</p>
<blockquote>
<p><strong>在 ES5 中，如果这个方法的参数不是一个（原始）对象，那么它将导致 TypeError</strong>。<br><strong>在 ES2015 中，非对象参数将被视为已被密封的普通对象，会直接返回它</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1                             (ES2015 code)</span></span><br></pre></td></tr></table></figure>
<p>它其他的表现适合<code>Object.freeze</code>是一致的。</p>
<h3 id="实现一个深度冻结"><a href="#实现一个深度冻结" class="headerlink" title="实现一个深度冻结"></a>实现一个深度冻结</h3><p>这里只实现一个简单的<strong>深度冻结</strong>方法，一些<strong>循环引用</strong>、<strong>特殊类型</strong>没有考虑在内，实现如下：</p>
<ul>
<li>递归对象属性，调用冻结方法</li>
<li>返回冻结完成的对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFreeze</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arguments is not object'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> propertyName = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">  propertyName.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[item] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj[item] !== <span class="string">'null'</span>) &#123;</span><br><span class="line">      deepFreeze(obj[item]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> example = deepFreeze(&#123; <span class="attr">example</span>: &#123; <span class="attr">name</span>: <span class="string">'admin'</span> &#125; &#125;);</span><br><span class="line">example.example.name = <span class="number">1</span>;</span><br><span class="line">example.example; <span class="comment">// &#123;name: "admin"&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>因为当前文章写得太长了，所以拆分为三篇博客。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">mdn Object.defineProperty()</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">mdn Object.defineProperties()</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">mdn Object.freeze()</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener">mdn Object.seal()</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>用webpack写一个vue单页面的脚手架</title>
    <url>/blog/vue/cli/webpack-cli-sap.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebPack</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
        <tag>Sap</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 ———— Vue中v-model、sync、$attre/$lisrener、provied/inject修饰符解析</title>
    <url>/blog/vue/effect/vue-vModel-sync.html</url>
    <content><![CDATA[<p><em>上善若水，水善利萬物而不爭。——《道德經》</em></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>在平时开发是经常用到一些父子组件通信，经常用到<code>props</code>、<code>vuex</code>等等，这里面记录另外的三种方式<code>v-model</code>、<code>sync</code>是怎么使用，再说是怎么实现，其实<code>v-model</code>、<code>sync</code>都是语法糖。还有<code>$attr</code>、<code>$listener</code>实现父子组件通信。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><hr>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><blockquote>
<p>2.2.0+ 新增</p>
</blockquote>
<p><code>v-mode1</code>其实就是一个语法糖，默认会利用名为<code>value</code>的<code>props</code>和名为<code>input</code>的事件，但是像单选框、复选框等类型的输入龙剑可能会讲<code>value</code>特性用于不同的目的。</p>
<p><code>v-model</code>的使用场景：当<strong>子组件</strong>需要改变父组件通过<code>props</code>传入的值</p>
<p><strong><em>父组件</em></strong></p>
<ul>
<li>父组件通过<code>v-model</code>绑定值</li>
<li>如需根据<code>v-model</code>传入的值改变，而触发其他更新请通过<code>watch</code>传入的值</li>
</ul>
<p><strong><em>子组件</em></strong></p>
<ul>
<li>声明<code>model</code>对象 设置事件<code>event</code>和<code>prop</code>字段</li>
<li>通过<code>porps</code>接受父组件传送值</li>
<li>修改是通过<code>this.$emit</code>广播事件</li>
</ul>
<p>代码示例：</p>
<p><strong><em>父组件代码</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;children v-model=<span class="string">"message"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import children from "./</span>children.vue<span class="string">";</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    children</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      message: "</span>parent<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  watch: &#123;</span></span><br><span class="line"><span class="string">    // 监听message变化</span></span><br><span class="line"><span class="string">    message(newV, oldV) &#123;</span></span><br><span class="line"><span class="string">      console.log(newV, oldV);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">"message"</span>, <span class="comment">//这个字段，是指父组件设置 v-model 时，将变量值传给子组件的 msg</span></span><br><span class="line">    event: <span class="string">"input"</span> <span class="comment">//这个字段，是指父组件监听 parent-event 事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    message: <span class="built_in">String</span> <span class="comment">//此处必须定义和model的prop相同的props，因为v-model会传值给子组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">//这里模拟异步将msg传到父组件v-model，实现双向控制</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">"input"</span>, <span class="string">"children"</span>);</span><br><span class="line">      <span class="comment">//将这个值通过 emit 触发parent-event，将some传递给父组件的v-model绑定的变量</span></span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这个示例是通过<code>v-model</code>实现的，下面不通过<code>v-model</code>实现同样效果。</p>
<h3 id="不使用-v-model-实现"><a href="#不使用-v-model-实现" class="headerlink" title="不使用 v-model 实现"></a>不使用 v-model 实现</h3><p>代码示例如下：</p>
<p><strong><em>父组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Children :message=<span class="string">"message"</span> @input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 不变</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="comment">// 不变</span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    message: String</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit("input", "children");</span></span><br><span class="line"><span class="regexp">    &#125;, 1500);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p>只是把<code>v-model</code>拆分为<code>props</code>和<code>@input</code>事件，子组件不需要配置<code>model</code>,只需要接受<code>props</code>和通过<code>this.$emit</code>广播事件就可以。<br>当然这个相对于<code>v-model</code>方法比较简便，但是灵活度查很多，选择使用那种看个人喜好。<br>在线地址：</p>
<iframe src="https://codesandbox.io/embed/vue-template-zcvn3?fontsize=14" title="Vue Template" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><blockquote>
<p>2.3.0+ 新增</p>
</blockquote>
<p>在有些情况下，我们可能需要对一个 <code>prop</code> 进行<strong><em>“双向绑定”</em></strong>。不幸的是，真正的<strong>双向绑定</strong>会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p>
<p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。同时也可以通过<code>sync</code>修饰符来实现。</p>
<p>在上面代码的基础上大致修改如下：</p>
<p><strong><em>父组件</em></strong></p>
<ul>
<li>通过修改触发事件<code>input</code>为<code>update:myPropName</code>实现相同效果</li>
</ul>
<p><strong><em>子组件</em></strong></p>
<ul>
<li>通过修改<code>this.$emit(update:myPropName)</code></li>
</ul>
<p>代码如下：</p>
<p><strong><em>父组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改如下</span></span><br><span class="line">&lt;Children :message=<span class="string">"message"</span> @update:input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:input'</span>, <span class="string">'children'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="sync-实现"><a href="#sync-实现" class="headerlink" title="sync 实现"></a>sync 实现</h3><p>上面的代码可以通过<code>sync</code>简写为下面代码：</p>
<p><strong><em>父组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改如下</span></span><br><span class="line">&lt;Children :messag.sync=<span class="string">"message"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码修改</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他不变</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:messag'</span>, <span class="string">'children'</span>);</span><br></pre></td></tr></table></figure>
<p>同时<code>sync</code>也支持对象，要配合<code>v-bind</code>实现可以简写为<code>:</code>，但是要注意这个对象如下两条：</p>
<blockquote>
<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 <code>v-model</code>。<br>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
</blockquote>
<h2 id="attrs、-listeners"><a href="#attrs、-listeners" class="headerlink" title="$attrs、$listeners"></a>$attrs、$listeners</h2><h3 id="attrs"><a href="#attrs" class="headerlink" title="\$attrs"></a>\$attrs</h3><blockquote>
<p>2.4.0 新增</p>
</blockquote>
<ul>
<li>类型：<code>{ [key: string]: string }</code></li>
<li>只读</li>
<li>详细：<br>包含了父作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 <code>prop</code> 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</li>
</ul>
<h3 id="listeners"><a href="#listeners" class="headerlink" title="\$listeners"></a>\$listeners</h3><blockquote>
<p>2.4.0 新增</p>
</blockquote>
<ul>
<li>类型：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></li>
<li>只读</li>
<li>详细：<br>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</li>
</ul>
<h3 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h3><p>实现父子组件通信</p>
<p><strong><em>父组件代码</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;Children</span><br><span class="line">      :message=<span class="string">"message"</span></span><br><span class="line">      @upDate=<span class="string">"upDate"</span></span><br><span class="line">      type=<span class="string">"del"</span></span><br><span class="line">      @input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span></span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Children <span class="keyword">from</span> <span class="string">"./Children"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">"parent"</span>,</span><br><span class="line">      type: <span class="string">"del"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    upDate (event) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(event);</span><br><span class="line">      <span class="keyword">this</span>.type = event;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    message: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"更新message值为"</span> + <span class="keyword">this</span>.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><em>子组件代码</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-bind=<span class="string">"$attrs"</span> v-on=<span class="string">"$listeners"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"children"</span>&gt;&#123;&#123;message&#125;&#125; &lt;span @click=<span class="string">"$listeners.upDate('data')"</span>&gt;&#123;&#123;$attrs.type&#125;&#125;&lt;<span class="regexp">/span&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    message: String</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.log(this.$attrs);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.log(this.$listeners);</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit("input", "children");</span></span><br><span class="line"><span class="regexp">      this.$emit('upDate', 'add')</span></span><br><span class="line"><span class="regexp">    &#125;, 1500);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p>同时<code>$attrs</code>、<code>$listeners</code>都是可以跨域父子组件，可以父子子子组件传递，类似于<code>react</code>中的<code>context</code>，只是一部分设计理念相同。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实就是检测到<code>.sync</code>修饰符，在<code>complier</code>阶段会编译生成多个<code>prop</code>，生成多个<code>事件</code>。其实像这个<strong>指令</strong>、<strong>修饰符</strong>、<strong>自定义指令</strong>都是在<code>vue</code>编译是解析成为<strong>v8</strong>能执行的代码。</p>
<p>无论是<code>vue</code>、<code>babel</code>、<code>react</code>的<code>complier</code>编译阶段大致分为三个阶段：</p>
<ul>
<li>通过词法解析<code>parse</code>生成抽象<code>AST</code>或<code>抽象代码树</code></li>
<li>优化<code>AST</code>,比如<code>vue</code>标记静态节点，<code>babal</code>中抽取静态代码，这个阶段被称为<code>optimize</code>或者<code>优化AST树</code></li>
<li>在<code>AST</code>代码的阶段上，生成可执行代码，这个过程可以叫做<code>codegen</code></li>
</ul>
<p><code>v-model</code>、<code>sync</code>都可以实现父子组件通信，并且可以在子组件中修改父组件传入的值。在平常看法的时候进场可以用到这两种方式，具体选择那种方式看个人喜好。在<code>element-ui</code>这个<code>input</code>组件也用到相关的属性。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener">\$attrs</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model" target="_blank" rel="noopener">自定义组件的-v-model</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-修饰符" target="_blank" rel="noopener">sync-修饰符</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScirpt面试题 ———— 有关原型一道笔试题</title>
    <url>/blog/interview-question/javascript/javascript-prototype.html</url>
    <content><![CDATA[<p><em><strong>慎終如始，則無敗事。——《道德經》</strong></em></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>这道面试题考察的比较综合，也有很多要注意的点，如果知道答案就没有必要往下看了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Preson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.b = [<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">this</span>.a];</span><br><span class="line">  <span class="keyword">this</span>.c = &#123; <span class="attr">demo</span>: <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, <span class="keyword">this</span>.b, <span class="keyword">this</span>.c.demo);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">this</span>.change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b.push(<span class="keyword">this</span>.a);</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="keyword">this</span>.b.length;</span><br><span class="line">    <span class="keyword">this</span>.c.demo = <span class="keyword">this</span>.a++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Preson();</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Preson();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">22</span>;</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure>
<h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><hr>
<p>这道题比较经典考察了<code>JavaScript</code>中很多方面的知识，大致如下几点：</p>
<ul>
<li>prototype 原型、原型链问题</li>
<li>new 改变 this 指向，new 产生实例属性和原型属性</li>
<li>值类型和引用类型</li>
<li>原型继承</li>
</ul>
<p>是一道比较综合的题前四题比较好答，后面的两题想多或者想少了都会出错。这里就对一些知识点不多做赘述，可以查看往期文章了解。<br><strong>往期文章</strong></p>
<blockquote>
<p><a href="/blog/javascript/javascript-Type-conversion.html">JavaScript 类型转换（一） 常见数据类型</a> &gt; <code>...后期添加</code></p>
</blockquote>
<h2 id="结题需要的知识点"><a href="#结题需要的知识点" class="headerlink" title="结题需要的知识点"></a>结题需要的知识点</h2><hr>
<p>大致的知识点如下：</p>
<ol>
<li><strong>构造函数有一个<code>prototype</code>属性指向原型对象，多个实例属性共享一个原型对象</strong></li>
<li><strong>实例中的属性都是独立的互相之间不会影响</strong></li>
<li><strong>每一个实例都有一个隐式原型<code>__proto__</code>指向构造函数的原型对象</strong></li>
<li><strong><code>this</code>的指向问题，大致如下：</strong></li>
</ol>
<ul>
<li>作为对象方法时，谁调用就指向谁</li>
<li><code>new</code>、<code>bind</code>、<code>call</code>、<code>apply</code>都会改变 this 的指向</li>
<li>箭头函数的<code>this</code>从外层普通函数获取</li>
</ul>
<ol start="5">
<li><strong>对象字面量和数组都是引用对象</strong></li>
<li><strong>原型链的查找规则： 就近原则</strong></li>
</ol>
<ul>
<li>当实例上存在属性时， 用实例上的</li>
<li>如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的</li>
<li>如果原型链都不存在，就用 Object 原型对象上的</li>
<li>如果 Object 原型对象都不存在， 就是 undefined</li>
</ul>
<h2 id="第一问-parent-show"><a href="#第一问-parent-show" class="headerlink" title="第一问 parent.show()"></a>第一问 parent.show()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.show();</span><br></pre></td></tr></table></figure>
<p>调用<code>parent.show()</code>的方法，其实就是调用<code>parent</code>实例上的<code>show</code>方法，直接输出<code>1, [1, 2, 1], 5</code>;没什么太多解释的，了解<code>new</code>关键字就可以。</p>
<h2 id="第二问-child1-show-、child2-show"><a href="#第二问-child1-show-、child2-show" class="headerlink" title="第二问 child1.show()、child2.show()"></a>第二问 child1.show()、child2.show()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure>
<p>首相要了解下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Preson();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">22</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码把<code>Child.prototype</code>指向一个<code>Preson</code>的实例，可以知道<code>Child.prototype.__proto__</code>指向<code>Preson.prototype</code>;<code>Child.prototype.constructor</code>指向<code>Preson</code>。下面是验证代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype.__proto__ === Preson.prototype; <span class="comment">// true</span></span><br><span class="line">Child.prototype.constructor === Preson; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>child1</code>、<code>child2</code>的结构如下图所示：<br><img src="../../../images/interviewquestion/javascript-prototype-1-1.png" alt="javascript-prototype"></p>
<p><code>child1</code>、<code>child2</code>都是<code>Child</code>构造函数实例化产生的，所以<code>child1.show() child2.show()</code>是调用的<code>Child.prototype</code>上的方法，但是注意<code>child1</code>、<code>child2</code>的对象上都声明了一个新属性<code>a</code>。<br>根据上面第<code>6</code>条知识点可知结果为<code>11, [1, 2, 1], 5)</code>、<code>12, [1, 2, 1], 5</code>；</p>
<p><strong>注意</strong><br>从代码上看<code>child1.__proto__.b</code>数组的第三项是指向<code>child1.__proto__.a</code>的，那我们此时修改<code>child1.__proto__.a</code>的值，是否会影响<code>child1.show()</code>的结果呢:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child1.__proto__.a = <span class="number">12123</span>;</span><br><span class="line">child1.show(); <span class="comment">// 11, [1, 2, 1], 5</span></span><br></pre></td></tr></table></figure>
<p>是没有影响的，因为<code>parent</code>实例生成的时候，<code>this.a</code>指向了一个原始值<code>2</code>,所以<code>this.b</code>中的第三项实际上是被赋值了一个<strong>原始值</strong>，故此处乍看起来像是<strong>引用类型</strong>的赋值，实则不是。<strong>原始值赋值会开辟新的存储空间</strong>，使得<code>this.a</code>和<code>this.b[2]</code>的值相等，但是却指向了堆内存里的不同地址。</p>
<h2 id="第三问-parent-show"><a href="#第三问-parent-show" class="headerlink" title="第三问 parent.show()"></a>第三问 parent.show()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.show();</span><br></pre></td></tr></table></figure>
<p>根据上面第<code>2</code>条知识点，可知<code>preson</code>和<code>Child</code>是<code>Person</code>的不同的实例，它们之间不会相互影响，所以它的经过不会更改为<code>1, [1, 2, 1], 5</code>。</p>
<h2 id="第四问-child1-show-、child2-show"><a href="#第四问-child1-show-、child2-show" class="headerlink" title="第四问 child1.show()、child2.show()"></a>第四问 child1.show()、child2.show()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面执行了</span></span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line"></span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure>
<p><code>child1.change()</code>执行了<code>change()</code>时执行过程如下：</p>
<p><strong><code>this.b.push(this.a)</code></strong><br>由于<code>this</code>的动态指向特性，<code>this.b</code>会指向<code>Child.prototype</code>上的<code>b</code>数组,<code>this.a</code>会指向<code>child1</code>的<code>a</code>属性,所以<code>Child.prototype.b</code>变成了<code>[1,2,1,11]</code>;</p>
<p><strong><code>this.a = this.b.length</code></strong><br><code>this.b.length</code>经过上一步的添加了一条数据变为了<code>4</code>，所以当前的<code>this.a</code>就是<code>4</code>。</p>
<p><strong><code>this.c.demo = this.a++;</code></strong><br><code>this.a</code>是<code>4</code>，<code>this.c.demo</code>的值被复制为<code>4</code>，不要忽略<code>this.a++</code>以后的值变为了<code>5</code>。</p>
<p><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果</p>
<p><code>child2.change()</code>执行了<code>change()</code>时执行过程如下：<br><strong><code>this.b.push(this.a)</code></strong><br>由于<code>this</code>的动态指向特性，<code>this.b</code>会指向<code>Child.prototype</code>上的<code>b</code>数组,<code>this.a</code>会指向<code>child2</code>的<code>a</code>属性,所以<code>Child.prototype.b</code>变成了<code>[1,2,1,11,12]</code>;</p>
<p><strong><code>this.a = this.b.length</code></strong><br><code>this.b.length</code>经过上一步的添加了一条数据变为了<code>5</code>，所以当前的<code>this.a</code>就是<code>5</code>。</p>
<p><strong><code>this.c.demo = this.a++;</code></strong><br><code>this.a</code>是<code>5</code>，<code>this.c.demo</code>的值被复制为<code>5</code>，不要忽略<code>this.a++</code>以后的值变为了<code>6</code>。</p>
<p>所以会输出如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child1.show(); <span class="comment">// 5, [1,2,1,11,12], 5</span></span><br><span class="line">child2.show(); <span class="comment">// 6, [1,2,1,11,12], 5</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>前端的所有知识都是比较零散的，所以尽量要建立自己的知识结构图才方便以后的查漏补缺</li>
<li>因为知识比较零散不便于记忆，最好多找几个切入点把零散的知识串联起来更容易记住</li>
<li>没有别的办法多写、多看、多记一遍不行就直到记住为止</li>
</ol>
<blockquote>
<p>值类型变量赋值给引用类型时，改变值类型变量的值并不会影响赋值给引用类型中的值，</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, test];</span><br><span class="line">test = <span class="number">2222</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4, 111];</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/dashnowords/p/9404237.html" target="_blank" rel="noopener">javascript 基础修炼(1)——一道十面埋伏的原型链面试题</a><br><a href="https://www.php.cn/js-tutorial-410582.html" target="_blank" rel="noopener">javascript 原型链的一道面试题的分析（详细）</a></p>
]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>深入element-ui组件 ———— input组件</title>
    <url>/blog/vue/ui/vue-element-input.html</url>
    <content><![CDATA[<p><strong><em>察见渊鱼者不详，智料隐匿者有殃。——《列子·说符》</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>在日常开发<code>PC</code>管理端界面的时候，会用到<strong>element-ui</strong>或者<strong>iview</strong>ui 框架，比较常用的<code>input</code>组件是怎么封装的呢，以<code>element-ui</code>框架的<code>input</code>组件为例，分析一下它是怎么封装实现的，也可以为以后自己封装框架提供思路。</p>
<p>因为代码还是挺多的，主要分析几个点：</p>
<ul>
<li>支持<strong>前置内容</strong>、<strong>后置内容</strong>、<strong>后置元素</strong></li>
<li>支持所有原声的<code>type</code>，并且可以切换<code>password</code>模式</li>
<li>支持<code>readonly</code>、<code>disabled</code>、<code>autocomplete</code>、<code>maxlength</code>、<code>minlength</code>等等</li>
<li>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code></li>
<li><code>element-ui</code>是怎么做到类似与<code>vue</code>的双向绑定的</li>
<li><code>type</code>为<code>textare</code>模式时，做到<code>calcTextareaHeight</code></li>
</ul>
<p>下面就一步一步分下，主要的点会着重分析，比较简单或者比较不重要的点会快速带过。</p>
<p>源码参考<a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/input.vue" target="_blank" rel="noopener">element-ui input</a></p>
<h2 id="前置、后置"><a href="#前置、后置" class="headerlink" title="前置、后置"></a>前置、后置</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"type !== 'textarea'"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 前置元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"el-input-group__prepend"</span> <span class="attr">v-if</span>=<span class="string">"$slots.prepend"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"prepend"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 前置内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"el-input__prefix"</span> <span class="attr">v-if</span>=<span class="string">"$slots.prefix || prefixIcon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"prefix"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-input__icon"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-if</span>=<span class="string">"prefixIcon"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:class</span>=<span class="string">"prefixIcon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  // 主题代码 省略</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 后置内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-input__suffix"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"getSuffixVisible()"</span>&gt;</span></span><br><span class="line">    // 省略内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 后置元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"el-input-group__append"</span> <span class="attr">v-if</span>=<span class="string">"$slots.append"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"append"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  // 省略内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码可以首先通过<code>type</code>区分开<code>textarea</code>单独处理，<strong>前后置</strong>又分为两类：</p>
<ul>
<li>一类直接通过<code>prop</code>传入<code>prefix-icon</code>、<code>suffix-icon</code>传入前后置<code>icon-class</code>显示不同的内容</li>
<li>另一类是通过<code>vue</code>中的内容分发机制<code>slot</code>显示不同的内容，更灵活</li>
</ul>
<p>在后置内容中也会处理<code>clearable</code>、<code>PwdVisible</code>、<code>show-word-limit</code>显示不同的内容。</p>
<h2 id="原声-type、其它原声属性"><a href="#原声-type、其它原声属性" class="headerlink" title="原声 type、其它原声属性"></a>原声 type、其它原声属性</h2><p>以<code>input</code>为例，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 其它地方省略</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:tabindex</span>=<span class="string">"tabindex"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">"type !== 'textarea'"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind</span>=<span class="string">"$attrs"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:type</span>=<span class="string">"showPassword ? (passwordVisible ? 'text': 'password') : type"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:disabled</span>=<span class="string">"inputDisabled"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:readonly</span>=<span class="string">"readonly"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:autocomplete</span>=<span class="string">"autoComplete || autocomplete"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"input"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionstart</span>=<span class="string">"handleCompositionStart"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionupdate</span>=<span class="string">"handleCompositionUpdate"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">compositionend</span>=<span class="string">"handleCompositionEnd"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">"handleInput"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">"handleFocus"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"handleBlur"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">change</span>=<span class="string">"handleChange"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:aria-label</span>=<span class="string">"label"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line">// 其它地方省略</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 其它地方省略</span></span></span><br><span class="line"><span class="javascript">      disabled: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      readonly: <span class="built_in">Boolean</span>,</span></span><br><span class="line">      autocomplete: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">'off'</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">/** @Deprecated in next major version */</span></span></span><br><span class="line">      autoComplete: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line">        validator(val) &#123;</span><br><span class="line"><span class="javascript">          process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.warn(</span></span><br><span class="line"><span class="javascript">              <span class="string">"[Element Warn][Input]'auto-complete' property will be deprecated in next major version. please use 'autocomplete' instead."</span></span></span><br><span class="line">            );</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="comment">// 其它地方省略</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里先不关注事件，只关注属性的设置，<code>element-ui</code>支持所有<code>input</code>原声的属性，其实就是通过<code>prop</code>传入<code>type</code>传入，如果是非<code>password</code>就直接赋值给<code>input</code>标签的<code>type</code>属性。<br>如果是<code>password</code>类型判断是否传入<code>show-password</code>字段，根据传入判断给<code>input</code>的<code>type</code>复制为<code>password</code>或者<code>text</code>。</p>
<h2 id="其它原声属性"><a href="#其它原声属性" class="headerlink" title="其它原声属性"></a>其它原声属性</h2><p>其它属性如<code>disabled</code>、<code>readonly</code>、<code>autocomplete</code>都是通过显示的<code>prop</code>传入，哪像一些没有显示接受的<code>prop</code>怎么获取到的呢，比如说<code>maxlength</code>、<code>minlength</code>这种没有显示接收的怎么获取到的呢。<br>是通过<code>v-bind=&quot;$attrs&quot;</code>获取到的，使用的时候直接通过<code>this.$attrs.XXXX</code>就可以使用对应的属性。<code>element-ui</code>中在检测输入长度是否超过设置的长度是有使用到如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略部分代码</span></span><br><span class="line">isWordLimitVisible() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.showWordLimit &amp;&amp;</span><br><span class="line">    <span class="keyword">this</span>.$attrs.maxlength &amp;&amp;</span><br><span class="line">    (<span class="keyword">this</span>.type === <span class="string">'text'</span> || <span class="keyword">this</span>.type === <span class="string">'textarea'</span>) &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.inputDisabled &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.readonly &amp;&amp;</span><br><span class="line">    !<span class="keyword">this</span>.showPassword;</span><br><span class="line">&#125;,</span><br><span class="line">upperLimit() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$attrs.maxlength;</span><br><span class="line">&#125;,</span><br><span class="line">textLength() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.value === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(<span class="keyword">this</span>.value).length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value || <span class="string">''</span>).length;</span><br><span class="line">&#125;,</span><br><span class="line">inputExceed() &#123;</span><br><span class="line">  <span class="comment">// show exceed style if length of initial value greater then maxlength</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isWordLimitVisible &amp;&amp;</span><br><span class="line">    (<span class="keyword">this</span>.textLength &gt; <span class="keyword">this</span>.upperLimit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 忽略部分代码</span></span><br></pre></td></tr></table></figure>
<p>如果不太了解<code>v-bind=&quot;$attrs&quot;</code>的使用可以看我另一篇文章<a href="/blog/vue/vue-vModel-sync.html">Vue 中 v-model 解析、sync 修饰符解析</a></p>
<h2 id="原声事件、双向绑定"><a href="#原声事件、双向绑定" class="headerlink" title="原声事件、双向绑定"></a>原声事件、双向绑定</h2><p>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code>。</p>
<p>常用的时间就不用多做介绍了，就是比较新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code>是用来出里一段文字输入的事件。详细信息请看：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart" target="_blank" rel="noopener">compositionstart</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionupdate" target="_blank" rel="noopener">compositionupdate</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionend" target="_blank" rel="noopener">compositionend</a></p>
<p>在外层就可以监听的到<code>input</code>标签的<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>事件，是因为组件内部在每一个方法中都有一个<code>this.$emit(&#39;input/focus/blur/change&#39;, evnet.target.value/event)</code>。</p>
<p>那是怎么做到修改外层通过<code>v-model</code>绑定的值的呢？</p>
<p>要想了解他是怎么实现双向绑定的就要了解<code>v-model</code>是什么，<code>v-model</code>其实就是一个语法糖，在<code>vue</code>编译阶段就会解析为<code>:value=&quot;绑定的值&quot;</code>和默认的<code>@input=(value) =&gt; {绑定的值 = value}</code>。然后再是在<code>input</code>标签上绑定的<code>handleInput</code>方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleInput(event) &#123;</span><br><span class="line">  <span class="comment">// should not emit input during composition</span></span><br><span class="line">  <span class="comment">// see: https://github.com/ElemeFE/element/issues/10516</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isComposing) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// hack for https://github.com/ElemeFE/element/issues/8548</span></span><br><span class="line">  <span class="comment">// should remove the following line when we don't support IE</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.value === <span class="keyword">this</span>.nativeInputValue) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, event.target.value);</span><br><span class="line">  <span class="comment">// ensure native input value is controlled</span></span><br><span class="line">  <span class="comment">// see: https://github.com/ElemeFE/element/issues/12850</span></span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="keyword">this</span>.setNativeInputValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里<code>input</code>的组件的属性基本上就解释完成，<code>textare</code>基本上都是一样的，但是<code>textarea</code>有一点特殊的操作。</p>
<h2 id="textarea-高度自适应"><a href="#textarea-高度自适应" class="headerlink" title="textarea 高度自适应"></a>textarea 高度自适应</h2><p>它是怎么实现高度自适应的，具体的实现代码是在<a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/calcTextareaHeight.js" target="_blank" rel="noopener">calcTextareaHeight</a>，大致分为几部：</p>
<ul>
<li>创建一个临时隐藏的<code>textarea</code>元素</li>
<li>通过隐藏的<code>textarea</code>计算显示的<code>textarea</code>元素的高度</li>
<li>并且判断<code>minRows</code>、<code>maxRows</code>属性</li>
<li>最后删除<code>textarea</code>元素，并且清空<code>dom</code>引用</li>
</ul>
<p>在<code>input</code>组件中通过创建<code>watch</code>监听<code>value</code>值的变化，每次<code>value</code>变化从新计算<code>textarea</code>元素的高度。</p>
<p><strong>创建一个临时隐藏的<code>textarea</code>元素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hiddenTextarea;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="comment">// 保证只执行一次</span></span><br><span class="line"><span class="keyword">if</span> (!hiddenTextarea) &#123;</span><br><span class="line">  <span class="comment">// 创建textarea</span></span><br><span class="line">  hiddenTextarea = <span class="built_in">document</span>.createElement(<span class="string">'textarea'</span>);</span><br><span class="line">  <span class="comment">// 添加到页面中</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(hiddenTextarea);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure>
<p><strong>通过隐藏的<code>textarea</code>计算显示的<code>textarea</code>元素的高度</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HIDDEN_STYLE = <span class="string">`</span></span><br><span class="line"><span class="string">  height:0 !important;</span></span><br><span class="line"><span class="string">  visibility:hidden !important;</span></span><br><span class="line"><span class="string">  overflow:hidden !important;</span></span><br><span class="line"><span class="string">  position:absolute !important;</span></span><br><span class="line"><span class="string">  z-index:-1000 !important;</span></span><br><span class="line"><span class="string">  top:0 !important;</span></span><br><span class="line"><span class="string">  right:0 !important</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONTEXT_STYLE = [</span><br><span class="line">  <span class="string">'letter-spacing'</span>,</span><br><span class="line">  <span class="string">'line-height'</span>,</span><br><span class="line">  <span class="string">'padding-top'</span>,</span><br><span class="line">  <span class="string">'padding-bottom'</span>,</span><br><span class="line">  <span class="string">'font-family'</span>,</span><br><span class="line">  <span class="string">'font-weight'</span>,</span><br><span class="line">  <span class="string">'font-size'</span>,</span><br><span class="line">  <span class="string">'text-rendering'</span>,</span><br><span class="line">  <span class="string">'text-transform'</span>,</span><br><span class="line">  <span class="string">'width'</span>,</span><br><span class="line">  <span class="string">'text-indent'</span>,</span><br><span class="line">  <span class="string">'padding-left'</span>,</span><br><span class="line">  <span class="string">'padding-right'</span>,</span><br><span class="line">  <span class="string">'border-width'</span>,</span><br><span class="line">  <span class="string">'box-sizing'</span></span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateNodeStyling</span>(<span class="params">targetElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> style = <span class="built_in">window</span>.getComputedStyle(targetElement);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> boxSizing = style.getPropertyValue(<span class="string">'box-sizing'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paddingSize =</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'padding-bottom'</span>)) +</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'padding-top'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> borderSize =</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'border-bottom-width'</span>)) +</span><br><span class="line">    <span class="built_in">parseFloat</span>(style.getPropertyValue(<span class="string">'border-top-width'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> contextStyle = CONTEXT_STYLE.map(</span><br><span class="line">    (name) =&gt; <span class="string">`<span class="subst">$&#123;name&#125;</span>:<span class="subst">$&#123;style.getPropertyValue(name)&#125;</span>`</span></span><br><span class="line">  ).join(<span class="string">';'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; contextStyle, paddingSize, borderSize, boxSizing &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="keyword">let</span> &#123; paddingSize, borderSize, boxSizing, contextStyle &#125; = calculateNodeStyling(</span><br><span class="line">  targetElement</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">hiddenTextarea.setAttribute(<span class="string">'style'</span>, <span class="string">`<span class="subst">$&#123;contextStyle&#125;</span>;<span class="subst">$&#123;HIDDEN_STYLE&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 设置value</span></span><br><span class="line">hiddenTextarea.value = targetElement.value || targetElement.placeholder || <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 获取隐藏textarea滚动整体高度</span></span><br><span class="line"><span class="keyword">let</span> height = hiddenTextarea.scrollHeight;</span><br><span class="line"><span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"><span class="comment">// 判断盒模型</span></span><br><span class="line"><span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果为border-box本身的高度加上borderSize</span></span><br><span class="line">  height = height + borderSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (boxSizing === <span class="string">'content-box'</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果为content-box本身的高度加上paddingSize</span></span><br><span class="line">  height = height - paddingSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把隐藏textarea的vlaue设置为空</span></span><br><span class="line">hiddenTextarea.value = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 获取每行高度： row的高度为滚动高度-padding</span></span><br><span class="line"><span class="keyword">let</span> singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure>
<p><strong>并且判断<code>minRows</code>、<code>maxRows</code>属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="comment">// 判断是否有设置minRows</span></span><br><span class="line"><span class="keyword">if</span> (minRows !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 最小高度 = 每行高度 * 最小行数</span></span><br><span class="line">  <span class="keyword">let</span> minHeight = singleRowHeight * minRows;</span><br><span class="line">  <span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果boxSizing为border-box时： 最小高度 = 原最小高度 + padding + border;</span></span><br><span class="line">    minHeight = minHeight + paddingSize + borderSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取当前计算的最小高度和上面计算出的scrollHeight度中的最大值</span></span><br><span class="line">  height = <span class="built_in">Math</span>.max(minHeight, height);</span><br><span class="line">  <span class="comment">// 赋值给result.minHeight</span></span><br><span class="line">  result.minHeight = <span class="string">`<span class="subst">$&#123;minHeight&#125;</span>px`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否有设置maxRows</span></span><br><span class="line"><span class="keyword">if</span> (maxRows !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 最大高度 = 每行高度 * 最大行数</span></span><br><span class="line">  <span class="keyword">let</span> maxHeight = singleRowHeight * maxRows;</span><br><span class="line">  <span class="keyword">if</span> (boxSizing === <span class="string">'border-box'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果boxSizing为border-box时： 最小高度 = 原最小高度 + padding + border;</span></span><br><span class="line">    maxHeight = maxHeight + paddingSize + borderSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取当前计算的最大高度和上面计算出的scrollHeight度中的最小值</span></span><br><span class="line">  height = <span class="built_in">Math</span>.min(maxHeight, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值给result.minHeight</span></span><br><span class="line">result.height = <span class="string">`<span class="subst">$&#123;height&#125;</span>px`</span>;</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br></pre></td></tr></table></figure>
<p><strong>最后删除<code>textarea</code>元素，并且清空<code>dom</code>引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果存在parentNode 就清除parentNode包含的hiddenTextarea 元素</span></span><br><span class="line">hiddenTextarea.parentNode &amp;&amp;</span><br><span class="line">  hiddenTextarea.parentNode.removeChild(hiddenTextarea);</span><br><span class="line"><span class="comment">// 清空dom引用释放变量</span></span><br><span class="line">hiddenTextarea = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 返回最小高度和最大高度</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>到此<code>textarea</code>结束，可能还有很多细节没有记录到，如果有什么意见请评论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整篇文章都是根据几点分析的，如下：</p>
<ul>
<li>支持<strong>前置内容</strong>、<strong>后置内容</strong>、<strong>后置元素</strong></li>
<li>支持所有原声的<code>type</code>，并且可以切换<code>password</code>模式</li>
<li>支持<code>readonly</code>、<code>disabled</code>、<code>autocomplete</code>、<code>maxlength</code>、<code>minlength</code>等等</li>
<li>支持常规<code>input</code>、<code>focus</code>、<code>blur</code>、<code>change</code>，支持新事件<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code></li>
<li><code>element-ui</code>是怎么做到类似与<code>vue</code>的双向绑定的</li>
<li><code>type</code>为<code>textare</code>模式时，做到<code>calcTextareaHeight</code></li>
</ul>
<p>当然还有很多的点没有记录到比如说<code>clear</code>、<code>emitter</code>、<code>Migrating</code>等等，这个会在后面的文章中着重介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/input.vue" target="_blank" rel="noopener">element-ui input</a><br><a href="https://github.com/ElemeFE/element/blob/dev/packages/input/src/calcTextareaHeight.js" target="_blank" rel="noopener">element-ui calcTextareaHeight</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Array系列(三) Array中的forEach方法可以用break、continue跳出循环？</title>
    <url>/blog/es/interview-question/es6-Array-break-continue.html</url>
    <content><![CDATA[<p><strong><em>飄風不終朝，驟雨不終日。——《道德經》</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>在<code>Array.prototype</code>上有很多方法，比较常用的就是<code>every</code>、<code>filter</code>、<code>forEach</code>、<code>map</code>、<code>some</code>这些循环方法，可以通过<code>break</code>、<code>comtinue</code>跳出循环？<br>现在基本上都是通过<code>forEach</code>、<code>every</code>来代替<code>for</code>循环，<code>for</code>循环可以通过<code>break</code>、<code>continue</code>跳出循环。而 forEach 可以不可以呢，下面一步一步的验证一下。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><hr>
<p>在<code>for</code>中遇到<code>break</code>就会退出当前循环，后面的循环不会再执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">'-'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure>
<p>在<code>for</code>中遇到<code>continue</code>就会退出当前本次循环，后面的循环会执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">'-'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>for</code>中不能使用 return，不然会报错</p>
</blockquote>
<h2 id="forEach、every、some、filter、map"><a href="#forEach、every、some、filter、map" class="headerlink" title="forEach、every、some、filter、map"></a>forEach、every、some、filter、map</h2><hr>
<p>如果想退出<code>forEach</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">'-'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<p>如果想退出<code>every</code>，就只能通过<code>return</code>, 它会退出当前循环，后面的循环不会再执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line">arr.every(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">'-'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure>
<p>如果想退出<code>some</code>，就只能通过<code>return</code>, <code>return false</code>和<code>return true</code>它的表现是不一致的。<code>return false</code>它的表现和<code>forEach</code>中的表现一致。 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">'-'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<p><code>return true</code>和<code>every</code>表现一致，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">'-'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-</span></span><br></pre></td></tr></table></figure>
<p>如果想退出<code>filter</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line">arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">'-'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<p>如果想退出<code>map</code>，就只能通过<code>return</code>, 它会退出当前本次循环，后面的循环会执行。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line">arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str += item + <span class="string">'-'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1-3-4-5-</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>forEach</code>、<code>every</code>、<code>some</code>中不能用<code>break</code>、<code>continue</code>跳出循环，不然会报错。</p>
</blockquote>
<p>都知道<code>filter</code>、<code>map</code>会返回一个新的数组，而<code>every</code>、<code>some</code>会返回一个<code>Boolean</code>类型的。</p>
<h2 id="some-和-every-需要注意的地方"><a href="#some-和-every-需要注意的地方" class="headerlink" title="some 和 every 需要注意的地方"></a>some 和 every 需要注意的地方</h2><hr>
<p><code>some()</code> 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个 Boolean 类型的值。<code>polyfill</code>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.some = <span class="function"><span class="keyword">function</span> (<span class="params">callbackfn, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = <span class="built_in">Number</span>(<span class="keyword">this</span>.length);</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">let</span> Pk = <span class="built_in">String</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (Pk <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = <span class="keyword">this</span>[Pk];</span><br><span class="line">      <span class="keyword">if</span> (callbackfn.call(thisArg, kValue, k, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，遇到回调返回值是 <code>true</code> 的话，函数就直接返回、结束了。这是种短路算法，并不是所有回调都执行一遍，然后再最后求所有与值。<code>every</code> 也类似，不过与之相反，遇到回调返回值是 <code>false</code> 时，整体就直接返回 <code>false</code> 了。<br>从实现上表达出的语义来讲，<code>some</code> 是在说：<strong>有一个成功，我就成功，而 <code>every</code> 是在说：有一个失败，我就失败</strong><br><strong>另外要强调一点，对于稀疏数组，不存在的索引值时，回调函数是不执行的</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">Array.prototype.some()</a> &gt; <a href="https://juejin.im/post/5d08a565e51d45773d468614#heading-2" target="_blank" rel="noopener">不再写 break 和 continue 了</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Array系列(四) Array常用的方法和实现reduce、map、filter、forEach</title>
    <url>/blog/es/interview-question/es6-Array-function.html</url>
    <content><![CDATA[<p><strong><em>挫其銳，解其紛，和其光，同其塵。</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><code>Array.prototype</code>上有很多方法，可以很方便的实现各种循环、过滤对数组做很多的处理，这里主要记录自己怎么实现几个方法<code>map</code>、<code>forEach</code>、<code>filter</code>、<code>reduce</code>，怎么使用就不多做讲解了因为在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">mdn 中 Array</a>或者别人的文章中有很多的讲解了。</p>
<h2 id="实现-reduce"><a href="#实现-reduce" class="headerlink" title="实现 reduce"></a>实现 reduce</h2><hr>
<p>首先要了解<code>reduce</code>它有两个参数，第一个参数是一个回调方法<code>callback</code>，第二个参数是一个初始值<code>initialValue</code>。<br>大致实现步骤如下：</p>
<ul>
<li>判断参数，判断调用方法本身是否为 Array</li>
<li>声明要用的变量</li>
<li>判断是否有初始值，如果没有则从本身数组中取，取到直接跳出循环</li>
<li>循环调用 callback</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfReduce = <span class="function"><span class="keyword">function</span> (<span class="params">callback, initalValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">'Array.prototype.reduce'</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明要用到的变量</span></span><br><span class="line">  <span class="comment">// 要循环的数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="comment">// 开始的数组索引 默认为 0</span></span><br><span class="line">  <span class="keyword">let</span> startIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为有初始化值 initalValue</span></span><br><span class="line">  <span class="keyword">if</span> (initalValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果初始值为 undefined 循环从数组中找到有值，并且退出循环</span></span><br><span class="line">    <span class="comment">// 过滤稀疏值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startIndex = i;</span><br><span class="line">        res = arr[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = initalValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在上一步拿到初始值，循环调用传入的回调函数，并且过滤松散值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex++; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = callback.call(<span class="literal">null</span>, res, arr[i], i, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试一下<code>selfReduce</code>和<code>reduce</code>方法是否表现一致，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev + next;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 15</span></span><br><span class="line">arr.selfReduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev + next;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>其实也可以去看一下官方的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">mdn reduce polyfill</a>。</p>
<h2 id="实现-map"><a href="#实现-map" class="headerlink" title="实现 map"></a>实现 map</h2><hr>
<p><code>map</code>的使用这里不多做赘述，只记录它的两种实现方式一种通过<code>for</code>循环实现，另一种通过<code>reduce</code>实现。</p>
<h3 id="for-循环实现"><a href="#for-循环实现" class="headerlink" title="for 循环实现"></a>for 循环实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfMap = <span class="function"><span class="keyword">function</span> (<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">'Array.prototype.reduce'</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明要用到的变量</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> aMap = [];</span><br><span class="line">  <span class="comment">// 循环调用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    <span class="comment">// 过滤稀疏值</span></span><br><span class="line">    <span class="keyword">if</span> (!arr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    aMap[i] = callback.call(context, arr[i], i, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> aMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试实现<code>selfMap</code>和<code>map</code>是否一致，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">aTest.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line">aTest.selfMap(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceMap = <span class="function"><span class="keyword">function</span> (<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">'Array.prototype.reduce'</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aMap = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 使用reduce实现循环</span></span><br><span class="line">  <span class="keyword">return</span> aMap.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拼接上次循环结果和当前结果</span></span><br><span class="line">    <span class="comment">// 循环调用callback</span></span><br><span class="line">    <span class="keyword">return</span> [...pre, callback.call(context, cur, index, <span class="keyword">this</span>)];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试实现<code>reduceMap</code>和<code>map</code>是否一致，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">aTest.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line">aTest.reduceMap(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h2 id="filter-实现"><a href="#filter-实现" class="headerlink" title="filter 实现"></a>filter 实现</h2><hr>
<p>filter 也用到很多次，这里也不多做赘述直接看两种实现方法：</p>
<h3 id="for-循环实现-1"><a href="#for-循环实现-1" class="headerlink" title="for 循环实现"></a>for 循环实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfFilter = <span class="function"><span class="keyword">function</span> (<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">'Array.prototype.reduce'</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = aArr.length;</span><br><span class="line">  <span class="keyword">let</span> aFArr = [];</span><br><span class="line">  <span class="comment">// 循环调用callback</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!aArr.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callback.call(context, aArr[i], i, <span class="keyword">this</span>) &amp;&amp; aFArr.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> aFArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reduce-实现-1"><a href="#reduce-实现-1" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceFilter = <span class="function"><span class="keyword">function</span> (<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">'Array.prototype.reduce'</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> aArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环调用callback</span></span><br><span class="line">  aArr.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> callback.call(context, cur, index, <span class="keyword">this</span>) ? [...pre, cur] : [...pre];</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> aArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aTest = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">aTest.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aTest.selfFilter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aTest.reduceFilter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="实现-forEach"><a href="#实现-forEach" class="headerlink" title="实现 forEach"></a>实现 forEach</h2><hr>
<p>for 循环实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selfForeach = <span class="function"><span class="keyword">function</span> (<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">'Array.prototype.reduce'</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> _len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _len; i++) &#123;</span><br><span class="line">    callback.call(context, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>reduce 循环实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceForeach = <span class="function"><span class="keyword">function</span> (<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不能是null调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">'Array.prototype.reduce'</span> + <span class="string">'called on null or undefined'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一个参数必须要为function</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...pre, callback.call(context, cur, index, <span class="keyword">this</span>)];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上理解了怎么实现，无论是使用 for 来实现还是用 reduce 实现，基本上没有太大的差别。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">Array.prototype.reduce()</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5cef46226fb9a07eaf2b7516#heading-4" target="_blank" rel="noopener">一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5c0b7f03e51d452eec725729" target="_blank" rel="noopener">JS Array.reduce 实现 Array.map 和 Array.filter</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>InterviewQuestion</tag>
        <tag>Polyfill</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的实现垂直水平居中其中方法</title>
    <url>/blog/css/layout-flow/css-center.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在面试的时候<strong>css 面试题</strong>里面基本上都会问一个元素<code>垂直水平居中</code>，其实这个有多种方式实现，同时元素可以是<strong>固定宽高、不固定宽高</strong>的。</p>
<p><strong>固定宽高</strong></p>
<ul>
<li>方式一：<code>position absolute + 负 margin</code></li>
<li>方式二：<code>position absolute + margin auto</code></li>
<li>方式三：<code>position absolute + calc</code></li>
</ul>
<p><strong>不固定宽高</strong></p>
<ul>
<li>方式四：<code>position absolute + transform</code></li>
<li>方式五：<code>css-table</code></li>
<li>方式六：<code>flex</code></li>
<li>方式七：<code>grid</code></li>
</ul>
<p>下面就直接上代码，公用的<code>html代码</code>和<code>css代码</code>就写在这里后面都会在这个基础上增加代码。<br><strong>html 公用代码</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-center"</span>&gt;</span></span><br><span class="line">    box-center</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css 公用代码</strong>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有两个元素它们是父子级的关系，要达到的效果是子元素要在父元素中垂直水平居中</strong>。</p>
<h2 id="固定宽高"><a href="#固定宽高" class="headerlink" title="固定宽高"></a>固定宽高</h2><p>固定宽高的意思就是要居中的这个元素它的<strong>宽高都是固定的值</strong>，下面一个一个用代码实现。</p>
<h3 id="position-absolute-负-margin"><a href="#position-absolute-负-margin" class="headerlink" title="position absolute + 负 margin"></a>position absolute + 负 margin</h3><p>css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用绝对定位让子元素基于父元素的左上角偏移 50%，但是这样不是真正的居中因为它多移动了本身元素的<strong>宽度的一半</strong>和<strong>高度的一半</strong>，这个时候我们可以通过<code>负margin</code>来修正这个问题，所以就有了<code>-50px</code>这两个属性。</p>
<h3 id="position-absolute-margin-auto"><a href="#position-absolute-margin-auto" class="headerlink" title="position absolute + margin auto"></a>position absolute + margin auto</h3><p>css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式通过设置各个方向的距离都是 <code>0</code>，此时再讲 <code>margin</code> 设为 <code>auto</code>，就可以在各个方向上居中了。</p>
<h3 id="position-absolute-calc"><a href="#position-absolute-calc" class="headerlink" title="position absolute + calc"></a>position absolute + calc</h3><p>css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">calc</span>(50% - 50px);</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(50% - 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>calc</code>计算属性减去元素本身高度和宽度的一半。</p>
<h2 id="不固定宽高"><a href="#不固定宽高" class="headerlink" title="不固定宽高"></a>不固定宽高</h2><p>固定宽高的意思就是要居中的这个元素它的<code>宽高都是不固定的值</code>，不固定宽高的方法是可以覆盖上面固定宽高的方法，下面一个一个用代码实现。</p>
<h3 id="position-absolute-transform"><a href="#position-absolute-transform" class="headerlink" title="position absolute + transform"></a>position absolute + transform</h3><p>css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修复绝对定位的问题，还可以使用 css3 新增的<code>transform</code>，<code>transform</code>的<code>translate</code>属性也可以设置百分比，其是相对于自身的宽和高，所以可以讲<code>translate</code>设置为<code>-50%</code>，就可以做到居中了。</p>
<h3 id="css-table"><a href="#css-table" class="headerlink" title="css-table"></a>css-table</h3><p>css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>display: table-cell</code>把<code>div</code>元素变为<code>table</code>元素的实现效果，通过这个特性也可以实现垂直水平居中。</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>flex</code>的两个属性实现垂直水平居中。</p>
<h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">justify-items</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>grid</code>布局实现居中，如果<code>grid</code>不太了解可以看<a href="/blog/css/css-grid.html">grid 布局</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有两种比较特殊的垂直水平居中的方式，应用场景比较少或者代价比较大，所以在这几记录一下如下：</p>
<ul>
<li>行内元素居中</li>
<li>table 布局</li>
</ul>
<h3 id="行内元素居中"><a href="#行内元素居中" class="headerlink" title="行内元素居中"></a>行内元素居中</h3><p>css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">  font-size: 0; // 兼容代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">line-height</span>: initial;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把<code>container</code>设置为行内元素，通过<code>text-align</code>就可以做到水平居中，通过<code>vertical-align</code>也可以在垂直方向做到居中。</p>
<h3 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h3><p>改变<code>html</code>结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-center"</span>&gt;</span>box-center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>css</code>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此处引用上面的公共代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用<code>table</code>属性实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面实现总结如下面表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">居中元素定宽高固定</th>
<th style="text-align:center">PC 兼容性</th>
<th style="text-align:center">移动端兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">position absolute + 负 margin</td>
<td style="text-align:center">固定宽高</td>
<td style="text-align:center">ie6+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓 2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">position absolute + margin auto</td>
<td style="text-align:center">固定宽高</td>
<td style="text-align:center">ie6+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓 2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">position absolute + calc</td>
<td style="text-align:center">固定宽高</td>
<td style="text-align:center">ie9+, chrome19+, firefox4+</td>
<td style="text-align:center">安卓 4.4+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">position absolute + transform</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie9+, chrome4+, firefox3.5+</td>
<td style="text-align:center">安卓 3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">css-table</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie8+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓 2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">flex</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie10+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓 2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">grid</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie10+, chrome57+, firefox52+</td>
<td style="text-align:center">安卓 6+, iOS10.3+</td>
</tr>
<tr>
<td style="text-align:center">table 布局</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie6+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓 2.3+, iOS6+</td>
</tr>
<tr>
<td style="text-align:center">行内元素居中</td>
<td style="text-align:center">不固定宽高</td>
<td style="text-align:center">ie6+, chrome4+, firefox2+</td>
<td style="text-align:center">安卓 2.3+, iOS6+</td>
</tr>
</tbody>
</table>
<p>推荐用法：</p>
<ul>
<li>PC 端<strong>有兼容性</strong>要求，宽高固定，推荐<code>absolute + 负margin</code></li>
<li>PC 端<strong>有兼容</strong>要求，宽高不固定，推荐<code>css-table</code></li>
<li>PC 端<strong>无兼容性</strong>要求，推荐<code>flex</code></li>
<li>移动端推荐使用<code>flex</code></li>
</ul>
<p>以后肯定<code>grid</code>会大方异彩。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yanhaijing.com/css/2018/01/17/horizontal-vertical-center/" target="_blank" rel="noopener">CSS 实现水平垂直居中的 1010 种方式 原创</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>var和let、const对比</title>
    <url>/blog/es/interview-question/es6-variable.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<strong>ECMAScript6</strong>中新增两个变量声明的指令<code>let</code>和<code>const</code>，以前经常用的<code>var</code>有什么区别。</p>
<h2 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a>var 声明</h2><p><code>var</code> <strong>声明语句</strong>声明一个变量，并可选地将其初始化为一个值。</p>
<ul>
<li>可重复声明</li>
<li>变量提升</li>
<li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>通过<code>var</code>关键字声明一个<code>count</code>变量，并且<code>count</code>的值为 1。</p>
<h3 id="可重复声明"><a href="#可重复声明" class="headerlink" title="可重复声明"></a>可重复声明</h3><p>可以重复声明<code>count</code>变量，也可以重新赋值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">2</span>;</span><br><span class="line">count = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><code>var</code>声明的变量是存在<strong>变量提升</strong>的 ，由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>提升将影响变量声明，而不会影响其值的初始化</strong>。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>var</code>声明变量的作用域限制在其声明位置的<strong>上下文中</strong>，而非声明变量总是<strong>全局</strong>的。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line">  sum = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">x();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.sum); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>建议始终声明变量，无论它们是在函数还是全局作用域内。</li>
</ul>
</blockquote>
<h2 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h2><p><code>let</code>允许你声明一个作用域被限制在 <code>块级中的变量</code>、<code>语句或者表达式</code>。与 <code>var</code> 关键字不同的是， <code>var</code>声明的变量只能是<code>全局</code>或者<code>整个函数块</code>的。</p>
<ul>
<li>不可重复声明，可以重复赋值</li>
<li>块作用域</li>
<li>暂存死区</li>
<li>不存在变量提升</li>
</ul>
<h3 id="不可重复声明，可以重复赋值"><a href="#不可重复声明，可以重复赋值" class="headerlink" title="不可重复声明，可以重复赋值"></a>不可重复声明，可以重复赋值</h3><p><strong><code>let</code>不可以重复同样名称的变量，但是可以重复给同一个变量多次赋值</strong>。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">2</span>; <span class="comment">// Identifier 'count' has already been declared</span></span><br><span class="line">count = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p><code>let</code>声明的变量只在其声明的<strong>块或子块中</strong>可用，这一点，与<code>var</code>相似。二者之间最主要的区别在于<code>var</code>声明的变量的作用域是<strong>整个封闭函数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>; <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>; <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>let 声明</strong>的变量不会挂载顶层对象下面，会临时创建一个<code>scope</code>来储存<strong>let 声明</strong>，执行完成清除，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">debugger</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> count = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sum = <span class="number">2</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在执行完<code>let count = 1;</code>，效果如下图所示：<br><img src="../../../images/es/es-let.png" alt="let"><br>当<strong>javascript</strong>执行完成后，<code>scope</code>也会被清空。</p>
<h3 id="暂存死区-不存在变量提升"><a href="#暂存死区-不存在变量提升" class="headerlink" title="暂存死区/不存在变量提升"></a>暂存死区/不存在变量提升</h3><p><code>let</code> 被创建在包含该声明的（块）作用域顶部，<strong>一般被称为“提升”</strong>。与通过 <code>var</code> 声明的有初始化值 <code>undefined</code> 的变量不同，通过 <code>let</code> 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 <code>ReferenceError</code>。该变量处在一个自块顶部到初始化处理的“暂存死区”中。<br>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// Uncaught ReferenceError: Cannot access 'count' before initialization</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h2><p>常量是块级作用域，很像使用 <code>let</code> 语句定义的变量。常量的值<strong>不能</strong>通过重新赋值来改变，并且<strong>不能</strong>重新声明。</p>
<ul>
<li>不能重复声明</li>
<li>不能重复赋值</li>
<li>块级作用域</li>
<li>暂存死区</li>
<li>不存在变量提升</li>
<li>一旦声明，必须马上赋值</li>
</ul>
<p><code>不能重复声明</code>、<code>块级作用域</code>、<code>块级作用域</code>、<code>不存在变量提升</code>在这里不再赘述和<code>let</code>中的表现相同，请看上文。</p>
<h3 id="一旦声明，必须马上赋值"><a href="#一旦声明，必须马上赋值" class="headerlink" title="一旦声明，必须马上赋值"></a>一旦声明，必须马上赋值</h3><p><code>const</code> 声明之后必须马上赋值，否则会报错，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count; <span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="不能重复赋值"><a href="#不能重复赋值" class="headerlink" title="不能重复赋值"></a>不能重复赋值</h3><p><code>const</code>声明创建一个值的<strong>只读引用</strong>。但这并不意味着它所持有的值是<strong>不可变</strong>的，只是<strong>变量标识符</strong>不能重新分配。<br><strong>JavaScript</strong>中的数据类型分为两大类：<code>值类型</code>、<code>引用类型</code>。</p>
<p><strong>值类型</strong></p>
<p>用<code>const</code>声明的变量被首次被赋值为<strong>值类型</strong>，它的值就不能改变了，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">2</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p><strong>引用类型</strong></p>
<p>只要不改变量的<strong>指针地址</strong>就不会报错，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'nihao'</span>,</span><br><span class="line">  age: <span class="number">17</span></span><br><span class="line">&#125;;</span><br><span class="line">user.name = <span class="string">'大家好'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结对比如下面表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">/</th>
<th style="text-align:center">能否重复声明</th>
<th style="text-align:center">能否重复赋值</th>
<th style="text-align:center">作用域</th>
<th style="text-align:center">变量提升</th>
<th style="text-align:center">暂存死区</th>
<th style="text-align:center">声明是否需要立即赋值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">var</td>
<td style="text-align:center">能</td>
<td style="text-align:center">能</td>
<td style="text-align:center">函数作用域/全局作用域</td>
<td style="text-align:center">存在变量提升</td>
<td style="text-align:center">不存在暂存死区</td>
<td style="text-align:center">不需要立即赋值</td>
</tr>
<tr>
<td style="text-align:center">let</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">能</td>
<td style="text-align:center">块级作用域/全局作用域</td>
<td style="text-align:center">不存在</td>
<td style="text-align:center">存在暂存死区</td>
<td style="text-align:center">不需要立即赋值</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">块级作用域/全局作用域</td>
<td style="text-align:center">不存在</td>
<td style="text-align:center">存在暂存死区</td>
<td style="text-align:center">需要立即赋值</td>
</tr>
</tbody>
</table>
<p>他们的特性基本上如上面表格所示，可以根据各个不同的需要，选择 var、let、const 来声明变量。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var" target="_blank" rel="noopener">var 声明语句</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let 声明语句</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const 声明语句</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247483812&amp;idx=1&amp;sn=9bab06614e079bd9cc533a3b2cd02a75&amp;chksm=faec857ccd9b0c6a9b58e49f747651ffdf484acdd6fc82318a0964e4c339dbda6586e340ca4d&amp;mpshare=1&amp;scene=1&amp;srcid=082024th073paIFjxG2PXq8C&amp;sharer_sharetime=1566313518851&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b#rd" target="_blank" rel="noopener">JS 系列一：var、let、const、解构、展开、函数</a></p>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中new相关的面试题</title>
    <url>/blog/interview-question/javascript/new-javascript.html</url>
    <content><![CDATA[<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个Foo 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Foo创建了一个叫getName的静态属性存储了一个匿名函数</span></span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Foo的原型对象新创建了一个叫getName的匿名函数</span></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明一个匿名，并且赋值给全局变量getName (函数表达式)</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明一个全局函数getName (函数声明)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName(); <span class="comment">// 第一问</span></span><br><span class="line">getName(); <span class="comment">// 第二问</span></span><br><span class="line">Foo().getName(); <span class="comment">// 第三问</span></span><br><span class="line">getName(); <span class="comment">// 第四问</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 第五问</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 第六问</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 第七问</span></span><br></pre></td></tr></table></figure>
<p><strong>如果这几个问题能直接回答出来，后面就没必要看了</strong>。</p>
<p><strong>简单了解一下 javascript 中的原型继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Preson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = name; <span class="comment">//私有属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name; <span class="comment">//公有属性</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Preson.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//公有方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">Preson.name = <span class="string">'Wscats'</span>; <span class="comment">//静态属性</span></span><br><span class="line">Preson.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//静态方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Son = <span class="keyword">new</span> Preson(<span class="string">'Son'</span>); <span class="comment">//实例化</span></span><br></pre></td></tr></table></figure>
<p>注意下面几点：</p>
<ul>
<li><strong>调用公有方法，公有属性，我们必需先实例化对象，也就是用 new 操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的</strong></li>
<li><strong>静态方法和静态属性就是我们无需实例化就可以调用</strong></li>
<li><strong>而对象的私有方法和属性,外部是不可以访问的</strong></li>
<li><strong>静态属性不能被继承</strong></li>
</ul>
<p>首先看一下代码，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先看一下<code>Foo.getName</code>会在<code>Foo.prototype.constructor</code>中添加一个<code>getName</code>属性，如果直接调用<code>Foo.getName</code>他就直接调用<code>Foo.prototype.constructor</code>上得<code>getName</code>属性。<br>如果没有通过<code>new</code>关键字调用<code>Foo</code>的话，是不能访问<code>prototype</code>中的<code>getName</code>属性。<br>代码结果如下：<br><img src="../../../images/interviewquestion/interviewquestion-javascirpt-1-1.png" alt="interviewquestion-javascript"></p>
<h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Foo.getName(); <span class="comment">// 第一问</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>根据上面的说明，可以得出第一问的<code>Foo.getName</code>就是会访问<code>constructor</code>上得静态属性，结果就是<code>2</code>。</p>
<h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getName(); <span class="comment">// 第二问</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>首先要介绍一下<strong>函数声明</strong>和<strong>函数表达式</strong>，如下：</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这里考察的是<strong>变量提升</strong>的技巧，简单来说就是<strong>函数声明</strong>存在变量提升，不了解变量提升的话可以看另一篇文章<a href="/blog/javascript/hoisting.html">javascript 中的变量提升</a>，所以这一题的答案就是 4。</p>
<h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Foo().getName(); <span class="comment">// 第三问</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>Foo().getName()</code>; 先执行了<code>Foo</code>函数，然后调用<code>Foo</code>函数的返回值对象的<code>getName</code>属性函数。主要考察<code>this</code>指向问题和在<code>Foo</code>函数中没有<code>var</code>声明变量问题。<br>要注意<code>Foo</code>函数中的<code>getName</code>声明是没有<code>var</code>的，所以它会在全局作用域中创建一个<code>getName</code>，如果全局作用域中存在这个属性就会<strong>覆盖</strong>全局作用域的已存在的属性。<br>所以当<code>Foo</code>函数执行完成之后<code>getName = function () { console.log(1);}</code>会覆盖<code>getName = function () { console.log(4); }</code>。</p>
<blockquote>
<p>注意：此处若依然没有找到会一直向上查找到 window 对象，若 window 对象中也没有 getName 属性，就在 window 对象中创建一个 getName 变量。</p>
</blockquote>
<p><code>Foo</code>函数的返回值是<code>this</code>，而<code>JS</code>的<code>this</code>问题已经有非常多的文章介绍，简单来讲 this 的指向就是由函数的调用方式决定的。<br>所以答案就是<strong>输出 1</strong>。<br>这里最主要考察两个知识点，一个是作用域问题、一个是 this 指向问题，这个就不多做解释直接看往期文章。</p>
<h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getName(); <span class="comment">// 第四问</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>直接调用<code>getName</code>函数，相当于<code>window.getName()</code>，因为这个变量已经被<code>Foo</code>函数执行时修改了，所以结果和第三问相同也会<strong>输出 1</strong>。</p>
<h2 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 第五问</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>第五问主要考察的是<code>JS中的运算符优先级</code>，所以首先要了解<strong>JS 中的运算符优先级</strong>，可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">MDN 运算符优先级</a>学习这里就不多展示，只展示用到的如下图所示：<br><img src="../../../images/interviewquestion/interviewquestion-javascirpt-1-2.png" alt="interviewquestion-javascript"><br>可以在上面看到一下两点：</p>
<ul>
<li>成员访问<code>.</code>的优先级为<strong>(19)</strong>比 new 无参数列表<strong>(18)</strong>优先级高</li>
<li>当点运算完后又因为有个括号()，此时就是变成 new 有参数列表<strong>(19)</strong>，所以直接执行 new，<code>new constructor</code> 后面可以跟<strong>一个指定对象实例的类型的类或函数</strong>。它是把<code>Foo.getName()</code>看做一个<strong>整体</strong>，而不是调用了<code>new</code>完成以后的<strong>函数</strong>，不信的话可以运行<code>new (Foo.getName)</code>这个代码，它的结果和本题的<strong>结果一致</strong>。<br>所以我们可以把代码改写成<code>new (Foo.getName)()</code>这样可以清晰的看到他的执行顺序，大的执行顺序分为两部步如下：</li>
</ul>
<ol>
<li>先执行<code>Foo.getName</code></li>
<li>再是<code>new (Foo.getName)()</code></li>
</ol>
<p>所以这里实际上将<strong>getName 函数</strong>作为了<strong>构造函数</strong>来执行，所以<strong>结果是 2</strong>。</p>
<h2 id="第六问"><a href="#第六问" class="headerlink" title="第六问"></a>第六问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 第六问</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>根据上面的<strong>运算符优先级</strong>可知，首先 new 有参数列表(19)跟点的优先级(19)是同级，同级的话按照<strong>从左向右的执行顺序</strong>，所以先执行 new 有参数列表(19)再执行点的优先级(19)，最后再函数调用(18)。</p>
<blockquote>
<p>new 有参数列表(19)-&gt;.成员访问(19)-&gt;()函数调用(18)<br>根据优先级可以把上面的问题该写为<code>(new Foo()).getName()</code>，这样可以更清晰的看到它的执行过程。</p>
</blockquote>
<h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><p>在传统语言中构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象，而在 JS 中构造函数可以有返回值也可以没有。大致可以分总结为三类：</p>
<ul>
<li>没有返回值则按照其他语言一样返回实例化对象。</li>
<li>若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（String,Number,Boolean,Null,Undefined）则与无返回值相同，实际返回其实例化对象。</li>
<li>若返回值是引用类型，则实际返回值为这个引用类型。</li>
</ul>
<p>原题中，由于返回的是<code>this</code>，而 this 在构造函数中本来就代表当前实例化对象，最终<code>Foo</code>函数返回<strong>实例化对象</strong>。<br>之后调用实例化对象的<code>getName</code>函数，因为在 Foo 构造函数中没有为<strong>实例化对象</strong>添加任何属性，当前对象的<strong>原型对象(prototype)</strong>中寻找<code>getName</code>函数。所以会执行<code>prototype</code>上得<code>getName</code>的方法也就是<code>function () { alert (3);};</code>，<strong>结果为 3</strong>。</p>
<h2 id="第七问"><a href="#第七问" class="headerlink" title="第七问"></a>第七问</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 第七问</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>根据第六问的优先级可以把第七问的代码改写为<code>new ((new Foo()).getName)()</code>，所以得到的<strong>结果也为 3</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实有很多关于<strong>this 指向</strong>、<strong>构造函数返回值</strong>、<strong>作用域</strong>都没有记录的很完整，以前有些过一些文章但是并没有整理，慢慢会整理好。</p>
]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>Https系列（三） Https+blob 视频播放</title>
    <url>/blog/network/https/http-https-blob.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自从 HTML5 提供了 video 标签，在网页中播放视频已经变成一个非常简单的事，只要一个 video 标签 src 属性设置为视频的地址就完事了。由于 src 指向真实的视频网络地址，在早期一般网站资源文件不怎么<strong>通过 referer 设置防盗链</strong>，所以可以随意的下载视频，也就有了后来通过 blob 加密视频文件。</p>
<blockquote>
<p>目前的云存储服务商大部分都支持 referer 防盗链。其原理就是在访问资源时，请求头会带上发起请求的页面地址，判断其不存在（表示直接访问图片地址）或不在白名单内，即为盗链。</p>
</blockquote>
<p>现在许多视频在线观看网站，你如果打开<code>chrome</code>查看其<code>video</code>标签，会发现它的<code>src</code>是一个以<code>blob:</code>开头的地址。</p>
<h2 id="Blob-和-ArrayBuffer"><a href="#Blob-和-ArrayBuffer" class="headerlink" title="Blob 和 ArrayBuffer"></a>Blob 和 ArrayBuffer</h2><p><code>Blob</code>是<strong>二进制原始数据</strong>但是类似<strong>文件</strong>的对象，ArrayBuffer 对象用来表示<strong>通用的、固定长度</strong>的<strong>原始二进制数据缓冲区</strong>。<br>同时他们是可以互相转换的<code>Blob</code>和<code>ArrayBuffer</code>。</p>
<h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p><code>Blob`对象表示一个`不可变、原始数据`的类文件对象。`Blob`表示的不一定是`JavaScript</code>原生格式的数据。<code>File</code> 接口基于<code>Blob</code>，继承了 <code>blob</code> 的功能并将其扩展使其支持用户系统上的文件。<br>使用 <code>Blob()</code> 构造函穿新创建的 Blob 对象。常用的方法和属性如下：</p>
<ul>
<li><code>slice()</code>方法： 创建包含另一个<code>blob</code>数据的子集<code>blob</code></li>
<li><code>Blob.size</code>属性（只读）： Blob 对象中所包含数据的大小（字节）。</li>
<li><code>Blob.type</code>属性（只读）： 一个字符串，表明该 Blob 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</li>
</ul>
<blockquote>
<ul>
<li>注意：slice()方法原本接受 length 作为第二个参数，以表示复制到新 Blob 对象的字节数。如果设置的参数使 start + length 超出了源 Blob 对象的大小，那返回的则是从 start 到结尾的数据。</li>
</ul>
</blockquote>
<ul>
<li>File 对象其实继承自 Blob 对象，并提供了提供了 name ， lastModifiedDate， size ，type 等基础元数据。</li>
</ul>
<h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p><code>ArrayBuffer</code>(length)来获得一片连续的内存空间，它不能直接读写，但可根据需要将其传递到 TypedArray 视图或 DataView 对象来解释原始缓冲区。实际上视图只是给你提供了一个某种类型的读写接口，让你可以操作<code>ArrayBuffer</code>里的数据。<strong>TypedArray 需指定一个数组类型来保证数组成员都是同一个数据类型，而 DataView 数组成员可以是不同的数据类型</strong>。</p>
<p><code>TypedArray</code> 对象描述一个底层的<strong>二进制数据缓存区</strong>的一个类似数组(array-like)视图，<code>TypedArray</code>对象如下几种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小（字节单位）</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">Web IDL type</th>
<th style="text-align:center">C 语言中的等效类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Int8Array</td>
<td style="text-align:center">1</td>
<td style="text-align:center">8 位二进制带符号整数 -2^7~(2^7) - 1</td>
<td style="text-align:center">byte</td>
<td style="text-align:center">int8_t</td>
</tr>
<tr>
<td style="text-align:center">Uint8Array</td>
<td style="text-align:center">1</td>
<td style="text-align:center">8 位无符号整数 0~(2^8) - 1</td>
<td style="text-align:center">octet</td>
<td style="text-align:center">uint8_t</td>
</tr>
<tr>
<td style="text-align:center">Int16Array</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16 位二进制带符号整数 -2^15~(2^15)-1</td>
<td style="text-align:center">short</td>
<td style="text-align:center">int16_t</td>
</tr>
<tr>
<td style="text-align:center">Uint16Array</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16 位无符号整数 0~(2^16) - 1</td>
<td style="text-align:center">unsigned short</td>
<td style="text-align:center">uint16_t</td>
</tr>
<tr>
<td style="text-align:center">Int32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32 位二进制带符号整数 -2^31~(2^31)-1</td>
<td style="text-align:center">long</td>
<td style="text-align:center">int32_t</td>
</tr>
<tr>
<td style="text-align:center">Uint32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32 位无符号整数 0~(2^32) - 1</td>
<td style="text-align:center">unsigned int</td>
<td style="text-align:center">uint32_t</td>
</tr>
<tr>
<td style="text-align:center">Float32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32 位 IEEE 浮点数</td>
<td style="text-align:center">unrestricted float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">Float64Array</td>
<td style="text-align:center">8</td>
<td style="text-align:center">64 位 IEEE 浮点数</td>
<td style="text-align:center">unrestricted double</td>
<td style="text-align:center">double</td>
</tr>
</tbody>
</table>
<h2 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL"></a>URL.createObjectURL</h2><p><code>URL.createObjectURL()</code> 静态方法会创建一个 <code>DOMString</code>，其中包含一个表示参数中给出的对象的<code>URL</code>。这个 <code>URL</code> 的<strong>生命周期</strong>和创建它的窗口中的 <code>document</code> 绑定。这个新的 URL 对象表示指定的 <code>File</code> 对象或 <code>Blob</code> 对象。</p>
<blockquote>
<p><code>DOMString</code>可以说是会话<strong>(session)</strong>级的，所以你在新的<code>tab</code>打开也就无效了</p>
</blockquote>
<p>video 标签的 src 属性，不管是相对路径，绝对路径，或者一个网络地址，归根结底都是指向一个<code>文件资源的地址</code>。上面的<code>Blob</code>其实是一个可以当作<code>文件</code>用的<code>二进制数据</code>，那么只要我们可以生成一个指向<code>Blob</code>的地址，再通过<code>URL.createObjectURL</code>生成一个临时地址，赋值给你<code>video</code>标签的<code>src</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> videoURL = URL.createObjectURL(video); <span class="comment">// blob:https://www.aaa.com/12212aa1s1</span></span><br></pre></td></tr></table></figure>
<p>通过<code>URL.revokeObjectURL(objectURL)</code> 释放一个之前已经存在的、通过调用 <code>URL.createObjectURL()</code> 创建的 <code>URL</code> 对象。</p>
<blockquote>
<p>如果是以文件协议打开的 html 文件（即 url 为 file://开头），则地址中<a href="http://localhost:1234会变成null，而且此时这个Blob" target="_blank" rel="noopener">http://localhost:1234会变成null，而且此时这个Blob</a> URL 是无法直接访问的。</p>
</blockquote>
<h2 id="HLS-和-MPEG-DASH"><a href="#HLS-和-MPEG-DASH" class="headerlink" title="HLS 和 MPEG DASH"></a>HLS 和 MPEG DASH</h2><p><code>HLS （HTTP Live Streaming）</code>, 是由 Apple 公司实现的<code>基于 HTTP 的媒体流传输协议</code>。<code>HLS 以 ts 为传输格</code>式，<code>m3u8 为索引文件</code>（文件中包含了所要用到的 <code>ts 文件名称</code>，时长等信息，可以用播放器播放，也可以用 vscode 之类的编辑器打开查看），在移动端大部分浏览器都支持，也就是说你可以用 <code>video 标签直接加载一个 m3u8 文件播放视频</code>或者直播，但是在 pc 端，除了苹果的 Safari，需要引入库来支持。<br>用到此方案的视频网站比如优酷，可以在视频播放时通过调试查看 <code>Network</code> 里的 <code>xhr</code> 请求，会发现一个 m3u8 文件，和每隔一段时间请求几个 ts 文件。<br><img src="./http-https-blob/https-1-1.png" alt="https"><br><img src="./http-https-blob/https-1-2.png" alt="https"><br>但是除了 <code>HLS</code>，还有 <code>Adobe</code> 的 <code>HDS</code>，微软的 <code>MSS</code>，方案一多就要有个标准点的东西，于是就有了 <code>MPEG DASH</code>。<br><code>DASH（Dynamic Adaptive Streaming over HTTP）</code> ，是一种在互联网上传送动态码率的 <code>Video Streaming</code> 技术，类似于苹果的 <code>HLS，DASH</code> 会通过 <code>media presentation description (MPD)</code>将视频内容切片成一个很短的文件片段，每个切片都有多个不同的码率，<code>DASH Client</code> 可以根据网络的情况选择一个码率进行播放，支持在不同码率之间无缝切换。<br><code>Youtube，B</code> 站都是用的这个方案。这个方案索引文件通常是 mpd 文件（类似 HLS 的 m3u8 文件功能），传输格式推荐的是 <code>fmp4（Fragmented MP4）</code>,文件扩展名通常为<code>.m4s</code> 或直接用<code>.mp4</code>。所以用调试查看 b 站视频播放时的网络请求，会发现每隔一段时间有几个 m4s 文件请求。<br><img src="./http-https-blob/https-1-3.png" alt="https"><br>不管是 HLS 还是 DASH 们，都有对应的库甚至是高级的播放器方便我们使用，但我们其实是想要学习一点实现。其实抛开掉索引文件的解析拿到实际媒体文件的传输地址，摆在我们面前的只有一个如何将多个视频数据合并让 video 标签可以无缝播放。</p>
<blockquote>
<p>与之相关的一篇 B 站文章推荐给感兴趣的朋友：<a href="https://www.bilibili.com/read/cv855111/" target="_blank" rel="noopener">我们为什么使用 DASH</a></p>
</blockquote>
<h2 id="MediaSource"><a href="#MediaSource" class="headerlink" title="MediaSource"></a>MediaSource</h2><p>video 标签 src 指向一个视频地址，视频播完了再将 src 修改为下一段的视频地址然后播放，这显然不符合我们无缝播放的要求。其实有了我们前面 Blob URL 的学习，我们可能就会想到一个思路，用 Blob URL 指向一个视频二进制数据，然后不断将下一段视频的二进制数据添加拼接进去。这样就可以在不影响播放的情况下，不断的更新视频内容并播放下去，想想是不是有点流的意思出来了。<br>要实现这个功能我们要通过 MediaSource 来实现，MediaSource 接口功能也很纯粹，作为一个媒体数据容器可以和 HTMLMediaElement 进行绑定。基本流程就是通过 URL.createObjectURL 创建容器的 BLob URL，设置到 video 标签的 src 上，在播放过程中，我们仍然可以通过 MediaSource.appendBuffer 方法往容器里添加数据，达到更新视频内容的目的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line"><span class="comment">//视频资源存放路径，假设下面有5个分段视频 video1.mp4 ~ video5.mp4，第一个段为初始化视频init.mp4</span></span><br><span class="line"><span class="keyword">const</span> assetURL = <span class="string">'http://www.demo.com'</span>;</span><br><span class="line"><span class="comment">//视频格式和编码信息，主要为判断浏览器是否支持视频格式，但如果信息和视频不符可能会报错</span></span><br><span class="line"><span class="keyword">const</span> mimeCodec = <span class="string">'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'MediaSource'</span> <span class="keyword">in</span> <span class="built_in">window</span> &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123;</span><br><span class="line">  <span class="keyword">const</span> mediaSource = <span class="keyword">new</span> MediaSource();</span><br><span class="line">  video.src = URL.createObjectURL(mediaSource); <span class="comment">//将video与MediaSource绑定，此处生成一个Blob URL</span></span><br><span class="line">  mediaSource.addEventListener(<span class="string">'sourceopen'</span>, sourceOpen); <span class="comment">//可以理解为容器打开</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//浏览器不支持该视频格式</span></span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Unsupported MIME type or codec: '</span>, mimeCodec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sourceOpen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mediaSource = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNextVideo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//ajax代码实现翻看上文，数据请求类型为arraybuffer</span></span><br><span class="line">    ajax(url, <span class="function"><span class="keyword">function</span> (<span class="params">buf</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//往容器中添加请求到的数据，不会影响当下的视频播放。</span></span><br><span class="line">      sourceBuffer.appendBuffer(buf);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//每次appendBuffer数据更新完之后就会触发</span></span><br><span class="line">  sourceBuffer.addEventListener(<span class="string">'updateend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//第一个初始化视频加载完就开始播放</span></span><br><span class="line">      video.play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">6</span>) &#123;</span><br><span class="line">      <span class="comment">//一段视频加载完成后，请求下一段视频</span></span><br><span class="line">      getNextVideo(<span class="string">`<span class="subst">$&#123;assetURL&#125;</span>/video<span class="subst">$&#123;i&#125;</span>.mp4`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">6</span>) &#123;</span><br><span class="line">      <span class="comment">//全部视频片段加载完关闭容器</span></span><br><span class="line">      mediaSource.endOfStream();</span><br><span class="line">      URL.revokeObjectURL(video.src); <span class="comment">//Blob URL已经使用并加载，不需要再次使用的话可以释放掉。</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//加载初始视频</span></span><br><span class="line">  getNextVideo(<span class="string">`<span class="subst">$&#123;assetURL&#125;</span>/init.mp4`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码修改自 <code>MDN</code> 的 <code>MediaSource</code> 词条中的示例代码，原例子中只有加载一段视频，我修改为了多段视频，代码里面很多地方还可以优化精简，这里没做就当是为了方便我们看逻辑。<br>此时我们已经基本实现了一个简易的流媒体播放功能，如果愿意可以再加入 <code>m3u8</code> 或 <code>mpd</code> 文件的解析，设计一下 UI 界面，就可以实现一个流媒体播放器了。<br>最后提一下一个坑，很多人跑了 <code>MDN 的 MediaSource</code> 示例代码，可能会发现使用官方提供的视频是没问题的，但是用了自己的 mp4 视频就会报错，这是因为 <code>fmp4 文件扩展名通常为.m4s</code> 或直接用<code>.mp4</code>，但却是特殊的<code>mp4</code> 文件。</p>
<h2 id="Fragmented-MP4"><a href="#Fragmented-MP4" class="headerlink" title="Fragmented MP4"></a>Fragmented MP4</h2><p>通常我们使用的 mp4 文件是嵌套结构的，客户端必须要从头加载一个<code>MP4 文件</code>，才能够完整播放，不能从中间一段开始播放。而 <code>Fragmented MP4（简称 fmp4）</code>，就如它的名字碎片 <code>mp4</code>，是由一系列的片段组成，如果服务器支持 <code>byte-range</code> 请求，那么，这些片段可以独立的进行请求到客户端进行播放，而不需要加载整个文件。<br>我们可以通过这个网站判断一个 mp4 文件<a href="http://nickdesaulniers.github.io/mp4info/" target="_blank" rel="noopener">是否为 Fragmented MP4 网站地址</a>。<br>我们通过<a href="https://ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a>或<a href="https://www.bento4.com/" target="_blank" rel="noopener">Bento4</a>的 mp4fragment 来将普通 mp4 转换为 Fragmented MP4，两个工具都是命令行工具，按照各自系统下载下来对应的压缩包，解压后设置环境变量指向文件夹中的 bin 目录，就可以使用相关命令了。<br>Bento4 的 mp4fragment，没有太多参数，命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mp4fragment video.mp4 video-fragmented.mp4</span><br></pre></td></tr></table></figure>
<p>FFmpeg 会需要设置一些参数，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i video.mp4 -movflags empty_moov+default_base_moof+frag_keyframe video-fragmented.mp4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips：网上大部分的资料中转换时是不带 <code>default_base_moof</code> 这个参数的，虽然可以转换成功，但是经测试如果不添加此参数网页中 MediaSource 处理视频时会报错。<br>视频的切割分段可以使用 Bento4 的 mp4slipt，命令如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mp4split video.mp4 --media-segment video-%llu.mp4 --pattern-parameters N</span><br></pre></td></tr></table></figure>
<h2 id="来个实例"><a href="#来个实例" class="headerlink" title="来个实例"></a>来个实例</h2><p>服务端使用的<code>nodejs</code>，<code>koa</code>框架，这里的操作很简单，就是用<code>fs.readFileSync</code>直接打开视频文件，得到的<code>data</code>结果是二进制的数据，直接作为结果返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="built_in">require</span>(<span class="string">'buffer'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">const</span> video = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// open 一个放在服务器的视频</span></span><br><span class="line">    <span class="keyword">let</span> data = fs.readFileSync(<span class="string">'XXX.XXX.XXX/simple.mp4'</span>);</span><br><span class="line">    ctx.response.body = data;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(&#123;</span><br><span class="line">      status: <span class="number">500</span>,</span><br><span class="line">      message: <span class="string">'视频传输错误'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line">router.get(<span class="string">'/video'</span>, video);</span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line">app.liseten(<span class="number">3002</span>);</span><br></pre></td></tr></table></figure>
<p>前端代码，这里使用的最原生的<code>XMLHttpRequest</code>对象语法，这里最重要的一点是要设置<code>responseType 为 blob</code>，这样接收到<code>response</code>直接就是一个<code>blob</code>对象供我们使用。这个<code>responseType</code>属性不属于<code>http</code>头部信息，而是 ajax 请求中 XHR 对象的属性(默认为””也就是 text 类型，而在一些封装 XHR 的框架中，一般把默认值设为 json)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://localhost:3001/video'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取blob对象</span></span><br><span class="line">    <span class="keyword">let</span> blob = <span class="keyword">this</span>.response;</span><br><span class="line">    <span class="built_in">console</span>.log(blob);</span><br><span class="line">    <span class="comment">// 获取blob对象地址，并把值赋给容器</span></span><br><span class="line">    $(<span class="string">'#sound'</span>).attr(<span class="string">'src'</span>, URL.createObjectURL(blob));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>这样就可以得到以 blob:开头的临时 url 地址，而且在向服务端请求时页隐藏了真实的视频地址.</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://juejin.im/post/5d1ea7a8e51d454fd8057bea" target="_blank" rel="noopener">为什么视频网站的视频链接地址是 blob？</a><br><a href="https://www.jianshu.com/p/04727924273d" target="_blank" rel="noopener">通过 BLOB 加密视频文件</a></p>
]]></content>
      <categories>
        <category>Https</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列 css中padding</title>
    <url>/blog/css/deep-attribute/css-padding.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>padding</code>: 简写属性在一个声明中设置所有内边距属性。所有浏览器都支持 <code>padding</code> 属性，这里就多做赘述了，但是要注意以下：</p>
<blockquote>
<p>任何的版本的 <code>Internet Explorer</code> （包括 IE8）都不支持属性值 <code>&quot;inherit&quot;</code>。</p>
</blockquote>
<p><strong>可能的值</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">auto</td>
<td style="text-align:center">浏览器计算内边距。</td>
</tr>
<tr>
<td style="text-align:center">length</td>
<td style="text-align:center">规定以具体单位计的内边距值，比如像素（px）、厘米(cm)等。默认值是 0px。</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center"><strong>规定基于父元素的宽度的百分比的内边距。</strong></td>
</tr>
<tr>
<td style="text-align:center">inherit</td>
<td style="text-align:center">规定应该从父元素继承内边距。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>padding 不支持负值</strong></p>
</blockquote>
<p>本篇目录：</p>
<ul>
<li><code>padding</code> 对 <code>block</code> 元素的影响</li>
<li><code>padding</code> 对 <code>inline</code> 元素的影响</li>
<li>关于 <code>padding</code> 的百分比值</li>
<li><code>padding</code> 的应用场景</li>
</ul>
<h2 id="padding-对-block-的影响"><a href="#padding-对-block-的影响" class="headerlink" title="padding 对 block 的影响"></a>padding 对 block 的影响</h2><ul>
<li><code>width</code> 固定</li>
<li><code>width</code> 为 <code>auto</code> 或者 <code>box-sizing</code> 为 <code>border-box</code> 的时候</li>
</ul>
<h3 id="width-固定"><a href="#width-固定" class="headerlink" title="width 固定"></a>width 固定</h3><p><code>padding</code> 是会影响元素的尺寸的，<code>padding</code> 会对 <code>block</code> 元素的尺寸产生影响。代码如下：<br><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示结果如下：<br><img src="./css-padding/css-padding-1-1.png" alt="css padding"><br>验证了上面的猜测，<strong>padding 会对 block 元素的尺寸产生影响</strong>；</p>
<h3 id="width-为-auto-或者-box-sizing-为-border-box-的时候"><a href="#width-为-auto-或者-box-sizing-为-border-box-的时候" class="headerlink" title="width 为 auto 或者 box-sizing 为 border-box 的时候"></a>width 为 auto 或者 box-sizing 为 border-box 的时候</h3><p>首先要知道 <code>box-sizing</code> 为 <code>border-box</code> 代表什么意思，其实就是盒模型为 ie 模式。ie 的盒模型就是他的<strong>content+padding+border</strong>都算在盒模型内。<br>这个用上面的例子就不太合适，看下面的一个例子：</p>
<p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  文字的应该怎么放置？</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示如下：<br><img src="./css-padding/padding-1-2.png" alt="css padding"></p>
<p>对于 <code>block</code> 水平元素，但是<strong>width:auto</strong>或<strong>box-sizing 为 border-box</strong>的时候 <code>padding</code><strong>不会影响</strong>元素的尺寸。</p>
<p>修改 css 代码如下：<br><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-padding/padding-1-3.png" alt="css padding"><br><img src="./css-padding/padding-1-4.png" alt="css padding"><br>当<code>padding</code>大小<strong>超过宽度</strong>时，宽度按<code>padding的宽度</code>显示，里面的<strong>文字按最小宽度</strong>显示。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>padding 值大于元素本身的宽度时，一定会影响尺寸</strong>。</li>
<li><strong>width 非 auto，padding 影响尺寸</strong>。</li>
<li><strong>width 为 auto 或 box-sizing 为 border-box，同时 padding 值没有超过元素本身的宽度，不影响尺寸</strong>。</li>
</ul>
<h2 id="padding-对-inline-元素的影响"><a href="#padding-对-inline-元素的影响" class="headerlink" title="padding 对 inline 元素的影响"></a>padding 对 inline 元素的影响</h2><p>在上面代码的基础上修改代码如下：<br><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下：<br><img src="./css-padding/padding-1-5.png" alt="css padding"><br><img src="./css-padding/padding-1-6.png" alt="css padding"><br><strong>水平 padding 影响尺寸，垂直 padding 不影响尺寸，但会影响背景色（占据空间）</strong>。</p>
<h2 id="关于-padding-的百分比值"><a href="#关于-padding-的百分比值" class="headerlink" title="关于 padding 的百分比值"></a>关于 padding 的百分比值</h2><ul>
<li>关于 block 元素的 padding 的百分比值</li>
<li>关于 inline 元素的 padding 的百分比值</li>
</ul>
<h3 id="block-元素的-padding-的百分比值"><a href="#block-元素的-padding-的百分比值" class="headerlink" title="block 元素的 padding 的百分比值"></a>block 元素的 padding 的百分比值</h3><p><strong>padding 百分比均是相对于父元素的宽度计算的</strong>。实现效果如下：</p>
<p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="comment">/* width: 100px; */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffed53</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下，可以明显看到<code>box</code>的宽高都是<code>100px</code>;<br><img src="./css-padding/padding-1-7.png" alt="css padding"><br><img src="./css-padding/padding-1-8.png" alt="css padding"></p>
<h3 id="inline-水平元素的-padding-百分比值"><a href="#inline-水平元素的-padding-百分比值" class="headerlink" title="inline 水平元素的 padding 百分比值"></a>inline 水平元素的 padding 百分比值</h3><p>注意以下几点：</p>
<ul>
<li>同样相对于宽度计算</li>
<li>默认的高度宽度细节有差异</li>
<li>padding 会断行</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#8ec63f</span>;</span></span><br><span class="line">    padding: 50%;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>若干文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="./css-padding/padding-1-9.png" alt="css-padding" width="50%"><br><img src="./css-padding/padding-1-10.png" alt="css-padding" width="50%"></p>
<p><code>inline</code>元素的垂直 padding 会让“幽灵空白节点”显现，也就是规范中的“strut”出现。</p>
<h2 id="标签元素的内置-paading"><a href="#标签元素的内置-paading" class="headerlink" title="标签元素的内置 paading"></a>标签元素的内置 paading</h2><ul>
<li>ol/li 元素内置 padding-left, 但单位是 px 不是 em;<ol>
<li>例如 chrom 浏览器下是 40px;</li>
<li>所以如果字号很小，间距就会很开；</li>
<li>如果字号很大，序号就会爬到容器外面</li>
</ol>
</li>
</ul>
<blockquote>
<p>备注：文字大小一般为 12px~14px ，padding-left 为 22px~25px，基本可以实号与下面的内容对齐。</p>
</blockquote>
<ul>
<li>所有浏览器 input/textarea 输入框内置 padding</li>
<li>所有浏览器 button 按钮内置 padding</li>
<li>所有浏览器 radio/chexbox 单复选框无内置 padding</li>
<li>button 按钮元素的 padding 最难控制<br>button 使用：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"btn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">label &#123; display: inline-block; line-height: 20px; padding: 10px; &#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以实现一个在任何浏览器上高度为<code>40px</code>按钮。</p>
<h2 id="padding-的应用场景"><a href="#padding-的应用场景" class="headerlink" title="padding 的应用场景"></a>padding 的应用场景</h2><ul>
<li>实现 3 道杠效果</li>
<li>实现白眼效果</li>
<li>1:1 头图布局</li>
<li>实现等高布局</li>
<li>两栏自适应布局</li>
</ul>
<h3 id="实现-3-道杠效果"><a href="#实现-3-道杠效果" class="headerlink" title="实现 3 道杠效果"></a>实现 3 道杠效果</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    padding: 15px 0;</span><br><span class="line">    border-top: 30px solid currentColor;</span><br><span class="line">    border-bottom: 30px solid currentColor;</span><br><span class="line">    background-color: currentColor;</span><br><span class="line">    background-clip: content-box;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注：background-clip:content-box ; /<strong>背景色不在 padding 区域显示</strong>/</p>
</blockquote>
<p>其实自己实现一个是最好的，借鉴一张别人的图如下：<br><img src="./css-padding/padding-2-1.png" alt="css-padding" width="50%"></p>
<h3 id="实现白眼效果"><a href="#实现白眼效果" class="headerlink" title="实现白眼效果"></a>实现白眼效果</h3><p><img src="./css-padding/padding-2-2.png" alt="css-padding" width="50%"></p>
<blockquote>
<p>备注：background-clip:content-box ; /<strong>背景色不在padding区域显示</strong>/</p>
</blockquote>
<h3 id="实现一个-1-1-布局"><a href="#实现一个-1-1-布局" class="headerlink" title="实现一个 1:1 布局"></a>实现一个 1:1 布局</h3><p><img src="./css-padding/padding-2-3.png" alt="css-padding" width="50%"></p>
<h3 id="实现等高布局"><a href="#实现等高布局" class="headerlink" title="实现等高布局"></a>实现等高布局</h3><p><img src="./css-padding/padding-2-4.png" alt="css-padding" width="50%"></p>
<blockquote>
<p>很大的 margin-bottom 负值，再用很大的 padding-bottom 填充缺失的空间</p>
</blockquote>
<h3 id="两栏自适应布局"><a href="#两栏自适应布局" class="headerlink" title="两栏自适应布局"></a>两栏自适应布局</h3><p><img src="./css-padding/padding-2-5.png" alt="css-padding" width="50%"><br><img src="./css-padding/padding-2-6.png" alt="css-padding" width="50%"></p>
<h2 id="总计"><a href="#总计" class="headerlink" title="总计"></a>总计</h2><p><code>padding 对 block 元素的影响</code></p>
<ul>
<li><strong>padding 值大于元素本身的宽度时，一定会影响尺寸</strong>。</li>
<li><strong>width 非 auto，padding 影响尺寸</strong>。</li>
<li><strong>width 为 auto 或 box-sizing 为 border-box，同时 padding 值没有超过元素本身的宽度，不影响尺寸</strong></li>
</ul>
<p><code>padding 对 inline 元素的影响</code></p>
<ul>
<li><strong>水平 padding 影响尺寸，垂直 padding 不影响尺寸，但会影响背景色（占据空间）</strong></li>
</ul>
<p><code>关于 padding 的百分比值</code></p>
<ul>
<li><strong>block 元素的 padding 的百分比值</strong><ol>
<li>padding 百分比均是相对于父元素的宽度计算的</li>
</ol>
</li>
<li><strong>inline 水平元素的 padding 百分比值</strong><ol>
<li>同样相对于宽度计算</li>
<li>默认的高度宽度细节有差异</li>
<li>padding 会断行</li>
</ol>
</li>
</ul>
<p><code>padding 的应用场景</code></p>
<ul>
<li><strong>实现 3 道杠效果</strong></li>
<li><strong>实现白眼效果</strong></li>
<li><strong>1:1 头图布局</strong></li>
<li><strong>实现等高布局</strong></li>
<li><strong>两栏自适应布局</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/qianxunpu/p/8303228.html" target="_blank" rel="noopener">css 之深入理解 padding</a><br><a href="https://www.imooc.com/learn/710" target="_blank" rel="noopener">CSS 深入理解之 padding</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 next-tick原理和源码解析</title>
    <url>/blog/vue/principle/vue-next-tick.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 vue 的官方文档中有一个 API 叫做 <code>nextTick</code>，<code>将回调延迟到下次 DOM 更新循环之后执行</code>。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.$nextTick([callback]);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line">[callback];</span><br></pre></td></tr></table></figure>
<p><strong>用法</strong><br>放在<code>Vue.nextTick()</code>回调函数中的执行的应该是<strong>涉及 DOM</strong>操作的 JavaScript 代码。</p>
<p>Vue 的响应式原理：在 data 选项里所有属性都会被<code>watcher</code>监控，当修改了<code>data</code>的某一个值，并不会<strong>立即</strong>反映到视图中。Vue 会将我们对<code>data</code>的更改放到<code>watcher</code>的一个队列中（异步），只有在当前任务空闲时才会去执行<code>watcher</code>队列任务。这就有一个延迟时间，所以对 dom 的操作要放在<code>$nextTick</code>中来操作，才能获取到最新的<code>dom</code>。</p>
<blockquote>
<p><a href="/blog/vue/principle/vue-definedProperty.html">响应式对象 Observer</a> &gt; <a href="/blog/vue/principle/vue-dep.html">依赖收集 Dep</a> &gt; <a href="/blog/vue/principle/vue-notify.html">派发更新 Watcher</a></p>
</blockquote>
<p><code>nextTick</code> 是 Vue 的一个<strong>核心</strong>实现，如果还不了解 js 运行机制，可以看一下另一篇文章<a href="/blog/javascript/eventloop/evenloop.html">js 运行机制</a>，这里就不多赘述了。</p>
<p>在浏览器环境中常见的 macro task 和 micro task 如下：<br><strong>macro task</strong>：</p>
<ul>
<li><code>setTimeout、setTimeInterval</code></li>
<li><code>MessageChannel</code></li>
<li><code>postMessage</code></li>
<li><code>setImmediate</code></li>
<li><code>requestAnimationFrame</code></li>
<li><code>I/O</code></li>
<li><code>UI 渲染</code>a</li>
</ul>
<p><strong>micro task</strong>：</p>
<ul>
<li>MutationObsever</li>
<li>Promise.then</li>
<li>process.nextTick</li>
</ul>
<h2 id="vue-源码解析"><a href="#vue-源码解析" class="headerlink" title="vue 源码解析"></a>vue 源码解析</h2><p>在<a href="/blog/vue/principle/vue-notify.html">派发更新 Watcher</a>里面有用到<code>nextTick(flushScheduerQueue)</code>，其实就是<code>vue</code>对派发更新的一个优化。下面直接看源码，在 src/core/util/next-tick.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nextTick，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。</span></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">'./error'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">'./env'</span>;</span><br><span class="line"><span class="comment">// flushScheduerQueue</span></span><br><span class="line"><span class="comment">/*存放异步执行的回调*/</span></span><br><span class="line"><span class="keyword">const</span> callbacks = [];</span><br><span class="line"><span class="comment">//一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*下一个tick时的回调*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//复制callback</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//清除callbacks</span></span><br><span class="line">  callbacks.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    <span class="comment">//触发callback的回调函数</span></span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span></span><br><span class="line"><span class="comment">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span></span><br><span class="line"><span class="comment">// microtasks have too high a priority and fire in between supposedly</span></span><br><span class="line"><span class="comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span></span><br><span class="line"><span class="comment">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span></span><br><span class="line"><span class="comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span></span><br><span class="line"><span class="comment">// Here we use microtask by default, but expose a way to force (macro) task when</span></span><br><span class="line"><span class="comment">// needed (e.g. in event handlers attached by v-on).</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  其大概的意思就是：在Vue2.4之前的版本中，nextTick几乎都是基于microTask实现的，</span></span><br><span class="line"><span class="comment">  但是由于microTask的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，</span></span><br><span class="line"><span class="comment">  就会导致一些诡异的问题；但是如果全部都改成macroTask，对一些有重绘和动画的场</span></span><br><span class="line"><span class="comment">  景也会有性能的影响。所以最终nextTick采取的策略是默认走microTask，对于一些DOM</span></span><br><span class="line"><span class="comment">  的交互事件，如v-on绑定的事件回调处理函数的处理，会强制走macroTask。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"><span class="keyword">let</span> microTimerFunc;</span><br><span class="line"><span class="keyword">let</span> macroTimerFunc;</span><br><span class="line"><span class="keyword">let</span> useMacroTask = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine (macro) task defer implementation.</span></span><br><span class="line"><span class="comment">// Technically setImmediate should be the ideal choice, but it's only available</span></span><br><span class="line"><span class="comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span></span><br><span class="line"><span class="comment">// events triggered in the same loop is by using MessageChannel.</span></span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而对于macroTask的执行，Vue优先检测是否支持原生setImmediate（高版本IE和Edge支持），</span></span><br><span class="line"><span class="comment">// 不支持的话再去检测是否支持原生MessageChannel，如果还不支持的话为setTimeout(fn, 0)。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    在Vue 2.4版本以前使用的MutationObserver来模拟异步任务。</span></span><br><span class="line"><span class="comment">    而Vue 2.5版本以后，由于兼容性弃用了MutationObserver。</span></span><br><span class="line"><span class="comment">    Vue 2.5+版本使用了MessageChannel来模拟macroTask。</span></span><br><span class="line"><span class="comment">    除了IE以外，messageChannel的兼容性还是比较可观的。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    可见，新建一个MessageChannel对象，该对象通过port1来检测信息，port2发送信息。</span></span><br><span class="line"><span class="comment">    通过port2的主动postMessage来触发port1的onmessage事件，</span></span><br><span class="line"><span class="comment">    进而把回调函数flushCallbacks作为macroTask参与事件循环。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = flushCallbacks;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine microtask defer implementation.</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">    <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// fallback to macro</span></span><br><span class="line">  microTimerFunc = macroTimerFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap a function so that if any code inside triggers state change,</span></span><br><span class="line"><span class="comment"> * the changes are queued using a (macro) task instead of a microtask.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    推送到队列中下一个tick时执行</span></span><br><span class="line"><span class="comment">    cb 回调函数</span></span><br><span class="line"><span class="comment">    ctx 上下文</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withMacroTask</span>(<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    fn._withTask ||</span><br><span class="line">    (fn._withTask = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      useMacroTask = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">const</span> res = fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      useMacroTask = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      microTimerFunc();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nextTick</code>这就是我们在上一节执行 <code>nextTick(flushSchedulerQueue)</code> 所用到的函数。它的逻辑也很简单，把传入的回调函数 <code>cb</code> 压入 <code>callbacks</code> 数组，最后一次性地根据 <code>useMacroTask</code> 条件执行 <code>macroTimerFunc</code> 或者是 <code>microTimerFunc</code>，而它们都会在下一个 <code>tick</code> 执行 <code>flushCallbacks</code>。<br><code>flushCallbacks</code> 这个方法就是挨个<strong>同步</strong>的去执行<code>callbacks</code>中的回调函数，<code>callbacks</code>中的回调函数是在调用 <code>nextTick</code> 的时候添加进去的；<br>这里使用 <code>callbacks</code> 而不是直接在 <code>nextTick</code> 中执行回调函数的原因是保证在同一个 <code>tick</code> 内多次执行 <code>nextTick</code>，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 <code>tick</code> 执行完毕。<br>注意这里有个比较难理解的地方，第一次调用 <code>nextTick</code> 的时候 <code>pending</code> 为<code>false</code>。<br>此时已经<code>push</code>到浏览器<code>event loop</code>中一个<strong>宏任务</strong>或<strong>微任务</strong>的<code>task</code>，如果在没有<code>flush</code>掉的情况下继续往<code>callbacks</code>里面添加。<br>那么在执行这个占位<code>queue</code>的时候会执行之后添加的回调，所以<code>macroTimerFunc</code>、<code>microTimerFunc</code> 相当于<code>task queue</code>的占位。<br>以后 <code>pending</code> 为<code>true</code>则继续往占位<code>queue</code>里面添加，<code>event loop</code>轮到这个<code>task queue</code>的时候将一并执行。<br>执行 <code>flushCallbacks</code> 时 <code>pending</code> 置<code>false</code>，允许下一轮执行 <code>nextTick</code> 时往<code>event loop</code>占位。</p>
<p><strong>macroTimerFunc、microTimerFunc</strong><br><code>next-tick.js</code> 申明了 <code>microTimerFunc</code> 和 <code>macroTimerFunc</code> 2 个变量，它们分别对应的是 <code>micro task</code> 的函数和 <code>macro task</code> 的函数。对于 <code>macro task</code> 的实现，优先检测是否支持原生 <code>setImmediate</code>，这是一个高版本 <code>IE</code> 和 <code>Edge</code>才支持的特性，不支持的话再去检测是否支持原生的 <code>MessageChannel</code>，如果也不支持的话就会降级为 <code>setTimeout</code> 0；而对于 <code>micro task</code> 的实现，则检测浏览器是否原生支持 <code>Promise，</code>不支持的话直接指向 <code>macro task</code> 的实现。</p>
<p><strong>nextTick 实现</strong></p>
<ol>
<li>首先 <code>nextTick</code> 把传入的 <code>cb</code> 回调函数用 <code>try-catch</code> 包裹后放在一个<strong>匿名函数</strong>中推入<code>callbacks</code>数组中。<br>这么做是因为防止单个 <code>cb</code> 如果执行错误不至于让整个<strong>JS 线程挂掉</strong>。<br>每个 cb 都包裹是防止这些回调函数如果执行错误不会相互影响，比如前一个抛错了后一个仍然可以执行。</li>
<li>然后检查 <code>pending</code> 状态，这个跟之前介绍的 <code>queueWatcher</code> 中的 <code>waiting</code> 是一个意思。<br>它是一个标记位，一开始是 <code>false</code> 在进入<code>macroTimerFunc</code>、<code>microTimerFunc</code>方法前被置为 <code>true</code>。因此下次调用 <code>nextTick</code> 就不会进入<code>macroTimerFunc</code>、<code>microTimerFunc</code>方法。<br>这两个方法中会在下一个 <code>macro/micro tick</code> 时候 <code>flushCallbacks</code> 异步的去执行<code>callbacks队</code>列中收集的任务，而 <code>flushCallbacks</code> 方法在执行一开始会把 <code>pending</code> 置 <code>false</code>。<br>因此下一次调用 <code>nextTick</code> 时候又能开启新一轮的 <code>macroTimerFunc</code>、<code>microTimerFunc</code>，这样就形成了 vue 中的 <code>event loop</code>。</li>
<li>最后检查是否传入了 <code>cb</code>。因为 <code>nextTick</code> 还支持 Promise 化的调用：<code>nextTick().then(() =&gt; {})</code>。所以如果没有传入 <code>cb</code> 就直接<code>return了一个Promise</code>实例，并且把<code>resolve</code>传递给<code>_resolve</code>。这样后者执行的时候就跳到我们调用的时候传递进 then 的方法中。</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;span id=<span class="string">'name'</span> ref=<span class="string">'name'</span>&gt;&#123;&#123; name &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click='change'&gt;change name&lt;/</span>button&gt;</span><br><span class="line">    &lt;div id=<span class="string">'content'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'userName'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change() &#123;</span><br><span class="line">        <span class="keyword">const</span> $name = <span class="keyword">this</span>.$refs.name</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'同步方式1：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML)</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setter前：'</span> + $name.innerHTML))</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">' setterName '</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'同步方式2：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML)</span><br><span class="line">        <span class="comment">// setTimeout(() =&gt; &#123;console("setTimeout方式：" + this.$refs.name.innerHTML)&#125;</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'setTimeout方式：'</span> + <span class="keyword">this</span>.$refs.name.innerHTML);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setter后：'</span> + $name.innerHTML))</span><br><span class="line">        <span class="keyword">this</span>.$nextTick().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Promise方式：'</span> + $name.innerHTML))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行结果如下图所示：<br><img src="../../../images/vue/vue-nextTick-1-1.png" alt="vue-nextTick"></p>
<ol>
<li>同步方式： 当把<code>data</code>中的<code>name</code>修改之后，此时会触发<code>name</code>的 <code>setter</code> 中的 <code>dep.notify</code> 通知依赖本<code>data</code>的<code>render watcher</code>去 <code>update</code>，<code>update</code> 会把 <code>flushSchedulerQueue</code> 函数传递给 <code>nextTick</code>，<code>render watcher</code>在 <code>flushSchedulerQueue</code> 函数运行时 <code>watcher.run</code> 再走 <code>diff -&gt; patch</code> 那一套重渲染 <code>re-render</code> 视图，这个过程中会重新依赖收集，这个过程是异步的；所以当我们直接修改了<code>name</code>之后打印，这时异步的改动还没有被 <code>patch</code> 到视图上，所以获取视图上的 DOM 元素还是原来的内容。</li>
<li>setter 前： <code>setter</code>前为什么还打印原来的是原来内容呢，是因为 <code>nextTick</code> 在被调用的时候把回调挨个<code>push</code>进<code>callbacks</code>数组，之后执行的时候也是 for 循环出来挨个执行，所以是类似于队列这样一个概念，先入先出；在修改<code>name</code>之后，触发把<code>render watcher</code>填入 <code>schedulerQueue</code> 队列并把他的执行函数 <code>flushSchedulerQueue</code> 传递给 <code>nextTick</code> ，此时<code>callbacks</code>队列中已经有了 <code>setter</code>前函数 了，因为这个 <code>cb</code> 是在 <code>setter</code>前函数 之后被<code>push</code>进<code>callbacks</code>队列的，那么先入先出的执行<code>callbacks</code>中回调的时候先执行 <code>setter</code>前函数，这时并未执行<code>render watcher</code>的 <code>watcher.run</code>，所以打印 DOM 元素仍然是原来的内容。</li>
<li>setter 后： <code>setter</code>后这时已经执行完 <code>flushSchedulerQueue</code>，这时<code>render watcher</code>已经把改动 <code>patch</code> 到视图上，所以此时获取 DOM 是改过之后的内容。</li>
<li>Promise 方式： 相当于 <code>Promise.then</code> 的方式执行这个函数，此时 DOM 已经更改。</li>
<li>setTimeout 方式： 最后执行<code>macro task</code>的任务，此时 DOM 已经更改。</li>
</ol>
<p>注意，在执行 <code>setter</code>前函数 这个异步任务之前，同步的代码已经执行完毕。异步的任务都还未执行，所有的 <code>$nextTick</code> 函数也执行完毕。所有回调都被<code>push</code>进了<code>callbacks</code>队列中等待执行，所以在<code>setter</code>前函数执行的时候。此时<code>callbacks</code>队列是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[setter前函数, flushSchedulerQueue, setter后函数, <span class="built_in">Promise</span>方式函数];</span><br></pre></td></tr></table></figure>
<p>它是一个<code>micro task</code>队列，执行完毕之后执行<code>macro task</code> <code>setTimeout</code>，所以打印出上面的结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>nextTick</code>是把要执行的任务推入到一个队列中，在下一个<code>tick</code>同步执行</li>
<li>数据改变后触发渲染<code>watcher</code>的<code>update</code>，但是<code>watchers</code>的<code>flush</code>是在<code>nextTick</code>后，所以重新渲染是异步的</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/next-tick.html#js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">nextTick</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a><br><a href="https://juejin.im/post/5b50760f5188251ad06b61be" target="_blank" rel="noopener">Vue 源码阅读 - 批量异步更新与 nextTick 原理</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>css实现Sticky footer效果</title>
    <url>/blog/css/effect/css-footer.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在网页设计中，<code>Sticky footers</code>设计是最古老和最常见的效果之一，大多数人都曾经经历过。所谓 “Sticky Footer”，并不是什么新的前端概念和技术，它指的就是一种网页效果： <strong>如果页面内容不足够长时，页脚固定在浏览器窗口的底部；如果内容足够长时，页脚固定在页面的最底部。但如果网页内容不够长，置底的页脚就会保持在浏览器窗口底部</strong>。</p>
<p>大致分为两种，一种是 <code>footer 为固定高度</code>、<code>一种为不固定的高度</code>，当然不固定高度是包含了固定高度的，他们实现方式是不同的<br>。</p>
<h2 id="固定-footer-高度"><a href="#固定-footer-高度" class="headerlink" title="固定 footer 高度"></a>固定 footer 高度</h2><ul>
<li><code>负 margin-bottom 实现</code></li>
<li><code>calc()</code></li>
<li><code>position: absolute</code></li>
</ul>
<h3 id="负-margin-bottom-实现"><a href="#负-margin-bottom-实现" class="headerlink" title="负 margin-bottom 实现"></a>负 margin-bottom 实现</h3><p>把 <code>wrapper</code> 部分最小高度设为 <code>100%</code>，再利用内容部分的负底部外边距值来达到当高度不满时，页脚保持在窗口底部，当高度超出则随之推出的效果。</p>
<p>html 代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  html,</span><br><span class="line">  body &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">    min-height: 100%;</span><br><span class="line"><span class="css">    <span class="comment">/* 等于footer的高度 */</span></span></span><br><span class="line">    margin-bottom: -50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">    height: 50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>.wrapper</code>的 <code>margin-bottom</code>值需要和<code>.footer</code>的负的<code>height</code>值保持一致，这一点不太友好。</p>
<h3 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h3><p>使用 CSS3 新增的计算函数 <code>calc()</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 等于footer的高度 */</span></span></span><br><span class="line">    min-height: calc(100vh - 50px);</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">    height: 50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不需考虑 <code>calc()</code> 以及 <code>vh</code> 单位的兼容情况，这是个很理想的实现方案。同样的问题是 <code>footer</code> 的高度值需要与 <code>content</code> 其中的计算值一致。<br>一般都是不建议使用 css 计算属性，会造成一定的性能损失。</p>
<h3 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position: absolute"></a>position: absolute</h3><p>通过绝对定位处理应该是常见的方案，只要使得页脚一直定位在主容器预留占位位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    min-height: 100%;</span><br><span class="line">    padding-bottom: 50px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>wrapper</code> 的 <code>padding-bottom</code> 需要与 <code>footer</code> 的 <code>height</code> 一致。</p>
<h2 id="不固定-footer-高度"><a href="#不固定-footer-高度" class="headerlink" title="不固定 footer 高度"></a>不固定 footer 高度</h2><ul>
<li>使用 <code>flexbox</code> 弹性盒布局</li>
<li><code>grid</code> 布局</li>
<li><code>table</code> 布局</li>
</ul>
<p>不固定 <code>footer</code> 高度是包含固定高度的 <code>Sticky footer</code> 的。</p>
<h3 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h3><p>弹性布局，把主轴设置为 <code>column</code>，再通过吧.<code>content</code> 的 <code>felx</code> 设置为 <code>1（1, 1, auto）</code>.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">    min-height: 100vh;</span><br><span class="line">    flex-direction: column;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    flex: 1;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">    min-height: 50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不知道 <code>flex</code> 布局的一些属性或者用法，可以看我另一篇博客。</p>
<h3 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h3><p><code>grid</code> 是比较新的 css3 的属性，没有看过可以看我另外一篇博客。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">    display: grid;</span><br><span class="line">    min-height: 100vh;</span><br><span class="line">    grid-template-rows: 1fr auto;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">    grid-row-start: 2;</span><br><span class="line">    grid-row-end: 3;</span><br><span class="line">    min-height: 50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>网格布局（Grid layout）</code>现在的支持还不太好，如果想查询浏览器或者在 <code>webview</code> 上的属性兼容性。可以去<a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a>查询，但是以后肯定是 <code>grid</code> 的天下。</p>
<h3 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h3><p><code>display: table</code> 的兼容性应该是最好的，直接上代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>100<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">    display: table;</span><br><span class="line">    width: 100%;</span><br><span class="line">    min-height: 100vh;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#0ff00f</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    display: table-row;</span><br><span class="line">    height: 100%;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">    min-height: 50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0ff0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，使用 <code>table</code> 方案存在一个比较常见的样式限制，通常 <code>margin、padding、border</code> 等属性会不符合预期。 笔者不建议使用这个方案。当然，问题也是可以解决的：别把其他样式写在 <code>table</code> 上。</p>
<p>每个方案都有自己的优势和劣势，根据页面具体需求，选择最适合的方案。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE3MjE1Mw%3D%3D&amp;mid=2247483693&amp;idx=1&amp;sn=ea846c8a1b404a8a0aa5a5175059e0f4&amp;chksm=fbb2a7fbccc52eed1b62f21503d93449c8425c464d5b4ac576facadf560f95ab9ea8aca5484b&amp;mpshare=1&amp;scene=23&amp;srcid=1120MlKsKxWYxEsbttZ5V0CO" target="_blank" rel="noopener">各种 CSS 实现 Sticky Footer</a><br><a href="https://www.jianshu.com/p/8fdb81e074e2" target="_blank" rel="noopener">CSS 五种方式实现 Footer 置底</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的grid布局</title>
    <url>/blog/css/deep-attribute/css-grid.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSS 网格布局擅长于将一个页面划分为几个主要区域，以及定义这些区域的<code>大小、位置、层次</code>等关系（前提是 HTML 生成了这些区域）。<br>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。<br>Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。<br>在 Grid 布局中，所有 css 属性分为两类，一类作用到 grid 容器上，还有一类作用在 grid 项目上。<br>如下表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">作用在 grid 容器上</th>
<th style="text-align:center">作用在 grid 子项上</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>grid-template-columns</strong> <br> <strong>grid-template-rows</strong> <br> <strong>grid-template-areas</strong> <br> <strong>grid-template</strong> <br> <strong>grid-column-gap </strong> <br> <strong>grid-row-gap </strong> <br> <strong>grid-gap </strong> <br> <strong>justify-items </strong> <br> <strong>align-items </strong> <br> <strong>place-items </strong> <br> <strong>justify-content </strong> <br> <strong>align-content </strong> <br> <strong>place-content </strong> <br> <strong>grid-auto-columns </strong> <br> <strong>grid-auto-rows </strong> <br> <strong>grid-auto-flow </strong> <br> <strong>grid </strong></td>
<td style="text-align:center"><strong>grid-column-start</strong> <br> <strong> grid-column-end</strong> <br> <strong> grid-row-start</strong> <br> <strong> grid-row-end</strong> <br> <strong> grid-column</strong> <br> <strong> grid-row</strong> <br> <strong> grid-area</strong> <br> <strong> justify-self</strong> <br> <strong> align-self</strong> <br> <strong> place-self</strong> <br></td>
</tr>
</tbody>
</table>
<h2 id="作用在-grid-容器上的-CSS-属性"><a href="#作用在-grid-容器上的-CSS-属性" class="headerlink" title="作用在 grid 容器上的 CSS 属性"></a>作用在 grid 容器上的 CSS 属性</h2><p>基础代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width"</span>&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #00ff00"</span>&gt;</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #ff0000"&gt;</span></span><br><span class="line"><span class="regexp">      2</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #0000ff; color: #fff"</span>&gt;</span><br><span class="line">      <span class="number">3</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #ffff00"&gt;</span></span><br><span class="line"><span class="regexp">      4</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #00ffff"</span>&gt;</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #0f0f0f; color: #fff"&gt;</span></span><br><span class="line"><span class="regexp">      6</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #f0f0f0"</span>&gt;</span><br><span class="line">      <span class="number">7</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #ff00ff"&gt;</span></span><br><span class="line"><span class="regexp">      8</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #fff000"</span>&gt;</span><br><span class="line">      <span class="number">9</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #00ff00"&gt;</span></span><br><span class="line"><span class="regexp">      10</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: #000fff; color: #fff"</span>&gt;</span><br><span class="line">      <span class="number">11</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="background: #00ffff"&gt;</span></span><br><span class="line"><span class="regexp">      12</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="grid-template-columns-和-grid-template-rows"><a href="#grid-template-columns-和-grid-template-rows" class="headerlink" title="grid-template-columns 和 grid-template-rows"></a>grid-template-columns 和 grid-template-rows</h3><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code> 属性定义每一列的列宽，<code>grid-template-rows</code> 属性定义每一行的行高。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会指定一个 <code>3 列 4 行</code>的网格，列宽和行高都是 <code>100px</code>;<br><img src="./css-grid/grid-1-1.png" alt="css grid"></p>
<p><strong>值</strong></p>
<ul>
<li>可以为 <code>px</code> 或者 <code>百分比（%）</code></li>
<li><code>auto</code></li>
<li><code>repeat( [ &lt;positive-integer&gt; | auto-fill | auto-fit ] , &lt;track-list&gt; )</code></li>
<li><code>fr(fraction)</code>是单词 <code>fraction</code> 的缩写，表示分数</li>
<li><code>max-content</code>、<code>min-content</code>、<code>minmax(min, max)</code></li>
</ul>
<p><code>px 和百分比</code>我们就不介绍了。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用 <code>auto-fill</code> 关键字表示自动填充。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把第一列设置为 <code>auto</code>，效果如下：<br><img src="./css-grid/grid-1-2.png" alt="css grid"></p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>表示网格轨道的重复部分，以一种更简洁的方式去表示大量而且重复列的表达式。函数接收两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。在第一个基础上改写代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 100px);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个效果和直接写三个 <code>100px</code> 的效果是一样的。</p>
<h3 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h3><p><code>fr</code>是单词 <code>fraction</code> 的缩写，表示分数。</p>
<ul>
<li>先从简单例子看起：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>1:1:1</code>，网格宽度三等分，实时效果如下：<br><img src="./css-grid/grid-1-3.png" alt="css grid"></p>
<ul>
<li>如果有固定尺寸值，则划分剩余空间大小，例如：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-grid/grid-1-4.png" alt="css grid"><br>后面两列是 <code>grid</code> 容器宽度减去 <code>100</code> 像素后的 <code>1/2</code>。</p>
<ul>
<li>如果和 <code>auto</code> 混用会如何呢</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-grid/grid-1-5.png" alt="css grid"><br><code>auto</code> 在和 <code>px、百分比</code>一起用的时候是撑满剩下的空间。但是和 <code>fr</code> 一起用的时候为内容宽度。</p>
<h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h3><p><code>grid-template-areas</code> 属性是 <code>grid areas</code> 在 CSS 中的特定命名。</p>
<p><strong>语法</strong><br><strong>值</strong><br><code>none</code><br>网格容器没有定义任何的<code>网格区块(grid areas)</code>。<br><code>&lt;string&gt;+</code><br>每一个给定的字符串会生成一行，一个字符串中用空格分隔的每一个单元<code>(cell)</code>会生成一列。多个同名的，跨越相邻行或列的单元称为网格区块<code>(grid area)</code>。非矩形的网格区块是无效的。</p>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #00ff00"</span>&gt;</span></span><br><span class="line">  1</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #ff0000"</span>&gt;</span></span><br><span class="line">  2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #0000ff; color: #fff"</span>&gt;</span></span><br><span class="line">  3</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #ffff00"</span>&gt;</span></span><br><span class="line">  4</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">'头部 头部 头部'</span></span><br><span class="line">    <span class="string">'nav content content'</span></span><br><span class="line">    <span class="string">'nav content content'</span></span><br><span class="line">    <span class="string">'foot foot foot'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: 头部;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: nav;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: foot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的网格区域一定要形成规整的矩形区域，什么 L 形，凹的或凸的形状都是不支持的，会认为是无效的属性值。<br><img src="./css-grid/grid-1-6.png" alt="css grid"></p>
<h3 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h3><p><code>grid-template</code> 是一个简写的 CSS 属性，用于定义 <code>grid columns</code>, <code>rows</code> 和 <code>areas</code>。<br>语法如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-template: &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;;</span><br></pre></td></tr></table></figure>
<p>用 <code>grid-template</code> 实现上面的效果，代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>:</span><br><span class="line">    <span class="string">'头部 头部 头部'</span> <span class="number">1</span>fr</span><br><span class="line">    <span class="string">'nav content content'</span> <span class="number">1</span>fr</span><br><span class="line">    <span class="string">'nav content content'</span> <span class="number">1</span>fr</span><br><span class="line">    <span class="string">'foot foot foot'</span> <span class="number">1</span>fr</span><br><span class="line">    / <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实现的效果和上面的一样。</p>
<blockquote>
<p>由于<code>grid-template</code>不会重置一些隐式的 grid 属性（如<code>grid-auto-columns</code>，<code>grid-auto-rows</code>和<code>grid-auto-flow</code>），因此，大多数时候，还是推荐使用 grid 代替 grid-template。</p>
</blockquote>
<h3 id="grid-column-gap-和-grid-row-gap、grid-gap"><a href="#grid-column-gap-和-grid-row-gap、grid-gap" class="headerlink" title="grid-column-gap 和 grid-row-gap、grid-gap"></a>grid-column-gap 和 grid-row-gap、grid-gap</h3><p><code>grid-column-gap</code> 和 <code>grid-row-gap</code> 属性用来定义网格中网格间隙的尺寸。你可以理解成田地之间走路的田垄宽度。<br>语法如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-column-gap: 10px; // 水平间隔 10px</span><br><span class="line">grid-row-gap: 10px; // 垂直间隔 10px</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-column-gap</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">grid-row-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-grid/grid-1-7.png" alt="css grid"></p>
<h4 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h4><p><code>CSS grid-gap</code> 属性是 <code>grid-column-gap</code> 和 <code>grid-row-gap</code> 属性的缩写。语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-gap</span>: &lt;<span class="selector-tag">grid-row-gap</span>&gt; &lt;<span class="selector-tag">grid-column-gap</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>实现和上面一样的布局代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span>;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span>;</span><br><span class="line"><span class="selector-tag">grid-gap</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<h3 id="justify-items、align-items、palce-items"><a href="#justify-items、align-items、palce-items" class="headerlink" title="justify-items、align-items、palce-items"></a>justify-items、align-items、palce-items</h3><p><code>justify-items</code> 属性设置单元格内容的水平位置（左中右），<code>align-items</code> 属性设置单元格内容的垂直位置（上中下）。<br><strong>语法如下</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">justify-items: start | end | center | stretch;</span><br><span class="line">align-items: start | end | center | stretch;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>start</code>：对齐单元格的起始边缘。</li>
<li><code>end</code>：对齐单元格的结束边缘。</li>
<li><code>center</code>：单元格内部居中。</li>
<li><code>stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#justify-items" target="_blank" rel="noopener">justify-items 效果参考 张鑫旭大佬的博客</a><br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#align-items" target="_blank" rel="noopener">align-items 效果参考 张鑫旭大佬的博客</a></p>
<h4 id="palce-items"><a href="#palce-items" class="headerlink" title="palce-items"></a>palce-items</h4><p><code>place-items</code> 属性是 <code>align-items</code> 属性和 <code>justify-items</code> 属性的合并简写形式。<br><strong>语法</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-items</span>: &lt;<span class="selector-tag">align-items</span>&gt; &lt;<span class="selector-tag">justify-items</span>&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果省略第二个值，则浏览器认为与第一个值相等。</p>
</blockquote>
<h3 id="justify-content、align-content、place-content"><a href="#justify-content、align-content、place-content" class="headerlink" title="justify-content、align-content、place-content"></a>justify-content、align-content、place-content</h3><p><code>justify-content</code> 属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code> 属性是整个内容区域的垂直位置（上中下）。</p>
<blockquote>
<p>justify-content 指定了网格元素的水平分布方式。此属性仅在网格总宽度小于 grid 容器宽度时候有效果。</p>
</blockquote>
<p>语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">justify-content: start | end | center | stretch | space-around | space-between |</span><br><span class="line">  <span class="selector-tag">space-evenly</span>;</span><br><span class="line">align-content: start | end | center | stretch | space-around | space-between |</span><br><span class="line">  <span class="selector-tag">space-evenly</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>start - 对齐容器的起始边框。</li>
<li>end - 对齐容器的结束边框。</li>
<li>center - 容器内部居中。</li>
<li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li>
<li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li>
<li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li>
<li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li>
</ul>
<p>正式效果参考如下：<br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#justify-content" target="_blank" rel="noopener">justify-content 效果参考 张鑫旭大佬的博客</a><br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#align-content" target="_blank" rel="noopener">align-content 效果参考 张鑫旭大佬的博客</a></p>
<h4 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h4><p><code>place-content</code> 属性是 <code>align-content</code> 属性和 <code>justify-content</code> 属性的合并简写形式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-content</span>: &lt;<span class="selector-tag">align-content</span>&gt; &lt;<span class="selector-tag">justify-content</span>&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p>
</blockquote>
<h3 id="grid-auto-columns、grid-auto-rows"><a href="#grid-auto-columns、grid-auto-rows" class="headerlink" title="grid-auto-columns、grid-auto-rows"></a>grid-auto-columns、grid-auto-rows</h3><p>指定任何自动生成的网格轨道（也称为隐式网格轨道）的大小。 当网格项目多于网格中的单元格或网格项目放置在显式网格之外时，将创建隐式轨道。<br><strong>语法</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-auto-columns</span>: &lt;<span class="selector-tag">track-size</span>&gt; ...;</span><br><span class="line"><span class="selector-tag">grid-auto-rows</span>: &lt;<span class="selector-tag">track-size</span>&gt; ...;</span><br></pre></td></tr></table></figure>
<p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<p>示例如划分好的网格是 2 行 x 2 列，但是，3 号项目指定在第 3 行，4 号项目指定在第 4 行。<br>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-auto-columns</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-grid/grid-1-8.png" alt="css grid"></p>
<h3 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h3><p><code>grid-auto-flow</code> 属性控制没有明确指定位置的 <code>grid</code> 子项的放置方式。比方说定义了一个 5*2 的 10 格子，共有 5 个元素，其中 2 个元素指定了放在哪个格子里，还有 3 个则自生自灭排列。此时，这 3 个元素如何排列就是由 grid-auto-flow 属性控制的。<br><strong>语法</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-auto-flow: row | column | row dense | column dense;</span><br></pre></td></tr></table></figure>
<ul>
<li>row 默认值。没有指定位置的网格依次水平排列优先。</li>
<li>column 没有指定位置的网格依次垂直排列优先。</li>
<li>dense dense 这个英文是稠密的意思。如果有设置，则表示自动排列启用“密集”打包算法。如果稍后出现的网格比较小，则尝试看看前面有没有合适的地方放置，使网格尽可能稠密紧凑。此属性值仅仅改变视觉顺序，会导致 DOM 属性和实际呈现顺序不符合，这对于可访问性是不友好的，建议谨慎使用。<br>示例请看<a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#grid-auto-flow" target="_blank" rel="noopener">grid-auto-flow 效果参考 张鑫旭大佬的博客</a></li>
</ul>
<h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>是下面所有这些 CSS 属性的缩写集合，<code>grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns 和 grid-auto-flow</code>。<br>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure>
<p><code>none</code>表示设置所有的子属性为初始值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid</span>: &lt;<span class="selector-tag">grid-template</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>和 grid-template 用法一致</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid: &lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;?;</span><br></pre></td></tr></table></figure>
<p>上面就是 grid 容器上的属性，属性很多不好记，要多练习几遍才能熟练使用。</p>
<h2 id="作用在-grid-子项上的-CSS-属性"><a href="#作用在-grid-子项上的-CSS-属性" class="headerlink" title="作用在 grid 子项上的 CSS 属性"></a>作用在 grid 子项上的 CSS 属性</h2><ul>
<li><code>grid-column-start, grid-column-end, grid-row-start 和 grid-row-end</code></li>
<li><code>grid-column 和 grid-row</code></li>
<li><code>grid-area</code></li>
<li><code>justify-self、align-self、place-self</code></li>
</ul>
<h3 id="grid-column-start-grid-column-end-grid-row-start-和-grid-row-end"><a href="#grid-column-start-grid-column-end-grid-row-start-和-grid-row-end" class="headerlink" title="grid-column-start, grid-column-end, grid-row-start 和 grid-row-end"></a>grid-column-start, grid-column-end, grid-row-start 和 grid-row-end</h3><p>表示 grid 子项所占据的区域的起始和终止位置，包括水平方向和垂直方向。<br><strong>语法</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto</span><br><span class="line">grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto</span><br><span class="line">grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto</span><br><span class="line">grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto</span><br></pre></td></tr></table></figure>
<p>语法中的管道分隔符|表示“或者”的意思，所以别看上面好长，实际上就一个属性值，具体来讲：</p>
<ul>
<li><code>&lt;number&gt;</code> : 起止与第几条网格线。</li>
<li><code>&lt;name&gt;</code> : 自定义的网格线的名称。</li>
<li><code>span &lt;number&gt;</code> : 表示当前网格会自动跨越指定的网格数量。</li>
<li><code>span &lt;name&gt;</code>: 表示当前网格会自动扩展，直到命中指定的网格线名称。</li>
<li><code>auto</code>: 全自动，包括定位，跨度等。</li>
</ul>
<p><strong>普通数字</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-grid/grid-1-10.png" alt="css grid"></p>
<p><strong>网格线的名字</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [第一列] <span class="number">100px</span> [第二列] <span class="number">100px</span> [第三列] <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [第一行] <span class="number">100px</span> [第二行] <span class="number">100px</span> [第三行] <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: 第一列;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: 第一行;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面结果相同</p>
<p><strong>span 关键字</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [第一列] <span class="number">100px</span> [第二列] <span class="number">100px</span> [第三列] <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [第一行] <span class="number">100px</span> [第二行] <span class="number">100px</span> [第三行] <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="grid-column-和-grid-row"><a href="#grid-column-和-grid-row" class="headerlink" title="grid-column 和 grid-row"></a>grid-column 和 grid-row</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。<br><strong>语法</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-column: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</span><br><span class="line">grid-row: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</span><br></pre></td></tr></table></figure>
<p>改写上面的代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: [第一列]/ span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: [第一行]/ span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面的实现一样。</p>
<h3 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h3><p><code>grid-area</code>表示当前网格所占用的区域。在介绍<code>grid-template-areas</code>属性的时候就演示过该属性，我们使用<code>grid-template-areas</code>属性自定义一些网格区域，然后使用<code>grid-area</code>属性让 grid 子项指定使用这些区域，就自动进行了区域分布。<br><code>grid-area</code>和<code>grid-column/grid-row</code>作用都是 grid 子项的分布，但<code>grid-area</code>语义要更好，识别度更佳，非常适合具有功能属性的布局区域（如头部，底部），同时，还支持非规则区域。</p>
<p><strong>语法</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-area: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li><name> 区域名称。由 grid-template-areas 属性创建。</name></li>
<li><code>&lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;</code> 占据网格区域的纵横起始位置。</li>
</ul>
<p>改写上面代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="justify-self、align-self、place-self"><a href="#justify-self、align-self、place-self" class="headerlink" title="justify-self、align-self、place-self"></a>justify-self、align-self、place-self</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。<br><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p>
<p><strong>语法</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">justify-self: start | end | center | stretch;</span><br><span class="line">align-self: start | end | center | stretch;</span><br></pre></td></tr></table></figure>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
<p>示例代码请看<br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#justify-self" target="_blank" rel="noopener">justify-self 效果参考 张鑫旭大佬的博客</a><br><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/#align-self" target="_blank" rel="noopener">align-self 效果参考 张鑫旭大佬的博客</a></p>
<h4 id="place-self"><a href="#place-self" class="headerlink" title="place-self"></a>place-self</h4><p>place-items 可以让 align-self 和 justify-self 属性写在单个声明中。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; / &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Grid 布局则适用于更大规模的布局（二维布局），而 Flexbox 布局最适合应用程序的组件和小规模布局（一维布局）</code></li>
<li><code>命名虽然支持中文，但由于 CSS 文件中文存在乱码的风险</code></li>
<li><code>在 Grid 布局中，float，display:inline-block，display:table-cell，vertical-align 以及 column-\*这些属性和声明对 grid 子项是没有任何作用的。这个可以说是 Grid 布局中的常识，面试经常会问的，一定要记得。</code></li>
<li><code>IE10-IE15 虽然名义上支持 Grid 布局，但支持的是老版本语法（本文是介绍的全是 2.0 全新语法）</code>，<br>兼容性查询请看<a href="https://caniuse.com" target="_blank" rel="noopener">can i use</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/" target="_blank" rel="noopener">写给自己看的 display: grid 布局教程</a><br><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid 网格布局教程</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>react的生命周期</title>
    <url>/blog/react/lifecircle/react-lifecycle.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<code>react</code> v16.x 对生命周期有比较大的变化，可以通过下面的两张比较经典的图片来一览变化。<br><strong>react v15.x</strong><br><img src="../../../images/react/react-lifecricle-1-2.png" alt="reac-lifecricle"><br><strong>react v16.x</strong><br><img src="../../../images/react/react-lifecricle-1-3.jpg" alt="reac-lifecricle"></p>
<p><code>react</code> v16.x 的生命周期是在 react v15.x 的生命周期基础上删减了一些生命周期，同时也新增了一些生命周期，删除的生命周期也可以通过 hook 来模拟实现。</p>
<p><strong>React 16.3 新增的生命周期方法</strong></p>
<ul>
<li><strong>getDerivedStateFromProps()</strong></li>
<li><strong>getSnapshotBeforeUpdate()</strong></li>
</ul>
<p><strong>逐渐废弃的生命周期方法</strong></p>
<ul>
<li><strong>componentWillMount()</strong></li>
<li><strong>componentWillReceiveProps()</strong></li>
<li><strong>componentWillUpdate()</strong></li>
</ul>
<blockquote>
<p>虽然废弃了这三个生命周期方法，但是为了向下兼容，将会做渐进式调整。（详情见#12028）<br>V16.3 并未删除这三个生命周期，同时还为它们新增以 UNSAFE_ 前缀为别名的三个函数 <code>UNSAFE_componentWillMount()</code>、<code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code>。<br>在 16.4 版本给出警告将会弃用 <code>componentWillMount()</code>、<code>componentWillReceiveProps()</code>、<code>componentWillUpdate()</code> 三个函数<br>然后在 17 版本将会删除 <code>componentWillMount()</code>、<code>componentWillReceiveProps()</code>、<code>componentWillUpdate()</code> 这三个函数，会保留使用 <code>UNSAFE_componentWillMount()</code>、<code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code></p>
</blockquote>
<p>一般生命周期分为三个阶段：</p>
<ol>
<li>创建阶段（Mounting）</li>
<li>更新阶段（Updating）</li>
<li>卸载阶段（UnMounting）</li>
</ol>
<p>从 React v16.x 开始，还对生命周期加入了错误处理（Error Handling）。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>其实用下面的这个图更能展现 v15.x 的流程图三个阶段的生命周期，图如下：<br><img src="../../../images/react/react-lifecricle-1-1.png" alt="reac-lifecricle"></p>
<h2 id="挂载-Mounting-阶段"><a href="#挂载-Mounting-阶段" class="headerlink" title="挂载(Mounting)阶段"></a>挂载(Mounting)阶段</h2><ul>
<li>constructor</li>
<li>static getDerivedStateFromProps()(<strong>新增</strong>)</li>
<li>componentWillMount()/UNSAFE_componentWillMount()(<strong>废弃</strong>)</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h3><p>对于每个组件实例这个方法只会调用<strong>一次</strong>。<br>`constructor 参数接受两个参数<strong>props</strong>，<strong>context</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props, context);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.props,<span class="keyword">this</span>.context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以获取到父组件传下来的的<strong>props</strong>,<strong>context</strong>,如果你想在<code>constructor</code>构造函数内部(注意是内部哦，在组件其他地方是可以直接接收的)使用<strong>props</strong>或<strong>context</strong>,则需要传入，并传入<code>super</code>对象。</p>
<p>构造函数通常用于：</p>
<ul>
<li>使用 <strong>this.state</strong> 来初始化 <strong>state</strong></li>
<li>给事件处理函数绑定 <strong>this</strong></li>
</ul>
<blockquote>
<p>ES6 子类的构造函数必须执行一次 <code>super</code>。React 如果构造函数中要使用 <strong>this.props</strong>，必须先执行 super(props)。</p>
</blockquote>
<h3 id="static-getDerivedStateFromProps-nextProps-prevState"><a href="#static-getDerivedStateFromProps-nextProps-prevState" class="headerlink" title="static getDerivedStateFromProps(nextProps, prevState)"></a>static getDerivedStateFromProps(nextProps, prevState)</h3><p><code>static getDerivedStateFromProps(nextProps, prevState)</code><br>首先，这是一个静态方法生命周期钩子。也就是说，定义的时候得在方法前加一个<code>static</code>关键字，或者直接挂载到<code>class</code>类上。</p>
<p>简要区分一下实例方法和静态方法：</p>
<ul>
<li>实例方法，挂载在 this 上或者挂载在 prototype 上，class 类不能直接访问该方法，使用 new 关键字实例化之后，实例可以访问该方法。</li>
<li>静态方法，直接挂载在 class 类上，或者使用新的关键字 static，实例无法直接访问该方法。</li>
</ul>
<p>当<code>创建时</code>、<code>接收新的 props 时</code>、<code>setState 时</code>、<code>forceUpdate 时</code>会执行这个方法。</p>
<blockquote>
<p>注意：v16.3 setState 时、forceUpdate 时不会执行这个方法，v16.4 修复了这个问题。</p>
</blockquote>
<p>这个生命周期钩子也经历了一些波折，原本它是被设计成<code>初始化</code>、<code>父组件更新</code>和<code>接收到 props</code>才会触发，现在只要渲染就会触发，也就是<code>初始化</code>和<code>更新阶段</code>都会触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize state in constructor,</span></span><br><span class="line">  <span class="comment">// Or with a property initializer.</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: <span class="literal">false</span>,</span><br><span class="line">    lastRow: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.currentRow !== state.lastRow) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        isScrollingDown: props.currentRow &gt; state.lastRow,</span><br><span class="line">        lastRow: props.currentRow</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return null to indicate no change to state.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在建议尽量少用，只在必要的场景中使用，一般使用场景如下：</p>
<ul>
<li>无条件的根据 <code>props</code> 更新 <code>state</code></li>
<li>当 <code>props</code> 和 <code>state</code> 的不匹配情况更新 <code>state</code></li>
</ul>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h3><ul>
<li>组件刚经历<code>constructor</code>,初始完数据</li>
<li>组件还未进入<code>render</code>，组件还未渲染完成，dom 还<strong>未渲染</strong></li>
</ul>
<p>在组件<strong>挂载</strong>到 DOM 前调用，且只会被调用一次，在这边调用 this.setState 不会引起组件重新渲染（<strong>如果是异步的话，会触发重新渲染</strong>）。</p>
<blockquote>
<p>这是 React 不再推荐使用的 API。</p>
</blockquote>
<h3 id="render（会多次执行）"><a href="#render（会多次执行）" class="headerlink" title="render（会多次执行）"></a>render（会多次执行）</h3><p>该方法会创建一个<strong>vnode</strong>，用来表示组件的输出。对于一个组件来讲，<code>render</code>方法是唯一一个必需的方法。<code>render</code>方法需要满足下面几点：</p>
<ol>
<li>只能通过 <strong>this.props</strong> 和 <strong>this.state</strong> 访问数据（不能修改）</li>
<li>可以返回 null,false 或者任何<code>React</code>组件</li>
<li>只能出现一个顶级组件，不能返回一组元素</li>
<li>不能改变组件的状态(<strong>state</strong>)</li>
<li>不能修改 DOM 的输出</li>
</ol>
<p>可以返回下面几种类型：</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>组件挂载到 DOM 后调用，且只会被调用一次。<br>一般用于下面的场景：</p>
<ul>
<li>异步请求 ajax</li>
<li>添加事件绑定（注意在 <code>componentWillUnmount</code> 中取消，以免造成内存泄漏）</li>
</ul>
<h2 id="更新-update-阶段"><a href="#更新-update-阶段" class="headerlink" title="更新(update)阶段"></a>更新(update)阶段</h2><ul>
<li>componentWillReceiveProps()/UNSAFE_componentWillReceiveProps()(<strong>废弃</strong>)</li>
<li>static getDerivedStateFromProps()(<strong>新增</strong>)</li>
<li>shouldComponentUpdate(nextProps,nextState)</li>
<li>componentWillUpdate(nextProps, nextState)/UNSAFE_componentWillUpdate(nextProps, nextState)(<strong>废弃</strong>)</li>
<li>render()</li>
<li>static getSnapshotBeforeUpdate()(<strong>新增</strong>)</li>
<li>componentDidUpdate()</li>
</ul>
<p>造成组件更新有两类(两种)：</p>
<ul>
<li><strong>调用 setState</strong></li>
</ul>
<ol>
<li>组件本身调用 setState，无论 state 有没有变化。可通过 shouldComponentUpdate 方法优化。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      someThings: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate(nextStates) &#123;</span><br><span class="line">    <span class="comment">// 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染</span></span><br><span class="line">    <span class="keyword">if</span> (nextStates.someThings === <span class="keyword">this</span>.state.someThings) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 虽然调用了setState ，但state并无变化</span></span><br><span class="line">    <span class="keyword">const</span> preSomeThings = <span class="keyword">this</span>.state.someThings;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      someThings: preSomeThings</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.someThings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父组件重新 render<ol>
<li>直接使用,每当父组件重新 render 导致的重传 props，子组件将直接跟着重新渲染，无论 props 是否有变化。可通过 shouldComponentUpdate 方法优化。</li>
</ol>
</li>
</ul>
<p>优化同上。</p>
<h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps (nextProps)"></a>componentWillReceiveProps (nextProps)</h3><p>componentWillReceiveProps`在接受父组件改变后的<strong>props</strong>需要重新渲染组件。<br>它接受一个参数：</p>
<ul>
<li>nextProps <strong>通过对比 nextProps 和 this.props，将 nextProps setState 为当前组件的 state，从而重新渲染组件</strong></li>
</ul>
<p>该声明周期函数可能在两种情况下被触发：</p>
<ul>
<li>组件接收到了新的属性。</li>
<li>组件没有收到新的属性，但是由于父组件重新渲染导致当前组件也被重新渲染。<br>同样，因为 Fiber 机制的引入，这个生命周期钩子有可能会多次触发。</li>
</ul>
<h3 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps()"></a>static getDerivedStateFromProps()</h3><p>见上文<code>static getDerivedStateFromProps()</code></p>
<h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)"></a>shouldComponentUpdate(nextProps,nextState)</h3><p>在接收新的 props 或新的 state 时，在渲染前会触发该方法。该方法通过返回 true（触发重新渲染） 或者 false（不会触发重新渲染） 来确定是否需要触发新的渲染。<br>但是官方提倡我们使用 PureComponent 来减少重新渲染的次数而不是手工编写 shouldComponentUpdate 代码。因为未来版本 shouldComponentUpdate 返回 false，仍然可能导致组件重新的渲染。</p>
<blockquote>
<p>Currently, if shouldComponentUpdate() returns false, then UNSAFE_componentWillUpdate(), render(), and componentDidUpdate() will not be invoked. In the future React may treat shouldComponentUpdate() as a hint rather than a strict directive, and returning false may still result in a re-rendering of the component.</p>
</blockquote>
<blockquote>
<p>PureComponent 自动实现了一个 shouldComponentUpdate 生命周期钩子。(浅比较)</p>
</blockquote>
<h3 id="componentWillUpdate-nextProps-nextState-UNSAFE-componentWillUpdate-nextProps-nextState"><a href="#componentWillUpdate-nextProps-nextState-UNSAFE-componentWillUpdate-nextProps-nextState" class="headerlink" title="componentWillUpdate(nextProps, nextState)/UNSAFE_componentWillUpdate(nextProps, nextState)"></a>componentWillUpdate(nextProps, nextState)/UNSAFE_componentWillUpdate(nextProps, nextState)</h3><p>当接收到新的 <code>props</code> 或 <code>state</code> 时，在渲染前执行该方法。在这个方法中不能调用<code>setState</code>，因为这样会导致<code>整个</code>生命周期<code>混乱</code>。<br>因为在异步渲染中，可能会导致网络请求多次，引起一些性能问题，同事在这其中获取一些 dom 信息是不能保证准确性。</p>
<blockquote>
<p>因为 Fiber 机制的引入，这个生命周期钩子有可能会多次调用。</p>
</blockquote>
<h3 id="static-getSnapshotBeforeUpdate-prevProps-prevState"><a href="#static-getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="static getSnapshotBeforeUpdate(prevProps, prevState)"></a>static getSnapshotBeforeUpdate(prevProps, prevState)</h3><p>这个方法在 <code>render()</code> 之后，<code>componentDidUpdate()</code> 之前调用。<br>两个参数<code>prevProps</code> 表示更新前的 <code>props</code>，<code>prevState</code> 表示更新前的 <code>state</code>返回值称为一个快照（snapshot），如果不需要 <code>snapshot</code>，则必须显示的返回 <code>null</code> —— 因为返回值将作为 <code>componentDidUpdate()</code> 的第三个参数使用。所以这个函数必须要配合 <code>componentDidUpdate()</code> 一起使用。<br>比如记录滚动的高度，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">    <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// If we have a snapshot value, we've just added new items.</span></span><br><span class="line">    <span class="comment">// Adjust scroll so these new items don't push the old ones out of view.</span></span><br><span class="line">    <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.listRef&#125;</span>&gt;</span>&#123;/* ...contents... */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h3><p>该方法在 getSnapshotBeforeUpdate 方法之后被调用，有三个参数 prevProps，prevState，snapshot，表示之前的 props，之前的 state，和 snapshot。第三个参数是 getSnapshotBeforeUpdate 返回的，所有 getSnapshotBeforeUpdate 时，必须要有 componentDidUpdate。</p>
<blockquote>
<p>可以使用 setState，会触发 render，所以要注意判断，避免导致死循环。</p>
</blockquote>
<h2 id="卸载阶段（Unmounting）"><a href="#卸载阶段（Unmounting）" class="headerlink" title="卸载阶段（Unmounting）"></a>卸载阶段（Unmounting）</h2><ul>
<li>componentWillUnmount</li>
</ul>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><p>在组件卸载或者销毁前调用。这个方法主要用来做一些清理工作，例如：</p>
<ul>
<li>取消事件绑定</li>
<li>订阅器</li>
<li>定时器</li>
</ul>
<blockquote>
<p>不能使用 setState</p>
</blockquote>
<h2 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理 Error Handling"></a>错误处理 Error Handling</h2><blockquote>
<p>这是 React v16.3.0 发布的 API。</p>
</blockquote>
<ul>
<li>componentDidCatch(err, info)</li>
</ul>
<p>任何子组件在渲染期间，生命周期方法中或者构造函数 constructor 发生错误时调用。<br>它主要用来捕获错误并进行相应处理，所以它的用法也比较特殊。但是它不能捕获下面的错误：</p>
<ul>
<li>事件处理 (Event handlers) （因为事件处理不发生在 React 渲染时，报错不影响渲染）</li>
<li>异步代码 (Asynchronous code) (e.g. setTimeout or requestAnimationFrame callbacks)</li>
<li>服务端渲染 (Server side rendering)</li>
<li>错误边界本身(而不是子组件)抛出的错误</li>
</ul>
<h2 id="组件树生命周期调用顺序"><a href="#组件树生命周期调用顺序" class="headerlink" title="组件树生命周期调用顺序"></a>组件树生命周期调用顺序</h2><p>应用初次挂载时，我们以<code>render</code>和<code>componentDidMount</code>为例，React 首先会调用根组件的<code>render</code>钩子，如果有子组件的话，依次调用子组件的<code>render</code>钩子，调用过程其实就是<code>递归</code>的顺序。</p>
<p>等所有组件的 render 钩子都递归执行完毕，这时候执行权在最后一个子组件手里，于是开始触发下一轮生命周期钩子，调用最后一个子组件的 componentDidMount 钩子，然后调用栈依次往上递归。</p>
<p><img src="../../../images/react/react-lifecricle-1-4.png" alt="reac-lifecricle"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.render();</span><br><span class="line">child.render();</span><br><span class="line">grandson.render();</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line">grandson.componentDidMount();</span><br><span class="line">child.componentDidMount();</span><br><span class="line">app.componentDidMount();</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line">app.render();</span><br><span class="line">child.render();</span><br><span class="line">grandson.render();</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line">grandson.componentDidUpdate();</span><br><span class="line">child.componentDidUpdate();</span><br><span class="line">app.componentDidUpdate();</span><br></pre></td></tr></table></figure>
<h2 id="V16-生命周期函数用法建议"><a href="#V16-生命周期函数用法建议" class="headerlink" title="V16 生命周期函数用法建议"></a>V16 生命周期函数用法建议</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用于初始化 state</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">// 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用</span></span><br><span class="line">  <span class="comment">// 因为该函数是静态函数，所以取不到 `this`</span></span><br><span class="line">  <span class="comment">// 如果需要对比 `prevProps` 需要单独在 `state` 中维护</span></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;&#125;</span><br><span class="line">  <span class="comment">// 判断是否需要更新组件，多用于组件性能优化</span></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;&#125;</span><br><span class="line">  <span class="comment">// 组件挂载后调用</span></span><br><span class="line">  <span class="comment">// 可以在该函数中进行请求或者订阅</span></span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line">  <span class="comment">// 用于获得最新的 DOM 数据</span></span><br><span class="line">  getSnapshotBeforeUpdate() &#123;&#125;</span><br><span class="line">  <span class="comment">// 组件即将销毁</span></span><br><span class="line">  <span class="comment">// 可以在此处移除订阅，定时器等等</span></span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line">  <span class="comment">// 组件销毁后调用</span></span><br><span class="line">  componentDidUnMount() &#123;&#125;</span><br><span class="line">  <span class="comment">// 组件更新后调用</span></span><br><span class="line">  componentDidUpdate() &#123;&#125;</span><br><span class="line">  <span class="comment">// 渲染组件函数</span></span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">  <span class="comment">// 以下函数不建议使用</span></span><br><span class="line">  UNSAFE_componentWillMount() &#123;&#125;</span><br><span class="line">  UNSAFE_componentWillUpdate(nextProps, nextState) &#123;&#125;</span><br><span class="line">  UNSAFE_componentWillReceiveProps(nextProps) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b7e0647e51d455d18400ef7#heading-10" target="_blank" rel="noopener">React 专题：生命周期</a><br><a href="https://blog.hhking.cn/2018/09/18/react-lifecycle-change/" target="_blank" rel="noopener">重新认识 React 生命周期</a><br><a href="https://www.jianshu.com/p/514fe21b9914" target="_blank" rel="noopener">详解 React 生命周期(包括 react16 版)</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>混合开发的JsBridge(-)</title>
    <url>/blog/mobile/jsbridge/JSBridege.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>JSBridge</strong><br>听其取名就是 js 和 Native 之前的桥梁，而实际上 JSBridge 确实是 JS 和 Native 之前的一种通信方式。混合开发，最重要的问题是：<strong>H5 和 Native 的双向通信</strong>。</p>
<p><strong>JSBridge 的实现原理</strong><br><code>JavaScript</code> 是运行在一个单独的 <code>JS Context</code> 中（例如，<code>WebView</code> 的 <code>Webkit</code> 引擎、<code>JSCore</code>）。由于这些 <code>Context</code>与原生运行环境的天然隔离，我们可以将这种情况与 <code>RPC</code>（Remote Procedure Call，远程过程调用）通信进行类比，将 <code>Native</code> 与 <code>JavaScript</code> 的每次互相调用看做一次 <code>RPC</code> 调用。<br>在 <code>JSBridge</code>的设计中，可以把前端看做 <code>RPC</code> 的客户端，把 <code>Native</code> 端看做 <code>RPC</code> 的服务器端，从而 <code>JSBridge</code> 要实现的主要逻辑就出现了：通信调用（<code>Native</code>与 <code>JS</code> 通信） 和 句柄解析调用。（如果你是个前端，而且并不熟悉 <code>RPC</code>的话，你也可以把这个流程类比成 JSONP 的流程）</p>
<p>流程如下图所示：<br><img src="../../images/moblie/JSBirgde.png" alt="JSBridege"></p>
<!-- ![JSBridege](../../images/moblie/JSBirgde-1-2.png) -->
<h2 id="H5-和-NA-的双向通信通用方法"><a href="#H5-和-NA-的双向通信通用方法" class="headerlink" title="H5 和 NA 的双向通信通用方法"></a>H5 和 NA 的双向通信通用方法</h2><p>H5 通信方式和兼容性如下表所示。指的是借助 Native 的 webview 加载 H5 页面，H5 和 NA 之间通过 API、URL 拦截、全局调用等形式，实现消息通信。</p>
<h3 id="H5-调用-NA-方法"><a href="#H5-调用-NA-方法" class="headerlink" title="H5 调用 NA 方法"></a>H5 调用 NA 方法</h3><table>
<thead>
<tr>
<th style="text-align:center">平台</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">shouldOverrideUrlLoading</td>
<td style="text-align:center">scheme 拦截方法</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">addJavascriptInterface</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">onJsAlert()、onJsConfirm()、onJsPrompt（）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IOS</td>
<td style="text-align:center">拦截 URL</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IOS(UIwebview)</td>
<td style="text-align:center">JavaScriptCore</td>
<td style="text-align:center">API 方法，IOS7+ 支持</td>
</tr>
<tr>
<td style="text-align:center">IOS(WKwebview)</td>
<td style="text-align:center">window.webkit.messageHandlers</td>
<td style="text-align:center">API 方法，IOS7+ 支持</td>
</tr>
</tbody>
</table>
<h3 id="NA-调用-H5-方法"><a href="#NA-调用-H5-方法" class="headerlink" title="NA 调用 H5 方法"></a>NA 调用 H5 方法</h3><table>
<thead>
<tr>
<th style="text-align:center">平台</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">loadurl()</td>
<td style="text-align:center">Android 4.4 +</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">evaluateJavascript()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IOS(UIwebview)</td>
<td style="text-align:center">stringByEvaluatingJavaScriptFromString</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IOS(UIwebview)</td>
<td style="text-align:center">JavaScriptCore</td>
<td style="text-align:center">IOS7.0+</td>
</tr>
<tr>
<td style="text-align:center">IOS(UIwebview)</td>
<td style="text-align:center">evaluateJavaScript:javaScriptString</td>
<td style="text-align:center">iOS8.0+</td>
</tr>
</tbody>
</table>
<h2 id="常用的-JSBridge-形式"><a href="#常用的-JSBridge-形式" class="headerlink" title="常用的 JSBridge 形式"></a>常用的 JSBridge 形式</h2><ul>
<li><code>H5 调 Android</code>-原生通过<code>addJavascriptInterface</code>注册，然后 H5 直接调用</li>
<li><code>Android 调 H5</code>-原生通过<code>loadUrl</code>来调用 H5，<code>4.4</code>及以上还可以通过<code>evaluateJavascript</code>调用</li>
<li><code>H5 调 iOS</code>-原生通过<code>JavaScriptCore</code>注册（需 ios7 以上），然后 H5 直接调用</li>
<li><code>iOS 调 H5</code>-通过<code>stringByEvaluatingJavaScriptFromString</code></li>
<li>改写浏览器原有对象</li>
<li><code>url scheme</code>交互</li>
</ul>
<h3 id="H5-调-Android"><a href="#H5-调-Android" class="headerlink" title="H5 调 Android"></a>H5 调 Android</h3><p>JSInterface 是安卓 4.2-官方推荐的解决方案，JSInterface 在 4.2 之前的版本都可以，但是存在严重的安全隐患，容易被利用提权。实现如下：<br>首先，原声 webview 需要先注册可供前端调用的 JS 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WebSettings webSettings = mWebView.getSettings();</span><br><span class="line"><span class="comment">//Android容器允许JS脚本</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">private <span class="built_in">Object</span> getJSBridge()&#123;</span><br><span class="line">    <span class="built_in">Object</span> insertObj = <span class="keyword">new</span> <span class="built_in">Object</span>()&#123;</span><br><span class="line">        @JavascriptInterface</span><br><span class="line">        public <span class="built_in">String</span> foo()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @JavascriptInterface</span><br><span class="line">        public <span class="built_in">String</span> foo2(final <span class="built_in">String</span> param)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"foo2:"</span> + param;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> insertObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Android容器设置侨连对象</span></span><br><span class="line">mWebView.addJavascriptInterface(getJSBridge(), <span class="string">"JSBridge"</span>);</span><br></pre></td></tr></table></figure>
<p>Native 中通过 addJavascriptInterface 添加暴露出来的 JS 桥对象,然后再该对象内部声明对应的 API 方法。</p>
<p><strong>H5 调用 Native 的方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用方法一</span></span><br><span class="line"><span class="built_in">window</span>.JSBridge.foo(); <span class="comment">//返回:'foo'</span></span><br><span class="line"><span class="comment">//调用方法二</span></span><br><span class="line"><span class="built_in">window</span>.JSBridge.foo2(<span class="string">'test'</span>); <span class="comment">//返回:'foo2:test'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在 Android4.2 以上(api17 后),暴露的 api 要加上注解@JavascriptInterface，否则会找不到方法。</li>
</ul>
</blockquote>
<ul>
<li>在 api17 以前,addJavascriptInterface 有风险,hacker 可以通过反编译获取 Native 注册的 Js 对象， 然后在页面通过反射 Java 的内置静态类，获取一些敏感的信息和破坏</li>
<li>JS 调用 Native 暴露的 api,并且能得到相应返回值</li>
</ul>
<h3 id="Android-调-H5"><a href="#Android-调-H5" class="headerlink" title="Android 调 H5"></a>Android 调 H5</h3><p>native 调用 js 比较简单，只要遵循：”javascript: 方法名(‘参数,需要转为字符串’)”的规则即可。</p>
<p><strong>在<code>4.4</code>版本之前</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mWebView = new WebView(this);</span></span><br><span class="line">mWebView.loadUrl(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>);</span><br><span class="line"><span class="comment">//ui线程中运行</span></span><br><span class="line">runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> run() &#123;</span><br><span class="line">        mWebView.loadUrl(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>);</span><br><span class="line">        Toast.makeText(Activity名.this, <span class="string">"调用方法..."</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>在 4.4 及以后（包括）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步执行JS代码,并获取返回值</span></span><br><span class="line">mWebView.evaluateJavascript(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>, <span class="keyword">new</span> ValueCallback&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> onReceiveValue(<span class="built_in">String</span> value) &#123;</span><br><span class="line">        <span class="comment">// 这里的value即为对应JS方法的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>4.4 之前 Native 通过 loadUrl 来调用 JS 方法,只能让某个 JS 方法执行,但是无法获取该方法的返回值</li>
</ul>
</blockquote>
<ul>
<li>4.4 及之后,通过 evaluateJavascript 异步调用 JS 方法,并且能在 onReceiveValue 中拿到返回值</li>
<li>mWebView.loadUrl(“javascript: 方法名(‘参数,需要转为字符串’)”); 函数需在 UI 线程运行，因为 mWebView 为 UI 控件(但是有一个坏处是会阻塞 UI 线程)</li>
</ul>
<h3 id="H5-调-iOS"><a href="#H5-调-iOS" class="headerlink" title="H5 调 iOS"></a>H5 调 iOS</h3><p>Native 中通过引入官方提供的 JavaScriptCore 库(iOS7 以上),然后可以将 api 绑定到 JSContext 上(然后 Html 中 JS 默认通过 window.top.*可调用)。<br>以 OC 为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</span><br><span class="line">-(<span class="keyword">void</span>)webViewDidFinishLoad:(UIWebView *)webView&#123;</span><br><span class="line">    [self hideProgress];</span><br><span class="line">    [self setJSInterface];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setJSInterface&#123;</span><br><span class="line">    JSContext *context =[_wv valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="comment">// 注册名为foo的api方法</span></span><br><span class="line">    context[@<span class="string">"foo"</span>] = ^() &#123;</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        NSArray *args = [JSContext currentArguments];</span><br><span class="line">        NSString *title = [NSString stringWithFormat:@<span class="string">"%@"</span>,[args objectAtIndex:<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">//做一些自己的逻辑</span></span><br><span class="line">        <span class="comment">//返回一个值  'foo:'+title</span></span><br><span class="line">        <span class="keyword">return</span> [NSString stringWithFormat:@<span class="string">"foo:%@"</span>, title];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>H5 调用 IOS 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.top.foo(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>iOS7 之前，js 无法直接调用 Native,只能通过 urlscheme 方式间接调用</li>
</ul>
</blockquote>
<ul>
<li>JS 能调用到已经暴露的 api,并且能得到相应返回值</li>
<li>iOS 原生本身是无法被 JS 调用的,但是通过引入官方提供的第三方”JavaScriptCore”,即可开放 api 给 JS 调用</li>
</ul>
<h3 id="iOS-调-H5"><a href="#iOS-调-H5" class="headerlink" title="iOS 调 H5"></a>iOS 调 H5</h3><p>Native 调用 js 的方法比较简单，Native 通过 stringByEvaluatingJavaScriptFromString 调用 Html 绑定在 window 上的函数。不过应注意 Oc 和 Swift 的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以取得JS函数执行的返回值</span></span><br><span class="line"><span class="comment">// 方法必须是Html页面绑定在最顶层的window上对象的</span></span><br><span class="line"><span class="comment">// 如window.top.foo</span></span><br><span class="line"><span class="comment">// Swift</span></span><br><span class="line">webview.stringByEvaluatingJavaScriptFromString(<span class="string">"方法名(参数)"</span>)</span><br><span class="line"><span class="comment">// OC</span></span><br><span class="line">[webView stringByEvaluatingJavaScriptFromString:@<span class="string">"方法名(参数);"</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Native 调用 JS 方法时,能拿到 JS 方法的返回值</li>
</ul>
</blockquote>
<ul>
<li>不适合传输大量数据(大量数据建议用接口方式获取)</li>
<li>有 iframe 时，需要获取顶层窗口的引用</li>
</ul>
<h3 id="改写浏览器原有对象"><a href="#改写浏览器原有对象" class="headerlink" title="改写浏览器原有对象"></a>改写浏览器原有对象</h3><p>改写 window 上的四种方法，然后拦截固定规则的参数分发给 Java 对应的方法处理：</p>
<ul>
<li>alert，可以被 webview 的 onJsAlert 监听</li>
<li>confirm，可以被 webview 的 onJsConfirm 监听</li>
<li>console.log，可以被 webview 的 onConsoleMessage 监听</li>
<li>prompt，可以被 webview 的 onJsPrompt 监听<br>prompt 简单举例说明，Web 页面通过调用<code>prompt()</code>方法，安卓客户端通过监听<code>onJsPrompt</code>事件，拦截传入的参数，如果参数符合一定协议规范，那么就解析参数，扔给后续的 Java 去处理。这种协议规范，最好是跟 iOS 的协议规范一样，这样跨端调起协议是一致的，但具体实现不一样而已。比如：<code>hybrid://action?arg1=1</code> 这样的协议，而其他格式的<code>prompt</code>参数，是不会监听的，即除了<code>hybrid://action?arg1=1</code> 这样的规范协议，<code>prompt</code>还是原来的<code>prompt</code>。</li>
</ul>
<p>这四个方法也是各有利弊，比如:</p>
<ul>
<li><code>alert</code>/<code>console.log</code>是调试最常用的，如果你要看看协议是不是写错了，但是传入协议却被拦截了。</li>
<li><code>confirm</code>和<code>prompt</code>都带返回值，<code>prompt</code>是四个里面唯一可以自定义返回值，可以做同步的交互，要比写各种回调更「顺」，但是一旦串行调用了，就会比较坑。</li>
</ul>
<blockquote>
<p>prompt 是目前安卓用的比较多的 JSBridge 解决方案。</p>
</blockquote>
<h3 id="url-scheme"><a href="#url-scheme" class="headerlink" title="url scheme"></a>url scheme</h3><p>这个叫法不是特别贴切，scheme 是 URI 的一种格式，上文提到的 hybrid://action?arg1=1 就是一个 scheme 协议，这里说的 scheme（或者 schema）泛指安卓和 iOS 的 schema 协议，因为它通用。</p>
<p>拦截 url scheme 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 url scheme 请求，之后 Native 拦截到请求并根据 url scheme（包括所带的参数）进行相关操作。<br>缺点：</p>
<ul>
<li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</li>
<li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li>
</ul>
<blockquote>
<ul>
<li>有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。</li>
</ul>
</blockquote>
<ul>
<li>为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。</li>
</ul>
<h2 id="唤起-APP-技术"><a href="#唤起-APP-技术" class="headerlink" title="唤起 APP 技术"></a>唤起 APP 技术</h2><p>APP 外（浏览器、微信等）调起 APP 自己，给 APP 进行导流。这时候就要用到 APP 的唤起技术。这里有一下几种方法：</p>
<ul>
<li>intent：安卓</li>
<li>localserver: 安卓</li>
<li>Universal links: IOS 9+</li>
<li>Deep link/Applink: 安卓</li>
<li>smart app banner: IOS</li>
</ul>
<h3 id="安卓-intent"><a href="#安卓-intent" class="headerlink" title="安卓 intent"></a>安卓 intent</h3><p>intent 格式示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">intent:</span><br><span class="line">   HOST/URI-path <span class="comment">// Optional host</span></span><br><span class="line">   #Intent;</span><br><span class="line">      package=[string];</span><br><span class="line">      action=[string];</span><br><span class="line">      category=[string];</span><br><span class="line">      component=[string];</span><br><span class="line">      scheme=[string];</span><br><span class="line">      S.xxx=xxx</span><br><span class="line">   end;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一部分：host 和 path 是跟 url 无异</li>
<li>第二部分：#intent 到 end 是完整的 intent，包含了调起的 app 包名，action 等是常用的配置项</li>
</ul>
<p>因为 Intent 不仅仅是调起 APP，而是安卓客户端内部模块通信也会用，所以权限很大，一般浏览器都给封掉了。</p>
<h3 id="安卓-localserver"><a href="#安卓-localserver" class="headerlink" title="安卓 localserver"></a>安卓 localserver</h3><p>启动一个本地 server，端口号是：8888，那么在手机上，网页就可以通过：<a href="http://127.0.0.1:8888" target="_blank" rel="noopener">http://127.0.0.1:8888</a> 访问这个 server，server 接收到请求就可以进行一些 native 的操作，对于需要回调数据的，就通过返回请求内容来执行，比如：</p>
<ul>
<li>获取个定位信息，js 执行\$.get(‘<a href="http://127.0.0.1:8888/getGeoLocation?callback=cbname&#39;" target="_blank" rel="noopener">http://127.0.0.1:8888/getGeoLocation?callback=cbname&#39;</a>)</li>
<li>server 收到请求之后，调用 native 方法，获取 GPS 的定位信息，然后将数据通过 response：window.cbname&amp;&amp;cbname({xxx})给页面返回定位数据</li>
</ul>
<blockquote>
<ul>
<li>如果控制不好权限，因为 localserver 是一直后台守候的，容易被利用，比如提权获取通讯录、甚至给通讯录发短信、容易造成蠕虫攻击</li>
</ul>
</blockquote>
<ul>
<li>另外安卓各种安全软件，都会清理内存和后台程序，很容易被干掉进程。浏览器也会封杀本地 server 调起，碰见 127.0.0.1 的请求就直接拦截。</li>
</ul>
<h3 id="Universal-links-Deep-link-Applink"><a href="#Universal-links-Deep-link-Applink" class="headerlink" title="Universal links / Deep link / Applink"></a>Universal links / Deep link / Applink</h3><p>这三个是官方推荐的调起方法，调起协议格式也是可以统一的，比如前文提到的 hybrid://action?arg1=xxx 这类 scheme 协议就是。这样可以统一安卓和 iOS 调起和 JSBridge 通信。</p>
<h4 id="Universal-Links"><a href="#Universal-Links" class="headerlink" title="Universal Links"></a>Universal Links</h4><p>iOS 9 新出的一个功能，需要在 App 内声明一个 https 域名（ul.test.com），然后在该网站根目录放置 apple-app-site-association 文件，文件指明了转发规则，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"applinks"</span>: &#123;</span><br><span class="line">        <span class="string">"apps"</span>: [],</span><br><span class="line">        <span class="string">"details"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"appID"</span>: “xxx.com.baidu.SomeApp”,</span><br><span class="line">            <span class="string">"paths"</span>: [<span class="string">"*"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 APP 安装成功之后，会下载这个文件，明确知道遇见 ul.test.com 的域名的 URL 时候，会把这个 URL 扔给你的 APP，让你去解析，APP 拿到这个 URL 就可以解析出来需要做什么事情。</p>
<p>Universal Link 是 iOS 9+的底层实现，所以在任何地方都可以直接调起 APP，不受微信这类封闭 APP 的限制。</p>
<h4 id="Deep-link-Applink"><a href="#Deep-link-Applink" class="headerlink" title="Deep link / Applink"></a>Deep link / Applink</h4><p>Deep link 是安卓一开始推出的，主要用于搜索调起 APP，后来推出 Applink，实际是 Deep link 的升级版。</p>
<p>这里需要提到微信的 APPlink，毕竟微信作为 SuperApp，是很大的分发资源，微信有自己的分发方法，安卓内可以申请微信的 APPlink，跟 Universal link 一样，也是一个域名下面的 URL，符合一定规则就由微信（ios 是底层系统）扔个对应的域名 APP 进行解析。</p>
<h3 id="smart-app-banner"><a href="#smart-app-banner" class="headerlink" title="smart app banner"></a>smart app banner</h3><p>在页面的 head 中添加下面 meta，在 Safari 浏览器中就会出现下面的 banner</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"apple-itunes-app"</span> content=<span class="string">"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Hybrid 是一种连接 H5 跟 NA 的思路，即可以快速迭代 H5 功能，又可以有 NA 的体验，是混合开发的典型开发模式。<br><strong>JSBridge 的最佳实践</strong></p>
<ul>
<li>官方推荐的方法</li>
<li>跨平台通用</li>
<li>安全可靠</li>
<li>约定大于配置的原则</li>
<li>协议规范都使用：hybrid://action/method?arg1=xxx&amp;arg2=xxx</li>
<li>iOS 使用 Universal Link 和 UIWebview 的 delegate</li>
<li>安卓使用 shouldOverrideUrlLoading 和 Applink</li>
</ul>
<p>以上就是 Native 和 H5 间的通信原理，在不同端的代码实现也有示例，下一篇是讲解怎么封装一个自己通用的 JSBridge。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yq.aliyun.com/articles/72774" target="_blank" rel="noopener">JSBridge 深度剖析</a><br><a href="https://dailc.github.io/2017/12/24/quickhybrid_native2h5interaction.html" target="_blank" rel="noopener">H5 和 Native 交互原理</a><br><a href="https://dailc.github.io/2017/12/24/quickhybrid_jsbridge.html" target="_blank" rel="noopener">JSBridge 的实现</a><br><a href="https://juejin.im/post/5bda6f276fb9a0226d18931f#heading-11" target="_blank" rel="noopener">JSBridge 实战</a><br><a href="https://juejin.im/post/5abca877f265da238155b6bc#heading-11" target="_blank" rel="noopener">JSBridge 的原理</a></p>
]]></content>
      <categories>
        <category>Mobile</category>
      </categories>
      <tags>
        <tag>Mobile</tag>
        <tag>JSBirdege</tag>
      </tags>
  </entry>
  <entry>
    <title>react简单的typeScript应用</title>
    <url>/blog/typescript/react-typescript.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>TypeScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的mixins、hoc、hooks三者对比</title>
    <url>/blog/react/hooks/react-mixins-hoc-hooks.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Mixin（混入）</code>是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以<code>拷贝任意多个对象的任意个方法</code>到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了<code>解决代码复用问题</code>。<br>如下图所示：<br><img src="../../../images/react/react-mixins-1-1.png" alt="reac-mixins"><br>Mixin 是用来提取可复用的逻辑或者方法，并且它比继承要更令活，它的应用范围也是比较广的比如在<code>JQuery</code>的<code>extend</code>方法。</p>
<p>Mixin 大致实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMixin</span>(<span class="params">target, mixin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        t   arget.prototype[<span class="built_in">arguments</span>[i]] = mixin.prototype[<span class="built_in">arguments</span>[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> methodName <span class="keyword">in</span> mixin.prototype) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Object</span>.hasOwnProperty(target.prototype, methodName)) &#123;</span><br><span class="line">                target.prototype[methodName] = mixin.prototype[methodName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setMixin(User,LogMixin,<span class="string">'actionLog'</span>);</span><br><span class="line">setMixin(Goods,LogMixin,<span class="string">'requestLog'</span>);</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>setMixin 方法</code>将任意对象的任意方法扩展到目标对象上。</p>
<h2 id="React-中的-Mixin"><a href="#React-中的-Mixin" class="headerlink" title="React 中的 Mixin"></a>React 中的 Mixin</h2><p><code>React</code>也提供了<code>Mixin</code>的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用<code>createClass</code>来创建<code>React 组件</code>时才可以使用，因为在<code>React 组件</code>的 es6 写法中它已经<code>被废弃掉</code>了。</p>
<p>例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过<code>Mixin</code>我们可以解决这一问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> LogMixin = &#123;</span><br><span class="line">  log: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'log'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'out'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> User = React.createClass(&#123;</span><br><span class="line">  mixins: [LogMixin],</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Goods = React.createClass(&#123;</span><br><span class="line">  mixins: [LogMixin],</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Mixin-的缺陷"><a href="#Mixin-的缺陷" class="headerlink" title="Mixin 的缺陷"></a>Mixin 的缺陷</h2><p><code>React</code>官方文档在<a href="https://react.docschina.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a>一文中提到了 Mixin 带来了危害：</p>
<ul>
<li><strong>Mixin 可能会相互依赖，相互耦合，不利于代码维护</strong></li>
<li><strong>不同的 Mixin 中的方法可能会相互冲突</strong></li>
<li><strong>Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</strong></li>
</ul>
<p><code>React</code>现在已经<code>不再推荐使用 Mixin</code>来解决代码复用问题，因为<code>Mixin</code>带来的<code>危害</code>比他产生的<code>价值</code>还要巨大，并且 React 全面推荐使用<code>高阶组件</code>来替代它。</p>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>React 推荐高阶组件和代替 Mixin 来做逻辑、代码复用，这里就不多赘述 Hoc 的使用和作用，如果不太清楚的可以看另一篇博客来了解 React 中的 HOC,<a href="/blog/react/optimization/react-hoc.html">react 的高阶组件浅析</a>。</p>
<h3 id="HOC-的作用"><a href="#HOC-的作用" class="headerlink" title="HOC 的作用"></a>HOC 的作用</h3><p>HOC 可以比 Mixin 做更多的事情，也没有 Mixin 产生那么大副作用，具体实现什么样的功能如下：</p>
<ul>
<li><strong>操作 props(属性)(通过属性代理实现、通过反向继承实现)</strong></li>
<li><strong>通过 Refs 访问到组件实例 （通过属性代理实现）</strong></li>
<li><strong>组件状态提升（通过属性代理实现）</strong></li>
<li><strong>操作 state （通过反向继承实现）</strong></li>
<li><strong>渲染劫持（通过属性代理实现、通过反向继承实现）</strong></li>
<li><strong>用其他元素包裹 WrappedComponent （通过属性代理实现）</strong></li>
</ul>
<h2 id="HOC-的缺陷"><a href="#HOC-的缺陷" class="headerlink" title="HOC 的缺陷"></a>HOC 的缺陷</h2><ul>
<li><code>HOC</code>需要在原组件上进行包裹或者嵌套，如果大量使用<code>HOC</code>，将会产生非常多的嵌套，这让调试变得非常困难。</li>
<li><code>HOC</code>可以劫持<code>props</code>，在不遵守约定的情况下也可能造成冲突。</li>
</ul>
<p><strong>在新版的 React 中推行 Hooks 来替代 HOC。它可以同时解决 Mixin 和 HOC 带来的问题</strong></p>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>在<code>React v16.7.0-alpha</code>中加入了新的特性<code>Hooks</code>，他可以让你在<code>class</code>以外使用<code>state</code>和其他<code>React</code>特性。</p>
<p>使用<code>Hooks</code>，你可以在将含有<code>state 的逻辑从组件中抽象出来</code>，这将可以让这些逻辑容易被测试。同时，<code>Hooks</code>可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现<code>状态逻辑复用的方案</code>。</p>
<p>可以看另一篇博客<a href="/blog/react/hooks/react-hooks.html">react 中 Hooks 浅析</a></p>
<h2 id="hook-使用事项"><a href="#hook-使用事项" class="headerlink" title="hook 使用事项"></a>hook 使用事项</h2><p><strong>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。</strong></p>
<h3 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h3><p><code>不要</code>在<code>循环，条件或嵌套函数</code>中<code>调用 Hook</code>， 确保总是在你的 <code>React 函数的最顶层调用</code>他们。</p>
<h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p><code>不要</code>在<code>普通的 JavaScript 函数中</code>调用 Hook。只能在<code>React 的函数组件中调用 Hook</code>。不要在其他 JavaScript 函数中调用。<br><strong>Hook 的提出主要就是为了解决 class 组件的一系列问题，所以我们能在 class 组件中使用它</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序的发展提出一个可以解决当前问题的方案，但随着时间的变化发现以前的方案有很大的副作用或者有更好的方案，就会更新一套更好的方案来解决问题，就像<code>React 中复用逻辑的变化从 Mixin(已废弃)到 HOC(用的比较多)再到现在的 Hooks(新贵)</code>，可能以后 Hooks 也会落伍但是一定要保持学习。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-36" target="_blank" rel="noopener">【React 深入】从 Mixin 到 HOC 再到 Hook</a></p>
]]></content>
      <categories>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>react中Hooks浅析</title>
    <url>/blog/react/hooks/react-hooks.html</url>
    <content><![CDATA[<p><a href="/blog/react/react-hoc.html">react 的高阶组件浅析</a><br><a href="/blog/react/react-hooks.html">react 中 Hooks 浅析</a><br><a href="/blog/react/react-mixins-hoc-hooks.html">react 的 mixins、hoc、hooks 对比</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
</blockquote>
<p>我们知道，functional component 在使用的时候有一些限制，比如需要生命周期、state 的时候就不能用 functional component。而有了 Hooks，你就可以在 funtional component 里，使用 class component 的功能:props，state，context，refs，和生命周期函数等等。<br><strong>虽然 Hooks 已经有要取代正宫 class 的趋势了，但是 react 目前没有计划抛弃 class，所以不要慌，你还是可以跟往常一样使用 class。</strong></p>
<h2 id="为什么引入-hook"><a href="#为什么引入-hook" class="headerlink" title="为什么引入 hook"></a>为什么引入 hook</h2><hr>
<h3 id="组件难以理解"><a href="#组件难以理解" class="headerlink" title="组件难以理解"></a>组件难以理解</h3><p>在使用 class 组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个<code>生命周期</code>中会调用越来越多的逻辑，越来越难以维护。<code>Hook</code> <strong>将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</strong>。而并非强制按照生命周期划分。你还可以使用 <code>reducer</code> 来管理组件的内部状态，使其更加可预测。使用<code>Hook</code>，可以让你更大限度的将<code>公用逻辑</code>抽离，将一个组件分割成<code>更小</code>的函数，而不是<code>强制</code>基于生命周期方法进行分割。</p>
<h3 id="组件嵌套问题"><a href="#组件嵌套问题" class="headerlink" title="组件嵌套问题"></a>组件嵌套问题</h3><p>如果我们需要抽离一些重复的逻辑，就会选择 <code>HOC</code> 或者 <code>render props</code> 的方式。这种方式首先提高了 debug 的难度，并且也很难实现共享状态。<br>但是通过 <code>Hooks</code> 的方式去抽离重复逻辑的话，一是不会增加组件的嵌套，二是可以实现状态的共享。</p>
<h3 id="使用函数代替-class"><a href="#使用函数代替-class" class="headerlink" title="使用函数代替 class"></a>使用函数代替 class</h3><p>相比函数，编写一个<code>class</code>可能需要掌握更多的知识，需要注意的点也越多，比如<code>this</code>指向、绑定事件等等。另外，计算机理解一个函数比理解一个<code>class</code>更快。<code>Hooks</code>让你可以在<code>class</code>之外使用更多 React 的新特性。</p>
<h3 id="减少状态逻辑复用的风险"><a href="#减少状态逻辑复用的风险" class="headerlink" title="减少状态逻辑复用的风险"></a>减少状态逻辑复用的风险</h3><p><code>Hook</code>和<code>Mixin</code>在用法上有一定的相似之处，但是<code>Mixin</code>引入的<code>逻辑</code>和<code>状态</code>是可以<code>相互覆盖</code>的，而多个<code>Hook</code>之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。<br>在不遵守约定的情况下使用<code>HOC</code>也有可能带来一定冲突，比如<code>props 覆盖</code>等等，使用 Hook 则可以避免这些问题。</p>
<h3 id="函数组件无-this-问题"><a href="#函数组件无-this-问题" class="headerlink" title="函数组件无 this 问题"></a>函数组件无 this 问题</h3><p>不需要通过<code>bind</code>函数改变事件的<code>this</code>指向问题。</p>
<h2 id="Hook-API-索引"><a href="#Hook-API-索引" class="headerlink" title="Hook API 索引"></a>Hook API 索引</h2><hr>

<p>大致所有的<code>hook</code>都在下面的列表中，但是比较重要的<code>hook</code>是<code>State Hook</code>、<code>Effect Hook</code>这两个 hook。</p>
<ul>
<li>基础 Hook<ul>
<li>useState</li>
<li>useEffect</li>
<li>useContext</li>
</ul>
</li>
<li>额外的 Hook<ul>
<li><a href="https://react.docschina.org/docs/hooks-reference.html#usereducer" target="_blank" rel="noopener">useReducer</a></li>
<li>useCallback</li>
<li>useMemo</li>
<li>useRef</li>
<li><a href="https://react.docschina.org/docs/hooks-reference.html#useimperativehandle" target="_blank" rel="noopener">useImperativeHandle</a></li>
<li><a href="https://react.docschina.org/docs/hooks-reference.html#useLayoutEffect" target="_blank" rel="noopener">useLayoutEffect</a></li>
<li><a href="https://react.docschina.org/docs/hooks-reference.html#useDebugValue" target="_blank" rel="noopener">useDebugValue</a></li>
</ul>
</li>
</ul>
<h3 id="State-Hook、Effect-Hook"><a href="#State-Hook、Effect-Hook" class="headerlink" title="State Hook、Effect Hook"></a>State Hook、Effect Hook</h3><ul>
<li><code>State Hook</code>(<code>useState</code> 通过在函数组件里调用它来给组件添加一些内部 <code>state</code>。)</li>
<li><code>Effect Hook</code> (<code>useEffect</code> 就是一个 <code>Effect Hook</code>，给函数组件增加了操作副作用的能力。)</li>
</ul>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseStateHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>useState()</code>返回的状态 <code>(count)</code> 与传入的第一个参数 <code>(initialState)</code> 值相同。</p>
<blockquote>
<p><strong>注意</strong> <code>React</code> 会确保 <code>setState</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>setState</code>。</p>
</blockquote>
<p><strong>函数式更新</strong></p>
<p>同时也会返回更新<code>state</code>函数<code>setCount</code>,两种用法直接传要更新的值，也可以传<code>fucntion</code>但是要<code>return</code>出要更新的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; setCount(<span class="number">1</span>)&#125;&gt;</span><br><span class="line">    Click me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">    Click me</span></span><br><span class="line"><span class="regexp">&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 与 <code>class</code> 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code>结合展开运算符来达到合并更新对象的效果。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123; ...prevState, ...updatedValues &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 <code>state</code> 对象。</p>
</blockquote>
<p><strong>惰性初始 state</strong></p>
<p><strong>initialState</strong> 参数只会在组件的<strong>初始渲染</strong>中起作用，后续渲染时会被<strong>忽略</strong>。也可以传入一个<strong>函数</strong>计算并返回初始的 state。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count setCount] = useSate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; porps &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> initialState = porps + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>useEffect</code> 就是一个 <code>Effect Hook</code>，给函数组件增加了操作副作用的能力。它跟 <code>class</code> 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 <code>API</code>。（我们会在使用 <code>Effect Hook</code> 里展示对比 <code>useEffect</code> 和这些方法的例子。）</p>
<p><strong>语法</strong></p>
<p><code>useEffect</code>方法接收传入两个参数：</p>
<ul>
<li>1.回调函数：在第组件一次<code>render</code>和之后的每次<code>update</code>后运行，<code>React</code>保证在<code>DOM 已经更新完成</code>之后才会运行回调。</li>
<li>2.状态依赖(数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 只要组件render后就会执行</span></span><br><span class="line">&#125;);</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 只有count改变时才会执行</span></span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>
<p><strong>清除 effect</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清除订阅</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在<strong>执行下一个 effect 之前，上一个 effect 就已被清除</strong>。</p>
<p><strong>effect 的执行时机</strong></p>
<p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，在浏览器完成布局与绘制之后，传给 <code>useEffect</code> 的函数会延迟调用。<br>虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在<code>任何新</code>的<code>渲染前</code>执行。<code>React</code> 将在组件更新前刷新上一轮渲染的 effect。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseStateHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行...'</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'清理...'</span>, count);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button</span></span><br><span class="line"><span class="regexp">        onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          setCount(count + 1);</span></span><br><span class="line"><span class="regexp">        &#125;&#125;</span></span><br><span class="line"><span class="regexp">      &gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行上面的代码，并且点击几次按钮，执行顺序如下：</p>
<p>如果我们加上浏览器渲染，他会在页面渲染之执行，运行如下：</p>
<p><strong>模拟 componentDidMount</strong></p>
<p><code>componentDidMount</code>等价于<code>useEffect</code>的回调仅在页面初始化完成后执行一次，当<code>useEffect</code>的第二个参数传入一个空数组时可以实现这个效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDidMount</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  useEffect(callback, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方不推荐上面这种写法，因为这有可能导致一些错误。</p>
</blockquote>
<p><strong>模拟 componentWillUnmount</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useUnMount</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> callback, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不像 <code>componentDidMount</code> 或者 <code>componentDidUpdate</code>，<code>useEffect</code> 中使用的 <code>effect</code> 并不会阻滞浏览器渲染页面。这让你的 <code>app</code> 看起来更加流畅。</p>
</blockquote>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>
<p>接收一个 <code>context</code> 对象（<code>React.createContext</code> 的返回值）并返回该 <code>context</code> 的当前值。当前的 <code>context</code> 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value prop</code> 决定。</p>
<p><a href="/blog/react/react-context.html">context 的使用请看另一篇博客</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span></span><br><span class="line"><span class="comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line">    <span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=<span class="string">'drak'</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 中间的组件再也不必指明往下传递 theme 了。</span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class ThemedButton extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 指定 contextType 读取当前的 theme context。</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 在这个例子中，当前的 theme 值为 “dark”。</span></span><br><span class="line"><span class="regexp">  static contextType = ThemeContext;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;Button theme=&#123;this.context&#125; /</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写<code>ThemeButton</code>组件，用<code>useContext</code>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>别忘记 <code>useContext</code> 的参数必须是 <code>context</code> 对象本身：</p>
<ul>
<li>正确： <code>useContext(ThemeContext)</code></li>
<li>错误： <code>useContext(ThemeContext.Consumer)</code></li>
<li>错误： <code>useContext(ThemeContext.Provider)</code></li>
</ul>
<p>调用了 <code>useContext</code> 的组件总会在 <code>context</code> 值变化时重新渲染。如果重渲染组件的开销较大，你可以 <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693" target="_blank" rel="noopener">通过使用 memoization 来优化</a>。</p>
<blockquote>
<p>如果你在接触 <code>Hook</code> 前已经对 <code>context API</code> 比较熟悉，那应该可以理解，<strong>useContext(MyContext)</strong> 相当于 class 组件中的 <strong>static contextType = MyContext</strong> 或者 <strong>&lt;MyContext.Consumer&gt;</strong>。</p>
</blockquote>
<p>useContext(MyContext) 只是让你能够读取 <code>context</code> 的值以及订阅 <code>context</code> 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 c<code>ontext</code>。</p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>如果你需要一个不会随着组件更新而重新创建的 <code>callback</code></p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 可以用来优化函数组件重渲染的性能。函数组价有<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener">React.memo(高阶组件)</a>，它类似类组件的<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">React.PureComponent</a>；它们都是 React 的顶层 API。</p>
<p><strong>useMemo 与 memo</strong></p>
<p><code>React.memo</code>针对的是一个函数组件的渲染是否重复执行，而 <code>useMemo</code> 定义的是一个函数逻辑是否重复执行。</p>
<p><strong>语法</strong></p>
<p>它的语法和<code>useEffect</code>很像，把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>。<br>参数：</p>
<ul>
<li>第一个参数是是需要执行的逻辑函数</li>
<li>第二个参数是这个逻辑依赖输入变量组成的数组，如果不传每次都会执行逻辑函数， 传入空数组只会执行一次。（非必传）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> renderCount = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'渲染次数：'</span> + count);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'渲染次数：'</span> + count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// eslint-disable-next-line react/react-in-jsx-scope</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        type=<span class="string">'button'</span></span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          setCount(count + <span class="number">1</span>);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        计数按钮</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;renderCount&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="../../../images/react/react-hook-1-1.png" alt="reac-hook"><br>可以在依赖输入做判断优化渲染次数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderCount = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'渲染次数：'</span> + count);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'渲染次数：'</span> + count;</span><br><span class="line">&#125;, [count === <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="../../images/react/react-hook-1-2.png" alt="reac-hook"><br><strong>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。</strong></p>
<blockquote>
<p>注意 依赖项数组不会作为参数传给“创建”函数。然虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。<br>我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</p>
</blockquote>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，使用<code>useRef Hook</code>，你可以轻松的获取到<code>dom</code>的<code>ref</code>。<br><code>useRef</code> 主要有两个使用场景：</p>
<ul>
<li>获取子组件或者 <code>DOM</code> 节点的句柄</li>
<li>渲染周期之间的共享数据的存储</li>
</ul>
<p>大家可能会想到 <code>state</code> 也可跨越渲染周期保存，但是 <code>state</code> 的赋值会触发重渲染，但是 <code>ref</code> 不会，从这点看 <code>ref</code> 更像是类属性中的普通成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">'text'</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 <code>ref</code> 对象。</p>
<p><strong>模拟实现 ComponentDidUpdate</strong></p>
<p><code>componentDidUpdate</code>就相当于除去第一次调用的<code>useEffect</code>，我们可以借助<code>useRef</code>生成一个标识，来记录是否为第一次执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDidUpdate</span>(<span class="params">callback, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> init = useRef(<span class="literal">true</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.current) &#123;</span><br><span class="line">      init.current = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请记住，当 <code>ref</code> 对象内容发生变化时，<code>useRef</code> 并不会通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 <code>DOM</code> 节点的 <code>ref</code> 时运行某些代码，则需要使用回调 <code>ref</code> 来实现。</p>
</blockquote>
<h2 id="hook-使用事项"><a href="#hook-使用事项" class="headerlink" title="hook 使用事项"></a>hook 使用事项</h2><p><strong>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。</strong></p>
<h3 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h3><p><code>不要</code>在<code>循环，条件或嵌套函数</code>中<code>调用 Hook</code>， 确保总是在你的 <code>React 函数的最顶层调用</code>他们。</p>
<h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p><code>不要</code>在<code>普通的 JavaScript 函数中</code>调用 Hook。只能在<code>React 的函数组件中调用 Hook</code>。不要在其他 JavaScript 函数中调用。<br><strong>Hook 的提出主要就是为了解决 class 组件的一系列问题，所以我们能在 class 组件中使用它</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://react.docschina.org/docs/hooks-overview.html" target="_blank" rel="noopener">Hook 概览</a><br><a href="https://react.docschina.org/docs/hooks-reference.html" target="_blank" rel="noopener">Hook API 索引</a><br><a href="https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-40" target="_blank" rel="noopener">从 Mixin 到 HOC 再到 Hook</a><br><a href="https://mp.weixin.qq.com/s/PmACWd4XvwXZXuTXggdhsw" target="_blank" rel="noopener">React 新特性 Hooks 讲解及实例(三)</a><br><a href="https://mp.weixin.qq.com/s/Tm7_JvMxSOvzsIXgx0rmYQ" target="_blank" rel="noopener">React 新特性 Hooks 讲解及实例(四)</a></p>
]]></content>
      <categories>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的hash、chunkhash、contenthash分别是什么</title>
    <url>/blog/webpack/docs/webpack-chunkhas-hash-contenthash.html</url>
    <content><![CDATA[<p><strong><em>知人者智，自知者明，胜人者有力，自胜者强。——老子</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<code>webpack</code>中有三种<code>hash</code>可以配置，分别是<code>hash</code>、<code>chunkhash</code>、<code>contenthash</code>他们是不对的可以针对不同的配置，首相要搞清楚这三种的<code>hash</code>的区别，什么场景下，适合用哪种。</p>
<p><strong>hash</strong><br>所有文件哈希值相同，只要改变内容跟之前的不一致，所有哈希值都改变，没有做到缓存意义</p>
<p><strong>chunkhash</strong><br>当有多个<code>chunk</code>，形成多个<code>bundle</code>时，如果只有一个<code>chunk</code>和一个<code>bundle</code>内容变了，其他的<code>bundle</code>的<code>hash</code>都会发生变化，因为大家都是公用的一个<code>hash</code>，这个时候<code>chunkhash</code>的作用就出来了。它根据不同的入口文件<code>(Entry)</code>进行依赖文件解析、构建对应的 <code>chunk</code>，生成对应的<strong>哈希值</strong>。</p>
<p><strong>contenthash</strong><br>在打包的时候我们会在<code>js</code>中导入<code>css</code>文件，因为他们是同一个入口文件，如果我只改了<code>js</code>得代码，但是他的<code>css</code>抽取生成<code>css</code>文件时候<code>hash</code>也会跟着变换。这个时候<code>contenthash</code>的作用就出来了。</p>
<p>下面直接用代码验证上面的猜想。</p>
<h2 id="一个简单的-webpack-配置"><a href="#一个简单的-webpack-配置" class="headerlink" title="一个简单的 webpack 配置"></a>一个简单的 webpack 配置</h2><p>我们现在就只创建一个能编译<code>js</code>的<code>webpack</code>配置，步骤如下：</p>
<ol>
<li>创建一个空文件加，并且在当文件夹中打开 <code>bash or cmd</code>。</li>
<li><code>npm init -y</code> 生成<code>package.json</code>。</li>
<li>如果你安装了<code>cnpm or yarn</code> 就执行 <code>cnpm i webpack webpack-cli -D</code>, 安装<code>webpack</code>的包。</li>
<li>创建<code>src</code>，在<code>src</code>内部创建<code>chunk0.js</code>、<code>chunk1.js</code>、<code>common.js</code>、<code>index.js</code>、<code>style.css</code>，并且编写内部代码</li>
<li>在项目根目录创建 <code>webpack.config.js</code></li>
<li>直接在<code>cmd</code>中运行 <code>webpack</code></li>
</ol>
<p>文件目录如下：<br><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-3.png" alt="webpack contenthash hash chunkhash"></p>
<p>下面是代码<br><strong>chunk0.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>chunk1.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">flow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'flow'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>common.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">commonJs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'commonJs'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">'./chunk0.js'</span>;</span><br><span class="line"><span class="keyword">import</span> commonJs <span class="keyword">from</span> <span class="string">'./common'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(commonJs());</span><br></pre></td></tr></table></figure>
<p><strong>style.css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>, <span class="comment">// 如果不添加就会警告</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>, <span class="comment">// 一个入口文件</span></span><br><span class="line">    chunk1: <span class="string">'./src/chunk1.js'</span> <span class="comment">// 两一个入口文件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span> <span class="comment">// 出口文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>我们直接运行<code>webpack</code>，运行结果如下图所示：</p>
<p>只有一个 hash，所有文件的 hash 都是相同：</p>
<p><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-4.png" alt="webpack contenthash hash chunkhash"><br>如果我们改变修改<strong>chunk1.js</strong>中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">flow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'flow1'</span>; <span class="comment">// flow =&gt; folw1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再运行 webpack 发现所有的 hash 都<font color="#ff502c">变化</font>了，如下图所示：</p>
<p><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-4.png" alt="webpack contenthash hash chunkhash"><br><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-5.png" alt="webpack contenthash hash chunkhash"></p>
<p>对比发现他们的 hash 并不相同了，这个时候如果想修改了<strong>chunk1.js</strong>,index.js 不产生变化，就要用到 chunkhash。</p>
<h2 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h2><ul>
<li>第一步 我们先把<strong>webpack.config.js</strong>做一下修改</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    chunk1: <span class="string">'./src/chunk1.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span> <span class="comment">// hash =&gt; chunkhash</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步 我们运行<code>webpack</code></li>
</ul>
<p><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-6.png" alt="webpack contenthash hash chunkhash"><br>根据上面图片发下，两个<code>chunk</code>的<code>hash</code>并不相同了。</p>
<ul>
<li>第三部 我们修改 <code>chunk1.js</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">flow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'flow11111'</span>; <span class="comment">// flow1 =&gt; flow11111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再运行<code>webpack</code></li>
</ul>
<p><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-6.png" alt="webpack contenthash hash chunkhash"><br><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-7.png" alt="webpack contenthash hash chunkhash"></p>
<p>根据图片我们看到了<code>chunk1.js</code>的<code>hash</code>变化，而<code>index.js</code>的<code>hash</code>并没有变化，达到了我们预期的效果，对我们线上的缓存也是比较好的。</p>
<h2 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h2><p>但是当我们一个<code>js</code>文件里面引用了一个<code>css</code>文件，如果我么修改了<code>css</code>文件内的内容，我们<code>css</code>中的内容，会发发现这整个<code>bundle</code>的<code>hash</code>也会发生更新。<br>我们要引入<code>css</code>，并且要把<code>css</code>提出、压缩生成一个<code>css</code>文件，就要借助一个<code>webpack</code>的插件，叫做<code>MiniCssExtractPlugin</code>,他可以帮我提取 css 到 css 文件，并且压缩 css。</p>
<ul>
<li>第一步先安装<code>css-loader</code>、<code>mini-css-extract-plugin</code>包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步修改<code>webpack.config.js</code> 如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>); <span class="comment">// 新增</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    chunk1: <span class="string">'./src/chunk1.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">'[name].[chunkhash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步运行 webpack</li>
</ul>
<p><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-8.png" alt="webpack contenthash hash chunkhash"></p>
<p>看代码可以看到<code>index.css</code>和<code>index.js</code>的<code>hash</code>是一样的。</p>
<ul>
<li>第四步修改 style.css</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  font-size: <span class="number">13</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第五步运行 webpack</li>
</ul>
<p><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-8.png" alt="webpack contenthash hash chunkhash"><br><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-9.png" alt="webpack contenthash hash chunkhash"></p>
<p>对比两次构建的<code>hash</code>，发现只修改了<code>style.css</code>的文件，引入他的<code>index.js</code>确也更新了<code>hash</code>，这个时候就需要<code>contenthash</code>来发挥作用了。</p>
<ul>
<li>第六步修改<code>webpack.config.js</code> 并且运行 webpack</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>); <span class="comment">// 新增</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    chunk1: <span class="string">'./src/chunk1.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-10.png" alt="webpack contenthash hash chunkhash"></p>
<p>看到他们直接 hash 就是不同的。</p>
<ul>
<li>修改<code>common.js</code>，直接运行 webpack</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">commonJs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'commonJs1'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-10.png" alt="webpack contenthash hash chunkhash"><br><img src="./webpack-chunkhas-hash-contenthash/webpack/webpack-1-11.png" alt="webpack contenthash hash chunkhash"></p>
<p>看到修改 js 时我们的 css 文件的 hash 并没有变更。</p>
<blockquote>
<p>注意，当使用<code>contenthash</code>时，如果修改 js 文件，css 文件的 hash 不会变化，但是修改 js 的文件，css 文件的 hash 也会变化。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>hash 所有文件哈希值相同；</strong><br><strong>chunkhash 根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值；</strong><br><strong>contenthash 计算与文件内容本身相关，主要用在 css 抽取 css 文件时。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cede821f265da1bbd4b5630" target="_blank" rel="noopener">面试必备！webpack 中那些最易混淆的 5 个知识点</a></p>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的bundle、module、chunk分别是什么</title>
    <url>/blog/webpack/docs/webpack-bundle-module-chunk.html</url>
    <content><![CDATA[<p><strong><em>祸兮福之所倚，福兮祸之所伏。——老子</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p><code>bundle</code>、<code>module</code>、<code>chunk</code> 都是 webpack 中的术语，下面就一个一个介绍他们的定义是什么，怎么产生的。</p>
<h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p><strong>Bundle</strong>是由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。<br><strong>Bundle 分离（Bundle Splitting）:</strong>这个流程提供了一个优化 build 的方法，允许 webpack 为应用程序生成多个 bundle。最终效果是，当其他某些 bundle 的改动时，彼此独立的另一些 bundle 都可以不受到影响，减少需要重新发布的代码量，因此由客户端重新下载并利用浏览器缓存。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p><strong>模块（Module）</strong>提供比较完整程序接触面（surface area）更小的离散功能块。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。<br><strong>模块解析（Module Resolution）</strong>一个模块可以作为另一个模块的依赖模块，resolver 是一个库（libary）用于帮助找不到模块的绝对路径，模块将在<strong>resolve.modules</strong>中指定的所有目录内搜索。</p>
<h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p><strong>Chunk</strong>这是 webpack 特定的术语被用在内部来管理 building 过程。bundle 是由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk)和子 chunk(child chunk)）。通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系。<br><strong>代码分离（Code Splitting）</strong>指将代码分离到每个 bundles/chunks 里面，你可以按需加载，而不是加载一个包含全部的 bundle。<br><strong>配置（Configuration）</strong>webpack 的配置文件是一个普通的 JavaScript 文件，它导出为一个对象。然后由 webpack 根据这个对象定义的属性进行处理。</p>
<h2 id="Bundle-VS-Chunk-VS-Module"><a href="#Bundle-VS-Chunk-VS-Module" class="headerlink" title="Bundle VS Chunk VS Module"></a>Bundle VS Chunk VS Module</h2><p>我们从定义和时期来说：</p>
<ul>
<li>“模块”<code>(module)</code>的概念大家都比较熟悉，如 <code>CommonJS 模块</code>、<code>AMD</code>、<code>ES6 Modules</code> 模块</li>
<li><code>chunk</code> 表示打包的时候产生得模块，由他来组成 <code>bundle</code></li>
<li>打包完成的源代码</li>
</ul>
<p>我们现在就只创建一个能编译<code>js</code>的<code>webpack</code>配置，步骤如下：</p>
<ol>
<li>创建一个空文件加，并且在当文件夹中打开 <code>bash or cmd</code>。</li>
<li><code>npm init -y</code> 生成<code>package.json</code>。</li>
<li>如果你安装了<code>cnpm or yarn</code> 就执行 <code>cnpm i webpack webpack-cli -D</code>, 安装<code>webpack</code>的包。</li>
<li>创建<code>src</code>，在<code>src</code>内部创建<code>chunk0.js</code>、<code>chunk1.js</code>、<code>common.js</code>、<code>index.js</code>、<code>style.css</code>，并且编写内部代码</li>
<li>在项目根目录创建 <code>webpack.config.js</code></li>
<li>直接在<code>cmd</code>中运行 <code>webpack</code></li>
</ol>
<p>下面是代码<br><strong>chunk0.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>chunk1.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">flow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'flow'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>common.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">commonJs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'commonJs'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">'./chunk0.js'</span>;</span><br><span class="line"><span class="keyword">import</span> commonJs <span class="keyword">from</span> <span class="string">'./common'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(commonJs());</span><br></pre></td></tr></table></figure>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>, <span class="comment">// 如果不添加就会警告</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>, <span class="comment">// 一个入口文件</span></span><br><span class="line">    chunk1: <span class="string">'./src/chunk1.js'</span> <span class="comment">// 两一个入口文件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span> <span class="comment">// 出口文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行的效果如下<br><img src="../../../images/webpack/webpack1-1.png" alt="webpack bundle module chunk"></p>
<p>通过上面的代码知道，<code>module</code> 就是没有被编译之前的代码，通过 <code>webpack</code> 的根据文件引用关系生成 <code>chunk</code> 文件，webpack 处理好 <code>chunk</code> 文件后，生成运行在浏览器中的代码 <code>bundle</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cede821f265da1bbd4b5630" target="_blank" rel="noopener">面试必备！webpack 中那些最易混淆的 5 个知识点</a><a href="http://qingbob.com/webpack-chunks-split-01/" target="_blank" rel="noopener">深入理解 Webpack 打包分块（上）</a></p>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript实现flatten多种方法</title>
    <url>/blog/algorithm/other/algorithm-other-flatten.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>我们在网上看到很多的关于数组的面试题，比如说给如下一个数组，把它<strong>拍平、去重、升序</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>其实这个题有很多种解法，比如用 <code>Array.prototype.flat</code>,或者自己实现一个 <code>flatten</code> 函数，我们这里主要关注的时 <code>flat</code> 方法的实现。</p>
<h2 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h2><p>用最新的语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<p>1、就是先拍平一个多维数组 <code>arr.flat</code>(ES6 语法)<br>2、再通过 <code>Set</code> 集合做去重<br>3、再通过 <code>Array.from</code> 把 <code>Set</code> 集合转为数组<br>4、再通过 <code>sort</code> 排序</p>
<p>如果不了解 <code>flat</code> 的函数的话，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">mdn Array.prototype.flat()</a>，或者看<a href="http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-flat%EF%BC%8CflatMap" target="_blank" rel="noopener">阮一峰老师的 <code>flat</code> 介绍</a>。<br>Set 集合的讲解可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">mdn Set</a>，或者看<a href="http://es6.ruanyifeng.com/?search=Set&amp;x=0&amp;y=0#docs/set-map" target="_blank" rel="noopener">阮一峰老师的 Set 介绍</a>。<br>我们这里主要讨论 flat 的实现。</p>
<h2 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.toString().split(<span class="string">','</span>)))</span><br><span class="line">  .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<p>1、我们调用 <code>Array</code> 上的 <code>toString</code> 方法把他转换为一个字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.toString();</span><br><span class="line"><span class="comment">// "8,5,9,4,1,3,7,5,10,3,4,6,2,4,3,2,4"</span></span><br></pre></td></tr></table></figure>
<p>这列我们就不讨论为什么返回的结果里面不包含<font color="#ff502c">‘[]’</font>这两个字符串，后面我在写一篇博客来说数组，的 <code>valueOf、toString</code> 方法。<br>2、再把字符串通过 <code>Array.prototype.split</code> 方法转换为数组<br>3、再通过 <code>Set</code> 集合做去重<br>4、再通过 <code>Array.from</code> 把 <code>Set</code> 集合转为数组<br>5、再通过 <code>sort</code> 排序</p>
<h2 id="第三种解法"><a href="#第三种解法" class="headerlink" title="第三种解法"></a>第三种解法</h2><p>自己通过封装一个 <code>flatten</code>，在不基于 <code>Array.prototype.flat</code> 方法上实现一个拍平函数</p>
<h3 id="ES6-实现"><a href="#ES6-实现" class="headerlink" title="ES6 实现"></a>ES6 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">arr</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.isArray(arr) ? arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> [...a, ...flatten(b)], []) : [arr];</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(flatten(arr))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>], <span class="number">1</span>, <span class="number">3</span>, [<span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>]], <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(arr)</span><br><span class="line">    ? arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, current</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [...prev, ...flatten(current)];</span><br><span class="line">      &#125;, [])</span><br><span class="line">    : [arr];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(flatten(arr))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>1、检测是否为数组<br>2、如果是数组，调用 <code>reduce</code> 函数实现合并函数<br>3、如果有嵌套数组，就递归调用该方法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现拍平数组大致有三种方法</p>
<ol>
<li><code>Array.prototype.flat</code> 方法</li>
<li><code>Array.prototype.toString</code> 方法转为字符串，再 <code>split</code></li>
<li>自己实现一个 <code>flatten</code> 函数</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理 （三）repaint(重绘)和reflow(回流)详解</title>
    <url>/blog/html/render/html-reload-reflow.html</url>
    <content><![CDATA[<p><strong><em>知足则不辱，知止则不殆。——老子</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>大多数设备的刷新频率是<strong>60Hz</strong>，也就说是浏览器对每一帧画面的渲染工作要在 <strong>16ms</strong> 内完成,超出这个时间，页面的渲染就会出现<strong>卡顿</strong>现象，影响用户体验。<br><strong>repaint(重绘)</strong>和 <strong>reflow(回流)</strong>发生在什么渲染的那个阶段，我们要了解什么叫做 <strong>repaint(重绘)</strong>和 <strong>reflow(回流)</strong>.</p>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="(重绘)"></a>(重绘)</h3><p><code>repaint</code> 就是在<code>不影响排版的情况下</code>对这个元素重新绘制的过程。例如改变一个元素的背景颜色、字体颜色等。</p>
<h3 id="reflow-回流、重排"><a href="#reflow-回流、重排" class="headerlink" title="reflow(回流、重排)"></a>reflow(回流、重排)</h3><p><code>当 render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建</code>。这就称为回流（其实我觉得叫重新布局更简单明了些）。每个页面至少需要一次回流，就是在页面第一次加载的时候。<br><strong>回流必将引起重绘，而重绘不一定会引起回流</strong></p>
<h3 id="三种常见的渲染流程"><a href="#三种常见的渲染流程" class="headerlink" title="三种常见的渲染流程"></a>三种常见的渲染流程</h3><p><strong>1. JS/CSS&gt;计算样式&gt;布局&gt;绘制&gt;渲染层合并</strong><br><img src="./html-reload-reflow/reflow-repaint-1-1.png" alt="reflow"><br>这张图上渲染流程对应的是<strong>reflow</strong>渲染的过程，它会经过布局再绘制。<br><strong>2. JS/CSS&gt;计算样式&gt;绘制&gt;渲染层合并</strong><br><img src="./html-reload-reflow/reflow-repaint-1-2.png" alt="repaint"><br>这张图上渲染流程对应的是<strong>repaint</strong>渲染的过程，它不需要经过布局，只需要绘制当前的元素，不需要重新计算它的父元素。<br><strong>3. JS/CSS&gt;计算样式&gt;渲染层合并</strong><br><img src="./html-reload-reflow/reflow-repaint-1-3.png" alt="compositor"><br>这张图上渲染流程比较特殊，它不选经过布局、绘制，它只需要在<strong>合成层</strong>上修改。</p>
<!-- ### repaint、reflow和eventLoop关系 -->
<h2 id="repaint-重绘-和-reflow-回流"><a href="#repaint-重绘-和-reflow-回流" class="headerlink" title="repaint(重绘)和 reflow(回流)"></a>repaint(重绘)和 reflow(回流)</h2><p>上面大致已经记录了 repaint、reflow 的流程和为什么要关注它，下面记录一下它们的触发条件、和 eventLoop 的关系。</p>
<h3 id="触发-repaint、reflow"><a href="#触发-repaint、reflow" class="headerlink" title="触发 repaint、reflow"></a>触发 repaint、reflow</h3><ol>
<li><strong>添加、删除元素</strong>（回流+重绘）</li>
<li>隐藏元素，<strong>display:none</strong>(回流+重绘)，<strong>visibility:hidden</strong>(只重绘，不回流)</li>
<li><strong>移动元素</strong>，比如改变 top、left（jquery 的 animate 方法就是改变 top、left 不一定会影响回流），或者移动元素到另外 1 个父元素中。(重绘+回流)</li>
<li>对 style 的操作（对不同的属性操作，影响不一样）（color、background-color）=&gt;(重绘) (padding、margin)=&gt;(回流)</li>
<li>浏览器大小改变<strong>resize</strong>、<strong>font-size</strong>（重绘+回流）</li>
<li><strong>transform/opacity</strong> （不会触发生重绘、回流）</li>
<li>最复杂的一种：<strong>获取某些属性</strong>，引发回流 很多浏览器会对回流做优化，他会等到足够数量的变化发生，在做一次批处理回流。 但是除了 render 树的直接变化。 当获取一些属性时，浏览器为了获得正确的值也会触发回流。<ol>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop/Left/Width/Height</li>
<li>clientTop/Left/Width/Height</li>
<li>width,height</li>
<li>调用了 getComputedStyle(), 或者 IE 的 currentStyle</li>
</ol>
</li>
</ol>
<p>上面大致就是触发<strong>repaint、reflow</strong>的操作，还有更多的后面还会补全。</p>
<h3 id="repaint、reflow-和-eventLoop-关系"><a href="#repaint、reflow-和-eventLoop-关系" class="headerlink" title="repaint、reflow 和 eventLoop 关系"></a>repaint、reflow 和 eventLoop 关系</h3><ol>
<li>当 <strong>Event loop</strong> 执行完 <strong>Microtasks</strong> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <strong>60Hz</strong> 的刷新率，每 <strong>16ms</strong> 才会更新一次。</li>
<li>然后判断是否有 <code>resize</code>或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <strong>16ms</strong> 才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了 <code>media query</code></li>
<li><strong>更新动画并且发送事件</strong></li>
<li><strong>判断是否有全屏操作事件</strong></li>
<li><strong>执行 requestAnimationFrame 回调</strong></li>
<li><strong>执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</strong></li>
<li><strong>更新界面</strong></li>
</ol>
<p>在这个里面记录了触发 <strong>repaing、reflow</strong>，还有和 <strong>eventloop</strong> 的关系，但是 <strong>eventloop</strong> 和 <strong>ui 渲染</strong>流程关系有点太复杂，所以大致记录了一下。</p>
<h2 id="优化渲染性能"><a href="#优化渲染性能" class="headerlink" title="优化渲染性能"></a>优化渲染性能</h2><ul>
<li><strong><em>减少重绘和回流</em></strong></li>
<li><strong><em>优化 JavaScript 的执行效率</em></strong></li>
<li><strong><em>对用户输入事件的处理函数去抖动</em></strong></li>
<li><strong><em>优先使用渲染层合并属性、控制层数量</em></strong></li>
<li><strong><em>结合 chrome 工具分析性能</em></strong></li>
</ul>
<h3 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h3><ul>
<li><strong><em>避免逐项更改样式</em></strong>。最好一次性更改 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。</li>
<li><strong><em>避免循环操作 DOM</em></strong>。创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到 window.document。</li>
<li><strong><em>避免多次读取 offsetLeft 等属性</em></strong>。无法避免则将它们缓存到变量。</li>
<li><strong><em>将复杂的元素绝对定位或固定定位，使它脱离文档流</em></strong>。否则回流代价十分高</li>
<li><strong><em>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</em></strong></li>
<li><strong><em>动画实现的速度的选择</em></strong>，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li>
<li><strong><em>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</em></strong></li>
<li><strong><em>使用 visibility 替换 display: none</em></strong> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li><strong><em>使用 translate 替代 top</em></strong></li>
<li><strong><em>把 DOM 离线后修改</em></strong>，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li>
<li><strong><em>使用 flexbox 替代老的布局模型</em></strong><br>还有很多在这里就不一一列举了，主要思想就是减少 reflow、repaint 的次数。</li>
</ul>
<h3 id="优化-JavaScript-的执行效率"><a href="#优化-JavaScript-的执行效率" class="headerlink" title="优化 JavaScript 的执行效率"></a>优化 JavaScript 的执行效率</h3><p><strong>动画实现，避免使用 setTimeout 或 setInterval，尽量使用 requestAnimationFrame</strong><br><strong>把耗时长的 JavaScript 代码放到 Web Workers 中去做</strong></p>
<h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h4><p><strong>动画实现，避免使用 setTimeout 或 setInterval，尽量使用 requestAnimationFrame</strong><br>setTimeout(callback)和 setInterval(callback)无法保证 callback 函数的执行时机，很可能在帧结束的时候执行，从而导致丢帧，如下图：<br><img src="./html-reload-reflow/reflow-repaint-1-4.png" alt="setTimeout、和setInterval"><br>requestAnimationFrame(callback)可以保证 callback 函数在每帧动画开始的时候执行。</p>
<blockquote>
<p>注意：jQuery 的 animate 函数就是用 setTimeout 来实现动画，可以通过 jquery-requestAnimationFrame 这个补丁来用 requestAnimationFrame 替代 setTimeout</p>
</blockquote>
<h4 id="把耗时长的-JavaScript-代码放到-Web-Workers-中去做"><a href="#把耗时长的-JavaScript-代码放到-Web-Workers-中去做" class="headerlink" title="把耗时长的 JavaScript 代码放到 Web Workers 中去做"></a>把耗时长的 JavaScript 代码放到 Web Workers 中去做</h4><p>把耗时长的 <strong>JavaScript 代码放到 Web Workers</strong> 中去做 JavaScript 代码运行在浏览器的<strong>主线程</strong>上，与此同时，浏览器的主线程还负责<strong>样式计算、布局、绘制</strong>的工作，如果 JavaScript 代码运行时间过长，就会<strong>阻塞</strong>其他渲染工作，很可能会导致丢帧。<br>前面提到每帧的渲染应该在 16ms 内完成，但在动画过程中，由于已经被占用了不少时间，所以 JavaScript 代码运行耗时应该控制在<strong>3-4 毫秒</strong>。</p>
<h3 id="对用户输入事件的处理函数去抖动"><a href="#对用户输入事件的处理函数去抖动" class="headerlink" title="对用户输入事件的处理函数去抖动"></a>对用户输入事件的处理函数去抖动</h3><p>用户输入事件处理函数会在运行时<strong>阻塞帧的渲染</strong>，并且会导致<strong>额外的布局</strong>发生。<br>理想情况下，当用户和页面交互，页面的<strong>渲染层合并线程</strong>将接收到这个事件并移动元素。这个响应过程是不需要主线程参与，不会导致 <strong>JavaScript、布局和绘制</strong>过程发生。</p>
<p><img src="./html-reload-reflow/reflow-repaint-1-5.png" alt="去抖"></p>
<p>但是如果被触摸的元素绑定了输入事件处理函数，比如 <code>touchstart/touchmove/touchend</code>，那么渲染层合并线程必须等待这些被绑定的处理<strong>函数执行完毕</strong>才能执行，也就是用户的滚动页面操作<strong>被阻塞</strong>了，表现出的行为就是滚动出现<strong>延迟或者卡顿</strong>。<br>简而言之就是你必须确保用户输入事件绑定的任何处理函数都能够<strong>快速的执行完毕</strong>，以便腾出时间来让<strong>渲染层合并线程</strong>完成他的工作。</p>
<p><img src="./html-reload-reflow/reflow-repaint-1-6.png" alt="去抖"></p>
<h4 id="避免使用运行时间过长的输入事件处理函数"><a href="#避免使用运行时间过长的输入事件处理函数" class="headerlink" title="避免使用运行时间过长的输入事件处理函数"></a>避免使用运行时间过长的输入事件处理函数</h4><p>输入事件处理函数，比如 <code>scroll/touch 事件</code>的处理，都会在 <code>requestAnimationFrame</code> 之前被调用执行。<br>因此，如果你在上述输入事件的处理函数中做了<strong>修改样式属性</strong>的操作，那么这些操作就会被浏览器<strong>暂存</strong>起来，然后在调用 <code>requestAnimationFrame</code> 的时候，如果你在一开始就做了<strong>读取样式属性</strong>的操作，那么将会触发浏览器的强制同步布局操作。</p>
<p><img src="./html-reload-reflow/reflow-repaint-1-7.png" alt="去抖"></p>
<h4 id="对滚动事件处理函数去抖动"><a href="#对滚动事件处理函数去抖动" class="headerlink" title="对滚动事件处理函数去抖动"></a>对滚动事件处理函数去抖动</h4><p>通过 requestAnimationFrame 可以对样式修改操作去抖动，同时也可以使你的事件处理函数变得更轻</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Store the scroll value for laterz.</span></span><br><span class="line">  lastScrollY = <span class="built_in">window</span>.scrollY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent multiple rAF callbacks.</span></span><br><span class="line">  <span class="keyword">if</span> (scheduledAnimationFrame) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduledAnimationFrame = <span class="literal">true</span>;</span><br><span class="line">  requestAnimationFrame(readAndUpdatePage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll);</span><br></pre></td></tr></table></figure>
<h3 id="chrome-分析结合"><a href="#chrome-分析结合" class="headerlink" title="chrome 分析结合"></a>chrome 分析结合</h3><p>使用 Chrome DevTools 来了解页面的渲染层情况</p>
<h4 id="Chrome-DevTools-gt-Preformance"><a href="#Chrome-DevTools-gt-Preformance" class="headerlink" title="Chrome DevTools &gt; Preformance"></a>Chrome DevTools &gt; Preformance</h4><p>通过 Chrome DevTools 的 Preformance 来录制一段操作，并且开启 More tools 的 Layers、Rendering 功能，如果下图所示:<br><img src="./html-reload-reflow/reflow-repaint-1-8.png" alt="Chrome DevTools"><br><img src="./html-reload-reflow/reflow-repaint-1-9.png" alt="Chrome DevTools"></p>
<h4 id="借助-Chrome-暴露在-window-上的-preformance-对象"><a href="#借助-Chrome-暴露在-window-上的-preformance-对象" class="headerlink" title="借助 Chrome 暴露在 window 上的 preformance 对象"></a>借助 Chrome 暴露在 window 上的 preformance 对象</h4><p>可以用 preformance 对象来做一些前端的性能分析和统计，如下图所示：<br><img src="./html-reload-reflow/reflow-repaint-1-10.png" alt="Chrome DevTools"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个上面了解了 <code>reflow、repaint</code> 的流程和他的触发条件，再后面也有一部分怎么优化性能，结合前面的渲染流程大致知道优化的是那部分的流程。当然在优化性能的时候，一定要结合 chrome 的性能分析功能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/a32b890c29b1" target="_blank" rel="noopener">深度剖析浏览器渲染性能原理，你到底知道多少？</a><br><a href="https://www.cnblogs.com/dll-ft/p/5810639.html" target="_blank" rel="noopener">回流(reflow)与重绘(repaint)</a><br><a href="https://www.cnblogs.com/goloving/p/7545954.html" target="_blank" rel="noopener">高性能 WEB 开发：深入理解页面呈现、重绘、回流</a></p>
]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>Render</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理 （一）在网址中输入一个网站后面都做了什么</title>
    <url>/blog/html/render/html-browser-render.html</url>
    <content><![CDATA[<p><strong><em>人法地，地法天，天法道，道法自然。</em></strong></p>
<p>如果想看更深入的了解渲染细节，可以看：</p>
<blockquote>
<p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Layout" target="_blank" rel="noopener">别人翻译的外国友人的渲染原理</a></p>
</blockquote>
<h2 id="浏览器是怎么渲染-html-的"><a href="#浏览器是怎么渲染-html-的" class="headerlink" title="浏览器是怎么渲染 html 的"></a>浏览器是怎么渲染 html 的</h2><p><code>关键渲染路径（Critical Rendering Path）</code>是指与当前用户操作有关的内容。例如用户刚刚打开一个页面，首屏的显示就是当前用户操作相关的内容，具体就是浏览器收到<code>HTML、CSS 和 JavaScript</code> 等资源并对其进行处理从而渲染出 <code>Web</code> 页面。<br>如下图所示渲染流程：<br><img src="./html-browser-render/bowser-render.png" alt="bowser-render"><br>当我们在浏览器中输入一个网址的时候，他是怎么请求资源，并且把我们的页面绘制出来的，大概可以分为六步，其中又可以细分，下面我大概说一个 6 大步骤：</p>
<blockquote>
<ol>
<li>浏览器首先通过 <code>HTTP</code> 协议或者 <code>HTTPS</code> 协议，向服务器请求页面，当然这个其中也可能有缓存什么的；</li>
<li>把请求回来的<code>HTML</code> 代码经过解析，构建成 <code>DOM</code> 树；</li>
<li>计算 <code>DOM 树</code>上的 <code>CSS</code> 属性，生成 <code>CSSOM 树(CSS Object Model)</code>；</li>
<li>将 <code>DOM 树</code>和 <code>CSSOM 树</code>合并成一个<code>渲染树(rendering tree)</code>；</li>
<li>渲染树的每个元素包含的内容都是<code>计算</code>过的，它被称之为<code>布局 layout</code>。浏览器使用一种流式处理的方法，只需要一次 <code>pass 绘制</code>操作就可以布局所有的元素；</li>
<li>将渲染树的各个节点绘制到屏幕上，这一步被称为<code>绘制 painting</code>；</li>
<li>按照合理的顺序合并图层然后显示到屏幕上 <code>Composite（渲染层合并）</code></li>
</ol>
</blockquote>
<h3 id="第一步请求资源"><a href="#第一步请求资源" class="headerlink" title="第一步请求资源"></a>第一步请求资源</h3><p>在我们在浏览器中输入完网址的时候，浏览器其实会先做以下几小步：</p>
<blockquote>
<ol>
<li><code>DNS 查询</code>（就是把当前域名解析成为 ip 地址）</li>
<li><code>TCP 连接</code></li>
<li><code>HTTP 请求响应</code></li>
<li>服务器返回数据</li>
</ol>
</blockquote>
<h3 id="第二步构建-DOM-树"><a href="#第二步构建-DOM-树" class="headerlink" title="第二步构建 DOM 树"></a>第二步构建 DOM 树</h3><p>在构建 <code>DOM 树</code>的时候又可以分为几小步：</p>
<blockquote>
<ol>
<li>字符流通过状态机解析成为 <code>词 token</code></li>
<li>词 <code>token =&gt; prase =&gt; DOM 树</code></li>
</ol>
</blockquote>
<p>构建 <code>DOM</code> 的过程是：从父到子，从先到后，一个一个节点构造，<code>DOM 树</code>结构和 HTML 标签一一对应。</p>
<h3 id="第三步-CSSOM-模型构建"><a href="#第三步-CSSOM-模型构建" class="headerlink" title="第三步 CSSOM 模型构建"></a>第三步 CSSOM 模型构建</h3><p>在计算 <code>css 规则</code>的时候，我们会在已经构建好的元素上，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。并且 <code>CSSOM</code> 主要是<code>DOM 结构</code>上的盒的描述，他基本上是依附于 <code>DOM 树</code>的。<br><code>CSS 计算</code>是把 <code>CSS 规则</code>应用到 <code>DOM 树</code>上，为 <code>DOM 结构</code>添加显示相关属性过程。<br><code>CSSOM</code> 是有 <code>rule</code> 部分和 <code>view</code> 部分的，<code>rule 部分</code>是在 <code>dom</code> 开始之前就构件完成的，而 <code>view</code> 部分是跟着 <code>dom</code> 同步构建的。</p>
<h3 id="第四步构建渲染树（Rendr-tree-construction）"><a href="#第四步构建渲染树（Rendr-tree-construction）" class="headerlink" title="第四步构建渲染树（Rendr tree construction）"></a>第四步构建渲染树（Rendr tree construction）</h3><p>通过 <code>DOM 树</code>和 <code>CSS 规则树</code>，浏览器就可以通过它两构建<code>渲染树</code>了。<br><code>渲染树</code>和 <code>DOM 元素</code>相对应的，但并非一一对应。非可视化的 <code>DOM 元素</code>不会插入呈现树中，例如<code>“head”元素</code>。如果元素的 <code>display</code> 属性值为<code>“none”</code>，那么也不会显示在呈现树中（但是 <code>visibility</code> 属性值为<code>“hidden”</code>的元素仍会显示）。</p>
<h3 id="第五步渲染树布局-layout-of-the-render-tree"><a href="#第五步渲染树布局-layout-of-the-render-tree" class="headerlink" title="第五步渲染树布局(layout of the render tree)"></a>第五步渲染树布局(layout of the render tree)</h3><p><strong>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息</strong>。计算这些值的过程称为<code>布局</code>或<code>重排</code>。<br>布局阶段会从<code>渲染树</code>更新节点开始遍历，由于渲染树的每个节点都是一个 <code>Render Object</code> 对象，包含宽高，位置，背景色等样式信息。浏览器中渲染这个过程，就是把每一个元素对应的盒变成<code>位图</code>，再把位图合成一个大的<code>位图</code>。<br>布局又分为全局布局和增量布局，<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Layout" target="_blank" rel="noopener">详情请看</a></p>
<h3 id="第六步渲染树绘制（Painting-the-render-tree）"><a href="#第六步渲染树绘制（Painting-the-render-tree）" class="headerlink" title="第六步渲染树绘制（Painting the render tree）"></a>第六步渲染树绘制（Painting the render tree）</h3><p>在绘制阶段，系统会遍历<code>呈现树</code>，并调用呈现器的<code>“paint”方法</code>，将<code>呈现器</code>的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。<br>绘制又分为<code>全局绘制</code>和<code>增量绘制</code>，并且绘制的属性也会有前后之分，<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">详情请看</a></p>
<h3 id="compositor-layer-合成渲染层"><a href="#compositor-layer-合成渲染层" class="headerlink" title="compositor layer 合成渲染层"></a>compositor layer 合成渲染层</h3><p>渲染过程把<code>元素变成位图</code>，合成把一部分<code>位图变成合成层</code>，最终的绘制过程把<code>合成层</code>显示到屏幕上。<br>对于 <code>transform/opacity</code> 这两种变换，浏览器不会用 <code>repaint/reflow</code> 处理，而是在已经渲染的元素基础上进行附加工作。<br>他的渲染流程为下图所示：<br><img src="./html-browser-render/reflow-repaint-1-1.png" alt="只执行 compositor"><br>js 改变样式，样式只触发合成属性，不触发 repaint/reflow.附原文链接<br><a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count" target="_blank" rel="noopener">stick-to-compositor-only-properties-and-manage-layer-count</a></p>
<h2 id="阻塞渲染：CSS、JavaScript、DOM"><a href="#阻塞渲染：CSS、JavaScript、DOM" class="headerlink" title="阻塞渲染：CSS、JavaScript、DOM"></a>阻塞渲染：CSS、JavaScript、DOM</h2><p>谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 <code>HTML 解析器（HTML Parser）</code>被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。<br>同时，由于下面两点：</p>
<blockquote>
<ol>
<li>默认情况下，<code>CSS 被视为阻塞渲染的资源</code>，这意味着浏览器将不会渲染任何已处理的内容，直至<code>CSSOM 构建完毕</code>。</li>
<li><code>JavaScrip</code>t 不仅可以读取和<code>修改 DOM 属性</code>，还可以<code>读取和修改 CSSOM</code> 属性，因此 <code>CSS 解析</code>与 <code>script 的执行</code>互斥。</li>
<li>存在<code>阻塞的 CSS 资源</code>时，浏览器会<code>延迟 JavaScript 的执行和 DOM 构建</code>。</li>
</ol>
</blockquote>
<p>正是由于以上这些原因，<code>script 标签</code>的位置很重要我们在实际开发中应该尽量坚持以下两个原则：<br><strong><em>在引入顺序上，CSS 资源先于 JavaScript 资源。</em></strong><br><strong><em>JavaScript 应尽量少的去影响 DOM 的构建。</em></strong><br>想理清楚 <code>CSS、JavaScript、DOM</code> 之间的相互<a href="http://asyncnode/blog/html/render/html-browser-render.html" target="_blank" rel="noopener">阻塞关系</a></p>
<h2 id="改变阻塞模式"><a href="#改变阻塞模式" class="headerlink" title="改变阻塞模式"></a>改变阻塞模式</h2><p>我们熟知的<code>javascript</code>标签上<code>defer</code>和<code>async</code>属性，还有可能不太熟知的<code>link</code>标签上的<code>preload</code>属性。</p>
<p>在介绍 async 和 defer 之前我们要先看了解两个概念，<code>load</code>和<code>DOMContentLoaded</code>的执行时机</p>
<h3 id="load-和-DOMContentLoaded"><a href="#load-和-DOMContentLoaded" class="headerlink" title="load 和 DOMContentLoaded"></a>load 和 DOMContentLoaded</h3><p><strong>load</strong><br>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。<br><strong>DOMContentLoaded</strong><br>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</p>
<h3 id="首先是-async-和-defer"><a href="#首先是-async-和-defer" class="headerlink" title="首先是 async 和 defer"></a>首先是 async 和 defer</h3><p>async 和 defer 他们对于内联脚本无作用（即没有 src 属性的脚本）<br><strong>async</strong><br>该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。async 与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发<code>之前或之后</code>执行，但一定在 load 触发<code>之前</code>执行。并且多个 async-script 的执行顺序是<code>不确定</code>的。</p>
<p><strong>defer</strong><br>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并<code>未停止</code>解析，这两个过程是<code>并行</code>的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后<code>触发</code> DOMContentLoaded 事件。</p>
<p>defer 与相比普通 script，有两点区别：载入 JavaScript 文件时<code>不阻塞</code> HTML 的解析，执行阶段被放到 HTML 标签<code>解析完成</code>之后。</p>
<h3 id="preload-和-prerender"><a href="#preload-和-prerender" class="headerlink" title="preload 和 prerender"></a>preload 和 prerender</h3><p><strong>preload</strong></p>
<p><code>&lt;link&gt;</code> 元素的 <code>rel 属性</code>的属性<code>值preload</code>能够让你在你的<code>HTML页面</code>中 <code>&lt;head&gt;元素</code>内部书写一些声明式的资源获取请求，可以指明哪些资源是在<code>页面加载完成后即刻需要的</code>。对于这种即刻需要的资源，你可能希望在页面加载的生命周期的早期阶段就开始获取，在浏览器的主渲染机制介入前就<code>进行预加载</code>。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。<br>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好.</p>
<p><strong>prerender</strong><br>可以通过预渲染将下载的文件<code>预先在后台渲染</code>，可以使用以下代码<code>开启预渲染</code><br>预渲染虽然可以提高页面的<code>加载速度</code>，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个里面基本上了解了浏览器的渲染过程，但是有很多细节没有套路比如说我们都知道浏览器是单线程的，<code>ui 线程</code>和 <code>javascript 线程</code>是怎么协调的，还有一个比较重要的是<code>重绘和回流（重排）</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">浏览器的渲染：过程与原理</a><br><a href="https://www.imooc.com/article/40004" target="_blank" rel="noopener">浏览器渲染原理与过程</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener">HTML <script> 元素用于嵌入或引用可执行脚本。</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Layout">浏览器的工作原理：新式网络浏览器幕后揭秘</a><br><a href="https://zhuanlan.zhihu.com/p/23428399">重绘，回流和合成，了解基本浏览器绘制帮你优化页面性能</a></p>
</script></a></p>]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>Render</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中实现一个自己的new</title>
    <url>/blog/javascript/extends/javascript-extends.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><hr>
<p>传统的 javascript 中只有对象，没有类的概念。它是基于原型的面向对象语言。原型对象特点就是将自身的属性共享给新对象。<br>先看一下 new 关键字是他都做了什么，让我们通过 new 实现继承的。<br>下面请看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name, year, model</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.getV = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">'--'</span> + <span class="keyword">this</span>.year + <span class="string">'--'</span> + <span class="keyword">this</span>.model;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> carOne = <span class="keyword">new</span> Car(<span class="string">'jeep'</span>, <span class="string">'2018'</span>, <span class="string">'Wrangler'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(carOne.getV());</span><br><span class="line"><span class="built_in">console</span>.log(carOne);</span><br><span class="line">&lt;font color=<span class="string">'#ff502c'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>new 关键字进行如下的操作：</p>
<blockquote>
<ol>
<li>创建一个空的 JavaScript 对象；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象；</li>
<li>将步骤 1 新创建的对象作为 this 的上下文；</li>
<li>如果该函数没有返回对象，则返回 this。</li>
</ol>
</blockquote>
<p>同时，我们自己写的这个函数接收的<font color="#ff502c">第一个参数</font>就是我们要<font color="#ff502c">继承</font>的对象。<br>下面我们就一步一步实现一个自己的 new 关键字</p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>第一步比较简单我们要首先定义一个 create 方法在方法内创建一个<font color="#ff502c">空对象</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象会在后面用到，经过后面的处理，如果<font color="#ff502c">没有</font>返回值，就会<font color="#ff502c">返回</font>我们创建的这个<font color="#ff502c">空对象</font>。</p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>第二步比较关键，用到了我们基于 prototype 继承的知识。就是把我们新创建的这个<font color="#ff502c">空对象</font>的<font color="#ff502c"><strong>proto</strong></font>，指向我们要<font color="#ff502c">继承对象</font>的<font color="#ff502c">prototype</font>。<br>下面我们就在第一步代码的基础上实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shfit.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一步我们就是通过<font color="#ff502c"><strong>proto</strong></font>关联了我们创建的空对象的 prototype 到我们要继承的<font color="#ff502c">另一个</font>对象。</p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>第三步，将步骤 1 新创建的对象作为<font color="#ff502c">this 的上下文</font>，我们通过<font color="#ff502c">apply 执行构造函数</font>并且改变 this 指向。<br>下面我们在第二步的基础上实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shfit.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">  <span class="comment">// 绑定this指向，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Preson.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>判断是否有返回值，如果该函数没有返回对象，则<font color="#ff502c">返回 this</font>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shfit.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">  <span class="comment">// 绑定this指向，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Preson.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">  <span class="comment">// 绑定this指向，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Preson.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name, year, model</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> carOne = create(Car, <span class="string">'jeep'</span>, <span class="string">'2018'</span>, <span class="string">'Wrangler'</span>);</span><br><span class="line"><span class="keyword">var</span> carTwo = <span class="keyword">new</span> Car(<span class="string">'jeep'</span>, <span class="string">'2018'</span>, <span class="string">'Wrangler'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(carOne);</span><br><span class="line"><span class="built_in">console</span>.log(carTwo);</span><br><span class="line"><span class="built_in">console</span>.log(carOne.__proto__ === Car.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(carTwo.__proto__ === Car.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>一道面试题</strong><br>一道有关 new 的面试题，其实一部还是考察运算符优先级。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Foo.getName();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></table></figure>
<p>其实这个是考察运算优先级和 new 的面试题，通过 mdn 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算优先级</a><br>new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (Foo.getName())();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></table></figure>
<p>对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">mdn new 运算符</a><br><a href="https://yuchengkai.cn/docs/frontend/#new" target="_blank" rel="noopener">大佬 new 的实现</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Extends</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-router</title>
    <url>/blog/vue/router/vue-router-flow.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>VueRouter</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中有三种wathcer</title>
    <url>/blog/vue/principle/vue-three-wathcer.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 Vue中的派发更新</title>
    <url>/blog/vue/principle/vue-notify.html</url>
    <content><![CDATA[<p><a href="/blog/vue/vue-definedProperty.html">深入 Vue 系列 Vue 中的响应式对象</a><br><a href="/blog/vue/vue-dep.html">深入 Vue 系列 Vue 中的依赖收集</a><br><a href="/blog/vue/vue-notify.html">深入 Vue 系列 Vue 中的派发更新</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过在<code>defineReactive</code>观测的<code>data</code>子项中的<code>getter</code>函数中完成<a href="/blog/vue/vue-dep.html">依赖收集</a>，在<code>defineReactive</code>观测的<code>data</code>子项中的<code>setter</code>函数中完成依赖派发。<br>首先看一下 defineReactive 中的 setter：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 子对象递归调用 observe</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123; ... &#125;, <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="comment">// 先getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="comment">// 如果跟原来值一样则不管</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有setter方法则执行</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">/*新的值需要重新进行observe，保证数据响应式*/</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">       <span class="comment">/*dep对象通知所有的订阅者*/</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做了两个步：</p>
<ul>
<li>一个是 <code>childOb = !shallow &amp;&amp; observe(newVal)</code>，如果 <code>shallow</code> 为 <code>false</code> 的情况，会对新设置的值变成一个响应式对象；</li>
<li><code>dep.notify()</code> <code>dep</code> 对象通知所有的订阅者</li>
</ul>
<h2 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h2><ul>
<li>执行 <code>dep.notify()</code></li>
<li>执行 <code>watcher.update()</code></li>
<li>执行 <code>queueWatcher(this)</code></li>
<li>执行 <code>nextTick(flushSchedulerQueue)</code></li>
<li>执行 <code>watcher.run()</code></li>
<li>执行 <code>watcher.get()</code></li>
</ul>
<h3 id="1-执行-dep-notify"><a href="#1-执行-dep-notify" class="headerlink" title="1. 执行 dep.notify()"></a>1. <strong>执行 dep.notify()</strong></h3><p>当我们对响应式数据做了修改，就会触发 <code>setter</code> 的逻辑，最后调用<code>dep.notify()</code>方法，它是<code>Dep</code>的一个实例方法。代码在<code>scr/core/observer.js</code>中:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 循环调用watcher.update()方法</span></span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做的事情是：</p>
<ul>
<li>遍历所有的 <code>subs</code>，也就是 <code>Watcher</code> 的实例数组，然后调用每一个 <code>watcher</code>的 <code>update</code> 方法。</li>
</ul>
<h3 id="2-执行-watcher-update"><a href="#2-执行-watcher-update" class="headerlink" title="2. 执行 watcher.update()"></a>2. <strong>执行 watcher.update()</strong></h3><p>watcher 类定义在<code>src/core/observer/watcher.js</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="comment">// 判断是否为computed watcher</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="comment">// A computed property watcher has two modes: lazy and activated.</span></span><br><span class="line">      <span class="comment">// It initializes as lazy by default, and only becomes activated when</span></span><br><span class="line">      <span class="comment">// it is depended on by at least one subscriber, which is typically</span></span><br><span class="line">      <span class="comment">// another computed property or a component's render function.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.dep.subs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// In lazy mode, we don't want to perform computations until necessary,</span></span><br><span class="line">        <span class="comment">// so we simply mark the watcher as dirty. The actual computation is</span></span><br><span class="line">        <span class="comment">// performed just-in-time in this.evaluate() when the computed property</span></span><br><span class="line">        <span class="comment">// is accessed.</span></span><br><span class="line">        <span class="keyword">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// In activated mode, we want to proactively perform the computation</span></span><br><span class="line">        <span class="comment">// but only notify our subscribers when the value has indeed changed.</span></span><br><span class="line">        <span class="keyword">this</span>.getAndInvoke(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.dep.notify();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否有sync 修饰符</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 执行queueWatcher</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的创建时渲染<code>watcher</code>所以会走 <code>queueWatcher(this)</code>的逻辑。这里主要做了：</p>
<ul>
<li>判断是否为<code>computed Watcher</code>、是否有<code>sync</code> 修饰符，如果都不满足执行<code>queueWatcher</code></li>
</ul>
<h3 id="3-执行-queueWatcher-this"><a href="#3-执行-queueWatcher-this" class="headerlink" title="3. 执行 queueWatcher(this)"></a>3. <strong>执行 queueWatcher(this)</strong></h3><p><code>queueWatcher</code> 的定义在 <code>src/core/observer/scheduler.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watcher队列</span></span><br><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = [];</span><br><span class="line"><span class="comment">// has 对象保证同一个 Watcher 只添加一次</span></span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id;</span><br><span class="line">  <span class="comment">// 保证watcher只添加一次</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//  保证对 nextTick(flushSchedulerQueue) 的调用逻辑只有一次</span></span><br><span class="line">      nextTick(flushSchedulerQueue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要做了如下：</p>
<ul>
<li>把<code>watcher</code>添加到一个队列里</li>
<li>在 <code>nextTick</code> 后执行 <code>flushSchedulerQueue</code></li>
</ul>
<blockquote>
<p>has 对象保证同一个 <code>Watcher</code> 只添加一次<br>判断是否为渲染<code>watcher</code><br>通过 <code>waiting</code> 保证对 <code>nextTick(flushSchedulerQueue)</code> 的调用逻辑只有一次</p>
</blockquote>
<h3 id="4-执行-nextTick-flushSchedulerQueue"><a href="#4-执行-nextTick-flushSchedulerQueue" class="headerlink" title="4. 执行 nextTick(flushSchedulerQueue)"></a>4. <strong>执行 nextTick(flushSchedulerQueue)</strong></h3><p><a href="/blog/vue/vue-next-tick.html">nextTick</a>这里单独记录，主要看<code>flushSchedulerQueue</code>，代码在<code>src/core/observer/scheduler.js</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  flushing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> watcher, id;</span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  <span class="comment">// 对watcher 根据id进行排序，保证从父到子执行</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="comment">// 遍历queue队列 并且执行 watcher的 run方法</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = <span class="literal">null</span>;</span><br><span class="line">    watcher.run();</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="comment">// 防止死循环</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> +</span><br><span class="line">            (watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span>),</span><br><span class="line">          watcher.vm</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice();</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice();</span><br><span class="line">  <span class="comment">// 把这些控制流程状态的一些变量恢复到初始值，把 watcher 队列清空。</span></span><br><span class="line">  resetSchedulerState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">  callActivatedHooks(activatedQueue);</span><br><span class="line">  callUpdatedHooks(updatedQueue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">'flush'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要做了以下几步：</p>
<ul>
<li>队列排序<ol>
<li>.组件的更新<strong>由父到子</strong>；因为父组件的创建过程是先于子的，所以 <code>watcher</code> 的创建也是<strong>先父后子</strong>，执行顺序也应该保持<strong>先父后子</strong>。</li>
<li>用户的<strong>自定义</strong> <code>watcher</code> 要<strong>优先</strong>于<strong>渲染</strong> <code>watcher</code> 执行；因为用户自定义 <code>watcher</code> 是在渲染 <code>watcher</code> 之前创建的。</li>
<li>如果一个组件在父组件的 <code>watcher</code> 执行期间被销毁，那么它对应的 <code>watcher</code> 执行都可以被跳过，所以父组件的 <code>watcher</code> 应该先执行。</li>
</ol>
</li>
<li>队列遍历<br>在对 <code>queue</code> 排序后，接着就是要对它做遍历，拿到对应的 <code>watcher</code>，执行 <code>watcher.run()</code>。这里需要注意一个细节，在遍历的时候每次都会对 <code>queue.length</code> 求值，因为在 <code>watcher.run()</code> 的时候，很可能用户会再次添加新的 <code>watcher</code>，这样会再次执行到 <code>queueWatcher</code>，如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id;</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这时候 <code>flushing</code> 为 <code>true</code>，就会执行到 <code>else</code> 的逻辑，然后就会从后往前找，找到第一个待插入 <code>watcher</code> 的 <code>id</code> 比当前队列中 <code>watcher</code> 的 <code>id</code> 大的位置。把 <code>watcher</code> 按照 <code>id</code>的插入到队列中，因此 <code>queue</code> 的长度发生了变化。</p>
<ul>
<li>状态恢复<br>这个过程就是执行 <code>resetSchedulerState</code> 函数，它的定义在 <code>src/core/observer/scheduler.js</code> 中:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = [];</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset the scheduler's state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  index = queue.length = activatedChildren.length = <span class="number">0</span>;</span><br><span class="line">  has = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    circular = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑非常简单，就是把这些控制流程状态的一些<strong>变量恢复到初始值</strong>，把 <code>watcher</code> 队列清空。</p>
<h3 id="5-执行-watcher-run"><a href="#5-执行-watcher-run" class="headerlink" title="5. 执行 watcher.run()"></a>5. <strong>执行 watcher.run()</strong></h3><p>接下来我们继续分析 <code>watcher.run()</code> 的逻辑，它的定义在 <code>src/core/observer/watcher.js</code> 中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getAndInvoke(<span class="keyword">this</span>.cb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAndInvoke(cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行watcher.run()函数</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get();</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.call(<span class="keyword">this</span>.vm, value, oldValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行watcher 的回调函数</span></span><br><span class="line">        cb.call(<span class="keyword">this</span>.vm, value, oldValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做了如下：</p>
<ul>
<li>执行 <code>this.getAndInvoke</code> 方法，并传入 <code>watcher</code> 的回调函数</li>
<li><code>getAndInvoke</code> 函数先 通过 <code>this.get()</code> 得到它当前的值，然后做判断，如果满足<strong>新旧值不等</strong>、<strong>新值是对象类型</strong>、<strong>deep</strong> 模式任何一个条件，则执行 <code>watcher</code> 的回调<blockquote>
<p>注意回调函数执行的时候会把<strong>第一个</strong>和<strong>第二个</strong>参数传入新值 <code>value</code> 和旧值 <code>oldValue</code>，这就是当我们添加自定义 <code>watcher</code> 的时候能在<strong>回调函数</strong>的参数中拿到<strong>新旧值</strong>的原因。</p>
</blockquote>
</li>
</ul>
<h3 id="6-执行-watcher-get"><a href="#6-执行-watcher-get" class="headerlink" title="6. 执行 watcher.get()"></a>6. <strong>执行 watcher.get()</strong></h3><p>那么对于渲染 watcher 而言，它在执行 this.get() 方法求值的时候，会执行 getter 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以这就是当我们去修改组件相关的<strong>响应式数据</strong>的时候，会触发组件<strong>重新渲染</strong>的原因，接着就会重新执行 <code>patch</code> 的过程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>派发更新的过程是：修改数据触发观测数据的<code>setter</code>方法=&gt;调用<code>dep.notify()</code> 通知所有的订阅者=&gt;循环调用<strong>订阅者</strong><code>watcher.update()</code>=&gt;循环调用<code>watcher.update()</code>=&gt;调用<code>queueWatcher()</code>,添加<code>watcher</code>到一个<code>queue</code>队列中=&gt;调用<code>nextTick(flushSchedulerQueue)</code> ，对<code>queue</code>根据<code>id</code>排序 =&gt; 调用<code>watcher.run()</code>方法 =&gt; 触发<code>watcher.get()</code>方法=&gt;调用<code>vm._update(vm._render(), hydrating)</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/setters.html#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">派发更新</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 Vue中的依赖收集</title>
    <url>/blog/vue/principle/vue-dep.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过响应式对象知道，每一个 <code>data</code> 的属相都会实例化一个 <code>Dep</code>，并且它的 <code>get</code> 函数中通过 <code>dep.depend</code>做依赖收集。通过下面这张图比较直观的看出依赖收集的过程：<br><img src="../../../images/vue/vue-Dep-1-1.jpg" alt="vue-Dep"><br><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 <code>getter</code> 和 <code>setter</code>，它的定义在 <code>src/core/observer/index.js</code>，在 <code>getter</code> 中会做依赖收集，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*在闭包中定义一个dep对象*/</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了getter/setter则将其缓存，新定义的getter/setter中会将其执行</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子对象递归调用 observe</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有getter方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">// 如果当前有watcher在读取当前值</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 那么进行依赖收集，dep.addSub</span></span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">/*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span></span><br><span class="line">          childOb.dep.depend();</span><br><span class="line">          <span class="comment">// 这里是对数组进行劫持</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">/*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span></span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="comment">// 先getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="comment">// 如果跟原来值一样则不管</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有setter方法则执行</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新的值需要重新进行observe，保证数据响应式*/</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      <span class="comment">/*dep对象通知所有的观察者*/</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getter</code> 的时候进行依赖的收集，注意这里，只有在 <code>Dep.target</code> 中有值的时候才会进行依赖收集，这个 <code>Dep.target</code> 是在<code>Watcher</code>实例的 <code>get</code> 方法调用的时候 <code>pushTarget</code> 会把当前取值的<code>watcher</code>推入 <code>Dep.target</code>，原先的<code>watcher</code>压栈到 <code>targetStack</code> 栈中，当前取值的<code>watcher</code>取值结束后出栈并把原先的<code>watcher</code>值赋给 <code>Dep.target</code>，<code>cleanupDeps</code> 最后把新的 <code>newDeps</code> 里已经没有的<code>watcher</code>清空，以防止视图上已经不需要的无用<code>watcher</code>触发<code>setter</code> 的时候首先 <code>getter</code>，并且比对旧值没有变化则<code>return</code>，如果发生变更，则<code>dep</code>通知所有<code>subs</code>中存放的依赖本数据的<code>Watcher</code>实例 <code>update</code> 进行更新，这里 <code>update</code> 中会 <code>queueWatcher( )</code> 异步推送到调度者观察者队列 <code>queue</code> 中，在<code>nextTick</code>时 <code>flushSchedulerQueue</code>( ) 把队列中的<code>watcher</code>取出来执行 <code>watcher.run</code> 且执行相关钩子函数。</p>
<h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p><code>Dep</code> 是整个 <code>getter</code> 依赖收集的核心，它的定义在 <code>src/core/observer/dep.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> type Watcher <span class="keyword">from</span> <span class="string">'./watcher'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span>;</span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++;</span><br><span class="line">    <span class="comment">// 订阅者的列表</span></span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*添加一个观察者对象*/</span></span><br><span class="line">  addSub(sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*移除一个观察者对象*/</span></span><br><span class="line">  removeSub(sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//给watcher收集依赖</span></span><br><span class="line">  <span class="comment">//这里是一个关键步骤，Dep.target是一个watcher实例</span></span><br><span class="line">  <span class="comment">//先将这个Dep实例添加到Watcher的依赖中</span></span><br><span class="line">  <span class="comment">//然后在watcher中调用dep.addSub将watcher添加到dep的订阅者中</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*通知所有订阅者*/</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="comment">//遍历这个依赖的所有订阅者watcher</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">//update()的最终目的就是要执行Watcher的getter</span></span><br><span class="line">      <span class="comment">//执行这个Watcher的getter的时候就会触发这个Watcher的依赖们的get()</span></span><br><span class="line">      <span class="comment">//然后重新收集依赖</span></span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// this is globally unique because there could be only one</span></span><br><span class="line"><span class="comment">// watcher being evaluated at any time.</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// watcher栈</span></span><br><span class="line"><span class="keyword">const</span> targetStack = [];</span><br><span class="line"><span class="comment">/* 将watcher观察者实例设置给Dep.target，用以依赖收集。同时将该实例存入target栈中 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">_target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target);</span><br><span class="line">  <span class="comment">// 改变目标指向</span></span><br><span class="line">  Dep.target = _target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将观察者实例从target栈中取出并设置给Dep.target */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = targetStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Dep.target</code> 是一个静态属性，这是一个全局唯一 <code>Watcher</code>，这是一个非常巧妙的设计，因为在同一时间只能有一个全局的 <code>Watcher</code> 被计算。</li>
<li>定义一些 <code>Dep</code> 上得方法，添加依赖方法、移除方法、调用 <code>watcher.update()</code>的方法</li>
<li>实例属性 <code>subs</code> 保存 <code>watcher</code> 订阅者的列表</li>
</ul>
<h2 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h2><p><code>src/core/observer/watcher.js</code> 代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn) <span class="comment">//  // 在get方法中执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// 调用get方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">/*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="comment">/*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        <span class="comment">/*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span></span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*将观察者实例从target栈中取出并设置给Dep.target*/</span></span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addDep (dep: Dep) &#123;...  &#125;<span class="comment">/* 添加一个依赖关系到Deps集合中 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;  ...&#125;<span class="comment">/* 清理newDeps里没有的无用watcher依赖 */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Watcher</code>是一个观察者对象。依赖收集以后<code>Watcher</code>对象会被保存在<code>Dep</code>的<code>subs</code>中，数据变动的时候<code>Dep</code>会通知<code>Watcher</code>实例，然后由<code>Watcher</code>实例回调<code>cb</code>进行视图的更新。</p>
<h2 id="触发流程"><a href="#触发流程" class="headerlink" title="触发流程"></a>触发流程</h2><p>大致流程如下：</p>
<ol>
<li>Vue 的 <code>mount</code> 过程是通过 <code>mountComponent</code> 函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化渲染 watcher</span></span><br><span class="line"><span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent,</span><br><span class="line">  noop,</span><br><span class="line">  &#123;</span><br><span class="line">    before() &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>初始化渲染<code>watcher</code>的时候，会执行<code>watcher</code>的构造函数，再会执行<code>this.get()</code>方法，进入 get 函数，首先执行：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pushTarget(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// pushTarget方法实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果存在Dep.target 就把 Dep.target 压入targetStack 栈，为了后面恢复使用</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target);</span><br><span class="line">  <span class="comment">// 把 Dep.target 赋值为当前的渲染 watcher</span></span><br><span class="line">  Dep.target = _target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上就是把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code> 并压栈（为了恢复用）。</p>
<ol start="3">
<li>接着会执行：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this.getter 对应就是 updateComponent 函数</span></span><br><span class="line">value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line"><span class="comment">// 所以就会执行</span></span><br><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 其实执行的就是个</span></span><br><span class="line">  vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// vm._update(vm._render(), hydrating)</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>执行<code>vm._render()</code> 这个方法会生成 渲染 <code>VNode</code>，并且在这个过程中会对 <code>vm</code> 上的<strong>数据访问</strong>，这个时候就触发了数据对象的 <code>getter</code>。每个对象属性的<code>getter</code>都持有一个<code>Dep</code>实例，在触发 getter 的时候就会调用<code>dep.depend()</code>方法，也就会执行<code>Dep.target.addDep(this)</code>。</p>
</li>
<li><p>执行<code>Dep.target.addDep(this)</code> 这个时候<code>Dep.target</code>已经被赋值为渲染<code>watcher</code>，因为在上面执行了<code>pushTarget(this)</code>。执行 addDep 方法代码如下：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line"><span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">        <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">            dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，那么就会执行 <code>this.subs.push(sub)</code>，也就是说把当前的 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>subs</code> 中，这个目的是为后续数据变化时候能通知到哪些 <code>subs</code> 做准备。</p>
<ol start="6">
<li>接着执行 <code>watcher</code> 中 <code>get()</code>方法中的 <code>traverse(value)</code>、<code>popTarget()</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">  <span class="comment">/*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span></span><br><span class="line">  traverse(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将观察者实例从target栈中取出并设置给Dep.target*/</span></span><br><span class="line">popTarget();</span><br><span class="line"></span><br><span class="line"><span class="comment">// popTarget 实现 在Dep类中</span></span><br><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line"><span class="comment">/* 将观察者实例从target栈中取出并设置给Dep.target */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = targetStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>traverse(value)</code>递归触发子项的<code>getter</code>完成依赖收集。再执行<code>popTarget()</code>实际上就是把 <code>Dep.target</code> 恢复成上一个状态，因为当前 <code>vm</code> 的数据依赖收集已经完成，那么对应的渲染<code>Dep.target</code> 也需要改变。</p>
<ol start="7">
<li>接着执行<code>watcher</code> 中 <code>get()</code>方法中的 <code>this.cleanupDeps()</code>, <code>cleanupDeps()</code>函数定义在<code>watcher</code>类中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cleanupDeps 函数</span></span><br><span class="line">cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">            dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先理解四个变量<code>depIds</code>、<code>newDepIds</code> 、<code>deps</code>、 <code>newDeps</code>。</p>
<ul>
<li><code>depIds Hash</code>表，用于快速查找（<code>dep</code>）</li>
<li><code>newDepIds Hash</code>表，用于快速查找（<code>newDeps</code>）</li>
<li><code>deps</code> 缓存上一轮执行观察者函数用到的<code>dep</code>实例</li>
<li><code>newDeps</code> 存储本轮执行观察者函数用到的<code>dep</code>实例</li>
</ul>
<p>在执行 <code>cleanupDeps</code> 函数的时候，会首先遍历 <code>deps</code>，移除对 <code>dep.subs</code> 数组中 <code>Wathcer</code> 的订阅，然后把 <code>newDepIds</code> 和 <code>depIds</code> 交换，<code>newDeps</code> 和 <code>deps</code> 交换，并把 <code>newDepIds</code> 和 <code>newDeps</code> 清空。</p>
<p><strong>为什么清除 Deps</strong><br>因此<code>Vue</code>设计了在每次<strong>添加完新的</strong>订阅，会<strong>移除掉旧的</strong>订阅，这样就保证了在我们刚才的场景中，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除了，所以不会有任何浪费。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在 <code>Vue</code> 中初始化渲染时，视图上绑定的数据就会实例化一个 <code>Watcher</code>，<strong>依赖收集</strong>就是是通过属性的 <code>getter</code> 函数完成的，<code>Observer</code> 、<code>Watcher</code> 、<code>Dep</code> 都与依赖收集相关。其中 <code>Observer</code> 与 <code>Dep</code> 是<strong>一对一</strong>的关系， <code>Dep</code> 与 <code>Watcher</code> 是<strong>多对多</strong>的关系，Dep 则是 <code>Observer</code> 和 <code>Watcher</code> 之间的<strong>纽带</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/getters.html#dep" target="_blank" rel="noopener">依赖收集</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a><br><a href="https://zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/#more" target="_blank" rel="noopener">Vue2.0 源码阅读：响应式原理</a><br><a href="https://juejin.im/post/5b40c8495188251af3632dfa" target="_blank" rel="noopener">Vue 源码阅读-依赖收集原理</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Vue系列 Vue中的响应式对象</title>
    <url>/blog/vue/principle/vue-definedProperty.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vue 的<strong>核心响应式</strong>是通过<code>Obeject.defineProperty</code>方法来实现的。 而<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a>是 ES5 中无法<strong>shim</strong>的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p><strong>Object.defineProperty</strong><br>Object.defineProperty 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor);</span><br></pre></td></tr></table></figure>
<p>obj 是要在其上定义属性的对象；prop 是要定义或修改的属性的名称；descriptor 是将被定义或修改的属性描述符。</p>
<p>由于 Vue 会在初始化实例时对属性执行 <strong>getter/setter</strong> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的。<br>响应式原理大致流程如下图所示：<br><img src="../../../images/vue/vue-defineProperty-1-1.png" alt="vue-defineProperty"><br>Vue 数据响应式变化主要涉及<strong>Observer、Watcher、Dep</strong>这三个主要的类。这里主要是响应式对象，后面分别会记录它的依赖收集、派发更新、三种 Watcher。<br>把普通对象改造为<strong>响应式对象</strong>在 Vue 中的大致流程为：</p>
<ul>
<li><code>initState</code>(初始化数据)</li>
<li><code>Observer(</code>劫持数据)</li>
<li><code>defineReactive</code>(依赖收集、派发更新)</li>
</ul>
<p>在 getter 对象中又会依赖收集，在 setter 中派发更新。</p>
<blockquote>
<p>Vue-version(2.6.10)</p>
</blockquote>
<h2 id="initState-初始化数据"><a href="#initState-初始化数据" class="headerlink" title="initState(初始化数据)"></a>initState(初始化数据)</h2><p>那么我们从一个简单的 Vue 实例的代码来分析 Vue 的响应式原理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'App'</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        msg: <span class="string">'initState'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<strong>Vue</strong>的初始化阶段，<code>_init</code> 方法执行的时候，会执行 <code>initState(vm)</code> 方法，它的定义在 <strong>src/core/instance/state.js</strong>中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options;</span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props);</span><br><span class="line">  <span class="comment">// 初始化methods</span></span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods);</span><br><span class="line">  <span class="comment">// 初始化data</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*该组件没有data的时候绑定一个空对象*/</span></span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化computed</span></span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed);</span><br><span class="line">  <span class="comment">// 初始化手写的watcher</span></span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initState</code> 方法主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>wathcer</code> 等属性做了初始化操作。主要看<code>initData</code>。</p>
<h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><p><code>initData</code>方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data;</span><br><span class="line">  <span class="comment">// 判断data是否为function 如果是直接执行，如果不是获取data</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span> ? getData(data, vm) : data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">          <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props;</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods;</span><br><span class="line">  <span class="keyword">let</span> i = keys.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">            <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      <span class="comment">// 通过 proxy 把每一个值 vm._data.xxx 都代理到 vm.xxx 上</span></span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 另一个是调用 observe 方法观测整个 data 的变化，把 data 也变成响应式</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 initData 过程中主要做了两件事：</p>
<ul>
<li>通过 <code>proxy</code> 把每一个值 vm._data.[key] 都代理到 vm.[key] 上；</li>
<li>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式（可观察），可以通过 <code>vm._data.[key]</code> 访问到定义 <code>data</code> 返回函数中对应的属性。</li>
</ul>
<h2 id="Observer-劫持数据"><a href="#Observer-劫持数据" class="headerlink" title="Observer(劫持数据)"></a>Observer(劫持数据)</h2><p>observe 的功能就是用来监测数据的变化，它的定义在 src/core/observer/index.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为VNode 如果是直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 如果存在__ob__ 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果不存在 实例化一个 Observer</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回 Observer实例</span></span><br><span class="line">  <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>observe</code> 方法的作用就是给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例。接下来我们来看一下 <code>Observer</code> 的作用。</p>
<p><strong>Observer</strong><br>observe 的功能就是用来监测数据的变化，它的定义在 src/core/observer/index.js 中：<br><code>Observer</code> 是一个类，它的作用是给对象的属性添加 <code>getter</code> 和 <code>setter</code>，用于<strong>依赖收集</strong>和<strong>派发更新</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 给对象的属性添加 getter 和 setter， 用于依赖收集、派发更新</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="comment">// 实例化 Dep 对象</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把自身实例添加到数据对象 value 的 __ob__ 属性上</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 判断value 是否为Array 做不同的调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//  遍历对象属性 并且每个属性添加 getter、setter</span></span><br><span class="line">  walk(obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray(items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法做的事情如下：</p>
<ul>
<li>实例化 <code>Dep</code> 对象</li>
<li>通过执行 <code>def</code> 函数把自身实例添加到数据对象 <code>value</code>的 <strong>ob</strong> 属性上</li>
<li>对 <code>value</code> 做判断，对于数组会调用 <code>observeArray</code> 方法，否则对纯对象调用 <code>walk</code>方法。</li>
</ul>
<blockquote>
<p>可以看到 <code>observeArray</code> 是遍历数组再次调用 <code>observe</code> 方法，而 <code>walk</code> 方法是遍历对象的 <code>key</code> 调用 <code>defineReactive</code> 方法，那么我们来看一下这个方法是做什么的。</p>
</blockquote>
<p><strong>def 方法</strong><br>def 的定义在 src/core/util/lang.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">obj: Object, key: string, val: any, enumerable?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自身实例添加到数据对象 value 的 __ob__ 属性上</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发中输出 <code>data</code> 上对象类型的数据，会发现该对象多了一个 <code>__ob__</code> 的属性。</p>
<h2 id="defineReactive-依赖收集、派发更新"><a href="#defineReactive-依赖收集、派发更新" class="headerlink" title="defineReactive(依赖收集、派发更新)"></a>defineReactive(依赖收集、派发更新)</h2><p><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 <code>getter</code> 和 <code>setter</code>，它的定义在 <code>src/core/observer/index.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*在闭包中定义一个dep对象*/</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了getter/setter则将其缓存，新定义的getter/setter中会将其执行</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子对象递归调用 observe</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有getter方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">// 如果当前有watcher在读取当前值</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 那么进行依赖收集，dep.addSub</span></span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">/*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span></span><br><span class="line">          childOb.dep.depend();</span><br><span class="line">          <span class="comment">// 这里是对数组进行劫持</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">/*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span></span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="comment">// 先getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="comment">// 如果跟原来值一样则不管</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果原本对象拥有setter方法则执行</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新的值需要重新进行observe，保证数据响应式*/</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      <span class="comment">/*dep对象通知所有的订阅者*/</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暂时不对<strong>依赖收集</strong>、<strong>派发更新</strong>、<strong>Dep</strong>讲述只记录<strong>数据劫持</strong>的过程记录，后面文章记录具体的<strong>依赖收集</strong>、<strong>派发更新</strong>、<strong>watcher</strong>、<strong>Dep</strong>、记录。<br><code>defineReactive</code> 函数最开始初始化 <code>Dep</code> 对象的实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，这样就保证了无论 <code>obj</code> 的结构多复杂，它的所有<strong>子属性</strong>也能变成响应式的对象，这样我们访问或修改 <code>obj</code> 中一个嵌套较深的属性，也能触发 <code>getter</code> 和 <code>setter</code>。最后利用 <code>Object.defineProperty</code> 去给 obj 的属性 key 添加 getter 和 setter。</p>
<h2 id="数据观测的特殊处理"><a href="#数据观测的特殊处理" class="headerlink" title="数据观测的特殊处理"></a>数据观测的特殊处理</h2><p>访问对象属性，其取值与赋值操作，都能被<code>Object.defineProperty()</code>成功拦截，但是<code>Object.defineProperty()</code>在处理数组上却存在一些问题。通过调用数据原型上的<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、 <code>reverse</code>等方法不能被观测到<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Cross-browser_concerns" target="_blank" rel="noopener">兼容性问题</a>。</p>
<p>在<strong>Vue</strong>中是对数组的原型上述方法做了一些增强操作。即<strong>保留</strong>原来操作的基础上，植入<strong>Vue</strong>的特定的操作代码。<br>代码在 src/core/observer/index.js 中定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// observeArray方法进行一遍观测处理</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    <span class="comment">/*dep对象通知所有的订阅者*/</span></span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>保留数组原来的操作 <code>push</code>、<code>unshift</code>、<code>splice</code>这些方法，会带来<strong>新的数据元素</strong>，而新带来的数据元素，我们是有办法得知的（即为传入的参数）那么新增的元素也是需要被配置为<strong>可观测数据</strong>的，这样子后续数据的变更才能得以处理。所以要对新增的元素调用<code>observer</code>实例上的<code>observeArray</code>方法进行一遍观测处理由于数组变更了，那么就需要通知观察者，所以通过<code>ob.dep.notify()</code>对数组的观察者<code>watchers</code>进行通知。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从初始化<code>initData</code>，到核心就是利用 <code>Object.defineProperty</code> 给数据添加了 <code>getter</code> 和 <code>setter</code>，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：<code>getter</code> 做的事情是<strong>依赖收集</strong>，<code>setter</code> 做的事情是<strong>派发更新</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/vuejs/vue/tree/dev/src" target="_blank" rel="noopener">Vue 源码</a><br><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/reactive-object.html#object-defineproperty" target="_blank" rel="noopener">响应式对象</a><br><a href="https://mp.weixin.qq.com/s/-pZnJWxrRlz-rOGhdshe7g" target="_blank" rel="noopener">Vue 响应式原理其实很好懂</a><br><a href="http://jungahuang.com/2018/02/07/About-responsive-of-Vue/" target="_blank" rel="noopener">深入理解 Vue 响应式原理</a><br><a href="https://juejin.im/entry/5bdab35d6fb9a0224e0e5794" target="_blank" rel="noopener">深入解析 Vue 依赖收集原理</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中render源码解析</title>
    <url>/blog/vue/principle/vue-update-render-createelement-patch.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码中new vue都做了什么</title>
    <url>/blog/vue/principle/vue-new-vue.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack实现热加载的两种方式 和 实现原理</title>
    <url>/blog/webpack/principle/webpack-hot-twofuntions.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebPack</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>编写一个自己的webpack插件plugin</title>
    <url>/blog/webpack/plugin/webpack-self-plugins.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>插件是 webpack 的支柱功能。<code>webpack</code> 自身也是构建于，你在 <code>webpack</code> 配置中用到的相同的插件系统之上！插件目的在于解决 <code>loader</code> 无法实现的其他事。<br>要想写好插件就要知道<code>Webpack</code>中的两个比较核心的概念<code>compiler</code>、<code>compilation</code>、<code>tapable</code>。在<a href="/blog/webpack/webpack-process.html">webpack 编译流程</a>已经都要记录。<br><code>Webpack</code> 通过 <code>Plugin</code> 机制让其更加灵活，以适应各种应用场景。 在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。</p>
<h2 id="实现一个-plugin"><a href="#实现一个-plugin" class="headerlink" title="实现一个 plugin"></a>实现一个 plugin</h2><p>一个 webpack plugin 基本包含以下几步：</p>
<ol>
<li>一个 <code>JavaScript 函数或者类</code></li>
<li>在<code>函数原型（prototype）</code>中定义一个注入<code>compiler</code>对象的<code>apply</code>方法。</li>
<li><code>apply</code>函数中通过<code>compiler</code>插入指定的事件钩子，在钩子回调中拿到<code>compilation</code>对象</li>
<li>使用<code>compilation</code>操纵修改<code>webapack</code>内部实例数据。</li>
<li>异步插件，数据处理完后使用<code>callback</code>回调</li>
</ol>
<p>最后会实现一个简单的<code>clean-webpack-plugin</code>。</p>
<h3 id="一个简单的插件"><a href="#一个简单的插件" class="headerlink" title="一个简单的插件"></a>一个简单的插件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackCleanupPlugin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'WebpackCleanupPlugin'</span>, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 应用函数</span></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(compiler);</span><br><span class="line">    <span class="comment">// 绑定钩子事件</span></span><br><span class="line">    compiler.plugin(<span class="string">'done'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(compilation);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何使用在 webpack.config.js 中引入并且使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="comment">// 引入自己的插件</span></span><br><span class="line"><span class="keyword">const</span> WebpackCleanupPlugin = <span class="built_in">require</span>(<span class="string">'./WebpackCleanupPlugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    chunk1: <span class="string">'./src/chunk1.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 使用自己的插件</span></span><br><span class="line">    <span class="keyword">new</span> WebpackCleanupPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>自己写的插件如下执行：</p>
<ul>
<li><code>webpack</code> 启动后，在读取配置的过程中会先执行 <code>new WebpackCleanupPlugin()</code> 初始化一个 WebpackCleanupPlugin 获得其实例。</li>
<li>在初始化 <code>compiler</code> 对象后，再调用 <code>WebpackCleanupPlugin.apply(compiler)</code> 给插件实例传入 <code>compiler</code> 对象。</li>
<li>插件实例在获取到 <code>compiler</code> 对象后，就可以通过 <code>compiler.plugin</code>(事件名称, 回调函数) 监听到 <code>Webpack</code> 广播出来的事件。</li>
<li>并且可以通过 <code>compiler</code> 对象去操作 <code>webpack</code>。</li>
</ul>
<p><strong>Compiler、Compilation</strong></p>
<ul>
<li><strong>Compiler 对象包含了 Webpack 环境所有的的配置信息</strong>，包含 <code>options</code>，<code>hook</code>，<code>loaders</code>，<code>plugins</code> 这些信息，这个对象在 <code>Webpack</code> 启动时候被实例化，它是<strong>全局唯一</strong>的，可以简单地把它理解为 <code>Webpack</code> 实例；<code>Compiler</code>中包含的东西如下所示：</li>
</ul>
<p><img src="../../../images/webpack/webpack-3-5.png" style="height: 300px"></p>
<ul>
<li><strong>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等</strong>。当 <code>Webpack</code> 以开发模式运行时，每当检测到一个文件变化，一次新的 <code>Compilation</code> 将被创建。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。通过 <code>Compilation</code> 也能读取到 <code>Compiler</code> 对象。</li>
</ul>
<p><code>Compilation</code>中包含的东西如下所示：</p>
<p><img src="../../../images/webpack/webpack-3-6.png" style="height: 300px"></p>
<blockquote>
<p><strong>Compiler 和 Compilation 的区别在于</strong>：<code>Compiler</code> 代表了整个 <code>Webpack</code> 从启动到关闭的生命周期，而 <code>Compilation</code> 只是代表了一次新的编译。</p>
</blockquote>
<p><a href="https://www.webpackjs.com/api/compiler-hooks/" target="_blank" rel="noopener">Compiler 钩子</a>和<a href="https://www.webpackjs.com/api/compilation-hooks/" target="_blank" rel="noopener">compilation 钩子</a></p>
<h2 id="一个简单的清除文件插件"><a href="#一个简单的清除文件插件" class="headerlink" title="一个简单的清除文件插件"></a>一个简单的清除文件插件</h2><hr>
<p>每次打包如果文件有修改会生成新的文件，文件的<strong>hash</strong>也会跟着变化，那么这个改变了的文件，他以前的文件就是无效的了，要把以前的文件清除掉，我们使用比较多的就是<code>clean-webpack-plugin</code>，这里自己实现一个简单的文件清除。如果不知道<a href="/blog/webpack/webpack-chunkhas-hash-contenthash.html">hash、contenthash、chunkhash</a>的区别可以看这一片文章。</p>
<p>大致分为以下几步：</p>
<ul>
<li>获取<code>output</code>路径，也就是出口路径一般为<code>dist</code></li>
<li>绑定钩子事件 <code>compiler.plugin(&#39;done&#39;, (stats) =&gt; {})</code></li>
<li>编译文件，与原来文件对比，删除未匹配文件 （同时可以 options 设置要忽略的文件）</li>
</ul>
<p>代码实现如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> recursiveReadSync = <span class="built_in">require</span>(<span class="string">'recursive-readdir-sync'</span>);</span><br><span class="line"><span class="keyword">const</span> minimatch = <span class="built_in">require</span>(<span class="string">'minimatch'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> union = <span class="built_in">require</span>(<span class="string">'lodash.union'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles</span>(<span class="params">fromPath, exclude = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = recursiveReadSync(fromPath).filter(<span class="function">(<span class="params">file</span>) =&gt;</span></span><br><span class="line">    exclude.every(</span><br><span class="line">      (excluded) =&gt;</span><br><span class="line">        !minimatch(path.relative(fromPath, file), path.join(excluded), &#123;</span><br><span class="line">          dot: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// console.log(files);</span></span><br><span class="line">  <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackCleanupPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 配置文件</span></span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 获取output路径</span></span><br><span class="line">    <span class="keyword">const</span> outputPath = compiler.options.output.path;</span><br><span class="line">    <span class="comment">// 绑定钩子事件</span></span><br><span class="line">    compiler.plugin(<span class="string">'done'</span>, (stats) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        compiler.outputFileSystem.constructor.name !== <span class="string">'NodeOutputFileSystem'</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取编译完成 文件名</span></span><br><span class="line">      <span class="keyword">const</span> assets = stats.toJson().assets.map(<span class="function">(<span class="params">asset</span>) =&gt;</span> asset.name);</span><br><span class="line">      <span class="built_in">console</span>.log(assets);</span><br><span class="line">      <span class="comment">// 多数组合并并且去重</span></span><br><span class="line">      <span class="keyword">const</span> exclude = union(<span class="keyword">this</span>.options.exclude, assets);</span><br><span class="line">      <span class="built_in">console</span>.log(exclude);</span><br><span class="line">      <span class="comment">// console.log('outputPath', outputPath);</span></span><br><span class="line">      <span class="comment">// 获取未匹配文件</span></span><br><span class="line">      <span class="keyword">const</span> files = getFiles(outputPath, exclude);</span><br><span class="line">      <span class="comment">// const files = [];</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'files'</span>, files);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.options.preview) &#123;</span><br><span class="line">        <span class="comment">// console.log('%s file(s) would be deleted:', files.length);</span></span><br><span class="line">        <span class="comment">// 输出文件</span></span><br><span class="line">        files.forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'    %s'</span>, file));</span><br><span class="line">        <span class="comment">// console.log();</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 删除未匹配文件</span></span><br><span class="line">        files.forEach(fs.unlinkSync);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.options.quiet) &#123;</span><br><span class="line">        <span class="comment">// console.log('\nWebpackCleanupPlugin: %s file(s) deleted.', files.length);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = WebpackCleanupPlugin;</span><br></pre></td></tr></table></figure>
<p>上面的这个插件实现了一个清除编译文件的效果。在这里就不做实验了，如果有兴趣可以自己把代码 copy 到本地，运行一下看一下结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上面大致知道怎么写一个简单的清除文件的<code>webpack</code>的<strong>插件</strong>，其实还可以做更多的事情如下：</p>
<ul>
<li>读取输出资源、代码块、模块及其依赖（在 <code>emit</code> 事件发生）</li>
<li>监听文件变化 <code>watch-run</code></li>
<li>修改输出资源 <code>compilation.assets</code></li>
</ul>
<p>具体实现可以看一下一下<a href="http://webpack.wuhaolin.cn/5%E5%8E%9F%E7%90%86/5-4%E7%BC%96%E5%86%99Plugin.html" target="_blank" rel="noopener">webpack 深入浅出</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5beb8875e51d455e5c4dd83f" target="_blank" rel="noopener">干货！撸一个 webpack 插件(内含 tapable 详解+webpack 流程)</a><br><a href="https://zoumiaojiang.com/article/what-is-real-webpack-plugin/" target="_blank" rel="noopener">看清楚真正的 Webpack 插件</a></p>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack编译流程</title>
    <url>/blog/webpack/principle/webpack-process.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>现在前端开发基本上都会用到<code>react</code>、<code>vue</code>，用到了前端<code>mvc</code>、<code>mvvm</code>框架，基本上都会涉及到打包发布，打包常用的工具就是<code>webpack</code>、<code>gulp</code>等等。经常使用自然也要了解一些他大致的流程也会方便使用。<br>首先要理解 webpack 中比较核心的概念：</p>
<ul>
<li><strong>Entry</strong>: 指定 webpack 开始构建的入口模块，从该模块开始构建并计算出直接或间接依赖的模块或者库。</li>
<li><strong>Output</strong>：告诉 webpack 如何命名输出的文件以及输出的目录</li>
<li><strong>Module</strong>: 模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li>
<li><strong>Chunk</strong>：<code>coding split</code>的产物，我们可以对一些代码打包成一个单独的<code>chunk</code>，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。在<code>webpack3</code>及以前我们都利用<code>CommonsChunkPlugin</code>将一些公共代码分割成一个<code>chunk</code>，实现单独加载。在<code>webpack4</code> 中<code>CommonsChunkPlugin</code>被废弃，使用<code>SplitChunksPlugin</code></li>
<li><strong>Loader</strong>：模块转换器，用于把模块原内容按照需求转换成新内容。</li>
<li><strong>Plugin</strong>：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。</li>
</ul>
<p>webpack 执行流程和事件流如下图所示：</p>
<p><img src="../../../images/webpack/webpack2.svg" style="height: 400px"><br>webpack编译过程中一个比较重要的概念<strong>compiler</strong>、<strong>compilation</strong>，如下：</p>
<ul>
<li><strong>Compiler 对象</strong>：负责文件监听和启动编译。<code>Compiler</code> 实例中包含了完整的 <code>webpack</code> 配置，全局只有一个 <code>Compiler</code> 实例。</li>
<li><strong>Compilation 对象</strong>：当 <code>webpack</code> 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。<!-- ![webpack-flow](../../../images/webpack/webpack-3-1.png) -->
</li>
</ul>
<h2 id="webpack-流程"><a href="#webpack-流程" class="headerlink" title="webpack 流程"></a>webpack 流程</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束依次执行以下流程：</p>
<ol>
<li><code>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</code>。</li>
<li><code>编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。</code></li>
<li><code>输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。</code></li>
</ol>
<p>如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：<br><img src="../../../images/webpack/webpack-3-2.png" alt="webpack-flow"><br>下面具体介绍一下 <code>webpack</code>的三个大阶段具体的小步。</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>初始化阶段大致分为：</p>
<ul>
<li>合并<code>shell</code>和<strong>配置文件文件</strong>的参数并且<strong>实例化 Complier 对象</strong>。</li>
<li><strong>加载插件</strong></li>
<li><strong>处理入口</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始化参数</td>
<td style="text-align:center">从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 new Plugin()。</td>
</tr>
<tr>
<td style="text-align:center">实例化 Compiler</td>
<td style="text-align:center">用上一步得到的参数初始化 <code>Compiler</code> 实例，<code>Compiler</code> 负责文件监听和启动编译。<code>Compiler</code> 实例中包含了完整的 <code>Webpack</code> 配置，全局只有一个 <code>Compiler</code> 实例。</td>
</tr>
<tr>
<td style="text-align:center">加载插件</td>
<td style="text-align:center">依次调用插件的 <code>apply</code> 方法，让插件可以监听后续的所有事件节点。同时给插件传入 <code>compiler</code> 实例的引用，以方便插件通过 <code>compiler</code> 调用 <code>Webpack</code> 提供的 <code>API</code>。</td>
</tr>
<tr>
<td style="text-align:center">environment</td>
<td style="text-align:center">开始应用 <code>Node.js</code> 风格的文件系统到 <code>compiler</code> 对象，以方便后续的文件寻找和读取。</td>
</tr>
<tr>
<td style="text-align:center">entry-option</td>
<td style="text-align:center">读取配置的 <code>Entrys</code>，为每个 <code>Entry</code> 实例化一个对应的 <code>EntryPlugin</code>，为后面该 <code>Entry</code> 的递归解析工作做准备。</td>
</tr>
<tr>
<td style="text-align:center">after-plugins</td>
<td style="text-align:center">调用完所有内置的和配置的插件的 <code>apply</code> 方法。</td>
</tr>
<tr>
<td style="text-align:center">after-resolvers</td>
<td style="text-align:center">根据配置初始化完 <code>resolver</code>，<code>resolver</code> 负责在文件系统中寻找指定路径的文件。</td>
</tr>
</tbody>
</table>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">before-run</td>
<td style="text-align:center">清除缓存</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">启动一次新的编译。</td>
</tr>
<tr>
<td style="text-align:center">watch-run</td>
<td style="text-align:center">和 <code>run</code> 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致<strong>重新启动</strong>一次新的编译。</td>
</tr>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">该事件是为了告诉插件一次<strong>新的</strong>编译将要启动，同时会给插件带上 <code>compiler</code> 对象。</td>
</tr>
<tr>
<td style="text-align:center">compilation</td>
<td style="text-align:center">当 <code>Webpack</code> 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。</td>
</tr>
<tr>
<td style="text-align:center">make</td>
<td style="text-align:center">一个新的 <code>Compilation</code> 创建完毕，即将从 <code>Entry</code> 开始读取文件，根据文件类型和配置的 <code>Loader</code> 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。</td>
</tr>
<tr>
<td style="text-align:center">after-compile</td>
<td style="text-align:center">一次 <code>Compilation</code> 执行完成。这里会根据编译结果 合并出我们最终生成的文件名和文件内容。</td>
</tr>
<tr>
<td style="text-align:center">invalid</td>
<td style="text-align:center">当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 <code>Webpack</code> 退出。</td>
</tr>
</tbody>
</table>
<p>这里主要最重要的就是<code>compilation</code>过程，<code>compilation</code> 实际上就是调用相应的 <code>loader</code> 处理文件生成 <code>chunks</code>并对这些 <code>chunks</code> 做优化的过程。几个关键的事件（<code>Compilation</code>对象<code>this.hooks</code>中）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">build-module</td>
<td style="text-align:center">使用对应的 <code>Loader</code> 去转换一个模块。</td>
</tr>
<tr>
<td style="text-align:center">normal-module-loader</td>
<td style="text-align:center">在用 <code>Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack</code> 后面对代码的分析。</td>
</tr>
<tr>
<td style="text-align:center">program</td>
<td style="text-align:center">从配置的入口模块开始，分析其 <code>AST</code>，当遇到 <code>require</code> 等导入其它模块语句时，便将其加入到<strong>依赖的模块列表</strong>，同时对新找出的<strong>依赖模块递归分析</strong>，最终搞清所有模块的<strong>依赖关系</strong>。</td>
</tr>
<tr>
<td style="text-align:center">seal</td>
<td style="text-align:center">所有模块及其<strong>依赖</strong>的模块都通过 <code>Loader</code> 转换完成后，根据依赖关系开始生成 <code>Chunk</code>。</td>
</tr>
</tbody>
</table>
<h3 id="输出阶段"><a href="#输出阶段" class="headerlink" title="输出阶段"></a>输出阶段</h3><table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">should-emit</td>
<td style="text-align:center">所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td>
</tr>
<tr>
<td style="text-align:center">emit</td>
<td style="text-align:center">确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td>
</tr>
<tr>
<td style="text-align:center">after-emit</td>
<td style="text-align:center">文件输出完毕。</td>
</tr>
<tr>
<td style="text-align:center">done</td>
<td style="text-align:center">成功完成一次完成的编译和输出流程。</td>
</tr>
<tr>
<td style="text-align:center">failed</td>
<td style="text-align:center">如果在编译和输出流程中遇到异常导致 <code>Webpack</code> 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</td>
</tr>
</tbody>
</table>
<h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><hr>
<p><code>Webpack</code>可以将其理解是一种基于<strong>事件流</strong>的编程范例，一个插件<strong>合集</strong>。而将这些插件控制在<code>webapck</code>事件流上的运行的就是<code>webpack</code>自己写的基础类<code>Tapable</code>。<code>Webpack</code> 的<strong>事件流</strong>机制应用了<strong>观察者模式</strong>，和 <code>Node.js</code> 中的 <code>EventEmitter</code>非常相似。<br><strong>Tapable 有四组成员函数</strong>：</p>
<ul>
<li><strong>plugin(name:string, handler:function)</strong>：允许将一个自定义插件注册到 <code>Tapable</code> 实例 的事件中。它的行为和 <code>EventEmitter</code> 的 <code>on()</code> 方法相似，用来注册一个<strong>处理函数/监听器</strong>，来在<strong>信号/事件</strong>发生时做一些事情。</li>
<li><strong>apply(…pluginInstances</strong>: <code>(AnyPlugin|function)[])：AnyPlugin</code> 应该是一个拥有 <code>apply</code> 方法的类（也可以是一个对象，但是不常见），或者只是一个包含注册代码的函数。这个方法只调用插件的定义，从而将真正的事件监听器可以注册到 <code>Tapable</code> 实例的注册列表中。</li>
<li><strong>applyPlugins*(name:string, …)</strong>：<code>Tapable</code> 实例可以通过使用这些函数，在指定的 <code>hash</code> 下应用所有的插件。这一组方法的行为和 <code>EventEmitter</code> 的 <code>emit()</code> 方法相似，使用多种策略细致地控制事件的触发。</li>
<li><strong>mixin(pt: Object)</strong>：一个简单地方法，使用混入而不是继承的方式扩展 <code>Tapable</code> 的原型。</li>
</ul>
<p>上面核心的对象 <code>Compiler</code>、<code>Compilation</code>等都是继承于<code>Tabable</code>类。可以直接在 <code>Compiler</code> 和 <code>Compilation</code> 对象上广播和监听器，方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广播出事件</span></span><br><span class="line"><span class="comment"> * event-name 为事件名称，注意不要和现有的事件重名</span></span><br><span class="line"><span class="comment"> * params 为附带的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">compiler.apply(<span class="string">'event-name'</span>, params);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。</span></span><br><span class="line"><span class="comment"> * 同时函数中的 params 参数为广播事件时附带的参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">compiler.plugin(<span class="string">'event-name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  doSomeThing();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同理，<code>compilation.apply</code> 和 <code>compilation.plugin</code> 使用方法和上面一致。</p>
<p><a href="https://github.com/webpack/tapable" target="_blank" rel="noopener">tapable</a>库暴露了很多 Hook（钩子）类，为插件提供挂载的钩子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  SyncHook,</span><br><span class="line">  SyncBailHook,</span><br><span class="line">  SyncWaterfallHook,</span><br><span class="line">  SyncLoopHook,</span><br><span class="line">  AsyncParallelHook,</span><br><span class="line">  AsyncParallelBailHook,</span><br><span class="line">  AsyncSeriesHook,</span><br><span class="line">  AsyncSeriesBailHook,</span><br><span class="line">  AsyncSeriesWaterfallHook</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br></pre></td></tr></table></figure>
<p>如下图所示 tapable 上的钩子：<br><img src="../../../images/webpack/webpack-3-4.png" alt="webpack-flow"></p>
<p>tabable 的提供了两类绑定钩子的方式：</p>
<ul>
<li><strong>AsyncHook(异步钩子)</strong>： <strong>绑定</strong>可以通过<code>tapAsync</code> 或 <code>tapPromise</code>（以及 <code>tap</code>），<strong>执行</strong>通过 <code>callAsync</code>、<code>promise</code>；</li>
<li><strong>syncHook(钩子)</strong>： <strong>绑定</strong>可以通过<code>tap</code>，<strong>执行</strong>通过 <code>call</code>；</li>
</ul>
<p>具体的用法请看<a href="https://github.com/webpack/tapable#tapable" target="_blank" rel="noopener">Tapable</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ol>
<li><strong>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</strong>；</li>
<li><strong>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</strong>；</li>
<li><strong>确定入口：根据配置中的 entry 找出所有的入口文件</strong>；</li>
<li><strong>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</strong>；</li>
<li><strong>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</strong>；</li>
<li><strong>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</strong>；</li>
<li><strong>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</strong>。</li>
</ol>
<p>同时我们也了解了 webpack 中比较核心的几个概念<code>compiler</code>、<code>compilation</code>、<code>tapable</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MjUxNjA4Mw==&amp;mid=2247484465&amp;idx=1&amp;sn=13e809bbad1aded06089f9f90f54280f&amp;chksm=ec017daddb76f4bb998db48b7b60ef61ce69f18a389b5d371f5abdec6af6e1e3819eaceb2194&amp;mpshare=1&amp;scene=1&amp;srcid=0724xrEwBfryLPOe61Ki51Oi&amp;sharer_sharetime=1563935222192&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b&amp;key=4a20f31792598319b088ea3b82b6daf06773b3d7ffa59c0bb5d9ec0f7388ff5fed13910f4aacc420e4591fbc921b91b777b3904d18b7e88b4a3fee042e9d5df41b3746bc994433035daadda223075e98&amp;ascene=1&amp;uin=MTY4MzM5MzY2Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=4jkq%2FusyjX7RQyhKNRuqJ4ao5EVltuqP5Geyej5jy%2BYFRnQMWIS09yOSU9wir8dM" target="_blank" rel="noopener">webpack 学习笔记（原理，实现 loader 和插件）</a><br><a href="https://github.com/lihongxun945/diving-into-webpack/blob/master/6-process-pipe-line.md" target="_blank" rel="noopener">webpack 源码分析六：webpack 处理流程分析</a><br><a href="https://juejin.im/post/5be9297351882516f5786404" target="_blank" rel="noopener">Webpack 原理与实践（一）：打包流程</a></p>
]]></content>
      <categories>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的依赖分析、依赖加载</title>
    <url>/blog/webpack/principle/webpack-rely-load.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebPack</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-router</title>
    <url>/blog/vue/router/vue-router.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>VueRouter</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中的events源码分析</title>
    <url>/blog/vue/principle/vue-click-eventbus.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型（六）多种数据类型判断方法</title>
    <url>/blog/javascript/type/javascript-bool-type.html</url>
    <content><![CDATA[<p><strong><em>日极则仄，月满则亏。物极则反，命曰环流。——《管子·白心》</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 ECMAScript 规范中，共定义了 7 种数据类型，分为基本数据类型和引用类型两大类，如下所示：</p>
<blockquote>
<p>基本类型： <strong>Null、Undefined、Symbol（ES6）、Number、Boolean、String</strong><br>引用类型： <strong>Obeject、Array、Date</strong>等等</p>
</blockquote>
<ul>
<li><p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在<code>栈</code>中，即按值访问。</p>
</li>
<li><p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在<code>堆(heap)</code>中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。</p>
</li>
</ul>
<h3 id="原始值-primitive-values"><a href="#原始值-primitive-values" class="headerlink" title="原始值( primitive values )"></a>原始值( primitive values )</h3><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。</p>
<p>注: <strong>想看 Java​Script 数据类型和数据结构 可以在： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">mdn</a>中查看</strong></p>
<p>有四种方法可以判断 Java​Script 中的类型如：</p>
<ul>
<li><strong>typeof 运算符</strong></li>
<li><strong>instanceof 运算符</strong></li>
<li><strong>constructor(原型对象的构造函数)</strong></li>
<li><strong>toString(内置[[Class]]属性)、Array.isArray()</strong><br>下面就分别来讲一下他们能判断什么类型，判断不了什么类型，因为什么还有一些注意事项。</li>
</ul>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><h3 id="typeof-语法"><a href="#typeof-语法" class="headerlink" title="typeof 语法"></a>typeof 语法</h3><p>typeof 运算符后跟操作数：</p>
<blockquote>
<p>typeof operand<br>or<br>typeof (operand)</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>operand 是一个表达式，表示对象或<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive" target="_blank" rel="noopener">原始值</a>，其类型将被返回。</p>
<p>下面表格总结了 typeof 可能返回的值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">“undefined”</td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center">“object”</td>
</tr>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">“boolean”</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">“number”</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">“string”</td>
</tr>
<tr>
<td style="text-align:center">Symbol （ECMAScript 6 新增）</td>
<td style="text-align:center">“symbol”</td>
</tr>
<tr>
<td style="text-align:center">宿主对象（由 JS 环境提供）</td>
<td style="text-align:center">Implementation-dependent</td>
</tr>
<tr>
<td style="text-align:center">函数对象（[[Call]] 在 ECMA-262 条款中实现了）</td>
<td style="text-align:center">“function”</td>
</tr>
<tr>
<td style="text-align:center">任何其他对象</td>
<td style="text-align:center">“object”</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'foo'</span>); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>在这其中要注意的是：</p>
<ul>
<li>其中<code>null</code>返回了<code>object</code>是因为<code>JavaScript</code>语言设计遗留的问题。</li>
<li>对于引用类型，除 <code>function</code> 以外，一律返回 <code>object</code> 类型</li>
<li>对于 <code>function</code> 返回 <code>function</code></li>
</ul>
<h3 id="typeof-null"><a href="#typeof-null" class="headerlink" title="typeof null"></a>typeof null</h3><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。由于 <code>null</code> 代表的是机器代码的<strong>空指针</strong>，一个对象类型的引用，值是零（大多数平台下值为 0x00）。<strong>自然前三位也是 0</strong>，所以执行<code>typeof</code>时会返回<code>&quot;object&quot;</code>.</p>
<p>这个 bug 是第一版 Javascript 留下来的。在这个版本，数值是以<strong>32 字节存储的</strong>，由标志位（1~3 个字节）和数值组成。标志位存储的是低位的数据。这里有五种标志位：</p>
<ul>
<li><strong>000：对象，数据是对象的应用。</strong></li>
<li><strong>1：整型，数据是 31 位带符号整数。</strong></li>
<li><strong>010：双精度类型，数据是双精度数字。</strong></li>
<li><strong>100：字符串，数据是字符串。</strong></li>
<li><strong>110：布尔类型，数据是布尔值。</strong><br>最低位有一位，那么标志位只有一个 1 字节长度；或者是零位，标志位有 3 个字节长度，多出两个了字节，一共多出四种类型。</li>
</ul>
<p><strong>原文地址<a href="http://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">英文</a></strong><br><strong>翻译地址<a href="http://www.cnblogs.com/xiaoheimiaoer/p/4572558.html" target="_blank" rel="noopener">中文</a></strong></p>
<blockquote>
<p><strong>判断 null 类型也很简单，就用 null === null 来判断</strong> &gt; <strong>看 typeof 所有的类型细节请看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">mdn-typeof</a></strong></p>
</blockquote>
<h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p><strong>instanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象的原型链中的任何位置</strong>.<br>原始值使用<code>instanceof</code>都会返回<code>false</code>，如果使用<code>new</code> 声明 是可以检测出来。对于是使用<code>new</code>声明的类型，它还可以检测出多层继承关系。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p>object instanceof constructor</p>
</blockquote>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>object 要检测的对象<br>constructor 某个构造函数</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 object 的原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'123'</span>;</span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C();</span><br><span class="line">c1 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(c1) === C.prototype</span></span><br><span class="line"></span><br><span class="line">C.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">c1 <span class="keyword">instanceof</span> C; <span class="comment">// false, C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c2 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(c2) === C.prototype</span></span><br><span class="line"></span><br><span class="line">c2.__proto__ = &#123;&#125;; <span class="comment">// 借助于非标准的__proto__伪属性</span></span><br><span class="line"></span><br><span class="line">c2 <span class="keyword">instanceof</span> C; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>注：<strong>需要注意的是，如果表达式 obj instanceof Foo 返回 true，则并不意味着该表达式会永远返回 true，因为 Foo.prototype 属性的值有可能会改变，改变之后的值很有可能不存在于 obj 的原型链上，这时原表达式的值就会成为 false。另外一种情况下，原表达式的值也会改变，就是改变对象 obj 的原型链的情况，虽然在目前的 ES 规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的</strong>proto<strong>伪属性，是可以实现的。比如执行 obj.</strong>proto<strong> = {}之后，obj instanceof Foo 就会返回 false 了。</strong></p>
<h3 id="、Array、Object-三者之间的关系"><a href="#、Array、Object-三者之间的关系" class="headerlink" title="[]、Array、Object 三者之间的关系"></a>[]、Array、Object 三者之间的关系</h3><p>从 <code>instanceof</code> 能够判断出 <code>[ ].__proto__</code> 指向 <code>Array.prototype</code>，而 <code>Array.prototype.__proto__</code> 又指向了<code>Object.prototype</code>，最终 <code>Object.prototype.__proto__</code> 指向了<code>null</code>，标志着原型链的结束。因此，<code>[]、Array、Object</code> 就在内部形成了一条原型链：</p>
<p><img src="./javascript-bool-type/javascript1.png" alt="[]-Array-Object" width="60%" style="margin: 0 auto;"></p>
<p>从原型链可以看出，<code>[]</code> 的 <code>__proto__</code> 直接指向<code>Array.prototype</code>，间接指向 <code>Object.prototype</code>，所以按照 <code>instanceof</code> 的判断规则，<code>[]</code> 就是<code>Object</code>的实例。依次类推，类似的 <code>new Date()、new Person()</code> 也会形成一条对应的原型链 。<strong>因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p>
<h3 id="instanceof-和多全局对象-多个-frame-或多个-window-之间的交互"><a href="#instanceof-和多全局对象-多个-frame-或多个-window-之间的交互" class="headerlink" title="instanceof 和多全局对象(多个 frame 或多个 window 之间的交互)"></a>instanceof 和多全局对象(多个 frame 或多个 window 之间的交互)</h3><p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 <code>[] instanceof window.frames[0].Array</code> 会返回<code>false</code>，因为 <code>Array.prototype !== window.frames[0].Array.prototype</code>，并且数组从前者继承。</p>
<p>实际上你可以通过使用 <code>Array.isArray(myObj)</code> 或者<code>Object.prototype.toString.call(myObj) === &quot;[object Array]&quot;</code>来安全的检测传过来的对象是否是一个数组。</p>
<h3 id="实现一个简单的-instanceof"><a href="#实现一个简单的-instanceof" class="headerlink" title="实现一个简单的 instanceof"></a>实现一个简单的 instanceof</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// L instanceof R</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line">  <span class="keyword">var</span> O = R.prototype; <span class="comment">// 取的R的显式原型</span></span><br><span class="line">  L = L.__proto__; <span class="comment">// 取的L的隐式原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 已找到顶层</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (O === L) &#123;</span><br><span class="line">      <span class="comment">// 当 O严格等于L时，返回true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L = L.__proto__; <span class="comment">// 继续向上一层原型链查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">instance_of([], <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line">instance_of([], <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="constructor-原型对象的构造函数"><a href="#constructor-原型对象的构造函数" class="headerlink" title="constructor(原型对象的构造函数)"></a>constructor(原型对象的构造函数)</h2><p>当一个函数 F 被定义时，JS 引擎会为 F 添加 <code>prototype</code> 原型，然后再在 <code>prototype</code>上添加一个 <code>constructor</code> 属性，并让其指向 F 的引用。如下所示：</p>
<p><img src="./javascript-bool-type/javascript2.png" alt="constructor" style="margin: 0 auto;"></p>
<p>当执行 <code>var f = new F()</code> 时，F 被当成了构造函数，f 是 F 的实例对象，此时 F 原型上的 <code>constructor</code> 传递到了 f 上，因此 <code>f.constructor === F</code>.</p>
<p>可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p>
<p>实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span>.constructor === <span class="built_in">String</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>; <span class="comment">// true;</span></span><br><span class="line"><span class="keyword">new</span> Data().constructor === <span class="built_in">Date</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>nul</code>l 和 <code>undefined</code> 是无效的对象，因此是不会有 <code>constructor</code> 存在的，这两种类型的数据需要通过其他方式来判断</li>
<li>函数的 <code>constructor</code> 是不稳定的，这个主要体现在自定义对象上，当开发者重写 <code>prototype</code> 后，原有的 <code>constructor</code> 引用会丢失，constructor 会默认为 Object</li>
</ul>
<p>总结： <strong>手动设置或更新构造函数可能会导致不同且有时令人困惑的后果。为了防止它，只需在每个特定情况下定义构造函数的角色。在大多数情况下，不使用构造函数，并且不需要重新分配构造函数。</strong></p>
<h2 id="toString-内置-Class-属性"><a href="#toString-内置-Class-属性" class="headerlink" title="toString(内置[[Class]]属性)"></a>toString(内置[[Class]]属性)</h2><hr>
<p>原型上的<code>toString()</code> 方法返回一个表示该对象的字符串。<br>调用该方法，默认返回当前对象的 <code>[[Class]]</code> 。这是一个内部属性，其格式为 <code>[object Xxx]</code> ，其中 Xxx 就是对象的类型。<br>对于 Object 对象，直接调用 <code>toString()</code> 就能返回 <code>[object Object]</code> 。而对于其他对象，则需要通过 <code>call / apply</code> 来调用才能返回正确的类型信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>); <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()); <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>); <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>); <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure>
<p>注：<strong>但是它不能检测非原生构造函数的构造函数名。</strong></p>
<blockquote>
<p><code>jquery</code>中的<code>$.type</code>原理就是通过<code>Object.prototype.toString.call()</code>;<br><code>Array.isArray</code>其实也是通过<code>[[Class]]</code>来判定当前是否维数组.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>以上就是已知的 4 中检测类型的方法，那个方法都不识最完美的，就看你要检测的是那个对应的类型，就用对应的检测方法。</strong></p>
<p>我们可以通过四种方式获取数据类型：</p>
<ul>
<li><code>typeof 运算符，用来区分对象和原始值</code></li>
<li><code>instanceof 运算符，用来分类对象</code></li>
<li><code>constructor，用来创建实例对象的 Object 构造函数的引用</code></li>
<li><code>[[Class]]是一个内部属性字符串，用来给对象分类</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/onepixel/p/5126046.html" target="_blank" rel="noopener">判断 JS 数据类型的四种方法</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">MDN 中的 constructor</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener">MDN 中的 toString</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">MDN 中的 typeof</a><br><a href="https://segmentfault.com/a/1190000015264821" target="_blank" rel="noopener">js 判断数据类型</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>vue渲染父子组件中生命周期执行顺序</title>
    <url>/blog/vue/lifecircle/vue-list-two.html</url>
    <content><![CDATA[<h2 id="vue-生命周期"><a href="#vue-生命周期" class="headerlink" title="vue 生命周期"></a>vue 生命周期</h2><p>在另一片博客中我已经有详细讲过<a href="/blog/vue/lifecircle/vue-list-one.html">vue 生命周期</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"setParentMessage"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">"parentMsgOne"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">"parentMsgTwo"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> mixins = &#123;</span></span><br><span class="line"><span class="javascript">        props: [<span class="string">'msg'</span>],</span></span><br><span class="line"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>from child: &#123;&#123;childMsg&#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">        data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            childMsg: <span class="keyword">this</span>.msg</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---beforeCreate'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        created() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---created'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---beforeMount'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---mounted'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---beforeUpdate'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---updated'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---beforeDestroy'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.childMsg + <span class="string">'---destroyed'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      Vue.component(<span class="string">'child'</span>, &#123;</span></span><br><span class="line">        mixins: [mixins]</span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            parentMsgOne: <span class="string">'childrenOne'</span>,</span></span><br><span class="line"><span class="javascript">            parentMsgTwo: <span class="string">'childrenTwo'</span>,</span></span><br><span class="line"><span class="javascript">            message: <span class="string">'parent'</span></span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          setParentMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.message = <span class="string">'parent--message--更新'</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="string">'parent---beforeCreate'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        created() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="string">'parent---created'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="string">'parent---beforeMount'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="string">'parent---mounted'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="string">'parent---beforeUpdate'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="string">'parent---updated'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="string">'parent---beforeDestroy'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="string">'parent---destroyed'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码执行结果如下：</p>
<p><img src="../../../images/vue/vue-hook4.png" alt="vue-hook" width="100%" style="margin: 0 auto;"></p>
<h3 id="beforeCreate-到-mounted"><a href="#beforeCreate-到-mounted" class="headerlink" title="beforeCreate 到 mounted"></a>beforeCreate 到 mounted</h3><ol>
<li>先创建父组件<br><code>beforeCreate</code><br><code>created</code><br><code>beforeMount</code></li>
<li>按顺序创建子组件<br><code>beforeCreate</code><br><code>created</code><br><code>beforeMount</code></li>
<li>先挂载子组件<br><code>mounted</code></li>
<li>在挂载父组件<br><code>mounted</code></li>
</ol>
<p>总结：<code>从创建到挂载，是从外到内，再由内到外</code></p>
<h3 id="beforeUpdate-到-updated"><a href="#beforeUpdate-到-updated" class="headerlink" title="beforeUpdate 到 updated"></a>beforeUpdate 到 updated</h3><blockquote>
<p>注： <code>只有在标签上绑定了 data 时，data 发生改变，才会触发 updated 钩子函数。如果只是在控制台改变 data，而没有反馈到视图上，则无法触发。</code></p>
</blockquote>
<ol>
<li>父组件点击事件更新 <code>data</code> 中的数据</li>
</ol>
<p><img src="../../../images/vue/vue-hook5.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>他不会重新渲染子组件</p>
<blockquote>
<p>注：<code>react 中如果父组件状态更新，子组件也会跟着更新。稍后的文章会讲怎么解决这种问题。</code></p>
</blockquote>
<ol start="2">
<li>子组件点击事件更新 <code>data</code> 中的数据</li>
</ol>
<p><img src="../../../images/vue/vue-hook6.png" alt="vue-hook" width="50%" style="margin: 0 auto;"><br>这个他也不会重新选然父组件</p>
<blockquote>
<p>注： <code>如果是 mixins 的话当 data 中的数据改变时，不会触发子组件中的 updated 函数。触发的顺序仍然是 mixins 先于组件</code></p>
</blockquote>
<blockquote>
<p>总结：<code>父子组件 update 互相不影响</code></p>
</blockquote>
<h3 id="beforeDestroy-到-destroy"><a href="#beforeDestroy-到-destroy" class="headerlink" title="beforeDestroy 到 destroy"></a>beforeDestroy 到 destroy</h3><p>在浏览器中执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.$destroy();</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/vue/vue-hook7.png" alt="vue-hook" width="50%" style="margin: 0 auto;"></p>
<ol>
<li>父组件先<code>beforeDestroy</code></li>
<li>子组件<code>beforeDestroy</code></li>
<li>子组件<code>destroyed</code></li>
<li>父组件<code>destroyed</code></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体来说<strong>vue 父子组件</strong>生命周期执行顺序为<code>从外到内，再从内到外</code>,<br><code>**总结：生命周期遵从“从外到内，再从内到外，mixins 先于组件”的原则。**</code></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Lifecircle</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期详解。</title>
    <url>/blog/vue/lifecircle/vue-list-one.html</url>
    <content><![CDATA[<h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><hr>
<p><a href="/blog/vue/vue-list-two.html">vue 父子组件渲染生命周期执行循序</a></p>
<h3 id="Vue-声明周期表格"><a href="#Vue-声明周期表格" class="headerlink" title="Vue 声明周期表格"></a>Vue 声明周期表格</h3><p>一说到 Vue 的生命周期，大家都能说上来一点.我自己会随着自己对 Vue 的深入了解，不断的完善自己对 Vue 的整体认识。<br>本文 Vue 的版本 <code>Vue 2.x</code> 官方生命周期图解：</p>
<!-- ![vue-hook]( 200x800) -->
<p><img src="../../../images/vue/vue-hook.png" alt="vue-hook" width="60%" style="margin: 0 auto;"></p>
<table>
<thead>
<tr>
<th style="text-align:center">生命周期钩子</th>
<th style="text-align:center">详细</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">beforeCreate</td>
<td style="text-align:center">在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</td>
</tr>
<tr>
<td style="text-align:center">created</td>
<td style="text-align:center">在实例创建完成后被立即调用。在这一步,实例已经完成以下配置：数据观测（data observer），属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没有开始，<code>\$el</code>属性目前不可见。</td>
</tr>
<tr>
<td style="text-align:center">beforeMount</td>
<td style="text-align:center">在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td style="text-align:center">mounted</td>
<td style="text-align:center"><code>el</code>被新创建的<code>vm.$el</code>替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 <br> 注意 mounted <strong>不会</strong> 承诺所有的子组件也一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.\$nextTick 替换掉 mounted。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td style="text-align:center">beforeUpdate</td>
<td style="text-align:center">数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现在的 DOM，比如手动移除已添加的事件监听器。<strong>该钩子在服务器渲染期间不被调用，因为只有初次渲染会在服务器端运行</strong></td>
</tr>
<tr>
<td style="text-align:center">updated</td>
<td style="text-align:center">由于数据更改导致的虚拟 dom 重新渲染和打补丁，在这之后会调用该钩子。<br> 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然后在大多数情况下，你应该避免在此期间更改状态。如果要相应的状态改变，通常最好使用 <a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener"><code>计算属性</code></a>或<a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener"><code>watcher</code></a>取而代之。 <br> 注意 <code>updated</code> 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.\$nextTick 替换掉 <code>updated</code>。</td>
</tr>
<tr>
<td style="text-align:center">beforeDestory</td>
<td style="text-align:center">实例销毁之前调用。在这一步，实例仍然完全可用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td style="text-align:center">destoryed</td>
<td style="text-align:center">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 <strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
</tbody>
</table>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"setMessage"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">          message: <span class="string">'Vue的生命周期'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          setMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.message = <span class="string">'updateMessage'</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.group(<span class="string">'------beforeCreate创建前状态------'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message); <span class="comment">// undefined</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        created() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.group(<span class="string">'------created创建完毕状态------'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data); <span class="comment">// Object ** 已经初始化</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message); <span class="comment">// Vue的生命周期 ** 已经初始化</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 当不存在el的时候只会执行到前面两个生命周期</span></span></span><br><span class="line">        beforeMount() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.group(<span class="string">'------beforeMount挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el); <span class="comment">// 已经初始化</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data); <span class="comment">// 已经初始化</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message); <span class="comment">// 已经初始化</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.group(<span class="string">'------mounted挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el); <span class="comment">// 已经初始化</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data); <span class="comment">// 已经初始化</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message); <span class="comment">// 已经初始化</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.group(<span class="string">'------beforeUpdate挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.group(<span class="string">'------updated挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.group(<span class="string">'------beforeDestroy挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.group(<span class="string">'------destroyed挂载前状态------'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'%c%s'</span>, <span class="string">'color:red'</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>1、beforeMount 生命周期之前</strong></p>
<p><img src="../../../images/vue/vue-hook1.png" alt="vue-hook" width="60%" style="margin: 0 auto;"><br>在这个调用<code>beforeMount</code>判断vm.$options是否存在<code>el</code>，如果没有的话则会<code>停止编译</code>，也就意味着<code>停止了生命周期</code>，直到在改vue实例上调用<code>vm.$mount(el)</code>。</p>
<p>vue 的实现代码：如果存在<code>el</code>时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原型上的<code>$mount</code>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el, hydrating</span>) </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm, el, hydrating</span>) </span>&#123;</span><br><span class="line">  vm.$el = el;</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们注释掉上面<code>el</code>属性的代码,并且不再后续调用<code>vm.$mount(el)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// el: '#app'</span></span><br></pre></td></tr></table></figure>
<p>如果没有<code>el</code>他只会执行前两个生命周期<code>beforeCreate、created</code>，如果我们在后续调用了<code>vm.\$mount(el)</code>，可以发现代码继续向下执行了</p>
<p>在浏览器上调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>
<p>他就会接着执行下去</p>
<p><strong>2、template 属性、outer html、render 函数三个优先级</strong></p>
<ol>
<li>如果直接调用<code>render</code>函数，那么他的优先级最高。</li>
<li>如果<code>vue</code>实例对象中有<code>template</code>参数选项，则将其作为模板编译成<code>render</code>函数。</li>
<li>如果没有<code>template</code>选项，则将外部<code>HTML</code>作为模板编译。</li>
<li>可以看到<code>template</code>中的模板优先级要高于<code>outer HTML</code>的优先级。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      // 如果render、template都不存在 会显示这个</span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message + '这是在outer HTML中的'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      // 如果三个都存在 最终会显示</span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>this is createElement<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        template: <span class="string">"&lt;h1&gt;&#123;&#123;message +'这是在template中的'&#125;&#125;&lt;/h1&gt;"</span>, <span class="comment">// 如果render不存在 只有 template 会显示这个</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">          message: <span class="string">'Vue的生命周期'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> createElement(<span class="string">'h1'</span>, <span class="string">'this is createElement'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>3、mounted</strong><br>可以看到此时是给<code>vue</code>实例对象添加<code>$el</code>成员，并且替换掉挂在的<code>DOM</code>元素。因为在之前<code>console</code>中打印的结果可以看到<code>beforeMount</code>之前<code>el</code>上还是<code>undefined</code></p>
<p><strong>4、mounted</strong><br>在<code>mounted</code>之前<code>h1</code>中还是通过<code></code>进行占位的，因为此时还有挂在到页面上，还是<code>JavaScript</code>中的虚拟<code>DOM</code>形式存在的。在<code>mounted</code>之后可以看到<code>h1</code>中的内容发生了变化。</p>
<p><strong>5、beforeUpdate 和 updated</strong><br>当<code>vue</code>发现<code>data</code>中的数据发生了改变，会触发对应组件的重新渲染，先后调用<code>beforeUpdate</code>和<code>updated</code>钩子函数。我们点击当前的<code>p</code>标签就会触发<code>data</code>中的<code>message</code>更新</p>
<p><strong>6、beforeDestroy 和 destroyed</strong><br><code>beforeDestroy</code> 钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。<br><code>destroyed</code> 钩子函数在<code>Vue</code> 实例销毁后调用。调用后，<code>Vue</code> 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000011381906?utm_source=tag-newest" target="_blank" rel="noopener">详解 vue 生命周期</a><br><a href="https://juejin.im/post/5c6d48e36fb9a049eb3c84ff" target="_blank" rel="noopener">详解 Vue 生命周期实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Lifecircle</tag>
      </tags>
  </entry>
  <entry>
    <title>css3中flex的所有属性详解</title>
    <url>/blog/css/deep-attribute/css-flex.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<strong>H5</strong>页面或者移动端书写<code>css</code>时，都会推荐你使用<code>flex</code>布局来实现，因为<code>flex</code>在移动端兼容性还是比较好的，最主要的是实现布局比较简单。</p>
<p>但是在真正的实战中很多人在不完全了解<strong>flex</strong>中的属性导致滥用，所以有了这篇文章，加深自己对<strong>flex</strong>的记忆。</p>
<h2 id="什么是-FC"><a href="#什么是-FC" class="headerlink" title="什么是 FC?"></a>什么是 FC?</h2><p><strong>FC 的全称是：Formatting Contexts，是 W3C CSS2.1 规范中的一个概念</strong>。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。<br>常见的<strong>FC</strong>有什么比如<strong>BFC</strong>、<strong>IFC</strong>、<strong>FFC</strong>、<strong>GFC</strong>，在以前的博客里面有记录过<strong>BFC</strong>，这里就不多做赘述只记录<strong>FFC</strong>。</p>
<h3 id="FFC-是什么？"><a href="#FFC-是什么？" class="headerlink" title="FFC 是什么？"></a>FFC 是什么？</h3><p><strong>Flex</strong>遵循的是<strong>FFC</strong>的规则，<strong>FFC</strong>又是什么呢？<br><code>FFC(Flex Formatting Contexts)</code>直译为”自适应格式化上下文”，<code>display</code>值为<code>flex</code>或者<code>inline-flex</code>的元素将会生成自适应容器（<code>flex container</code>）。</p>
<p><strong>布局规则</strong></p>
<ul>
<li>设置为 <code>flex</code> 的容器被渲染为一个块级元素</li>
<li>设置为 <code>inline-flex</code> 的容器则渲染为一个行内元素</li>
<li><strong>弹性容器中的每一个子元素都是一个弹性项目</strong>。弹性项目可以是任意数量的。弹性容器外和弹性项目内的一切元素都不受影响。简单地说，Flexbox 定义了弹性容器内弹性项目该如何布局</li>
</ul>
<p>基本上<strong>FFC</strong>和<a href="/blog/css/docs/css-docs-bfc.html"><strong>BFC</strong></a>是比较类似的这里只记录它们之前的区别，区别如下：</p>
<ul>
<li><strong>FlexBox</strong>不支持<code>::first-line</code>和<code>::first-letter</code>这两种伪元素</li>
<li><code>vertical-align</code>对<code>FlexBox</code>中的子元素是没有效果的</li>
<li><code>float</code>和<code>clear</code>属性对<code>FlexBox</code>中的子元素是没有效果的，对<code>FlexBox</code>是有作用的</li>
<li>多烂布局<code>Cloumn-*</code>在<code>FlexBox</code>中也是无效的</li>
<li><code>FlexBox</code>下的子元素不会继承父级容器的宽</li>
</ul>
<h2 id="Flex-中的概念"><a href="#Flex-中的概念" class="headerlink" title="Flex 中的概念"></a>Flex 中的概念</h2><p>给<code>div</code>元素设置<code>display</code>值为<code>flex</code>或者<code>inline-flex</code>的元素将会生成自适应容器（<code>flex container</code>）。<br><strong>Flex</strong>有很多属性，大致可以分为两类一类作用在<strong>flex 容器上</strong>、一类作用在<strong>flex 子项上</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">作用在 flex 容器上</th>
<th style="text-align:center">作用在 flex 子项上</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flex-direction (设置主轴方向)</td>
<td style="text-align:center">order (在父容器中的排序)</td>
</tr>
<tr>
<td style="text-align:center">flex-wrap (主轴是否换行)</td>
<td style="text-align:center">flex-grow (当有空白区域，是否站空白区域，是否扩展)</td>
</tr>
<tr>
<td style="text-align:center">flex-flow (flex-direction flex-wrap)</td>
<td style="text-align:center">flex-shrink (当空间过小时，是否收缩自身，是否收缩)</td>
</tr>
<tr>
<td style="text-align:center">justify-content (水平方向子项对齐和分布方式)</td>
<td style="text-align:center">flex-basis (在分配剩余空间之前元素的默认大小)</td>
</tr>
<tr>
<td style="text-align:center">align-items (垂直方向子项对齐和分布方式)</td>
<td style="text-align:center">flex (flex-grow flex-shrink flex-basis)</td>
</tr>
<tr>
<td style="text-align:center">align-content (水平方向 flex 子项的对齐和分布方式，于 justify-content 类似且对立)</td>
<td style="text-align:center">align-self (自己本身的垂直对齐方式)</td>
</tr>
</tbody>
</table>
<p><img src="./css-flex/flex-1-1.png" alt="flex-main"></p>
<p>采用 Flex 布局的元素，称为 Flex 容器（flex container）,简称“容器”。它的所有子元素自动成为容器成员，成为 Flex 项目（flex item）,简称“项目”。</p>
<p>容器默认存在两根轴：<strong>水平的主轴（main axis）和垂直的交叉轴（cross axis）</strong>。<br>主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；<br>交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<p>项目默认沿<strong>主轴排列</strong>。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<p>本文上所用到的<code>html</code>结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox-item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox-item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flexbox-item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>css</code>基础结构如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox-item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: cadetblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: coral;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作用在-flex-容器上的-CSS-属性"><a href="#作用在-flex-容器上的-CSS-属性" class="headerlink" title="作用在 flex 容器上的 CSS 属性"></a>作用在 flex 容器上的 CSS 属性</h2><hr>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><code>flex-direction</code>用来控制子项整体布局方向，是从左往右还是从右往左，是从上往下还是从下往上。<br>语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个值</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。<br><img src="./css-flex/flex-1-2.png" alt="flex-main"></li>
<li>row-reverse：主轴为水平方向，起点在右端。<br><img src="./css-flex/flex-1-3.png" alt="flex-main"></li>
<li>column：主轴为垂直方向，起点在上沿。<br><img src="./css-flex/flex-1-4.png" alt="flex-main"></li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code>用来控制子项整体单行显示还是换行显示，如果换行，则下面一行是否反方向显示。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有三个值如下：</p>
<p><strong>nowrap</strong><br>默认值，表示单行显示，不换行。于是很容易出现宽度溢出的场景，其渲染表现比较复杂，需要对 CSS3 宽度有一定了解，可以阅读“理解 CSS3 max/min-content 及 fit-content 等 width 值”这篇文章。具体表现如下（以水平布局举例）：</p>
<ul>
<li>flex 子项最小内容宽度 min-content 之和大于 flex 容器宽度，则内容溢出，表现和 white-space:nowrap 类似。</li>
<li>如果 flex 子项最小内容宽度 min-content 之和小于 flex 容器宽度，则：<ul>
<li>flex 子项默认的 fit-content 宽度之和大于 flex 容器宽度，则 flex 子项宽度收缩，正好填满 flex 容器，内容不溢出。</li>
<li>flex 子项默认的 fit-content 宽度之和小于 flex 容器宽度，则 flex 子项以 fit-content 宽度正常显示，内容不溢出。</li>
</ul>
</li>
</ul>
<p><strong>wrap</strong><br>宽度不足换行显示。<br><img src="./css-flex/flex-1-5.png" alt="flex-main"><br><strong>wrap-reverse</strong><br>宽度不足换行显示，但是是<strong>从下往上开始</strong>，也就是原本换行在<strong>下面</strong>的子项现在跑到<strong>上面</strong>。<br><img src="./css-flex/flex-1-6.png" alt="flex-main"></p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>的缩写，表示<strong>flex 布局</strong>的<strong>flow 流动</strong>特性，语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt; <span class="string">'flex-direction'</span> &gt; || &lt; <span class="string">'flex-wrap'</span> &gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例说明如果设置代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row-reverse wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="./css-flex/flex-1-7.png" alt="flex-main"></p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>属性决定了<strong>水平方向子项的对齐和分布方式</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li><code>flex-start</code>: <strong>默认值。逻辑 CSS 属性值，与文档流方向相关。默认表现为左对齐</strong>。</li>
<li><code>flex-end</code>: <strong>逻辑 CSS 属性值，与文档流方向相关。默认表现为右对齐</strong>。</li>
<li><code>center</code>: <strong>表现为居中对齐</strong>。<br><img src="./css-flex/flex-1-8.png" alt="flex-main"></li>
<li><code>space-between</code>: <strong>表现为两端对齐。between 是中间的意思，意思是多余的空白间距只在元素中间区域分配</strong>。<br><img src="./css-flex/flex-1-9.png" alt="flex-main"></li>
<li><code>space-around</code>: <strong>around 是环绕的意思，意思是每个 flex 子项两侧都环绕互不干扰的等宽的空白间距，最终视觉上边缘两侧的空白只有中间空白宽度一半</strong>。<br><img src="./css-flex/flex-1-10.png" alt="flex-main"></li>
<li><code>space-evenly</code>: <strong>evenly 是匀称、平等的意思。也就是视觉上，每个 flex 子项两侧空白间距完全相等</strong>。<br><img src="./css-flex/flex-1-11.png" alt="flex-main"></li>
</ul>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li>
</ul>
<p><img src="./css-flex/flex-1-12.png" alt="flex-main"></p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><code>align-content</code>可以看成和<code>justify-content</code>是相似且对立的属性，<code>justify-content</code>指明水平方向 flex 子项的对齐和分布方式，而<code>align-content</code>则是指明垂直方向每一行<code>flex</code>元素的<strong>对齐和分布方式</strong>。如果所有<code>flex</code>子项只有一行，则<code>align-content</code>属性是没有任何效果的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: stretch | flex-start | flex-end | center | space-between |</span><br><span class="line">    space-around | space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有 7 个值，每个值是不同作用如下面所示:</p>
<ul>
<li><code>stretch</code>: 默认值。每一行 flex 子元素都等比例拉伸。例如，如果共两行 flex 子元素，则每一行拉伸高度是 50%。</li>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：表现为整体垂直居中对齐。</li>
<li><code>space-between</code>：表现为上下两行两端对齐。剩下每一行元素等分剩余空间。</li>
<li><code>space-around</code>：每一行元素上下都享有独立不重叠的空白空间。</li>
<li><code>space-evenly</code>： 每一行元素都完全上下等分。</li>
</ul>
<p><img src="./css-flex/flex-1-13.png" alt="flex-main"></p>
<h2 id="作用在-flex-子项上的-CSS-属性"><a href="#作用在-flex-子项上的-CSS-属性" class="headerlink" title="作用在 flex 子项上的 CSS 属性"></a>作用在 flex 子项上的 CSS 属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>可以通过设置<strong>order</strong>改变某一个<strong>flex</strong>子项的排序位置。数值越小，排列越靠前，默认为 0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth(1)</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* 整数值，默认值是 0 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth(2)</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flexbox</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth(3)</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="./css-flex/flex-1-14.png" alt="flex-main"></p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code>属性中的<code>grow</code>是扩展的意思，扩展的就是<code>flex</code>子项所占据的宽度，扩展所侵占的空间就是除去元素外的剩余的空白间隙。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-grow</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* 数值，可以是小数，默认值是 0 */</span></span><br></pre></td></tr></table></figure>
<p><code>flex-grow</code>不支持负值，默认值是<code>0</code>，表示不占用剩余的空白间隙扩展自己的宽度。如果<code>flex-grow</code>大于<code>0</code>，则<code>flex</code>容器剩余空间的分配就会发生，具体规则如下：</p>
<ul>
<li><p>所有剩余空间总量是<code>1</code>。</p>
</li>
<li><p>如果只有一个<code>flex</code>子项设置了<code>flex-grow</code>属性值：</p>
<ul>
<li>如果<code>flex-grow</code>值小于<code>1</code>，则扩展的空间就总剩余空间和这个比例的计算值。</li>
<li>如果<code>flex-grow</code>值大于<code>1</code>，则独享所有剩余空间。</li>
</ul>
</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-grow" target="_blank" rel="noopener">张鑫旭大佬：具体可参见下面“grow 案例 1”。</a></p>
<ul>
<li>如果有多个<code>flex</code>子项设置了<code>flex-grow</code>属性值：</li>
<li>如果<code>flex-grow</code>值总和小于<code>1</code>，则每个子项扩展的空间就总剩余空间和当前元素设置的<code>flex-grow</code>比例的计算值。</li>
<li>如果<code>flex-grow</code>值总和大于<code>1</code>，则所有剩余空间被利用，分配比例就是<code>flex-grow</code>属性值的比例。例如所有的<code>flex</code>子项都设置<code>flex-grow:1</code>，则表示剩余空白间隙大家等分，如果设置的<code>flex-grow</code>比例是 1:2:1，则中间的 flex 子项占据一半的空白间隙，剩下的前后两个元素等分。</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-grow" target="_blank" rel="noopener">张鑫旭大佬：具体可参见下面“grow 案例 2”。</a></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><code>shrink</code>是“收缩”的意思，<code>flex-shrink</code>主要处理当<code>flex</code>容器空间不足时候，单个元素的收缩比例。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* 数值，默认值是 1 */</span></span><br></pre></td></tr></table></figure>
<p><code>flex-shrink</code>不支持负值，默认值是<code>1</code>，也就是默认所有的<code>flex</code>子项都会收缩。如果设置为<code>0</code>，则表示不收缩，保持原始的<code>fit-content</code>宽度。</p>
<p><code>flex-shrink</code>的内核跟<code>flex-grow</code>很神似，<code>flex-grow</code>是空间足够时候如何利用空间，<code>flex-shrink</code>则是空间不足时候如何收缩腾出空间。</p>
<p>两者的规则也是类似。已知 flex 子项不换行，且容器空间不足，不足的空间就是“完全收缩的尺寸”：</p>
<ul>
<li>如果只有一个<strong>flex 子项</strong>设置了<code>flex-shrink</code>：<ul>
<li><code>flex-shrink</code>值小于<code>1</code>，则收缩的尺寸不完全，会有一部分内容<strong>溢出 flex 容器</strong>。</li>
<li><code>flex-shrink</code>值大于等于<code>1</code>，则收缩完全，正好<strong>填满 flex 容器</strong>。</li>
</ul>
</li>
<li>如果多个<strong>flex 子项</strong>设置了<code>flex-shrink</code>：<ul>
<li><code>flex-shrink</code>值的总和小于<code>1</code>，则收缩的尺寸不完全，每个元素收缩尺寸占“完全收缩的尺寸”的比例就是设置的<code>flex-shrink</code>的值。</li>
<li><code>flex-shrink</code>值的总和大于<code>1</code>，则收缩完全，每个元素收缩尺寸的比例和<code>flex-shrink</code>值的比例一样。下面案例演示的就是此场景。</li>
</ul>
</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-shrink" target="_blank" rel="noopener">张鑫旭大佬：案例显示代码</a></p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code>定义了<strong>在分配剩余空间之前元素的默认大小</strong>。相当于对浏览器提前告知：浏览器兄，我要占据这么大的空间，提前帮我预留好。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto; /* 默认值是 auto */</span><br></pre></td></tr></table></figure>
<p>默认值是<code>auto</code>，就是自动。有设置<code>width</code>则占据空间就是<code>width</code>，没有设置就按内容宽度来。</p>
<p>如果同时设置<code>width</code>和<code>flex-basis</code>，就渲染表现来看，会忽略<code>width</code>。<strong>flex 顾名思义就是弹性的意思，因此，实际上不建议对 flex 子项使用 width 属性，因为不够弹性</strong>。</p>
<p>当剩余空间不足的时候，<code>flex</code>子项的实际宽度并通常不是设置的<code>flex-basis</code>尺寸，因为 flex 布局剩余空间不足的时候默认会收缩。</p>
<p>当剩余空间不足的时候，flex 子项的实际宽度并通常不是设置的<code>flex-basis</code>尺寸，因为 flex 布局剩余空间不足的时候默认会收缩。</p>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-basis" target="_blank" rel="noopener">张鑫旭大佬：案例显示代码</a></p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的缩写。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex: none | auto | [ &lt; 'flex-grow' &gt; &lt; 'flex-shrink' &gt;? || &lt; 'flex-basis' &gt; ];</span><br></pre></td></tr></table></figure>
<p>其中第 2 和第 3 个参数<strong>（flex-shrink 和 flex-basis）</strong>是可选的。默认值为<code>0 1 auto</code>。</p>
<p>flex 为<code>none</code>和<code>auto</code>简写实际效果如下：</p>
<ul>
<li><strong>flex 默认值等同于 flex:0 1 auto</strong>；</li>
<li><strong>flex:none 等同于 flex:0 0 auto</strong>；</li>
<li><strong>flex:auto 等同于 flex:1 1 auto</strong>；</li>
</ul>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#flex-flex" target="_blank" rel="noopener">张鑫旭大佬：案例显示代码</a></p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><code>align-self</code>指控制单独某一个<strong>flex 子项的垂直对齐方式</strong>.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure>
<p><strong>唯一区别就是 align-self 多了个 auto（默认值），表示继承自 flex 容器的 align-items 属性值</strong>。</p>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/#align-self" target="_blank" rel="noopener">张鑫旭大佬：案例显示代码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/" target="_blank" rel="noopener">写给自己看的 display: flex 布局教程</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a><br><a href="https://zhuanlan.zhihu.com/p/25303493" target="_blank" rel="noopener">30 分钟学会 Flex 布局</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的高阶组件(hoc)浅析</title>
    <url>/blog/react/optimization/react-hoc.html</url>
    <content><![CDATA[<p><a href="/blog/react/react-hoc.html">react 的高阶组件浅析</a><br><a href="/blog/react/react-hooks.html">react 中 Hooks 浅析</a><br><a href="/blog/react/react-mixins-hoc-hooks.html">react 的 mixins、hoc、hooks 对比</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
</blockquote>
<p>高阶组件可以看作 React 对装饰模式的一种实现，<strong>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件</strong>。</p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>
<p>可以从下面几个方面探索 HOC。<br><img src="../../images/react/react-hoc-1-1.png" alt="reac-hoc"></p>
<p><strong>HOC 的实现方式</strong></p>
<ul>
<li>属性代理</li>
<li>反向继承</li>
</ul>
<p><strong>高阶组件的使用场景</strong></p>
<ul>
<li>操作 props(属性)</li>
<li>通过 Refs 访问到组件实例</li>
<li>组件状态提升</li>
<li>操作 state</li>
<li>渲染劫持</li>
<li>用其他元素包裹 WrappedComponent</li>
</ul>
<h2 id="HOC-的实现方式"><a href="#HOC-的实现方式" class="headerlink" title="HOC 的实现方式"></a>HOC 的实现方式</h2><p><font color="#ff502c"></font><br><code>React</code> 中实现 <code>HOC</code> 的两种主要方式：<code>Props Proxy</code>(属性代理)（PP）和 <code>Inheritance Inversion</code>(反向继承)(II) 。 两者都支持不同的方式来操作 <strong>WrappedComponent</strong> 。</p>
<p>这里不会详细介绍生命周期方法来做什么，因为它不是 <code>HOC</code> 的特性，而是 <code>React</code> 的特性。 但请注意，使用 <code>Inheritance Inversion(反向继承)</code>，您可以为 <code>WrappedComponent</code> 创建新的生命周期方法。 记得总是这样调用 <code>super[lifecycleHook]</code> ，这样就不会破坏 <code>WrappedComponent</code> 。</p>
<h3 id="属性代理-Props-Proxy"><a href="#属性代理-Props-Proxy" class="headerlink" title="属性代理 Props Proxy"></a>属性代理 Props Proxy</h3><p>Props Proxy(属性代理)(PP) 以下列方式实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里的重要部分是 HOC 得 render 方法<strong>返回</strong>WrappedComponent 类型的 React 元素。我们还通过 HOC 接收到得<code>props</code>(属性)，这就是名字<code>Props Proxy</code>的由来。</p>
<p>对比原生组件增强的项：</p>
<ul>
<li>操作 props</li>
<li>可操作组件的生命周期</li>
<li>通过 Refs 访问到组件实例</li>
<li>用其他元素包裹 WrappedComponent</li>
<li>提取 state(状态)</li>
</ul>
<h3 id="Inheritance-Inversion-反向继承"><a href="#Inheritance-Inversion-反向继承" class="headerlink" title="Inheritance Inversion(反向继承)"></a>Inheritance Inversion(反向继承)</h3><p>Inheritance Inversion(反向继承)(II) 通过以下方式实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的 HOC 类<font color="#ff502c">Enhancer</font> <strong>继承（extends）了</strong>WrappedComponent。它被成为<font color="#ff502c">Inheritance Inversion(反向继承)</font>，因为它不是用 WrappedComponent 来继承某些<font color="#ff502c">Enhancer</font>类。而是被<font color="#ff502c">Enhancer</font>被动继承。通过这种方式，他们之间的关系似乎是<strong>反向（inverse）</strong>。</p>
<p><font color="#ff502c">反向继承</font>允许 <font color="#ff502c">HOC</font> 通过 <font color="#ff502c">this</font> 访问 <font color="#ff502c">WrappedComponent</font> 实例，这意味着它可以访问 <font color="#ff502c">state(状态)</font>，<font color="#ff502c">props(属性)</font>，<font color="#ff502c">组件生命周期方法</font>和 <font color="#ff502c">render</font> 方法。<br>对比原生组件增强的项：</p>
<ul>
<li>可操作所有传入的 props</li>
<li>可操作组件的生命周期</li>
<li>获取 refs</li>
<li>可操作 state</li>
<li>可以渲染劫持</li>
</ul>
<h2 id="高阶组件的使用场景"><a href="#高阶组件的使用场景" class="headerlink" title="高阶组件的使用场景"></a>高阶组件的使用场景</h2><hr>

<h3 id="操作-props-属性"><a href="#操作-props-属性" class="headerlink" title="操作 props(属性)"></a>操作 props(属性)</h3><blockquote>
<p>通过属性代理实现</p>
</blockquote>
<p>你可以<code>读取、添加、编辑、删除</code>传给 <code>WrappedComponent</code> 的 <code>props(属性)</code>。在<code>删除或编辑</code>重要的 <code>props(属性)</code> 时要小心，你应该通过命名空间确保高阶组件的 <code>props</code> 不会破坏 <code>WrappedComponent</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        ...this.props,</span><br><span class="line">        userName: <span class="string">'asyncnode'</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="通过-Refs-访问到组件实例"><a href="#通过-Refs-访问到组件实例" class="headerlink" title="通过 Refs 访问到组件实例"></a>通过 Refs 访问到组件实例</h3><p><code>高阶组件</code>中可获取原组件的<code>ref</code>，通过<code>ref</code>获取组件<code>实例</code>，如下面的代码，当程序初始化完成后调用原组件的 log 方法。</p>
<blockquote>
<p>通过属性代理实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">RefsHoC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrapperRef.log();</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          ref=&#123;(ref) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.wrapperRef = ref;</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用高阶组件的时候并不能获取到原组件的真实 ref，需要手动进行传递，<a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components" target="_blank" rel="noopener">详情请看</a></p>
<h3 id="组件状态提升"><a href="#组件状态提升" class="headerlink" title="组件状态提升"></a>组件状态提升</h3><p>将原组件的状态提取到<code>HOC</code>中进行管理，如下面的代码，我们将<code>Input</code>的<code>value</code>提取到<code>HOC</code>中进行管理，使它变成受控组件，同时不影响它使用<code>onChange</code>方法进行一些其他操作。基于这种方式，我们可以实现一个简单的<code>双向绑定</code>。</p>
<blockquote>
<p>通过属性代理实现</p>
</blockquote>
<p>示例：在以下提取 state(状态)示例中，我们非常规的提取 name 输入字段的值和 onChange 处理程序。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    onChange(event) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onChange &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">this</span>.setState(</span><br><span class="line">        &#123;</span><br><span class="line">          name: event.target.value</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onChange === <span class="string">'function'</span>) &#123;</span><br><span class="line">            onChange(event);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        value: name,</span><br><span class="line">        onChange: <span class="keyword">this</span>.onChange</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以像这样使用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@ppHOC <span class="comment">//装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作-state"><a href="#操作-state" class="headerlink" title="操作 state"></a>操作 state</h3><p><code>HOC</code>可以读取，编辑和删除 <code>WrappedComponent</code> 实例的状态，如果需要，还可以添加更多的 <code>state(状态)</code>。 请记住，您正在弄乱 <code>WrappedComponent</code> 的 <code>state(状态)</code>，这会导致您破坏一些东西。 大多数情况下，<code>HOC</code> 应限于读取或添加 <code>state(状态)</code> ，而添加 <code>state(状态)</code> 时应该被命名为不会弄乱 <code>WrappedComponent</code> 的 <code>state(状态)</code>。</p>
<blockquote>
<p>通过反向继承实现</p>
</blockquote>
<p>示例：通过访问 <code>WrappedComponent</code> 的 <code>props(属性)</code> 和 <code>state(状态)</code> 进行调试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">IIHOCDEBUGGER</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">II</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;HOC Debugger Component&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;Props&lt;/</span>p&gt; <span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;JSON.stringify(this.props, null, 2)&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line">          &lt;p&gt;State&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/</span>pre&gt;</span><br><span class="line">          &#123;<span class="keyword">super</span>.render()&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>HOC</code> 用其他元素包裹着 <code>WrappedComponent</code> ，并且还显示了 <code>WrappedComponent</code> 的实例 <code>props(属性)</code> 和 <code>state(状态)</code> 。</p>
<h3 id="渲染劫持-Render-Highjacking"><a href="#渲染劫持-Render-Highjacking" class="headerlink" title="渲染劫持(Render Highjacking)"></a>渲染劫持(Render Highjacking)</h3><blockquote>
<p>通过反向继承实现</p>
</blockquote>
<p>它被称为 渲染劫持(Render Highjacking)，因为 HOC 控制了 WrappedComponent 的渲染输出，并且可以用它做各种各样的事情。<br>在渲染劫持中，您可以：state(状态)，props(属性)</p>
<ul>
<li>读取，添加，编辑，删除渲染输出的任何 React 元素中的 props(属性)</li>
<li>读取并修改 render 输出的 React 元素树</li>
<li>有条件地渲染元素树</li>
<li>把样式包裹进元素树（就像在 Props Proxy(属性代理) 中的那样）<br>注：render 是指 WrappedComponent.render 方法<br>通过<strong>渲染劫持</strong>可以做到<strong>组合渲染</strong>和<strong>条件渲染</strong>.<br>示例 1：<strong>条件渲染</strong>。除非 <code>this.props.loggedIn</code> 不为 <code>true</code> ，否则此 <code>HOC</code> 将准确渲染 <code>WrappedComponent</code> 将渲染的内容。（假设 HOC 将收到 loggedIn props(属性)）.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反向继承实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过属性代理实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        return null;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例 2：<strong>组合渲染</strong>。 新增一个 title。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反向继承实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;div className=<span class="string">'title'</span>&gt;&#123;<span class="keyword">this</span>.props.title&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;super.render()&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>React.Fragment&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过属性代理实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;div className=<span class="string">'title'</span>&gt;&#123;<span class="keyword">this</span>.props.title&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;WrappedComponent &#123;...this.props&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在 <code>Props Proxy</code>(属性代理) 类型的高阶函数中做不到渲染劫持。</p>
</blockquote>
<p>虽然可以通过 <code>WrappedComponent.prototype.render</code> 访问 <code>render</code> 方法，但是您需要模拟 <code>WrappedComponent</code> 实例及其 <code>props</code>(属性)，并且可能需要自己处理组件生命周期，而不是依赖 <code>React</code> 执行它。 在我的实验中不值得这么做，如果你想做渲染劫持(<code>Render Highjacking</code>)，你应该使用 <code>Inheritance Inversion</code>(反向继承) 而不是 <code>Props Proxy</code>(属性代理)。 请记住，React 在内部处理组件实例，而处理实例的唯一方法是通过 this 或 refs 。</p>
<h3 id="用其他元素包裹-WrappedComponent"><a href="#用其他元素包裹-WrappedComponent" class="headerlink" title="用其他元素包裹 WrappedComponent"></a>用其他元素包裹 WrappedComponent</h3><blockquote>
<p>通过属性代理实现</p>
</blockquote>
<p>可以将 WrappedComponent 与其他组件和元素包装在一起，以用于样式，布局或其他目的。 一些基本用法可以通过常规父组件来完成.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123; <span class="attr">display</span>: <span class="string">'block'</span> &#125;&#125;&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>使用 <code>HOC</code> 包裹组件时，会丢失原始 <code>WrappedComponent</code> 的名称，这可能会在开发和调试时影响到您。人们通常做的是通过获取 <code>WrappedComponent</code> 的名称并预先添加某些内容来自定义 <code>HOC</code> 的名称。 以下内容摘自 <code>React-Redux</code> 。用 <code>HOC</code> 包裹了一个组件会使它失去原本 <code>WrappedComponent</code> 的名字，可能会影响开发和调试。通常会用 <code>WrappedComponent</code> 的名字加上一些 前缀作为 HOC 的名字。下面的代码来自 React-Redux:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span>;</span><br><span class="line">&#125;</span><br><span class="line">HOC.displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何使用-HOC"><a href="#如何使用-HOC" class="headerlink" title="如何使用 HOC"></a>如何使用 HOC</h2><p>上面的示例代码都写的是如何声明一个<code>HOC</code>，<code>HOC</code>实际上是一个函数，所以我们将要增强的组件作为参数调用<code>HOC</code>函数，得到增强后的组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>原组件<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> inheritHOC(myComponent);</span><br></pre></td></tr></table></figure>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>假设现在我们有 logger，visible，style 等多个 HOC，现在要同时增强一个 Input 组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">logger(visible(style(Input)));</span><br></pre></td></tr></table></figure>
<p>这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> g(f(...args)));</span><br><span class="line">compose(logger, visible, style)(Input);</span><br></pre></td></tr></table></figure>
<p><code>compose</code>函数返回一个所有函数组合后的函数，<code>compose(f, g, h)</code> 和 <code>(...args) =&gt; f(g(h(...args)))</code>是一样的。<br>很多第三方库都提供了类似<code>compose</code>的函数，例如<code>lodash.flowRight</code>，<code>Redux</code>提供的<code>combineReducers</code>函数等。</p>
<h3 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h3><p>我们还可以借助 ES7 为我们提供的 Decorators 来让我们的写法变的更加优雅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@logger</span><br><span class="line">@visible</span><br><span class="line">@style</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Decorators</code>是<code>ES7</code>的一个提案，还没有被标准化，但目前<code>Babel</code>转码器已经支持，我们需要提前配置<code>babel-plugin-transform-decorators-legacy</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="HOC-的实际应用"><a href="#HOC-的实际应用" class="headerlink" title="HOC 的实际应用"></a>HOC 的实际应用</h2><p>多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用， 官方文档中<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">CommentList</a>的示例也是解决了代码复用问题。</p>
<h3 id="日志打点"><a href="#日志打点" class="headerlink" title="日志打点"></a>日志打点</h3><p>某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.start = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.end = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;WrappedComponent.dispalyName&#125;</span> 渲染时间：<span class="subst">$&#123;<span class="keyword">this</span>.end - <span class="keyword">this</span>.start&#125;</span> ms`</span></span><br><span class="line">      );</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user&#125;</span>进入<span class="subst">$&#123;WrappedComponent.dispalyName&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user&#125;</span>退出<span class="subst">$&#123;WrappedComponent.dispalyName&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="可用、权限控制"><a href="#可用、权限控制" class="headerlink" title="可用、权限控制"></a>可用、权限控制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; visible, auth, display = <span class="literal">null</span>, ...props &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span> || (auth &amp;&amp; authList.indexOf(auth) === <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> display;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>authList</code>是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的 visible 是 false，我们将其显示为传入的组件样式，或者<code>null</code>。我们可以将任何需要进行权限校验的组件应用<code>HOC</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@auth</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  ...  &#125;</span><br><span class="line">@auth</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  ...  &#125;</span><br><span class="line"></span><br><span class="line">&lt;Button auth=<span class="string">"user/addUser"</span>&gt;添加用户&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">&lt;Input auth="user/</span>search<span class="string">" visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>在<code>vue</code>中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而<code>React</code>中没有做这样的处理，在默认情况下，表单元素都是非受控组件。给表单元素绑定一个状态后，往往需要手动书写<code>onChange</code>方法来将其改写为<strong>受控组件</strong>，在表单元素非常多的情况下这些重复操作是非常痛苦的。<br>我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。<br><img src="../../images/react/react-hoc-1-2.png" alt="reac-hoc"><br>…代码未完成（后续补上）</p>
<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息：<br>…代码未完成（后续补上）</p>
<h2 id="使用-HOC-的注意事项"><a href="#使用-HOC-的注意事项" class="headerlink" title="使用 HOC 的注意事项"></a>使用 HOC 的注意事项</h2><hr>

<h3 id="静态属性拷贝"><a href="#静态属性拷贝" class="headerlink" title="静态属性拷贝"></a>静态属性拷贝</h3><p>当我们应用<code>HOC</code>去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在<code>HOC</code>的结尾手动拷贝他们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOCComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  HOCComponent.staticMethod = WrappedComponent.staticMethod;</span></span><br><span class="line"><span class="xml">  // ...</span></span><br><span class="line"><span class="xml">  return HOCComponent;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用<code>hoist-non-react-statics</code>来帮助我们解决这个问题，它可以自动帮我们拷贝所有非 React 的静态方法，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOCComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  hoistNonReactStatic(HOCComponent, WrappedComponent);</span></span><br><span class="line"><span class="xml">  return HOCComponent;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="传递-refs"><a href="#传递-refs" class="headerlink" title="传递 refs"></a>传递 refs</h3><p>使用高阶组件后，获取到的<code>ref</code>实际上是<code>最外层</code>的<code>容器组件</code>，而非<code>原组件</code>，但是很多情况下我们需要用到<code>原组件的ref</code>。<br>高阶组件并不能像透传 props 那样将 refs 透传，我们可以用一个回调函数来完成 ref 的传递：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    getWrappedRef = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.wrappedRef;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          ref=&#123;(ref) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.wrappedRef = ref;</span><br><span class="line">          &#125;&#125;</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@hoc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Input</span><br><span class="line">        ref=&#123;(ref) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.inpitRef = ref.getWrappedRef();</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React 16.3</code>版本提供了一个<code>forwardRef API</code>来帮助我们进行<code>refs</code>传递，这样我们在高阶组件上获取的<code>ref</code>就是原组件的 ref 了，而不需要再手动传递，如果你的<code>React</code>版本大于<code>16.3</code>，可以使用下面的方式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; forwardedRef, ...props &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return React.forwardRef((props, ref) =&gt; &#123;</span></span><br><span class="line">    return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不要在-render-方法中使用-HOC"><a href="#不要在-render-方法中使用-HOC" class="headerlink" title="不要在 render 方法中使用 HOC"></a>不要在 render 方法中使用 HOC</h3><p>React Diff 算法的原则是：</p>
<ul>
<li>使用组件标识确定是卸载还是更新组件</li>
<li>如果组件的和前一次渲染时标识是相同的，递归更新子组件</li>
<li>如果标识不同卸载组件重新挂载新组件</li>
</ul>
<p>每次调用<strong>高阶组件</strong>生成的都是是一个<strong>全新</strong>的组件，组件的<strong>唯一标识</strong>响应的也会改变，如果在 render 方法调用了高阶组件，这会导致组件每次都会被<strong>卸载后重新挂载</strong>。</p>
<h3 id="不要改变原始组件"><a href="#不要改变原始组件" class="headerlink" title="不要改变原始组件"></a>不要改变原始组件</h3><p>官方文档对高阶组件的说明：</p>
<blockquote>
<p>高阶组件就是一个没有副作用的纯函数。</p>
</blockquote>
<p>我们再来看看纯函数的定义：</p>
<blockquote>
<p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。 该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。</p>
</blockquote>
<p><strong>我们使用高阶组件是为了增强而非改变原组件</strong>。</p>
<h3 id="透传不相关的-props"><a href="#透传不相关的-props" class="headerlink" title="透传不相关的 props"></a>透传不相关的 props</h3><p>使用高阶组件，我们可以代理所有的<code>props</code>，但往往特定的 HOC 只会用到其中的一个或几个<code>props</code>。我们需要把其他不相关的<code>props</code>透传给原组件，如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visible</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; visible, ...props &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们只使用<code>visible</code>属性来控制组件的显示可隐藏，把其他<code>props</code>。</p>
<h2 id="HOC-的缺陷"><a href="#HOC-的缺陷" class="headerlink" title="HOC 的缺陷"></a>HOC 的缺陷</h2><ul>
<li><code>HOC</code>需要在原组件上进行包裹或者嵌套，如果大量使用<code>HOC</code>，将会产生非常多的嵌套，这让调试变得非常困难。</li>
<li><code>HOC</code>可以劫持<code>props</code>，在不遵守约定的情况下也可能造成冲突。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>HOC 相对于 Mixins 的好处</strong>：</p>
<ul>
<li><strong>高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合</strong></li>
<li><strong>高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为</strong></li>
<li><strong>高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担</strong></li>
</ul>
<p><strong>HOC 实现方式有两种</strong>：</p>
<ul>
<li><strong>通过属性代理实现</strong></li>
<li><strong>通过反向继承实现</strong></li>
</ul>
<p><strong>高阶组件的使用场景</strong>:</p>
<ul>
<li><strong>操作 props(属性)(通过属性代理实现、通过反向继承实现)</strong></li>
<li><strong>通过 Refs 访问到组件实例 （通过属性代理实现）</strong></li>
<li><strong>组件状态提升（通过属性代理实现）</strong></li>
<li><strong>操作 state （通过反向继承实现）</strong></li>
<li><strong>渲染劫持（通过属性代理实现、通过反向继承实现）</strong></li>
<li><strong>用其他元素包裹 WrappedComponent （通过属性代理实现）</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a><br><a href="https://www.html.cn/archives/9462" target="_blank" rel="noopener">深入理解 React 高阶组件（Higher Order Component，简称：HOC）</a><br><a href="https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-13" target="_blank" rel="noopener">【React 深入】从 Mixin 到 HOC 再到 Hook</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>HOC</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript类型转换（三）常见的面试题</title>
    <url>/blog/javascript/type/javascript-type-one-questionone.html</url>
    <content><![CDATA[<p><strong><em>多言多败，多事多害。——《训蒙增广》</em></strong></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在另一篇文章中有表述大致显示转化规则，隐式转换规则，着篇文章中会收集一些前端比较经典的关于类型转换的问题。下面就开始比较经典的面试题。</p>
<h2 id><a href="#" class="headerlink" title="![] == []"></a>![] == []</h2><p>这个题在另一篇面试中有记录过，<a href="/blog/javascript/type/javascript-false-true.html">![] == []</a>.</p>
<h2 id="a-1-amp-amp-a-2-amp-amp-a-3"><a href="#a-1-amp-amp-a-2-amp-amp-a-3" class="headerlink" title="(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)"></a>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)</h2><p>这个真的有很多种办法，这里只记录我知道的方法，如果有好的方法，请在下方留言，大家一起进步。<br>首先要知道<code>==和===的区别</code>。</p>
<p><strong>==</strong><br>宽松匹配 : <code>==会先将左右两两边的值转化成相同的原始类型，然后再去比较他们是否相等</code>。<br><strong>===</strong><br><code>他是不转化直接比较，如果类型不同直接就是false，如果类型相同，原始值相同就为true</code>。</p>
<p>这里主要讲解<code>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)</code>相等的多种解法，如下：</p>
<ol>
<li>重写<code>Object</code>的<code>valueOf</code></li>
<li>重写<code>Object</code>的<code>toString</code></li>
<li>重写<code>ToPrimitive</code>，<code>es6 smybol(&#39;&#39;)</code></li>
<li>通过劫持 obj 的<code>getter</code>方法</li>
<li>数组<code>join、shift</code></li>
<li>字符串骚操作</li>
</ol>
<h3 id="重写-Object-的-valueOf、重写-Object-的-toString"><a href="#重写-Object-的-valueOf、重写-Object-的-toString" class="headerlink" title="重写 Object 的 valueOf、重写 Object 的 toString"></a>重写 Object 的 valueOf、重写 Object 的 toString</h3><p><strong>重写代码的 valueOf 方法、和 toString 方法</strong>，如果不知道 ToPrimitive(obj, type)规则，请看<a href="/blog/javascript/type/javascript-type-one-question.html">ToPrimitive 规则</a>我的另一篇博客。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">a.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">a1.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">a1.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a1 == <span class="number">1</span> &amp;&amp; a1 == <span class="number">2</span> &amp;&amp; a1 == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="重写-ToPrimitive，es6-smybol-‘’"><a href="#重写-ToPrimitive，es6-smybol-‘’" class="headerlink" title="重写 ToPrimitive，es6 smybol(‘’)"></a>重写 ToPrimitive，es6 smybol(‘’)</h3><p><strong>在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为，得到我们想要的结果</strong>。看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">a[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Obj-defineProperty"><a href="#Obj-defineProperty" class="headerlink" title="Obj.defineProperty"></a>Obj.defineProperty</h3><p><strong>通过劫持对象的属性值的 getter 操作</strong>，让他累加来做到我们想要的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="通过数组的方式实现"><a href="#通过数组的方式实现" class="headerlink" title="通过数组的方式实现"></a>通过数组的方式实现</h3><p><strong>通过改变数组的 join 方法实现</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的骚操作"><a href="#字符串的骚操作" class="headerlink" title="字符串的骚操作"></a>字符串的骚操作</h3><p><strong>通过定义变量是包含空格</strong>，实现视觉上的相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aﾠ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> ﾠa = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aﾠ == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; ﾠa == <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面就是知道的可以让<code>(aﾠ == 1 &amp;&amp; a == 2 &amp;&amp; ﾠa== 3 )</code>的六种方法，如果还有后面会接着补充，下面来说一下<code>(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3)</code>。</p>
<h2 id="a-1-amp-amp-a-2-amp-amp-a-3-1"><a href="#a-1-amp-amp-a-2-amp-amp-a-3-1" class="headerlink" title="(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3)"></a>(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3)</h2><p>在上面介绍过<code>==与===的区别</code>， ===是不会进行类型转换的，所以==的很多规则并不适用，那只有<strong>劫持方法</strong>和<strong>字符串</strong>的操作可以实现，其他方法都不能实现。</p>
<h3 id="Obj-defineProperty-1"><a href="#Obj-defineProperty-1" class="headerlink" title="Obj.defineProperty"></a>Obj.defineProperty</h3><p><strong>通过劫持对象的属性值的 getter 操作</strong>，让他累加来做到我们想要的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.value += <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的骚操作-1"><a href="#字符串的骚操作-1" class="headerlink" title="字符串的骚操作"></a>字符串的骚操作</h3><p><strong>通过定义变量是包含空格</strong>，实现视觉上的相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aﾠ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> ﾠa = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aﾠ === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; ﾠa === <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>未完待续。。。。如有经典试题可评论</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码中parse生成AST</title>
    <url>/blog/vue/principle/vue-parse.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码中complier整体流程</title>
    <url>/blog/vue/principle/vue-complier.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript类型转换（二） 类型转换</title>
    <url>/blog/javascript/type/javascript-type-one-question.html</url>
    <content><![CDATA[<p><strong><em>天下难事必作于易，天下大事必作于细。——《道德经》</em></strong></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在 JavaScript 中关于类型转换的规则是非常混乱的，有<strong>强制转换（显示转换）</strong>、<strong>隐式转换</strong>，并且转换的规则没有完整可参考的文档，只有当时的提议书。并且在<strong>隐式转换</strong>的时候会出现很多不可思议的 bug.</p>
<blockquote>
<p>类型转换发生在静态类型的语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）；</p>
</blockquote>
<p>我们先来解释显示转换再来隐式转换。<br>如果想了解<a href="/blog/javascript/type/javascript-Type-conversion.html">javaScript 中的类型</a>，或者<a href="/blog/javascript/type/javascript-IF-False-options.html">if 运算符转换规则</a>的知识可以看看我其他的博客。</p>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><ol>
<li><code>ToString</code></li>
<li><code>ToNumber</code></li>
<li><code>ToBoolean</code></li>
</ol>
<p>首先介绍显示转换中的基本类型互转，<code>字符串、数字、布尔值、null、undefined</code> 之间的转换。</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><ol>
<li><code>ToPrimitive(转换为原始值)</code></li>
<li><code>valueOf(返回指定对象的原始值)</code></li>
<li><code>运算符中的转换（+、-、\*、/）</code></li>
<li><code>==</code></li>
</ol>
<p>再来看一下 <code>ToPrimitive</code> 把对象转为原始值，当然也有 <code>Object.prototype.toString()</code>的介绍，再试 <code>valueOf</code> 返回对象的原始值，再最后就是运算符在<code>基本类型</code>和 <code>object 之间的运算</code>，其中最坑的应该是<code>==的隐士转换</code>，因为他的左右规则不同，左右类型不同执行的又不同。</p>
<h3 id="ToPrimitive-的规则"><a href="#ToPrimitive-的规则" class="headerlink" title="ToPrimitive 的规则"></a>ToPrimitive 的规则</h3><p>我们要用到的<code>ToPrimitive</code>的规则，因为显示转换也会用到<code>ToPrimitive</code>的规则，如果还想所有的转换规则请看.<a href="http://www.ecma-international.org/" target="_blank" rel="noopener">ecma 规则</a><br><strong>ToPrimitive</strong>(转换为原始值)<br><code>ToPrimitive</code> 运算符接受一个值，和一个可选的 期望类型作参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params obj 要转换的对象 ，required</span></span><br><span class="line"><span class="comment"> * @params type 期望转换为的原始数据类型，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ToPrimitive(obj, type);</span><br></pre></td></tr></table></figure>
<p>根据`type<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**type 为 string**</span><br><span class="line"></span><br><span class="line">1. 先调用 obj 的`toString`方法，如果返回`原始值`，则不往下执行，如果返回不是原始值，则执行`第二步`。</span><br><span class="line">2. 调用 obj 的`valueOf`方法，如果为`原始值`，则不往下执行，如果返回不是原值值，则执行`第三步`。</span><br><span class="line">3. 抛出`TypeError`异常</span><br><span class="line"></span><br><span class="line">**type 为 Number**</span><br><span class="line"></span><br><span class="line">1. 先调用 obj 的`valueOf`方法，如果返回`原始值`，则不往下执行，如果返回不是原始值，则执行`第二步`。</span><br><span class="line">2. 调用 obj 的`toString`方法，如果为`原始值`，则不往下执行，如果返回不是原值值，则执行`第三步`。</span><br><span class="line">3. 抛出`TypeError`异常</span><br><span class="line"></span><br><span class="line">**type 参数为空**</span><br><span class="line"></span><br><span class="line">1. 该对象为`Date`，则 type 被设置为`String`</span><br><span class="line">2. 否则，type 被设置为`Number`</span><br><span class="line"></span><br><span class="line">这基本上就是 object 常用的转换的一些规则，在下面会验证 ToPrimitive 规则是否正确。</span><br><span class="line"></span><br><span class="line">## 显示转换</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">我们先看一下基本类型之间的转换的图标如下：</span><br><span class="line"></span><br><span class="line">|         |  Null  |  Undefined  | Boolean(true) | Boolean(false) |         Number         |       String        |</span><br><span class="line">| :-----: | :----: | :---------: | :-----------: | :------------: | :--------------------: | :-----------------: |</span><br><span class="line">| Boolean | false  |    false    |       -       |       -        | (0/NAN)=&gt;false OR true | (&apos;&apos;)=&gt;false OR true |</span><br><span class="line">| Number  |   0    |     NaN     |       1       |       0        |           -            | (&apos;&apos;)=&gt;false OR true |</span><br><span class="line">| String  | &apos;null&apos; | &apos;undefined&apos; |    &apos;true&apos;     |    &apos;false&apos;     |        &apos;Number&apos;        |          -          |</span><br><span class="line"></span><br><span class="line">我们下面一个一个说明`ToString`、`ToNumber`、`ToBoolean`的大致规则。</span><br><span class="line"></span><br><span class="line">### ToString</span><br><span class="line"></span><br><span class="line">抽象操作`ToString`负责处理非字符串到字符串的强制类型转换。</span><br><span class="line">验证一下上面表格中的转换规则，验证的时候加上 object 的转换验证，代码如下：</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">console.log(String(null)); // &apos;null&apos;</span><br><span class="line">console.log(String(undefined)); // &apos;undefined&apos;</span><br><span class="line">console.log(String(true)); // &apos;true&apos;</span><br><span class="line">console.log(String(false)); // &apos;false&apos;</span><br><span class="line">console.log(String(1)); // &apos;1&apos;</span><br><span class="line">console.log(String(0)); // &apos;0&apos;</span><br><span class="line">console.log(String(NaN)); // &apos;NaN&apos;</span><br><span class="line">console.log(String([1, 2, 3])); // &apos;1,2,3&apos; or [].toString()</span><br><span class="line">console.log(String(&#123; a: 123 &#125;)); // [object Object]</span><br><span class="line">console.log(String(new Date())); // &apos;Sat Apr 20 2019 00:00:00 GMT+0800 (中国标准时间)&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码证明了我们上面 table 中的基本类型的·String·转换规则。</p>
<blockquote>
<p>注意：对象这里要先转换为原始值，调用<code>ToPrimitive</code>转换，<code>type</code>就指定为<code>string</code>了，继续回到<code>ToPrimitive</code>进行转换（看 ToPrimitive）。</p>
</blockquote>
<h3 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h3><p>抽象操作<code>ToNumber</code>负责处理非<code>Number</code>到<code>Number</code>的强制类型转换。<br>验证一下上面表格中的转换规则，验证的时候加上 object 的转换验证，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'1'</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'0'</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'abcd'</span>)); <span class="comment">// 'NaN'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(&#123; <span class="attr">a</span>: <span class="number">123</span> &#125;)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// 1555689600000</span></span><br></pre></td></tr></table></figure>
<p>上面的代码证明了我们上面 table 中的基本类型的<code>Number</code>转换规则。</p>
<blockquote>
<p>注意：对象这里要先转换为原始值，调用<code>ToPrimitive</code>转换，type 就指定为<code>number</code>了，继续回到<code>ToPrimitive</code>进行转换（看 ToPrimitive）。</p>
</blockquote>
<h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><p>抽象操作<code>ToBoolean</code>负责处理非<code>Boolean</code>到<code>Boolean</code>的强制类型转换。<br>验证一下上面表格中的转换规则，验证的时候加上 object 的转换验证，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'true'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'false'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">''</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'abcd'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123; <span class="attr">a</span>: <span class="number">123</span> &#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123;&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// 1555689600000</span></span><br></pre></td></tr></table></figure>
<p>在表格上只有基本类型的转换为 Boolean 的规则，具体的转换规则为：</p>
<ul>
<li><code>false</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>空字符串&#39; &#39;</code></li>
<li><code>数字零 0</code></li>
<li><code>NaN</code></li>
</ul>
<p>只有上面的会转为<code>false</code>,其他的都会转为<code>true</code>.<br>他和 <code>if()</code>条件运算符转换的规则基本上一至，请看<a href="/blog/javascript/type/javascript-IF-False-options.html">if 运算符转换</a>。</p>
<h2 id="隐士转换"><a href="#隐士转换" class="headerlink" title="隐士转换"></a>隐士转换</h2><hr>
<p>在上面已经列出了<code>ToPrimitive</code>的常用的转换规则，在下面会验证上面的规则是否正确。最坑的也是规则对多的就是运算符的转换，可能现在只知道一部分，后面会慢慢补全。</p>
<h3 id="ToPrimitive-验证"><a href="#ToPrimitive-验证" class="headerlink" title="ToPrimitive 验证"></a>ToPrimitive 验证</h3><p><strong>Object 转 String 规则验证</strong><br>首先验证 Obejct 转换为 String 的规则，直接上代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'toString'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">String</span>(obj);</span><br><span class="line"><span class="comment">// 1. toString</span></span><br><span class="line"><span class="comment">// 2. valueOf</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>根据上面的输出结果，证明上面的 <code>String()</code>，走了<code>ToPrimitive(obj, string)</code>的<code>type</code>为<code>string</code>的规则。详情见上面。</p>
<p><strong>Object 转 Number 规则验证</strong><br>再验证 <code>Obejct</code> 转换为 <code>Number</code> 的规则，直接上代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'toString'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Number</span>(obj);</span><br><span class="line"><span class="comment">// 1. valueOf</span></span><br><span class="line"><span class="comment">// 2. toString</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>根据上面的输出结果，证明上面的 <code>Number()</code>，走了<code>ToPrimitive(obj, number)</code>的<code>type</code>为<code>number</code>的规则。详情见上面。</p>
<p><strong>其他转变如数组转 String 或者 Number</strong></p>
<p>再验证 <code>Obejct</code> 转换为 <code>Number</code> 的规则，直接上代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'toString'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Number</span>(obj);</span><br><span class="line"><span class="comment">// 1. valueOf</span></span><br><span class="line"><span class="comment">// 2. toString</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<p>根据上面的输出结果，证明上面的 Number()，走了<code>ToPrimitive(obj, number)</code>的<code>type</code>为<code>number</code>的规则。详情见上面。</p>
<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><p>JavaScript 调用 <code>valueOf()</code> 方法用来把对象转换成原始类型的值（数值、字符串和布尔值）。但是我们很少需要自己调用此函数，<code>valueOf</code> 方法一般都会被 JavaScript 自动调用。</p>
<ul>
<li><code>String</code> =&gt; 返回字符串值</li>
<li><code>Number</code> =&gt; 返回数字值</li>
<li><code>Boolean</code> =&gt; 返回<code>Boolean</code>的 this 值</li>
<li><code>Object</code> =&gt; 返回 this</li>
<li><code>Date</code> =&gt; 返回一个数字，即时间值,字符串中内容是依赖于具体实现的</li>
</ul>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span>.valueOf()); <span class="comment">// 'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="number">123</span>).valueOf()); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">true</span>).valueOf()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; <span class="attr">a</span>: <span class="number">123</span> &#125;.valueOf()); <span class="comment">// &#123;a: 123&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// Sat Apr 20 2019 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<h3 id="运算符中的转换（-、-、-、"><a href="#运算符中的转换（-、-、-、" class="headerlink" title="运算符中的转换（+、-、*、/)"></a>运算符中的转换（+、-、*、/)</h3><p>在运算符中的转换又分为两种，自动转换为<code>string</code>类型、自动转换为<code>number</code>类型。</p>
<h4 id="自动转换为-string-类型"><a href="#自动转换为-string-类型" class="headerlink" title="自动转换为 string 类型"></a>自动转换为 string 类型</h4><p>在基础类型中，当一个值为字符串，另一个值非字符串，则后者转为字符串，当有一个是对象时，会走<code>ToPrimitive(obj, number)</code>，<code>ToPrimitive</code>转换请看上面，下面看代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="number">1</span>); <span class="comment">// 'a1'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="literal">true</span>); <span class="comment">// 'atrue'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="literal">false</span>); <span class="comment">// 'afalse'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="literal">undefined</span>); <span class="comment">// 'aundefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + <span class="literal">null</span>); <span class="comment">// 'anull'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> + []); <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">'a'</span> +</span><br><span class="line">    &#123;</span><br><span class="line">      toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">); <span class="comment">// 'a1'</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">'a'</span> +</span><br><span class="line">    &#123;</span><br><span class="line">      valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">); <span class="comment">// 'a1'</span></span><br></pre></td></tr></table></figure>
<h4 id="自动转换为-number-类型"><a href="#自动转换为-number-类型" class="headerlink" title="自动转换为 number 类型"></a>自动转换为 number 类型</h4><p>加法运算符，如果没有一个为<code>string</code>类型的时候，都会优先转换为<code>Number</code>类型，如果有一个为 object 时，会走<code>ToPrimitive(obj, number)</code>，<code>ToPrimitive</code>转换请看上面。一元运算符，也是需要注意。下面看代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">false</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">null</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + []); <span class="comment">// ‘true’</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">null</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> - <span class="literal">false</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> - <span class="literal">true</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> - <span class="string">'0'</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> * <span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span> * <span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> - <span class="string">'0'</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span> - <span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span> - <span class="string">'0'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> - <span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> - <span class="number">0</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="number">1</span> -</span><br><span class="line">    &#123;</span><br><span class="line">      valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="number">1</span> -</span><br><span class="line">    &#123;</span><br><span class="line">      valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 一元运算符</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'abc'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="string">'abc'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">'1'</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="string">'1'</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="literal">false</span>); <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：null 转为数值时为 0，而 undefined 转为数值时为 NaN</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title="=="></a>==</h3><p><code>==</code> 抽象相等比较与<code>+运算符</code>不同，不再是 <code>String 优先</code>，而是 <code>Number 优先</code>。假设左面为 <code>x、y</code> 为右面，大概的规则如下。</p>
<ol>
<li>如果<code>x,y</code> 都为 <code>number</code>,直接比较</li>
<li>如果 <code>x 为 string，y 为 number，x 转换为 number 比较</code>，反则相反。</li>
<li>如果存在对象，通过<code>ToPrimitive(obj, number)type 为 number 进行转换</code>，再进行比较。</li>
<li>如果 <code>x，y 有一方存在 boolean,按照 ToNumber 将 boolean 转换为 1 或 0</code>，再进行比较。</li>
</ol>
<p>验证代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x,y 都number 比较</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一方为string一方为number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> == <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="string">'1'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一方为 对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 因为对象的规则比较繁杂，如果普通对象[] 和 ![] 规则不同请看下面文章</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在 booelan</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="string">'0'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="string">'0'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在这里就不多赘述了，看我另一篇文章 <a href="/blog/javascript/type/javascript-false-true.html">![] == []</a>，通过一道面试题。来讲解基本的转换规则，因为这个规则其实挺复杂的，一两句话讲不清楚。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 中的类型转换基本上分为<strong>显示转换、隐式转换</strong>。</p>
<p><strong>显示转换</strong></p>
<ol>
<li><code>ToString</code></li>
<li><code>ToNumber</code></li>
<li><code>ToBoolean</code></li>
</ol>
<p><strong>隐式转换</strong></p>
<ol>
<li><code>ToPrimitive(转换为原始值)</code></li>
<li><code>valueOf(返回指定对象的原始值)</code></li>
<li><code>运算符中的转换（+、-、*、/）</code></li>
<li><code>==</code></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/_THIZY4KTa1IlVb4k9qbJg" target="_blank" rel="noopener">经常被面试官考的 JavaScript 数据类型知识你真的懂吗？</a><br><a href="https://javascript.ruanyifeng.com/grammar/conversion.html" target="_blank" rel="noopener">数据类型转换</a><br><a href="https://github.com/amandakelake/blog/issues/34" target="_blank" rel="noopener">深入理解 JS 的类型、值、类型转换 #34</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单mvvm双向绑定基础框架 (未完成)</title>
    <url>/blog/vue/effect/vue-simple-mvvm.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>eventloop图解</title>
    <url>/blog/javascript/eventloop/evenloop.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>arrow-functions（箭头函数）和普通的函数的区别</title>
    <url>/blog/es/interview-question/es6-arrow-functions.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在用 vue 框架、或者 react 框架中我们会用到很多 es6 中的新特性，比较多的就是<font color="#ff502c">箭头函数</font>.都会知道一点普通函数和箭头函数的区别,这里总结一下<strong>箭头函数和普通函数的区别</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对比</th>
<th style="text-align:center">普通函数</th>
<th style="text-align:center">箭头函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">this 指向规则</td>
<td style="text-align:center">this 总是指向调用它的那个对象</td>
<td style="text-align:center">1.所有箭头函数本身没有 this <br>2.箭头函数的 this 在定义的时候捕获自外层第一个普通函数的 this <br> 3.如果箭头函数外层没有普通函数,严格模式和非严格模式下它的 this 都会指向 window(全局对象)</td>
</tr>
<tr>
<td style="text-align:center">有无 prototype</td>
<td style="text-align:center">有</td>
<td style="text-align:center">箭头函数没有<font color="#ff502c">prototype</font>(原型)</td>
</tr>
<tr>
<td style="text-align:center">可否 new</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">箭头函数作为匿名函数,是不能作为构造函数的(因为箭头函数没有 constructor),不能使用 new,不然会报错</td>
</tr>
<tr>
<td style="text-align:center">有无 arguments</td>
<td style="text-align:center">有</td>
<td style="text-align:center">1.箭头函数的 this 指向全局,使用会报未声明的错误 <br> 2.箭头函数的 this 指向普通函数时,它的<font color="#ff502c">argumens</font>继承于改普通函数</td>
</tr>
<tr>
<td style="text-align:center">可否 new</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">箭头函数作为匿名函数,是不能作为构造函数的(因为箭头函数没有 constructor),不能使用 new,不然会报错</td>
</tr>
<tr>
<td style="text-align:center">可否改变 this 指向</td>
<td style="text-align:center">可以通过 call、apply、bind 改变 this 的指向</td>
<td style="text-align:center">箭头函数本身的 this 指向不能改变,但是可以修改它要捕获的对象的 this</td>
</tr>
</tbody>
</table>
<h2 id="箭头函数-this-指向的规则"><a href="#箭头函数-this-指向的规则" class="headerlink" title="箭头函数 this 指向的规则"></a>箭头函数 this 指向的规则</h2><h3 id="1-箭头函数的-this-在定义的时候捕获自外层第一个普通函数的-this"><a href="#1-箭头函数的-this-在定义的时候捕获自外层第一个普通函数的-this" class="headerlink" title="1.箭头函数的 this 在定义的时候捕获自外层第一个普通函数的 this"></a>1.箭头函数的 this 在定义的时候捕获自外层第一个普通函数的 this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.b();</span><br><span class="line">obj.c();</span><br></pre></td></tr></table></figure>
<p><strong>箭头函数外层没有普通函数，严格模式和非严格模式下它的 this 都会指向 window(全局对象)</strong><br><strong>this 对象的指向是可变的，但是在箭头函数中，它是固定的。</strong></p>
<h3 id="2-不能直接修改箭头函数的-this-指向-但是可以通过修改外层函数的-this"><a href="#2-不能直接修改箭头函数的-this-指向-但是可以通过修改外层函数的-this" class="headerlink" title="2.不能直接修改箭头函数的 this 指向,但是可以通过修改外层函数的 this"></a>2.不能直接修改箭头函数的 this 指向,但是可以通过修改外层函数的 this</h3><p><strong>不能通过 call、apply、bind 改变 this</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.b.call(&#123; <span class="attr">a</span>: <span class="number">30</span> &#125;); <span class="comment">// 30</span></span><br><span class="line">obj.c.call(&#123; <span class="attr">a</span>: <span class="number">40</span> &#125;); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>由于箭头函数<strong>没有</strong>自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。<br><strong>但是可以改变它外部普通函数的 this 指向，箭头函数也会跟着改变。</strong></p>
<font color="#ff502c">函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</font>

<h3 id="3-箭头函数没有prototype-原型-，所以箭头函数本身没有-this"><a href="#3-箭头函数没有prototype-原型-，所以箭头函数本身没有-this" class="headerlink" title="3.箭头函数没有prototype(原型)，所以箭头函数本身没有 this"></a>3.箭头函数没有<font color="#ff502c">prototype</font>(原型)，所以箭头函数本身没有 this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bb = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bb.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="4-箭头函数是匿名函数，不能作为构造函数，不能使用-new"><a href="#4-箭头函数是匿名函数，不能作为构造函数，不能使用-new" class="headerlink" title="4.箭头函数是匿名函数，不能作为构造函数，不能使用 new"></a>4.箭头函数是匿名函数，不能作为构造函数，不能使用 new</h3><p>如果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bb = <span class="keyword">new</span> aa(); <span class="comment">// Uncaught TypeError: aa is not a constructor</span></span><br></pre></td></tr></table></figure>
<h3 id="5-箭头函数的-arguments"><a href="#5-箭头函数的-arguments" class="headerlink" title="5.箭头函数的 arguments"></a>5.箭头函数的 arguments</h3><ul>
<li>箭头函数的 this 指向全局，使用 arguments 会报未声明的错误</li>
<li>箭头函数的 this 指向普通函数时,它的 argumens 继承于该普通函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bb = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> aa = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">  &#125;;</span><br><span class="line">  cc();</span><br><span class="line">&#125;;</span><br><span class="line">aa.call(&#123; <span class="attr">name</span>: <span class="string">'aa'</span> &#125;);</span><br><span class="line">bb();</span><br></pre></td></tr></table></figure>
<p>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<h3 id="箭头函数不能当做-Generator-函数-不能使用-yield-关键字"><a href="#箭头函数不能当做-Generator-函数-不能使用-yield-关键字" class="headerlink" title="箭头函数不能当做 Generator 函数,不能使用 yield 关键字"></a>箭头函数不能当做 Generator 函数,不能使用 yield 关键字</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>箭头函数注意事项</strong></p>
<ul>
<li><strong>箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名</strong></li>
<li><strong>箭头函数一条语句返回对象字面量，需要加括号</strong></li>
<li><strong>箭头函数在参数和箭头之间不能换行！</strong></li>
<li><strong>箭头函数不支持 new.target</strong></li>
<li><strong>箭头函数的 this 意外指向和代码的可读性。</strong></li>
</ul>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么在vue中推荐使用Mixins</title>
    <url>/blog/vue/optimization/vue-Mixins-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Mixins</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Vue中双向绑定的原理（mvvm）</title>
    <url>/blog/vue/principle/vue-mvvm.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Http系列(二) Http2中的多路复用</title>
    <url>/blog/network/http/http-http2-1.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>多路复用</code>代替原来的<code>序列和阻塞机制</code>，所有就是请求的都是通过<code>一个 TCP 连接并发</code>完成。同时也很好的解决了<code>浏览器限制同一个域名下</code>的<code>请求数量</code>的问题。</p>
<p>在 HTTP/2 中，有了二进制分帧之后，HTTP/2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2 中：</p>
<ul>
<li><strong>同域名下所有通信都在单个连接上完成，同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应</strong>。</li>
<li><strong>单个连接可以承载任意数量的双向数据流，单个连接上可以并行交错的请求和响应，之间互不干扰</strong>。</li>
<li><strong>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低</strong>。</li>
</ul>
<h2 id="帧（frame）和流（stream）"><a href="#帧（frame）和流（stream）" class="headerlink" title="帧（frame）和流（stream）"></a>帧（frame）和流（stream）</h2><p>在 HTTP/2 中，有两个非常重要的概念：帧（frame）和流（stream）。</p>
<h3 id="帧（frame）"><a href="#帧（frame）" class="headerlink" title="帧（frame）"></a>帧（frame）</h3><p>HTTP/2 中<strong>数据传输的最小单位</strong>，因此帧不仅要细分表达 HTTP/1.x 中的各个部份，也优化了 HTTP/1.x 表达得不好的地方，同时还增加了 HTTP/1.x 表达不了的方式。<br>每一帧都包含几个字段，有<strong>length、type、flags、stream identifier、frame playload</strong>等，其中<code>type 代表帧的类型</code>，在 HTTP/2 的标准中定义了 10 种不同的类型，包括上面所说的 HEADERS frame 和 DATA frame。此外还有：<br><code>PRIORITY</code>（设置流的优先级）<br><code>RST_STREAM</code>（终止流）<br><code>SETTINGS</code>（设置此连接的参数）<br><code>PUSH_PROMISE</code>（服务器推送）<br><code>PING</code>（测量 RTT）<br><code>GOAWAY</code>（终止连接）<br><code>WINDOW_UPDATE</code>（流量控制）<br><code>CONTINUATION</code>（继续传输头部数据）</p>
<p>在 HTTP 2.0 中，它把数据报的两大部分分成了 <code>header frame</code> 和 <code>data frame</code>。也就是头部帧和数据体帧。</p>
<h3 id="流（stream）"><a href="#流（stream）" class="headerlink" title="流（stream）"></a>流（stream）</h3><p>流： 存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。<br>HTTP/2 长连接中的数据包是不按请求-响应顺序发送的，一个完整的请求或响应(称一个数据流 stream，每个数据流都有一个独一无二的编号)可能会分成非连续多次发送。它具有如下几个特点：</p>
<ul>
<li><strong>双向性：同一个流内，可同时发送和接受数据</strong>。</li>
<li><strong>有序性：流中被传输的数据就是二进制帧 。帧在流上的被发送与被接收都是按照顺序进行的</strong>。</li>
<li><strong>并行性：流中的 二进制帧 都是被并行传输的，无需按顺序等待</strong>。</li>
<li><strong>流的创建：流可以被客户端或服务器单方面建立, 使用或共享</strong>。</li>
<li><strong>流的关闭：流也可以被任意一方关闭</strong>。</li>
<li><strong>HEADERS 帧在 DATA 帧前面</strong>。</li>
<li><strong>流的 ID 都是奇数，说明是由客户端发起的，这是标准规定的，那么服务端发起的就是偶数了</strong>。</li>
</ul>
<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>从 Http/0.9 到 Http/2 要发送多个请求，从<strong>多个 Tcp 连接=&gt;keep-alive=&gt;管道化=&gt;多路复用</strong>不断的减少多次创建 Tcp 等等带来的性能损耗。</p>
<h3 id="多个-Tcp-连接"><a href="#多个-Tcp-连接" class="headerlink" title="多个 Tcp 连接"></a>多个 Tcp 连接</h3><p>在最早的时候没有<code>keep-alive</code>只能创建多个<code>Tcp</code>连接来做多次请求。多次 http 请求效果如下图所示：<br><img src="./http-http2-1/http2.0-1-6.png" alt="http2.0" width="50%"><br>一次请求完成就会关闭本次的 Tcp 连接，下个请求又要从新建立 Tcp 连接传输完成数据再关闭，造成很大的性能损耗。</p>
<h3 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h3><p><code>Keep-Alive</code>解决的核心问题是： 一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是<strong>可以配置</strong>的，不管你用的是<code>Apache</code>还是<code>nginx</code>。<br>以往，浏览器判断响应数据是否接收完毕，是看连接是否关闭。在使用持久连接后，就不能这样了，这就要求服务器对持久连接的响应头部一定要返回<code>content-length</code>标识<code>body的</code>长度，供浏览器判断界限。有时，<code>content-length</code>的方法并不是太准确，也可以使用 <code>Transfer-Encoding: chunked</code> 头部发送一串一串的数据，最后由长度为 0 的<code>chunked</code>标识结束。<br>多次 http 请求效果如下图所示：<br><img src="./http-http2-1/http2.0-1-7.png" alt="http2.0" width="50%"><br>上图：设置 Connection:Keep-Alive，保持连接在一段时间内不断开。</p>
<p><code>Keep-Alive</code>还是存在如下问题：</p>
<ul>
<li>串行的文件传输。</li>
<li>同域并行请求限制带来的阻塞（6~8）个</li>
</ul>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p><code>HTTP 管线化</code>可以<code>克服同域并行请求限制带来的阻塞</code>，它是建立在<strong>持久连接</strong>之上，是把所有请求一并发给服务器，但是服务器需要按照<strong>顺序一个一个响应</strong>，而不是等到一个响应回来才能发下一个请求，这样就节省了很多请求到服务器的时间。不过，HTTP 管线化<strong>仍旧</strong>有阻塞的问题，若上一响应迟迟不回，<strong>后面的响应</strong>都会被阻塞到。<br><img src="./http-http2-1/http2.0-1-8.png" alt="http2.0" width="50%"><br>上图：HTTPpipelining：建立多个连接</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>多路复用代替原来的<code>序列和阻塞机制</code>。所有就是请求的都是通过<code>一个 TCP 连接并发</code>完成。因为在多路复用之前所有的传输是基于<code>基础文本的</code>，在多路复用中是基于<code>二进制数据帧</code>的传输、<code>消息</code>、<code>流</code>，所以可以做到乱序的传输。<code>多路复用</code>对同一域名下所有请求都是基于<code>流</code>，所以<code>不存在</code>同域并行的阻塞。多次请求如下图：<br><img src="./http-http2-1/http2.0-1-9.png" alt="http2.0" width="50%"><br>上图：多路复用</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）</strong>。</p>
<p><strong>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流</strong>。</p>
<p><strong>HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效</strong>。</p>
<p>多路复用代替了 HTTP1.x 的<strong>序列和阻塞机制</strong>，所有的相同域名请求都通过<strong>同一个 TCP 连接并发</strong>完成。<strong>同一 Tcp 中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.kancloud.cn/digest/web-performance-http2/74825" target="_blank" rel="noopener">多路复用</a><br><a href="https://segmentfault.com/a/1190000018401534" target="_blank" rel="noopener">一文读懂 HTTP/2 及 HTTP/3 特性</a><br><a href="https://zhuanlan.zhihu.com/p/26559480" target="_blank" rel="noopener">一文读懂 HTTP/2 特性</a><br><a href="https://segmentfault.com/a/1190000011172823" target="_blank" rel="noopener">浅析 HTTP/2 的多路复用</a></p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Http2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的变量提升</title>
    <url>/blog/javascript/scope/hoisting.html</url>
    <content><![CDATA[<h2 id="产生变量提升的原因"><a href="#产生变量提升的原因" class="headerlink" title="产生变量提升的原因"></a>产生变量提升的原因</h2><p>在 ES6 之前，JavaScript <code>没有块级作用域(一对花括号{}即为一个块级作用域)</code>，大致分为<code>全局作用域</code>和<code>函数作用域</code>。变量提升即将变量声明提升到它所在<code>作用域</code>的<code>最开始</code>的部分。<br>在 JavaScript 代码运行之前其实是有一个<code>编译阶段</code>的。编译之后才是<code>从上到下</code>，一行一行解释执行。变量提升就发生在<code>编译阶段</code>，它把<code>变量</code>和<code>函数</code>的声明提升至作用域的顶端。（编译阶段的工作之一就是将变量与其作用域进行关联）。我先分开介绍变量提升和函数提升到后面再放到一起比较。<br>如果想更深入的了解<a href="https://www.cnblogs.com/liuhe688/p/5891273.html" target="_blank" rel="noopener">产生变量提升的原因</a><br><strong><code>注意</code></strong></p>
<ol>
<li>同一个变量只会<code>声明一次</code>，其它的会被覆盖掉。</li>
<li><code>变量提升/函数提升</code>是提升到<code>当前作用域</code>的顶部，如果遇到特殊的<code>if(){}/try-cache</code>作用域，同时也会把也会提升到<code>特殊作用域</code>的外部。</li>
<li><code>函数提升</code>的优先级是高于<code>变量提升</code>的优先级，并且<code>函数声明</code>和<code>函数定义</code>的部分一起被提升。</li>
</ol>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>我们直接从代码从最基础的开始</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>相信这个大家知道，上面代码其实就是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>他会提前声明 a,但是不会给 a 赋值。<br>但是如下代码会怎么执行呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果没有通过 var 声明值类型的就不会存在变量提升，而是会报错。</p>
<h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p><code>声明函数</code>有两种方式: 一种是<code>函数表达式</code>，另一种是<code>函数声明</code>。</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> aa = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 代码分解 ***/</span></span><br><span class="line"><span class="keyword">var</span> aa;</span><br><span class="line"><span class="built_in">console</span>.log(aa);</span><br><span class="line">aa = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><code>函数表达式</code>和<code>变量</code>的提升效果基本上是一致的，它会输出<code>undefined</code>。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>它和<code>函数表达式</code>是有点不一样的，在没有<code>{}作用域</code>时它们表现是一致的。表现一致的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 代码分解 ***/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<p>那如果<code>变量提升</code>和<code>函数提升</code>同时存在，谁先谁后呢? 我们根据上面的注意事项<code>1</code>和<code>3</code>可以得出结果，根据实例来分析一下。 请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// aaaa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 代码分解 ***/</span></span><br><span class="line"><span class="keyword">var</span> aa; <span class="comment">// 只会声明一次的变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 变量别覆盖为 aa 字面量函数</span></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125; 输出字面量函数</span></span><br><span class="line">aa = <span class="string">'aaaa'</span>; <span class="comment">// aa 重新被覆盖为 'aaaa'</span></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// aaaa 输出最后的覆盖值</span></span><br></pre></td></tr></table></figure>
<p>其实我们可以通过<code>chrome</code>浏览器调试效果大致如下图所示：<br><img src="./hoisting/javascirpt-hosting-1.png" alt="hosting-debugger"></p>
<p>到这里就大致知道<code>变量提升</code>、<code>函数提升</code>它们的大致过程和它们之间的<code>优先级</code>。下面我们来说一下它们和<code>块级作用域</code>和<code>函数作用域</code>的关系。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在<code>ES6</code>出现之后作用域变得很复杂，有太多种了，这里只说和本篇文章相关的几种作用域。我们只看<code>全局作用域</code>、<code>词法作用域</code>、<code>块级作用域</code>、<code>函数作用域</code>这四种作用域。<br><code>全局作用域</code>基本上没什么好说的，上面的样例基本上都是<code>全局作用域</code>，这里就不做多的赘述。</p>
<h3 id="词法作用域-函数作用域"><a href="#词法作用域-函数作用域" class="headerlink" title="词法作用域/函数作用域"></a>词法作用域/函数作用域</h3><p>词法作用域：<code>函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行。</code><br>我们直接通过一个例子来分析一下：</p>
<p>在有<code>作用域</code>时，我们来看一下<code>函数声明</code>的表现，还是通过一个实例来分析一下，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 如果直接输入 会报错 VM1778:1 Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>下面修改代码来分析在<code>函数作用域</code>中<code>函数声明</code>的特殊表现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// aaaa</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> aa = <span class="string">'bbbb'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// bbbb</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 代码分解 ***/</span></span><br><span class="line"><span class="keyword">var</span> aa;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line">aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// aaaa</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> aa;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line">  aa = <span class="string">'bbbb'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// bbbb</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>全局声明了一个名字叫做<code>aa</code>的变量，它被提升全局域的顶部声明，而在<code>test</code>函数中我们又声明了一个变量<code>aa</code>,这个变量在当前<code>函数作用</code>的顶部声明。在函数的执行的阶段，变量的读取都是就近原则，先从当先的<code>活动对象</code>或<code>作用域</code>查找，如果没有才会从<code>全局对象</code>或<code>全局作用域</code>查找。</p>
<p>稍微加大一点难度，修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// aaaa</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// aaaa</span></span><br><span class="line">  aa = <span class="string">'bbbb'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// bbbb</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 代码分解 ***/</span></span><br><span class="line"><span class="keyword">var</span> aa;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line">aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// aaaa</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// aaaa</span></span><br><span class="line">  aa = <span class="string">'bbbb'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// bbbb</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>我们把<code>test函数</code>内部的<code>var aa = &#39;bbbb&#39;</code>修改为<code>aa = bbbb</code>，这样就<code>不存在变量提升</code>只是一个简单<code>变量覆盖赋值</code>。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在<code>ES6</code>中新增了<code>块级作用域</code>，我们可以通过<code>let/const</code>来创建<code>块级作用域</code>，只能在当前<code>块中访问</code>通过<code>let/const</code>声明的变量。<br>我们简单的了解一下<code>let</code>和<code>块级作用域</code>，请看下方的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(aa); // VM439541:1 Uncaught SyntaxError: Identifier 'aa' has already been declared</span></span><br><span class="line">  <span class="keyword">let</span> aa = <span class="string">'aaa'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// VM439096:4 Uncaught ReferenceError: aa is not defined</span></span><br></pre></td></tr></table></figure>
<p>在<code>if条件语句</code>内部通过<code>let aa = &#39;aaa&#39;</code>中的<code>let</code>关键字创建了一个<code>块级作用域</code>，所以我们在外面不能访问<code>aa</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// VM440010:1 Uncaught ReferenceError: aa is not defined</span></span><br><span class="line"><span class="keyword">let</span> aa = <span class="string">'aaa'</span>;</span><br></pre></td></tr></table></figure>
<p><code>let</code>声明的变量同时存在<code>DTZ(暂时性死区)</code>，在<code>let</code>声明变量之前使用这个变量，会触发<code>DTZ(暂时性死区)</code>报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aa = <span class="string">'aaa'</span>;</span><br><span class="line"><span class="keyword">let</span> aa = <span class="string">'aaa'</span>;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'aa' has already been declared</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>不能多次声明同一个变量，不然会报错。</p>
<h3 id="if-判断-try-cache"><a href="#if-判断-try-cache" class="headerlink" title="if 判断/try-cache"></a>if 判断/try-cache</h3><p><code>if(){}/try-cache(){}</code>它们算一个作用域吗？我们通过下面的例子一步一步的分析它们，我们以<code>if</code>为分析样例请看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> aa = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**代码分析**/</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  aa = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>在<code>变量提升</code>时<code>if</code>是<code>不存在作用域</code>的，它的作用域就是全局作用域。那如果是<code>函数提升</code>呢？<code>if会存在作用域</code>吗？<br>通过下面这个实例我们大概会了解<code>函数提升</code>和<code>if</code>的关系：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">//function aa () &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**代码分析**/</span></span><br><span class="line"><span class="keyword">var</span> aa;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">//function aa () &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过这个可以看到当前执行的结果和上面所描述的<code>函数提升</code>表现并不一致，它只是提升了<code>aa</code>的声明，赋值只是发生在<code>if</code>内部的，这也是<code>函数提升</code>在<code>if</code>中特异的表现。再来一个更特异的<code>if</code>和<code>函数提升</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// **** 执行序号 5</span></span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// **** 执行序号 6</span></span><br><span class="line">  aa = <span class="number">1</span>; <span class="comment">// **** 执行序号 7</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// **** 执行序号 8</span></span><br><span class="line">  <span class="built_in">console</span>.log(aa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa);</span><br><span class="line"><span class="comment">/**代码分析 执行顺序**/</span></span><br><span class="line"><span class="keyword">var</span> aa;</span><br><span class="line">aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125;</span></span><br><span class="line">  aa = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// function aa () &#123;&#125; 再执行一遍</span></span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 1 ?这个确定对？</span></span><br></pre></td></tr></table></figure>
<p>我们主要观察<code>if</code>内部的<code>aa = 1; function aa () {}</code>的顺序，在当前代码中<code>第二个console.log(aa)</code>会输出一个<code>1</code>，如果我们把<code>aa = 1; function aa () {}</code>改为<code>function aa () {}; aa = 1;</code> 它外部的<code>console.log(aa)</code>就会变化，看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="comment">// **** 执行序号 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125; **** 执行序号 2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// **** 执行序号 3</span></span><br><span class="line">  aa = <span class="number">1</span>； <span class="comment">// **** 执行序号 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**代码分析 执行顺序**/</span></span><br><span class="line"><span class="keyword">var</span> aa;</span><br><span class="line">aa = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125;</span></span><br><span class="line">  <span class="comment">// function aa () &#123;&#125; 再执行一遍</span></span><br><span class="line">  aa = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// function aa () &#123;&#125; ?这个确定对？</span></span><br></pre></td></tr></table></figure>
<p>如果是按上面分析的代码执行顺序是相同的，但是为什么结果不太相同，这种资料不太好找，我们直接上代码去<code>chrome</code>中调试一下代码就一清二楚了，大致调试过程如下：</p>
<p><strong><code>function aa () {}; aa = 1;</code>执行过程</strong></p>
<ol>
<li><p>执行序号 1 时： 进入<code>if</code>内部执行，在<code>scope</code>中会多出来一个<code>block</code>，也就是在<code>作用域链</code>中会多出来一个<code>block</code>，这个作用域中有<code>aa = function aa () {}</code>。如下图所示：<br><img src="./hoisting/javascirpt-hosting-2.png" alt="hosting-debugger"><br>这个时候<code>block</code>是<code>function aa() {}</code>而全局的<code>window.aa</code>现在还是<code>aaaa</code></p>
</li>
<li><p>执行序号 2 时： 执行<code>console.log(aa)</code>,这个只是一个输出语法并不会改变变量的值,执行效果没有变。<br><img src="./hoisting/javascirpt-hosting-3.png" alt="hosting-debugger"></p>
</li>
<li><p>执行序号 3 时: 执行<code>function aa() {}</code>, 我们可以看到<code>block</code>和<code>全局作用域</code>的<code>aa</code>变量都改变为<code>function aa () {}</code>，如下图所示：<br><img src="./hoisting/javascirpt-hosting-4.png" alt="hosting-debugger"></p>
</li>
<li><p>执行序号 4 时: 它会执行的代码<code>aa = 1</code>，这个时候根据作用域链的规则，就近获取和修改变量。所以<code>block</code>内的<code>aa = 1</code>,而全局变量<code>window.aa = function aa () {}</code> 如下图所示：<br><img src="./hoisting/javascirpt-hosting-5.png" alt="hosting-debugger"></p>
</li>
</ol>
<p><strong><code>aa = 1; function aa () {};</code>执行过程</strong></p>
<ol>
<li><p>执行序号 5 时： 进入<code>if</code>内部执行，在<code>scope</code>中会多出来一个<code>block</code>，也就是在<code>作用域链</code>中会多出来一个<code>block</code>，这个作用域中有<code>aa = function aa () {}</code>。如下图所示：<br><img src="./hoisting/javascirpt-hosting-2.png" alt="hosting-debugger"><br>这个时候<code>block</code>是<code>function aa() {}</code>而全局的<code>window.aa</code>现在还是<code>aaaa</code></p>
</li>
<li><p>执行序号 6 时： 执行<code>console.log(aa)</code>,这个只是一个输出语法并不会改变变量的值,执行效果没有变。<br><img src="./hoisting/javascirpt-hosting-3.png" alt="hosting-debugger"></p>
</li>
<li><p>执行序号 7 时: 执行<code>aa = 1</code>, 我们可以看到<code>block</code>作用域的变量<code>aa</code>被赋值为了<code>1</code>，而<code>全局作用域</code>中的变量<code>aa</code>还是<code>aaaa</code>。如下图所示：<br><img src="./hoisting/javascirpt-hosting-6.png" alt="hosting-debugger"></p>
</li>
<li><p>执行序号 8 时: 它会执行的代码<code>function aa() {}</code>，当前代码执行完成时，我们会发现<code>全局作用域</code>中的变量<code>aa</code>也被赋值为<code>1</code>. 如下图所示：<br><img src="./hoisting/javascirpt-hosting-7.png" alt="hosting-debugger"></p>
</li>
</ol>
<p><strong><code>aa = 1;</code>执行过程</strong><br>当没有<code>function aa () {};</code>函数声明时，我们会发现不会产生一个临时的<code>block</code>作用域，也不会存在奇特的现象。</p>
<p>综合上面三个实例中我们可以得出以下的结论：</p>
<ul>
<li>在<code>if</code>内部包含了<code>函数声明</code>会在内部产生一个<code>block作用域</code>，在不包含时不会产生<code>block作用域</code>。</li>
<li>在当前<code>if</code>外部存在和<code>函数声明</code>相同的<code>变量名称</code>时，当执行到<code>函数声明</code>时同时会更新外部<code>函数作用域or全局作用域</code>中变量的值，只更新当前执行的这一次。</li>
</ul>
<p>我们再来一个例子来证明我们得到的结论，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// debugger</span></span><br><span class="line">  <span class="keyword">var</span> aa = <span class="string">'aaaa'</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(aa); <span class="comment">// 第一个 ƒ aa () &#123;&#125;</span></span><br><span class="line">    aa = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(aa); <span class="comment">// 第二个 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(aa); <span class="comment">// 第三个 1</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 第四个 VM5607:13 Uncaught ReferenceError: aa is not defined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个<code>console.log(aa)</code>会输出<code>ƒ aa () {}</code>，因为<code>函数声明</code>的提升和赋值都会放到<code>if</code>的内部。同时会产生一个<code>block作用域</code>。</li>
<li>第二个<code>console.log(aa)</code>会输出<code>if</code>内部中的<code>aa = 1</code>，因为<code>a = 1</code>会把<code>if</code>产生的<code>block作用域</code>中的变量<code>aa</code>修改为了<code>1</code>。</li>
<li>第三个<code>console.log(aa)</code>会输出<code>test函数作用域</code>中的<code>aa = 1</code>，因为在执行<code>function aa () {}</code>是都会更新外部变量<code>aa</code>的值为<code>1</code>，也就是<code>test函数作用域</code>中的<code>aa = 1</code>;</li>
<li>第四个<code>console.log(aa)</code>会输出<code>全局作用域</code>中的<code>aa</code>，因为从来没有声明过全局变量<code>aa</code>所以会报错，<code>is not defined</code>。</li>
</ul>
<h2 id="来两道题"><a href="#来两道题" class="headerlink" title="来两道题"></a>来两道题</h2><p>来两道题加深一下印象。</p>
<h3 id="第一道题"><a href="#第一道题" class="headerlink" title="第一道题"></a>第一道题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>
<p>如果只能答出来就没有必要看了。</p>
<p>如果变量提升遇到函数提升，那个优先级更高呢，看下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>看上面的代码知道<code>函数提升</code>是<code>高于变量提升</code>的，因为在 javascript 中函数是一等公民，<code>并且不会被变量声明覆盖</code>，但是会被<code>变量赋值覆盖</code>。其实代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(1);&#125;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>我们再来一个稍微复杂一点的，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(2);&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<p>在多次函数提升的会后一个覆盖前一个，然后才是变量提升，其实代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;console.log(2);&#125;</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<h3 id="第二道题"><a href="#第二道题" class="headerlink" title="第二道题"></a>第二道题</h3><p>第二道题会比第一道题难一点点，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(aa);</span><br><span class="line"><span class="keyword">var</span> aa = <span class="string">'aaa'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(aa);</span><br><span class="line">  aa = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  aa = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(aa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa);</span><br></pre></td></tr></table></figure>
<p>如果上面的内容看懂了，大概这个题就会感觉很简单，大致过程如下：</p>
<ul>
<li>第一个<code>console.log(aa)</code>会输出<code>全局作用域</code>中的<code>aa</code>值为<code>undefined</code>，因为<code>var aa = &#39;aaa&#39;</code>会产生变量提升，会把<code>var aa;</code>放到全局作用域中的顶端，所以会输出<code>undefined</code>。</li>
<li>第二个<code>console.log(aa)</code>会输出<code>if</code>内部中的<code>aa = ƒ aa () {}</code>，<code>if</code>内部执行产生<code>block作用域</code>，并且<code>block作用域</code>内部的<code>ƒ aa () {}</code>被提升到顶部，所以会输出<code>ƒ aa () {}</code>。</li>
<li>第三个<code>console.log(aa)</code>会输出<code>block作用域</code>中的<code>aa = 2</code>，因为在执行<code>function aa () {}</code>是都会更新外部变量<code>aa</code>的值为<code>1</code>，也就是<code>全局作用域</code>中的<code>aa = 1</code>;</li>
<li>第四个<code>console.log(aa)</code>会输出<code>全局作用域</code>中的<code>aa</code>，因为在上一步中我们知道了<code>全局作用域</code>中的<code>aa = 1</code>，所以会输出<code>1</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line">ƒ aa () &#123;&#125;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>到此结束 JavaScript 中的变量提升，如果发现本篇文章没有涉及的变量提升的知识点和错误的地方，请大家多多指正、探讨。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>webSocket(二) 短轮询、长轮询、Websocket、sse</title>
    <url>/blog/network/socket/http-web-socket2.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Web Sockets 定义了一种在通过一个单一的 socket 在网络上进行<strong>全双工通讯的通道</strong>。仅仅是传统的 HTTP 通讯的一个增量的提高，尤其对于<strong>实时、事件驱动</strong>的应用来说是一个飞跃。<br>通过<code>Polling(轮询)</code>、<code>Long-Polling(长轮询)</code>、<code>Websocket</code>、<code>sse</code>的对比。四种 Web 即时通信技术比较它们的<strong>实现方式</strong>和<strong>各自的优缺点</strong>。<br>对比优缺点如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">轮询(Polling)</th>
<th style="text-align:center">长轮询(Long-Polling)</th>
<th style="text-align:center">Websocket</th>
<th style="text-align:center">sse</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通信协议</td>
<td style="text-align:center">http</td>
<td style="text-align:center">http</td>
<td style="text-align:center">tcp</td>
<td style="text-align:center">http</td>
</tr>
<tr>
<td style="text-align:center">触发方式</td>
<td style="text-align:center">client(客户端)</td>
<td style="text-align:center">client(客户端)</td>
<td style="text-align:center">client、server(客户端、服务端)</td>
<td style="text-align:center">client、server(客户端、服务端)</td>
</tr>
<tr>
<td style="text-align:center">优点</td>
<td style="text-align:center">兼容性好容错性强，实现简单</td>
<td style="text-align:center">比短轮询节约资源</td>
<td style="text-align:center">全双工通讯协议，性能开销小、安全性高，可扩展性强</td>
<td style="text-align:center">实现简便，开发成本低</td>
</tr>
<tr>
<td style="text-align:center">缺点</td>
<td style="text-align:center">安全性差，占较多的内存资源与请求数</td>
<td style="text-align:center">安全性差，占较多的内存资源与请求数</td>
<td style="text-align:center">传输数据需要进行二次解析，增加开发成本及难度</td>
<td style="text-align:center">只适用高级浏览器</td>
</tr>
<tr>
<td style="text-align:center">延迟</td>
<td style="text-align:center">非实时，延迟取决于请求间隔</td>
<td style="text-align:center">同短轮询</td>
<td style="text-align:center">实时</td>
<td style="text-align:center">非实时，默认 3 秒延迟，延迟可自定义</td>
</tr>
</tbody>
</table>
<p>上面基本上包含了各个实现方式的<strong>优点</strong>和<strong>缺点</strong>，它们基于什么<strong>协议</strong>、由那端<strong>主动</strong>发送数据。</p>
<h2 id="轮询-Polling"><a href="#轮询-Polling" class="headerlink" title="轮询(Polling)"></a>轮询(Polling)</h2><p><strong>短轮询(Polling)</strong>的实现思路就是<strong>浏览器端</strong>每隔几秒钟向<strong>服务器端</strong>发送<code>http</code>请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。<strong>在服务端响应完成，就会关闭这个 Tcp 连接</strong>，如下图所示：<br><img src="./http-web-socket2/websocket-1-1.jpg" alt="webSocket"><br>示例代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Polling</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fetch(url)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// somthing</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setInterval(polling, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：可以看到实现非常简单，它的<strong>兼容性</strong>也比较好的只要<strong>支持 http 协议</strong>就可以用这种方式实现。</li>
<li>缺点：但是它的缺点也很明显就是非常的消耗资源，因为建立<code>Tcp</code>连接是非常消耗资源的，服务端响应完成就会关闭这个<code>Tcp</code>连接，下一次请求再次建立<code>Tcp</code>连接。</li>
</ul>
<h2 id="COMET"><a href="#COMET" class="headerlink" title="COMET"></a>COMET</h2><p><strong>Alex Russell（Dojo Toolkit 的项目 Lead）</strong>称这种基于<code>HTTP长连接</code>、无须在浏览器端安装插件的“服务器推”技术为<code>“Comet”</code>。<br>常用的 COMET 分为两种：<strong>基于 HTTP 的长轮询（long-polling）技术，以及基于 iframe 的长连接流（stream）模式</strong>。</p>
<h3 id="长轮询（Long-Polling）"><a href="#长轮询（Long-Polling）" class="headerlink" title="长轮询（Long-Polling）"></a>长轮询（Long-Polling）</h3><p>客户端发送请求后服务器端<strong>不会立即</strong>返回数据，服务器端会<strong>阻塞请求</strong>连接不会<strong>立即断开</strong>，直到服务器端<strong>有数据更新或者是连接超时</strong>才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据。大致效果如下：<br><img src="./http-web-socket2/websocket-1-2.jpg" alt="webSocket"><br>客户端的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LongPolling</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fetch(url)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      LongPolling();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      LongPolling();</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">LongPolling();</span><br></pre></td></tr></table></figure>
<ul>
<li>优点： 长轮询和短轮询比起来，明显减少了很多不必要的 http 请求次数，相比之下节约了资源。</li>
<li>缺点：连接挂起也会导致资源的浪费。</li>
</ul>
<h3 id="基于-iframe-的长连接流（stream）模式"><a href="#基于-iframe-的长连接流（stream）模式" class="headerlink" title="基于 iframe 的长连接流（stream）模式"></a>基于 iframe 的长连接流（stream）模式</h3><p>当我们在页面中嵌入一个<code>iframe</code>并设置其 src 时，服务端就可以通过长连接<code>“源源不断”</code>地向客户端输出内容。<br>例如，我们可以向客户端返回一段<code>script</code>标签包裹的<code>javascript</code>代码，该代码就<code>会在 iframe 中执行</code>。因此，如果我们预先在<code>iframe</code>的父页面中定义一个<code>处理函数 process()</code>，而在每次有新数据需要<code>推送时</code>，在该连接响应中写入<code>&lt;script&gt;parent.process(\${your_data})&lt;/script&gt;</code>。那么 iframe 中的这段代码就会调用父页面中预先定义的<code>process()函数</code>。（是不是有点像 JSONP 传输数据的方式？）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在父页面中定义的数据处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不可见的iframe</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.style = <span class="string">'display: none'</span>;</span><br><span class="line"><span class="comment">// src指向后端接口</span></span><br><span class="line">iframe.src = <span class="string">'/long_iframe'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure>
<p>后端还是以 node 为例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回数据的方法，将数据拼装成script脚本返回给iframe</span></span><br><span class="line">  <span class="keyword">const</span> iframeSend = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="string">`&lt;script type="text/javascript"&gt;</span></span><br><span class="line"><span class="string">                        parent.process(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)</span></span><br><span class="line"><span class="string">                    &lt;/script&gt;`</span>;</span><br><span class="line">    res.write(script);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  res.setHeader(<span class="string">'connection'</span>, <span class="string">'keep-alive'</span>);</span><br><span class="line">  <span class="comment">// 注意设置相应头的content-type</span></span><br><span class="line">  res.setHeader(<span class="string">'content-type'</span>, <span class="string">'text/html; charset=utf-8'</span>);</span><br><span class="line">  <span class="comment">// 当有数据更新时，服务端“推送”数据给客户端</span></span><br><span class="line">  EVENT.addListener(MSG_POST, iframeSend);</span><br><span class="line"></span><br><span class="line">  req.socket.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'iframe socket close'</span>);</span><br><span class="line">    <span class="comment">// 注意在连接关闭时移除监听，避免内存泄露</span></span><br><span class="line">    EVENT.removeListener(MSG_POST, iframeSend);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="./http-web-socket2/websocket-1-3.gif" alt="webSocket"></p>
<blockquote>
<p>不过使用 iframe 有个小瑕疵，因此这个 iframe 相当于永远也不会加载完成，所以浏览器上会一直有一个 loading 标志。</p>
</blockquote>
<p>他的优缺点和上面的长轮询一样。</p>
<h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><p>WebSocket 的一些特性和基础使用方法在这里就不多赘述了，请看另一篇博客<a href="/blog/http/http-web-socket1.html">webSocket(一) 浅析</a>;<br>大致代码如下：<br><strong>服务端</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server: receive connection'</span>);</span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: recevied: %s'</span>, message);</span><br><span class="line">  &#125;);</span><br><span class="line">  ws.send(<span class="string">'world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">  ws.send(<span class="string">'from client:hello'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'from server:'</span> + e.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行效果如下：<br><img src="./http-web-socket2/web-socket-1-2.png" alt="webSocket"></p>
<ul>
<li>优点：不会造成性能的浪费</li>
<li>缺点：学习一套新的请求库</li>
</ul>
<h2 id="SSE-Server-Sent-Events"><a href="#SSE-Server-Sent-Events" class="headerlink" title="SSE (Server-Sent Events)"></a>SSE (Server-Sent Events)</h2><p><code>Server-Sent</code>是<code>HTML5</code>提出一个标准。由客户端发起与服务器之间创建<code>TCP</code>连接，然后<strong>并维持这个连接</strong>，直到客户端或服务器中的任何一方断开，<code>ServerSent</code>使用的是”问”+”答”的机制，连接创建后浏览器会周期性地发送消息至服务器询问，是否有自己的消息。其实现原理类似于我们在上一节中提到的<strong>基于 iframe 的长连接模式</strong>。<br>HTTP 响应内容有一种特殊的<code>content-type —— text/event-stream</code>，该响应头标识了响应内容为<strong>事件流</strong>，客户端<strong>不会关闭连接</strong>，而是等待服务端不断得发送响应结果。<br>SSE 规范比较简单，主要分为两个部分：浏览器中的<code>EventSource</code>对象，以及服务器端与浏览器端之间的<strong>通讯协议</strong>。</p>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>在浏览器中可以通过<code>EventSource</code>构造函数来创建该对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">'/sse'</span>);</span><br></pre></td></tr></table></figure>
<p>而<code>SSE</code>的响应内容可以看成是一个<strong>事件流</strong>，由不同的事件所组成。这些事件会触发前端<code>EventSource</code>对象上的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的事件</span></span><br><span class="line">source.addEventListener(</span><br><span class="line">  <span class="string">'message'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的事件名</span></span><br><span class="line">source.addEventListener(</span><br><span class="line">  <span class="string">'my_msg'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    process(e.data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接打开</span></span><br><span class="line">source.addEventListener(</span><br><span class="line">  <span class="string">'open'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'open sse'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误</span></span><br><span class="line">source.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>EventSource</code>通过事件监听的方式来工作。注意上面的代码监听了<code>y_msg</code>事件，SSE 支持自定义事件，默认事件通过监听 message 来获取数据。实现代码如下:</p>
<p><strong>客户端</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示聊天信息</span></span><br><span class="line"><span class="keyword">let</span> chat = <span class="keyword">new</span> EventSource(<span class="string">'/chat-room'</span>);</span><br><span class="line">chat.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = event.data;</span><br><span class="line">  $(<span class="string">'.list-group'</span>).append(<span class="string">"&lt;li class='list-group-item'&gt;"</span> + msg + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">  <span class="comment">// chat.close(); 关闭server-sent event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义事件</span></span><br><span class="line">chat.addEventListener(<span class="string">'myChatEvent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = event.data;</span><br><span class="line">  $(<span class="string">'.list-group'</span>).append(<span class="string">"&lt;li class='list-group-item'&gt;"</span> + msg + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>服务端 nodejs</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line">router.get(<span class="string">'/chat-room'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当res.white的数据data 以\n\n结束时 就默认该次消息发送完成，触发onmessage方法，以\r\n不会触发onmessage方法</span></span><br><span class="line">  res.header(&#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/event-stream'</span>,</span><br><span class="line">    <span class="string">'Cache-Control'</span>: <span class="string">'no-cache'</span>,</span><br><span class="line">    Connection: <span class="string">'keep-alive'</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// res.white("event: myChatEvent\r\n"); 自定义事件</span></span><br><span class="line">  res.write(<span class="string">'retry: 10000\r\n'</span>); <span class="comment">// 指定通信的最大间隔时间</span></span><br><span class="line">  res.write(<span class="string">'data: start~~\n\n'</span>);</span><br><span class="line">  res.end(); <span class="comment">// 不加end不会认为本次数据传输结束 会导致不会有下一次请求</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>优点： 客户端只需连接一次，Server 就定时推送，除非其中一端断开连接。并且 SSE 会在连接意外断开时自动重连。</li>
<li>缺点： 要学习新的语法</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面四种 Web 即时通信技术比较，可以从不同的角度考虑，它们的优先级是不同的，基本上可以分为两大类基于<code>http</code>和<code>tcp</code>两种通信中的一种。<br><strong>兼容性考虑</strong><br><code>短轮询&gt;长轮询&gt;长连接 SSE&gt;WebSocket</code><br><strong>从性能方面考虑</strong><br><code>WebSocket&gt;长连接 SSE&gt;长轮询&gt;短轮询</code><br><strong>服务端推送</strong><br><code>WebSocket&gt;长连接 SSE&gt;长轮询</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://juejin.im/post/5b135b78f265da6e420eab7d#heading-7" target="_blank" rel="noopener">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a> &gt; <a href="https://mp.weixin.qq.com/s/7KtvnY4zSfjORtxv30YaKQ" target="_blank" rel="noopener">JavaScript 服务器推送技术之 WebSocket</a> &gt; <a href="https://www.cnblogs.com/huchong/p/8595644.html" target="_blank" rel="noopener">轮询、长轮询、长连接、websocket</a> &gt; <a href="https://www.jianshu.com/p/ef054d3d1b62" target="_blank" rel="noopener">消息推送机制-轮询、长轮询、SSE(Server Sent Event)和 WS(WebSocket)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Http系列(三) Http/Tcp三次握手和四次挥手</title>
    <url>/blog/network/http/http-tcp.html</url>
    <content><![CDATA[<h2 id="TCP-概念"><a href="#TCP-概念" class="headerlink" title="TCP 概念"></a>TCP 概念</h2><p><code>TCP(Transmission Control Protocol 传输控制协议)</code>是一种面向连接(连接导向)<code>的、</code>可靠<code>的、</code>基于 IP 的传输层<code>协议。 首先来看看 OSI 的七层模型 ![OSI](./http-tcp/1.jpg) 我们需要知道</code>TCP<code>工作在网络 OSI 的七层模型中的第四层——</code>传输层，IP 在第三层——网络层，ARP 在第二层——数据链路层`;同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上<strong>头部信息</strong>，进行 封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封 装的过程。在 OSI 七层模型中，每一层的作用和对应的协议如下：<br><img src="./http-tcp/http-1-1.jpg" alt="OSI"></p>
<p><strong>标志位</strong><br>要理解三次握手四次挥手，首先要理解几个比较重要的标示如 SYN、ACK，如下面的表格所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SYN</td>
<td style="text-align:center">请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为 1</td>
</tr>
<tr>
<td style="text-align:center">ACK</td>
<td style="text-align:center">确认号是否有效，一般置为 1。</td>
</tr>
<tr>
<td style="text-align:center">FIN</td>
<td style="text-align:center">释放一个连接。</td>
</tr>
<tr>
<td style="text-align:center">PSH</td>
<td style="text-align:center">提示接收端应用程序立即从 TCP 缓冲区把数据读走。</td>
</tr>
<tr>
<td style="text-align:center">RST</td>
<td style="text-align:center">对方要求重新建立连接，复位。</td>
</tr>
<tr>
<td style="text-align:center">URG</td>
<td style="text-align:center">紧急指针（urgent pointer）有效。</td>
</tr>
</tbody>
</table>
<p><strong>序号</strong></p>
<ul>
<li>序号：Seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li>
<li>确认序号：Ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。</li>
</ul>
<p>三次握手四次挥手整体的流程如下图所示：<br><img src="./http-tcp/http-1-3.jpg" width="50%"></p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>三次握手的过程大致如下图所示：<br><img src="./http-tcp/http-1-2.png" alt="OSI"><br>大致步骤如下：</p>
<h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p><strong>客户端向服务器发出连接请求报文</strong>，这时报文首部中的同部位<code>SYN=1</code>，同时随机生成<code>初始序列号 seq=x</code>，此时，TCP 客户端进程进入了 <code>SYN-SENT（同步已发送状态）状态</code>。TCP 规定，<code>SYN 报文段（SYN=1 的报文段）</code>不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。</p>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p><strong><code>TCP</code>服务器收到请求报文后</strong>，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK=1，SYN=1</code>，确认号是<code>ack=x+1</code>，同时也要为自己随机初始化一个<code>序列号 seq=y</code>，此时，TCP 服务器进程进入了<code>SYN-RCVD（同步收到）状态</code>。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有<code>SYN(建立连接)</code>和<code>ACK(确认)标志</code>，询问客户端是否准备好。</p>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p><strong><code>TCP</code>客户进程收到确认后，还要向服务器给出确认</strong>。<code>确认报文的 ACK=1，ack=y+1</code>，此时，TCP 连接建立，客户端进入<code>ESTABLISHED（已建立连接）状态</code>。TCP 规定，<code>ACK 报文段</code>可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。</p>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><blockquote>
<p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。</p>
</blockquote>
<p><strong>样例</strong><br>在谢希仁著《计算机网络》书中同时举了一个例子，如下：</p>
<blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p>
</blockquote>
<p>总结一下就是为了<strong>防止服务端的等待浪费资源</strong>。</p>
<h2 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h2><p>建立连接后，两台主机就可以相互传输数据了。如下图所示：<br><img src="./http-tcp/http-1-4.png" width="50%"></p>
<ul>
<li><strong>主机 A 初始 seq 为 1200,滑动窗体为 100,向主机 B 传递数据的过程</strong>。</li>
<li>假设主机 B 在完全成功接收数据的基础上,那么主机 B 为了确认这一点，向主机 A 发送 ACK 包，并将 Ack 号设置为 1301。因此按如下的公式确认 Ack 号：Ack 号 = Seq 号 + 传递的字节数 + 1 （这是在完全接受成功的情况下）</li>
<li>主机 A 获得 B 传来的 ack(1301)后,开始发送 seq 为 1301,滑动窗体为 100 的数据。</li>
</ul>
<p>与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。上面说了，主机 B 完全成功接收 A 发来的数据才是这样的,如果存在丢包该如何。下面分析传输过程中数据包丢失的情况，如下图所示：<br><img src="./http-tcp/http-1-5.png" width="50%"></p>
<p>上图表示通过 Seq 1301 数据包向主机 B 传递 100 字节的数据，但中间发生了错误，主机 B 未收到。经过一段时间后，主机 A 仍未收到对于 Seq 1301 的 ACK 确认，因此尝试重传数据。为了完成数据包的重传，TCP 套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>四次挥手流程大致如下图所示：<br><img src="./http-tcp/http-1-6.png" alt="OSI"></p>
<h3 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h3><p><code>客户端发送一个 FIN(结束)，用来关闭客户到服务端的连接</code>。<br>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<code>FIN=1</code>，其<code>序列号为 seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</p>
<h3 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h3><p><code>服务端收到这个 FIN，他发回一个 ACK(确认)，确认收到序号为收到序号+1，和 SYN 一样，一个 FIN 将占用一个序号</code>。<br>服务器收到连接释放报文，发出确认报文，<code>ACK=1，ack=u+1</code>，并且带上自己的<code>序列号 seq=v</code>，此时，服务端就进入了<code>CLOSE-WAIT（关闭等待）状态</code>。TCP 服务器<br>通知高层的应用进程，客户端向服务器的方向就释放了，<code>这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受</code>。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p>
<blockquote>
<p>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
</blockquote>
<h3 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h3><p><code>服务端发送一个 FIN(结束)到客户端，服务端关闭客户端的连接</code>。<br><code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1</code>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的<code>序列号为 seq=w</code>，此时，服务器就进入了<code>LAST-ACK（最后确认）状态</code>，等待客户端的确认。</p>
<h3 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h3><p><code>客户端发送 ACK(确认)报文确认，并将确认的序号+1，这样关闭完成</code>。<br><strong>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态</strong>。</p>
<blockquote>
<p>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p>
</blockquote>
<h2 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h2><ul>
<li><strong>为什么要三次握手</strong></li>
<li><strong>为什么是 4 次挥手</strong></li>
<li><strong>TCP 和 UDP 的区别</strong></li>
<li><strong>客户端突然挂掉了怎么办</strong></li>
<li><strong>为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态</strong></li>
<li><strong>浏览器同时可以开启多少个 http 链接</strong></li>
</ul>
<h3 id="为什么要三次握手（两次握手可以吗？）"><a href="#为什么要三次握手（两次握手可以吗？）" class="headerlink" title="为什么要三次握手（两次握手可以吗？）"></a>为什么要三次握手（两次握手可以吗？）</h3><p>client 发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达 server，本来这已经是一个失效的报文，但是 server 端接收到这个请求报文后，还是会想 client 发出确认的报文，表示同意连接。假如不采用三次握手，那么只要 server 发出确认，新的建立就连接了，但其实这个请求是失效的请求，client 是不会理睬 server 的确认信息，也不会向服务端发送确认的请求，但是 server 认为新的连接已经建立起来了，并一直等待 client 发来数据，这样，server 的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server 会因为收不到确认的报文，就知道 client 并没有建立连接。这就是三次握手的作用。</p>
<p>简单来说，就是为了<strong>防止服务端的等待浪费资源</strong></p>
<h3 id="为什么是-4-次挥手"><a href="#为什么是-4-次挥手" class="headerlink" title="为什么是 4 次挥手"></a>为什么是 4 次挥手</h3><p>握手的时候，A 和 B 打个招呼，B 可以直接把自己的 SYN 信息和对 A 的回应 ACK 信息一起带上，但是挥手的时候，A 说我要断开了，B 还没发完最后的数据，因此需要先回应一下 A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了 2 步：<br>（1）回应 A；<br>（2）发送自己的最后一个数据</p>
<p><strong>为了确保数据能够完成传输。</strong></p>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul>
<li>TCP 是<code>面向连接</code>的，udp 是<code>无连接</code>的即发送数据前不需要先建立链接。</li>
<li><code>TCP 保证数据正确性，UDP 可能丢包，TCP 保证数据顺序，UDP 不保证</code>。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付 Tcp 通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li><strong>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多</strong>。</li>
<li><strong>TCP 是面向字节流，UDP 面向报文，UDP 具有较好的实时性，工作效率比 TCP 高</strong>.并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</li>
<li><strong>TCP 对系统资源要求较多，UDP 对系统资源要求较少</strong>。</li>
<li><strong>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节</strong>。</li>
</ul>
<h3 id="客户端突然挂掉了怎么办"><a href="#客户端突然挂掉了怎么办" class="headerlink" title="客户端突然挂掉了怎么办"></a>客户端突然挂掉了怎么办</h3><p>正常连接时，客户端突然挂掉了，如果没有措施处理这种情况，那么就会出现客户端和服务器端出现<strong>长时期的空闲</strong>。解决办法是在<strong>服务器端设置保活计时器</strong>，每当服务器收到客户端的消息，就将计时器复位。<strong>超时时间通常设置为 2 小时</strong>。若服务器超过 2 小时没收到客户的信息，他就发送<strong>探测报文段</strong>。若发送了 10 个探测报文段，每一个相隔 75 秒，还没有响应就认为客户端出了故障，因而终止该连接。<br><strong>设置保活计时器</strong></p>
<h3 id="为什么-TIME-WAIT-状态需要经过-2MSL-最大报文段生存时间-才能返回到-CLOSE-状态"><a href="#为什么-TIME-WAIT-状态需要经过-2MSL-最大报文段生存时间-才能返回到-CLOSE-状态" class="headerlink" title="为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态"></a>为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态</h3><p><strong>TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文</strong><br>原因是，担心网络不可靠而导致的丢包，最后一个回应 B 的 ACK 万一丢了怎么办，在这个时间内，A 是可以重新发包的，但是超过了最大等待时间的话，就算收不到也没用了，所以就可以关闭了。</p>
<h3 id="浏览器同时可以开启多少个-http-链接"><a href="#浏览器同时可以开启多少个-http-链接" class="headerlink" title="浏览器同时可以开启多少个 http 链接"></a>浏览器同时可以开启多少个 http 链接</h3><p>浏览器对于同一个域名，一般 PC 端浏览器会针对<code>单个域名的 server</code>同时<code>建立 6 ～ 8 个连接</code>，<code>手机端</code>的连接数则一般控制在<code>4 ～ 6 个</code>（这个根据浏览器内核不同可能会有所差异），超过浏览器<code>最大连接数</code>限制，后续请求就会<code>被阻塞</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/qdhxhz/p/8470997.html" target="_blank" rel="noopener">TCP 三次握手和四次挥手</a><br><a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">TCP 的三次握手与四次挥手理解及面试题（很全面）</a><br><a href="https://mp.weixin.qq.com/s/efON3efZoDmHJg1os_3nqA" target="_blank" rel="noopener">通俗大白话来理解 TCP 协议的三次握手和四次分手</a></p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>webSocket(一) 浅析</title>
    <url>/blog/network/socket/http-web-socket1.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>WebSocket 由多个标准构成: WebSocket API 是 W3C 定义的，而 WebSocket 协议(RFC 6455)及其扩展则由 HyBi Working Group(IETF)定义。</p>
</blockquote>
<p>HTML5 开始提供的一种浏览器与服务器进行<code>全双工通讯的网络技术</code>，属于<code>应用层协议</code>。它基于<code>TCP 传输协议</code>，并<code>复用 HTTP 的握手通道</code>。<br><code>WebSocket</code> 可以实现<strong>客户端与服务器间双向</strong>、<strong>基于消息的文本或二进制数据传输</strong>。<code>WebSocket</code> 连接远远不是一个<strong>网络套接字</strong>，因为浏览器在这个简单的 API 之后隐藏了所有的复杂性，而且还提供了更多服务:</p>
<ul>
<li><code>连接协商和同源策略</code>;</li>
<li><code>与既有 HTTP 基础设施的互操作</code>;</li>
<li><code>基于消息的通信和高效消息分帧</code>;</li>
<li><code>子协议协商及可扩展能力</code>。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>为什么已经有了轮询还要 WebSocket 呢，是因为短轮询和长轮询有个缺陷：<code>通信只能由客户端发起</code>。<br>WebSocket 提供了一个<code>文明优雅的全双工通信</code>方案。一般适合于对数据的实时性要求比较强的场景，如通信、股票、直播、共享桌面，特别适合于客户端与服务频繁交互的情况下，如聊天室、实时共享、多人协作等平台。<br>他的主要特点如下：</p>
<ul>
<li><strong>建立在 TCP 协议之上，服务器端的实现比较容易。</strong></li>
<li><strong>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</strong></li>
<li><strong>数据格式比较轻量，性能开销小，通信高效。服务器与客户端之间交换的标头信息大概只有 2 字节;</strong></li>
<li><strong>可以发送文本，也可以发送二进制数据。</strong></li>
<li><strong>没有同源限制，客户端可以与任意服务器通信。</strong></li>
<li><strong>协议标识符是 <code>ws</code>（如果加密，则为 wss），服务器网址就是 URL。ex：<code>ws://example.com:80/some/path</code></strong></li>
<li><strong>不用频繁创建及销毁 TCP 请求，减少网络带宽资源的占用，同时也节省服务器资源;</strong></li>
<li><strong>WebSocket 是纯事件驱动的，一旦连接建立，通过监听事件可以处理到来的数据和改变的连接状态，数据都以帧序列的形式传输。服务端发送数据后，消息和事件会异步到达。</strong></li>
<li><strong>无超时处理。</strong></li>
</ul>
<h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p>
<ul>
<li><code>CONNECTING：值为 0，表示正在连接</code>。</li>
<li><code>OPEN：值为 1，表示连接成功，可以通信了</code>。</li>
<li><code>CLOSING：值为 2，表示连接正在关闭</code>。</li>
<li><code>CLOSED：值为 3，表示连接已经关闭，或者打开连接失败</code>。</li>
</ul>
<h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果要指定多个回调函数，可以使用addEventListener方法。</span></span><br><span class="line">ws.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line">ws.addEventListener(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="webSocket-onmessage-webSocket-send"><a href="#webSocket-onmessage-webSocket-send" class="headerlink" title="webSocket.onmessage()\webSocket.send()"></a>webSocket.onmessage()\webSocket.send()</h3><p><strong>webSocket.onmessage()</strong><br>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。也可以处理二进制数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，服务器数据可能是文本，也可能是二进制数据（`blob对象或Arraybuffer对象`）。</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received data string'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received arraybuffer'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">'blob'</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">'arraybuffer'</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>webSocket.send()</strong><br>实例对象的<code>send()</code>方法用于向服务器发送数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发送 Blob 对象的例子。</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.querySelector(<span class="string">'input[type="file"]'</span>).files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 ArrayBuffer 对象的例子。</span></span><br><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure>
<h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line">socket.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="webSocket-学习"><a href="#webSocket-学习" class="headerlink" title="webSocket 学习"></a>webSocket 学习</h2><p>对网络应用层协议的学习来说，最重要的往往就是<strong>连接建立过程、数据交换教程</strong>。当然，数据的格式是逃不掉的，因为它直接决定了协议本身的能力。好的数据格式能让协议更高效、扩展性更好。<br>大致可以通过下面的几个方面来学习:</p>
<ul>
<li><strong>如何建立连接</strong></li>
<li><strong>数据帧格式</strong></li>
<li><strong>数据传递</strong></li>
<li><strong>连接保持+心跳</strong></li>
<li><strong>Sec-WebSocket-Key/Accept 的作用</strong></li>
<li><strong>数据掩码的作用</strong></li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在正式介绍协议细节前，先来看一个简单的例子，有个直观感受。例子包括了<strong>WebSocket 服务端、WebSocket 客户端（网页端）</strong>。完整代码可以在 这里 找到。这里服务端用了<code>ws</code>这个库。相比大家熟悉的<code>socket.io</code>，ws 实现更<strong>轻量</strong>，更适合学习的目的。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>代码如下，监听<code>8080</code>端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server: receive connection'</span>);</span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: recevied: %s'</span>, message);</span><br><span class="line">  &#125;);</span><br><span class="line">  ws.send(<span class="string">'world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>服务端运行结果如下图所示：<br><img src="./http-web-socket1/web-socket-1-1.png" alt="webSocket"></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>代码如下，向 8080 端口发起 WebSocket 连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">  ws.send(<span class="string">'from client:hello'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'from server:'</span> + e.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端运行结果如下图所示：<br><img src="./http-web-socket1/web-socket-1-2.png" alt="webSocket"></p>
<h2 id="如何建立连接"><a href="#如何建立连接" class="headerlink" title="如何建立连接"></a>如何建立连接</h2><p>前面提到，WebSocket 复用了<code>HTTP 的握手通道</code>。具体指的是，客户端通过 HTTP 请求与 WebSocket<code>服务端协商升级协议</code>。协议升级完成后，后续的数据交换则遵照<code>WebSocket 的协议</code>。</p>
<h3 id="客户端：申请协议升级"><a href="#客户端：申请协议升级" class="headerlink" title="客户端：申请协议升级"></a>客户端：申请协议升级</h3><p>首先，客户端发起协议升级请求。可以看到，采用的是标准的 HTTP 报文格式，且只支持<code>GET 方法</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: localhost:<span class="number">8080</span></span><br><span class="line">Origin: http:<span class="comment">//127.0.0.1:3000</span></span><br><span class="line">Connection: Upgrade <span class="comment">// 表示要升级协议</span></span><br><span class="line">Upgrade: websocket <span class="comment">// 表示要升级到websocket协议。</span></span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span> <span class="comment">// 表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</span></span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw== <span class="comment">// 与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</span></span><br></pre></td></tr></table></figure>
<p>重点请求首部意义如下：</p>
<ul>
<li><code>Connection</code>: <code>Upgrade</code> 表示要升级协议</li>
<li><code>Upgrade: websocket</code>：表示要升级到 <code>websocket</code> 协议。</li>
<li><code>Sec-WebSocket-Version</code>: 13：表示 <code>websocket</code> 的版本。如果服务端不支持该版本，需要返回一个 <code>Sec-WebSocket-Versionheader</code>，里面包含服务端支持的版本号。</li>
<li><code>Sec-WebSocket-Key</code>：与后面服务端响应首部的 <code>Sec-WebSocket-Accept</code> 是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</li>
</ul>
<blockquote>
<p>注意，上面请求省略了部分非重点请求首部。由于是标准的 <code>HTTP</code> 请求，类似 <code>Host、Origin、Cookie</code> 等请求首部会照常发送。在握手阶段，可以通过相关请求<code>首部进行 安全限制、权限校验</code>等。</p>
</blockquote>
<h3 id="服务端：响应协议升级"><a href="#服务端：响应协议升级" class="headerlink" title="服务端：响应协议升级"></a>服务端：响应协议升级</h3><p>服务端返回内容如下，状态代码<code>101</code>表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="./http-web-socket1/web-socket-1-3.png" alt="webSocket"></p>
<blockquote>
<p>备注：每个 header 都以\r\n 结尾，并且最后一行加上一个额外的空行\r\n。此外，服务端回应的 HTTP 状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。</p>
</blockquote>
<h3 id="Sec-WebSocket-Accept-的计算"><a href="#Sec-WebSocket-Accept-的计算" class="headerlink" title="Sec-WebSocket-Accept 的计算"></a>Sec-WebSocket-Accept 的计算</h3><p><code>Sec-WebSocket-Accept</code>根据客户端请求首部的<code>Sec-WebSocket-Key</code>计算出来。<br>计算公式为：</p>
<ul>
<li>将<code>Sec-WebSocket-Key</code>跟<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>拼接。</li>
<li>通过<code>SHA1</code>计算出摘要，并转成<code>base64</code>字符串。</li>
</ul>
<p>伪代码如下：<br><code>&gt;toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ) )</code></p>
<p>验证下前面的返回结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> magic = <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span>;</span><br><span class="line"><span class="keyword">const</span> secWebSocketKey = <span class="string">'w4v7O6xFTi36lq3RNcgctw=='</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> secWebSocketAccept = crypto</span><br><span class="line">  .createHash(<span class="string">'sha1'</span>)</span><br><span class="line">  .update(secWebSocketKey + magic)</span><br><span class="line">  .digest(<span class="string">'base64'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(secWebSocketAccept);</span><br><span class="line"><span class="comment">// Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span></span><br></pre></td></tr></table></figure>
<h2 id="数据帧格式"><a href="#数据帧格式" class="headerlink" title="数据帧格式"></a>数据帧格式</h2><p><strong>客户端、服务端数据的交换</strong>，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下 <code>WebSocket 的数据帧格式</code>。<br><code>WebSocket 客户端、服务端通信的最小单位是帧（frame）</code>，由 <code>1 个或多个帧组成一条完整的消息（message）</code>。</p>
<ul>
<li><code>发送端：将消息切割成多个帧，并发送给服务端</code>；</li>
<li><code>接收端：接收消息帧，并将关联的帧重新组装成完整的消息</code>；</li>
</ul>
<p><strong>数据帧的格式</strong>。详细定义可参考 <a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="noopener">RFC6455 5.2 节</a> 。</p>
<h3 id="数据帧格式概览"><a href="#数据帧格式概览" class="headerlink" title="数据帧格式概览"></a>数据帧格式概览</h3><p>下面给出了 WebSocket 数据帧的统一格式。熟悉 TCP/IP 协议的同学对这样的图应该不陌生。</p>
<ul>
<li>从左到右，单位是比特。比如<code>FIN</code>、<code>RSV1</code>各占据 1 比特，<code>opcode</code>占据 4 比特。</li>
<li>内容包括了<code>标识、操作代码、掩码、数据、数据长度</code>等。（下一小节会展开）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (<span class="number">4</span>)  |A|     (<span class="number">7</span>)     |             (<span class="number">16</span>/<span class="number">64</span>)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (<span class="keyword">if</span> payload len==<span class="number">126</span>/<span class="number">127</span>)   |</span><br><span class="line">| |<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, <span class="keyword">if</span> payload len == <span class="number">127</span>  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, <span class="keyword">if</span> MASK <span class="keyword">set</span> to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="数据帧格式详解"><a href="#数据帧格式详解" class="headerlink" title="数据帧格式详解"></a>数据帧格式详解</h3><p><strong>FIN</strong>：1 个比特。<br>如果是<strong>1</strong>，表示这是消息（message）的<strong>最后一个分片（fragment）</strong>，如果是<strong>0</strong>，表示不是是消息（message）的<strong>最后一个分片（fragment）</strong>。</p>
<p><strong>RSV1, RSV2, RSV3</strong>：各占 1 个比特。<br>一般情况下全为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以<code>非 0</code>，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用 WebSocket 扩展，连接出错。</p>
<p><strong>Opcode: 4 个比特。</strong><br>操作代码，Opcode 的值决定了应该如何解析后续的<code>数据载荷（data payload）</code>。如果操作代码是不认识的，那么接收端应该<code>断开连接（fail the connection）</code>。可选的操作代码如下：</p>
<ul>
<li>%x0：<code>表示一个延续帧</code>。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li>
<li>%x1：<code>表示这是一个文本帧（frame）</code></li>
<li>%x2：<code>表示这是一个二进制帧（frame）</code></li>
<li>%x3-7：<code>保留的操作代码，用于后续定义的非控制帧</code>。</li>
<li>%x8：<code>表示连接断开</code>。</li>
<li>%x9：<code>表示这是一个 ping 操作</code>。</li>
<li>%xA：<code>表示这是一个 pong 操作</code>。</li>
<li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li>
</ul>
<p><strong>Mask: 1 个比特。</strong><br>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。<br>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。<br>如果 Mask 是 1，那么在 Masking-key 中会定义一个<code>掩码键（masking key）</code>，并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask 都是 1。</p>
<p><strong>Payload length：</strong>数据载荷的长度，单位是字节。为 7 位，或 7+16 位，或 1+64 位。<br>假设数 <code>Payload length === x</code>，如果</p>
<ul>
<li><code>x 为 0~126</code>：数据的长度为 x 字节。</li>
<li><code>x 为 126</code>：后续 2 个字节代表一个 16 位的无符号整数，该无符号整数的值为数据的长度。</li>
<li><code>x 为 127</code>：后续 8 个字节代表一个 64 位的无符号整数（最高位为 0），该无符号整数的值为数据的长度。</li>
</ul>
<p>此外，如果 <code>payload length 占用了多个字</code>节的话，<code>payload length 的二进制表达采用网络序（big endian，重要的位在前）</code>。</p>
<p><strong>Masking-key：</strong>或 4 字节（32 位）<br>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为 1，且携带了 4 字节的 Masking-key。如果 Mask 为 0，则没有 Masking-key。</p>
<blockquote>
<p>备注：载荷数据的长度，不包括 mask key 的长度。</p>
</blockquote>
<p><strong>Payload data：</strong>(x+y) 字节<br>载荷数据：包括了扩展数据、应用数据。其中，扩展数据 x 字节，应用数据 y 字节。</p>
<p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为 0 字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p>
<p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p>
<h3 id="掩码算法"><a href="#掩码算法" class="headerlink" title="掩码算法"></a>掩码算法</h3><p><code>掩码键（Masking-key）</code>是由客户端挑选出来的 <code>32 位的随机数</code>。掩码操作不会影响数据载荷的长度。<code>掩码、反掩码</code>操作都采用如下算法：</p>
<p>首先，假设：</p>
<ul>
<li><code>original-octet-i</code>：为原始数据的第 i 字节。</li>
<li><code>transformed-octet-i</code>：为转换后的数据的第 i 字节。</li>
<li><code>j</code>：为 i mod 4 的结果。</li>
<li><code>masking-key-octet-j</code>：为 mask key 第 j 字节。</li>
</ul>
<p>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>
<blockquote>
<p>j = i MOD 4<br>transformed-octet-i = original-octet-i XOR masking-key-octet-j</p>
</blockquote>
<h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>一旦 WebSocket 客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>
<p>WebSocket 根据<code>opcode</code>来区分操作的类型。比如<code>0x8 表示断开连接</code>，<code>0x0-0x2 表示数据交互</code>。</p>
<h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>WebSocket 的每条消息可能被切分成多个数据帧。当 WebSocket 的接收方收到一个数据帧时，会根据<code>FIN 的值</code>来判断，是否已经收到消息的最后一个数据帧。</p>
<p><code>FIN=1</code>表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>
<p>此外，<code>opcode</code>在数据交换的场景下，表示的是数据的类型。<code>0x01 表示文本</code>，<code>0x02 表示二进制</code>。<code>而 0x00</code>比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>
<h3 id="数据分片例子"><a href="#数据分片例子" class="headerlink" title="数据分片例子"></a>数据分片例子</h3><p>直接看例子更形象些。下面例子来自<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" target="_blank" rel="noopener">MDN</a>，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>
<p><strong>第一条消息</strong><br>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>
<p><strong>第二条消息</strong></p>
<ul>
<li>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。</li>
<li>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。</li>
<li>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Client: FIN=<span class="number">1</span>, opcode=<span class="number">0x1</span>, msg=<span class="string">"hello"</span></span><br><span class="line">Server: (process complete message immediately) Hi.</span><br><span class="line">Client: FIN=<span class="number">0</span>, opcode=<span class="number">0x1</span>, msg=<span class="string">"and a"</span></span><br><span class="line">Server: (listening, <span class="keyword">new</span> message containing text started)</span><br><span class="line">Client: FIN=<span class="number">0</span>, opcode=<span class="number">0x0</span>, msg=<span class="string">"happy new"</span></span><br><span class="line">Server: (listening, payload concatenated to previous message)</span><br><span class="line">Client: FIN=<span class="number">1</span>, opcode=<span class="number">0x0</span>, msg=<span class="string">"year!"</span></span><br><span class="line">Server: (process complete message) Happy <span class="keyword">new</span> year to you too!</span><br></pre></td></tr></table></figure>
<h2 id="连接保持-心跳"><a href="#连接保持-心跳" class="headerlink" title="连接保持+心跳"></a>连接保持+心跳</h2><p>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。<br>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<ul>
<li>发送方-&gt;接收方：ping</li>
<li>接收方-&gt;发送方：pong</li>
</ul>
<p>ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode 分别是 0x9、0xA。</p>
<p>举例，WebSocket 服务端向客户端发送 ping，只需要如下代码（采用 ws 模块）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.ping(<span class="string">''</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Sec-WebSocket-Key-Accept-的作用"><a href="#Sec-WebSocket-Key-Accept-的作用" class="headerlink" title="Sec-WebSocket-Key/Accept 的作用"></a>Sec-WebSocket-Key/Accept 的作用</h2><p>前面提到了，<code>Sec-WebSocket-Key/Sec-WebSocket-Accept</code>在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p>
<p>作用大致归纳如下：</p>
<ul>
<li>避免<code>服务端收到非法的 websocket 连接</code>（比如 http 客户端不小心请求连接 websocket 服务，此时服务端可以直接拒绝连接）</li>
<li>确保<code>服务端理解 websocket 连接</code>。因为 ws 握手阶段采用的是 http 协议，因此可能 ws 连接是被一个 http 服务器处理并返回的，此时客户端可以通过 Sec-WebSocket-Key 来确保服务端认识 ws 协议。（并非百分百保险，比如总是存在那么些无聊的 http 服务器，光处理 Sec-WebSocket-Key，但并没有实现 ws 协议。。。）</li>
<li>用浏览器里发起 ajax 请求，设置 header 时，<code>Sec-WebSocket-Key 以及其他相关的 header 是被禁止的</code>。这样可以避免客户端发送 ajax 请求时，意外请求协议升级（websocket upgrade）</li>
<li><code>可以防止反向代理（不理解 ws 协议）返回错误的数据</code>。比如反向代理前后收到两次 ws 连接的升级请求，反向代理把第一次请求的返回给 cache 住，然后第二次请求到来时直接把 cache 住的请求给返回（无意义的返回）。</li>
<li><code>Sec-WebSocket-Key 主要目的并不是确保数据的安全性</code>，因为 <code>Sec-WebSocket-Key</code>、<code>Sec-WebSocket-Accept</code> 的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。</li>
</ul>
<blockquote>
<p>强调：<code>Sec-WebSocket-Key/Sec-WebSocket-Accept</code> 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws 客户端、ws 服务端，其实并没有实际性的保证。</p>
</blockquote>
<h2 id="数据掩码的作用"><a href="#数据掩码的作用" class="headerlink" title="数据掩码的作用"></a>数据掩码的作用</h2><p>WebSocket 协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p>
<ul>
<li><code>代理缓存污染攻击</code></li>
<li>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：<code>对数据载荷进行掩码处理</code>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000012709475" target="_blank" rel="noopener">WebSocket：5 分钟从入门到精通</a><br><a href="https://mp.weixin.qq.com/s/sXde-0h7jjGlt4hdwi_Ngw" target="_blank" rel="noopener">WebSocket 通信过程与实现</a></p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流（throttle）与函数去抖（debounce）</title>
    <url>/blog/javascript/effect/javascript-debounce-throttle.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以下场景往往由于事件频繁被触发，因而频繁执行 DOM 操作、资源加载等重行为，导致 UI 停顿甚至浏览器崩溃。</p>
<ol>
<li><p>window 对象的 resize、scroll 事件</p>
</li>
<li><p>拖拽时的 mousemove 事件</p>
</li>
<li><p>射击游戏中的 mousedown、keydown 事件</p>
</li>
<li><p>文字输入、自动完成的 keyup 事件</p>
</li>
</ol>
<p>实际上对于 window 的 resize 事件，实际需求大多为停止改变大小 n 毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了 debounce 和 throttle 两种解决办法。</p>
<h2 id="与函数去抖（debounce）"><a href="#与函数去抖（debounce）" class="headerlink" title="与函数去抖（debounce）"></a>与函数去抖（debounce）</h2><p>当<code>调用动作 n 毫秒</code>后，才会执行该动作，若在这<code>n 毫秒</code>内又调用此动作则将<code>重新</code>计算执行时间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timer为第二次要调用间隔的时间，只有大于间隔时间的调用会立即执func，不然要等到timer之后再执行</span></span><br><span class="line"><span class="comment"> * @param timer &#123;Number&#125; 间隔时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * @param func &#123;Function&#125; 要执行的函数</span></span><br><span class="line"><span class="comment"> * @param * &#123;Function&#125; 返回匿名函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">timer, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextAction;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(nextAction);</span><br><span class="line">    nextAction = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(content, args);</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>调用 onresize 函数，我们不需要触发频率这么快，要让函数执行延迟 500 毫秒再执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.onresize = debounce(<span class="number">500</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考-v1-9-1-的-Underscore-js-debounce"><a href="#参考-v1-9-1-的-Underscore-js-debounce" class="headerlink" title="参考 v1.9.1 的 Underscore.js debounce"></a>参考 v1.9.1 的 Underscore.js debounce</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class="line"><span class="comment">// be triggered. The function will be called after it stops being called for</span></span><br><span class="line"><span class="comment">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class="line"><span class="comment">// leading edge, instead of the trailing.</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//immediate 不传为 undefind, 默认不立即执行，传true 立即执行一次</span></span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (args) result = func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// restArguments Underscore.js 的restArguments方法 https://underscorejs.org/#restArguments</span></span><br><span class="line">  <span class="comment">// 格式化 参数为数组</span></span><br><span class="line">  <span class="keyword">var</span> debounced = restArguments(<span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// _.delay Underscore.js _.delay https://underscorejs.org/#delay</span></span><br><span class="line">      timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><p>预先设定一个<code>执行周期</code>，当再次调用动作的<code>时刻</code>大于等于<code>执行周期</code>则执行该动作，然后进入下一个新周期。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timer为第二次要调用间隔的时间，只有大于间隔时间的调用会立即执func，不然要等到timer之后再执行</span></span><br><span class="line"><span class="comment"> * @param delay &#123;Number&#125; 间隔时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * @param func &#123;Function&#125; 要执行的函数</span></span><br><span class="line"><span class="comment"> * @param * &#123;Function&#125; 返回匿名函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">delay, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextAction = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (currTime - nextAction &gt; delay) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      nextAction = currTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>和防抖一样调用 onresize 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="number">500</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考-v1-9-1-的-Underscore-js-throttle"><a href="#参考-v1-9-1-的-Underscore-js-throttle" class="headerlink" title="参考 v1.9.1 的 Underscore.js throttle"></a>参考 v1.9.1 的 Underscore.js throttle</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class="line"><span class="comment">// during a given window of time. Normally, the throttled function will run</span></span><br><span class="line"><span class="comment">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class="line"><span class="comment">// but if you'd like to disable the execution on the leading edge, pass</span></span><br><span class="line"><span class="comment">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = _.now();</span><br><span class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  throttled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    previous = <span class="number">0</span>;</span><br><span class="line">    timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSEffect</tag>
      </tags>
  </entry>
  <entry>
    <title>require和import的区别</title>
    <url>/blog/es/esm-common/javascript-module.html</url>
    <content><![CDATA[<h2 id="简单比较"><a href="#简单比较" class="headerlink" title="简单比较"></a>简单比较</h2><p>对比表格如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">对比类型</th>
<th style="text-align:center">import</th>
<th style="text-align:center">require</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">何时加载</td>
<td style="text-align:center">编译时加载</td>
<td style="text-align:center">运行时加载</td>
</tr>
<tr>
<td style="text-align:center">静态化</td>
<td style="text-align:center">ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</td>
<td style="text-align:center">只有运行时才能得到这个对象，不能在编译时做到静态化</td>
</tr>
<tr>
<td style="text-align:center">调用时间</td>
<td style="text-align:center">import 是编译时调用，所以严格模式必须放在文件开头</td>
<td style="text-align:center">require 是运行时调用，所以 require 理论上可以运用在代码的任何地方</td>
</tr>
<tr>
<td style="text-align:center">模块输出</td>
<td style="text-align:center">模块输出的是值的引用，不会缓存，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块</td>
<td style="text-align:center">模块输出的是一个值的拷贝，并且在第一次加载是缓存，后面加载都会读取缓存</td>
</tr>
<tr>
<td style="text-align:center">模块加载</td>
<td style="text-align:center">按引入加载</td>
<td style="text-align:center">整体加载</td>
</tr>
<tr>
<td style="text-align:center">循环加载</td>
<td style="text-align:center">ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值</td>
<td style="text-align:center">CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出</td>
</tr>
</tbody>
</table>
<p>下面我们一项一项具体解释：</p>
<h3 id="何时加载-静态化"><a href="#何时加载-静态化" class="headerlink" title="何时加载/静态化"></a>何时加载/静态化</h3><p>require / exports ：<br>遵循 <code>CommonJS/AMD</code>，只能在<code>运行时</code>确定模块的依赖关系及输入/输出的变量，<code>无法</code>进行<code>静态优化</code>。</p>
<p>import / export：<br>遵循 <code>ES6</code> 规范，支持<code>编译时静态分析</code>，便于 JS 引入宏和类型检验。<code>动态绑定</code>。</p>
<h3 id="调用时间"><a href="#调用时间" class="headerlink" title="调用时间"></a>调用时间</h3><p>import / export：<br>import 命令具有<code>提升效果</code>，会<code>提升</code>到整个模块的头部，<code>首先执行</code>。（是在编译阶段执行的）<br>因为 import 是静态执行的，不能使用表达式和变量，即在运行时才能拿到结果的语法结构.</p>
<p>require / exports ：<br>require 是<code>运行时</code>调用，所以 require 理论上可以运用在代码的<code>任何地方</code></p>
<h3 id="模块输出-模块加载"><a href="#模块输出-模块加载" class="headerlink" title="模块输出/模块加载"></a>模块输出/模块加载</h3><p>require / exports ：<br>CommonJS 模块输出的是<code>值的拷贝</code>，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值，并且会在第一次加载是<code>缓存</code>这个值的拷贝，他是<code>完全</code>输出这个值的拷贝。</p>
<p>import / export：<br>模块输出的是值的<code>引用</code>，<code>不会</code>缓存，而是<code>动态</code>地去被加载的模块取值，并且变量总是绑定其所在的模块，并且只会<code>加载</code>引入的值，不去全部加载。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ESM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型（五）== 混乱的转换规则</title>
    <url>/blog/javascript/type/javascript-false-true.html</url>
    <content><![CDATA[<p><strong><em>察见渊鱼者不详，智料隐匿者有殃。——《列子·说符》</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 有两种比较方式：<strong>严格比较运算符</strong>和<strong>转换类型比较运算符</strong>。对于严格比较运算符（===）来说，仅当两个操作数的<strong>类型相同且值相等</strong>为 <code>true</code>，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数<strong>转换成相同的类型</strong>。</p>
<p>比较的特点:</p>
<ul>
<li><strong>对于两个拥有相同字符顺序，相同长度，并且每个字符的位置都匹配的字符串，应该使用严格比较运算符。</strong></li>
<li><strong>对于两个数值相同的数字应该使用严格比较运算符，NaN 和任何值不相等，包括其自身，正数零等于负数零。</strong></li>
<li><strong>对于两个同为 true 或同为 false 的布尔操作数，应使用严格比较运算符。</strong></li>
<li><strong>不要使用严格比较运算符或比较运算符来比较两个不相等的对象。</strong></li>
<li><strong>当比较一个表达式和一个对象时，仅当两个操作数引用相同的对象（指针指向相同对象）。</strong></li>
<li><strong>对于 Null 和 Undefined 类型而言，应使用严格比较运算符比较其自身，使用比较运算符进行互相比较。</strong></li>
</ul>
<p><a href="https://www.h5jun.com/post/why-false-why-true.html" target="_blank" rel="noopener">false/true</a></p>
<h3 id="一致-严格相等"><a href="#一致-严格相等" class="headerlink" title="一致/严格相等 (===)"></a>一致/严格相等 (===)</h3><p>一致运算符不会进行类型转换，仅当操作数<strong>严格相等</strong>时返回<code>true</code></p>
<h3 id="相等"><a href="#相等" class="headerlink" title="相等(==)"></a>相等(==)</h3><p>比较操作符会为两个不同类型的操作数<strong>转换类型</strong>，然后进行<strong>严格比较</strong>。当两个操作数都是对象时，JavaScript 会比较其<strong>内部引用</strong>，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的<strong>引用地址相同</strong>。</p>
<p>非严格比较操作符 == 是会做强制类型转换的，那么根据 ECMA 262 它的规则是：</p>
<p><strong>图 1-1</strong><br><img src="./javascript-false-true/1.png" alt="! =="><br><strong><code>ToPrimitive：</code></strong></p>
<p><strong>图 1-2</strong><br><img src="./javascript-false-true/2.png" alt="! =="></p>
<p><strong>图 1-3</strong><br><img src="./javascript-false-true/3.png" alt="! =="></p>
<p><strong>图 1-4</strong><br><img src="./javascript-false-true/4.png" alt="! =="><br><strong><code>ToBoolean:</code></strong></p>
<p><strong>图 1-5</strong></p>
<p><img src="./javascript-false-true/5.png" alt="! =="><br><strong>图 1-6</strong><br><img src="./javascript-false-true/6.png" alt="! =="></p>
<p><a href="http://www.ecma-international.org" target="_blank" rel="noopener">ecma 规则</a></p>
<h2 id="false-or-or-false-为-true"><a href="#false-or-or-false-为-true" class="headerlink" title="[] == false or ![] == [] or ![] == false 为 true"></a>[] == false or ![] == [] or ![] == false 为 true</h2><p>mdn 运算符优先级参考表<br><img src="./javascript-false-true/false-true-1.png" alt="! =="><br><img src="./javascript-false-true/false-true-2.png" alt="! =="></p>
<p><code>==</code>的优先级 16<br><code>!</code>的优先级 10</p>
<h3 id="false-结果为-true"><a href="#false-结果为-true" class="headerlink" title="[] == false 结果为 true"></a>[] == false 结果为 true</h3><p>根据图 1-1 可知</p>
<ul>
<li>第 7 条：<strong>If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).</strong></li>
<li>第 9 条：<strong>If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.</strong></li>
</ul>
<p>所以 <code>[] == false</code> 的比较是对 x 执行 <code>ToPrimitive(x)</code>，然后和 <code>ToNumber(false)</code> （为 0）进行比较。</p>
<p><strong>看一下 ToPrimitive：</strong><br>根据上图 1-2、1-3、1-4 的规则对于<code>ToPrimitive([])</code>，先执行<code>[].valueOf()</code>，返回 result 的是’[]’，因为 Type(result)是 Object，所以继续执行<code>[].toString()</code>，返回””。<br>因此实际上最终是比较<code>&quot;&quot; == 0</code>，结果为<code>true</code>。</p>
<h3 id="结果为-true"><a href="#结果为-true" class="headerlink" title="![] == [] 结果为 true"></a>![] == [] 结果为 true</h3><p>按照优先级，先执行 ![]，根据规范，实际上是 <code>!(ToBoolean([]))</code>：<br>根据上图 1-5、1-6 可看出，实际上 <code>ToBoolean([])</code> 会<code>return</code>出<code>true</code>, <code>![]</code> 就是 <code>false</code>.<br>[] 上文已经讲过了 是 “”。<br>所以对比就是 <code>false == &quot;&quot;</code>，结果为<code>true</code>。</p>
<h3 id="false-结果为-true-1"><a href="#false-结果为-true-1" class="headerlink" title="![] == false 结果为 true"></a>![] == false 结果为 true</h3><p>按照优先级，先执行 <code>![]</code>，根据规范，实际上是 <code>!(ToBoolean([]))</code>：<br>根据上图可看出，实际上 <code>ToBoolean([])</code> 会 return 出 true, ![] 就是 false.<br><code>false == false</code> ，结果为<code>true</code>。</p>
<h3 id="false-结果为-false"><a href="#false-结果为-false" class="headerlink" title="!![] == false 结果为 false"></a>!![] == false 结果为 false</h3><p>按照优先级，先执行 !![]，根据规范，实际上是 <code>!!(ToBoolean([]))</code>：<br>根据上图可看出，实际上 <code>ToBoolean([])</code>会 return 出 true, !![] 就是 true.<br><code>true == false</code> ，结果为 <code>false</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上一个<strong>对象转为原始值</strong>的大致过程再进行对比，如果不太清楚可以看另一篇博客<a href="/blog/javascript/javascript-type-one-question.html">JavaScript 数据类型（二） 类型转换</a>，但是在本篇博客中最重要的时<code>ToBoolean([])</code>的转换比较不容易理解。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>Http系列(四) Http中Get/Post的区别</title>
    <url>/blog/network/http/http-get-post.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：<code>GET</code> 和 <code>POST</code>。</p>
<ul>
<li><strong>GET - 从指定的资源请求数据。</strong></li>
<li><strong>POST - 向指定的资源提交要被处理的数据</strong></li>
</ul>
<p>最直观的区别就是<code>GET</code>把参数包含在<code>URL</code>中，<code>POST</code>通过<code>request body</code>传递参数。<code>POST</code>和<code>GET</code>大致区别如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">GET</th>
<th style="text-align:center">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">后退按钮/刷新</td>
<td style="text-align:center">无害</td>
<td style="text-align:center">数据会被重新提交（浏览器应该告知用户数据会被重新提交）</td>
</tr>
<tr>
<td style="text-align:center">书签</td>
<td style="text-align:center">可收藏为书签</td>
<td style="text-align:center">不可收藏为书签</td>
</tr>
<tr>
<td style="text-align:center">缓存</td>
<td style="text-align:center">能被缓存</td>
<td style="text-align:center">不能缓存</td>
</tr>
<tr>
<td style="text-align:center">编码类型</td>
<td style="text-align:center">application/x-www-form-urlencoded</td>
<td style="text-align:center">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码</td>
</tr>
<tr>
<td style="text-align:center">历史</td>
<td style="text-align:center">参数保留在浏览器历史中</td>
<td style="text-align:center">参数不会保存在浏览器历史中</td>
</tr>
<tr>
<td style="text-align:center">对数据长度的限制</td>
<td style="text-align:center">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）</td>
<td style="text-align:center">无限制</td>
</tr>
<tr>
<td style="text-align:center">对数据类型的限制</td>
<td style="text-align:center">只允许 ASCII 字符</td>
<td style="text-align:center">没有限制。也允许二进制数据</td>
</tr>
<tr>
<td style="text-align:center">安全性</td>
<td style="text-align:center">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分 在发送密码或其他敏感信息时绝不要使用 GET ！</td>
<td style="text-align:center">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中</td>
</tr>
<tr>
<td style="text-align:center">可见性</td>
<td style="text-align:center">数据在 URL 中对所有人都是可见的</td>
<td style="text-align:center">数据不会显示在 URL 中</td>
</tr>
</tbody>
</table>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><hr>
<p><strong>其实<code>GET</code>和<code>POST</code>都是<code>http协议中</code>的两种发送请求的方法。</strong></p>
<ul>
<li><strong>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</strong></li>
<li><strong>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</strong></li>
<li><strong>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</strong></li>
<li><strong>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</strong></li>
<li><strong>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</strong></li>
<li><strong>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。</strong></li>
<li><strong>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</strong></li>
<li><strong>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</strong></li>
<li><strong>GET 参数通过 URL 传递，POST 放在 Request body 中。</strong></li>
<li><strong>http 协议并未规定 get 和 post 的长度限制</strong></li>
<li><strong>get 的最大长度限制是因为浏览器和 web 服务器限制了 URL 的长度</strong></li>
<li><strong>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）</strong></li>
</ul>
<h3 id="其实很多人说-get-请求比-post-请求快，主要是底下两条"><a href="#其实很多人说-get-请求比-post-请求快，主要是底下两条" class="headerlink" title="其实很多人说 get 请求比 post 请求快，主要是底下两条"></a>其实很多人说 get 请求比 post 请求快，主要是底下两条</h3><ol>
<li><strong>get 请求比 post 请求少一步</strong></li>
<li><strong>get 请求可以缓存</strong></li>
</ol>
<p><strong>get 请求过程</strong>：</p>
<ol>
<li><strong>浏览器请求 tcp 连接（第一次握手）</strong></li>
<li><strong>服务器答应进行 tcp 连接（第二次握手）</strong></li>
<li>浏览器确认，<strong>并发送 get 请求头和数据</strong>（第三次握手，这个报文比较小，所以 http 会在此时进行第一次数据发送）</li>
<li>服务器返回 200 OK 响应</li>
</ol>
<p><strong>post 请求过程</strong>：</p>
<ol>
<li><strong>浏览器请求 tcp 连接（第一次握手）</strong></li>
<li><strong>服务器答应进行 tcp 连接（第二次握手）</strong></li>
<li><strong>浏览器确认，并发送 post 请求头</strong>（第三次握手，这个报文比较小，所以 http 会在此时进行第一次数据发送）</li>
<li><strong>服务器返回 100 Continue 响应</strong></li>
<li><strong>浏览器发送数据</strong></li>
<li>服务器返回 200 OK 响应</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>GET</code>在浏览器回退时是<strong>无害</strong>的，而<code>POST</code>会<strong>再次</strong>提交请求。</li>
<li><code>GET</code>产生的 URL 地址可以被<code>Bookmark</code>，而<code>POST</code>不可以。</li>
<li><code>GET</code>请求会被浏览器主动<code>cache</code>，而<code>POST</code>不会，除非手动设置。</li>
<li><code>GET</code>请求只能进行<code>url</code>编码，而<code>POST</code>支持多种编码方式。</li>
<li><code>GET</code>请求参数会被完整保留在浏览器历史记录里，而<code>POST</code>中的参数不会被保留。</li>
<li><code>GET</code>请求在<code>URL</code>中传送的参数是有长度限制的，而<code>POST</code>么有。</li>
<li>对参数的数据类型，<code>GET</code>只接受<code>ASCII</code>字符，而<code>POST</code>没有限制。</li>
<li><code>GET</code>比<code>POST</code>更不安全，因为参数直接暴露在<code>URL</code>上，所以不能用来传递敏感信息。</li>
<li><code>GE</code>T 参数通过<code>URL</code>传递，<code>POST</code>放在<code>Request body</code>中。</li>
<li><code>http</code>协议并未规定<code>get</code>和<code>post</code>的长度限制</li>
<li><code>get</code>的最大长度限制是因为浏览器和<code>web</code>服务器限制了<code>URL</code>的长度</li>
<li>对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应<code>200</code>（返回数据）；而对于 POST，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a><br><a href="https://www.cnblogs.com/logsharing/p/8448446.html#!comments" target="_blank" rel="noopener">GET 和 POST 两种基本请求方法的区别</a></p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise系列（三） 实现一个自己的Promise</title>
    <url>/blog/es/promise/es6-promise-two.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>接上文的<code>Promsie</code>文章，在这篇文章中实现<code>Promsie</code>常用的方法，并且是实现<code>PromsieA+</code>的规范等等。</p>
<h2 id="实现-Promise-方法-catch、resolve、reject、all、race-等方法"><a href="#实现-Promise-方法-catch、resolve、reject、all、race-等方法" class="headerlink" title="实现 Promise 方法 catch、resolve、reject、all、race 等方法"></a>实现 Promise 方法 catch、resolve、reject、all、race 等方法</h2><p><code>catch</code>方法：</p>
<blockquote>
<p>相当于调用 <code>then</code> 方法, 但只传入 <code>Rejected</code> 状态的回调函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加catch方法</span></span><br><span class="line">PromiseA.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">111</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 111</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>resolve</code>方法：</p>
<blockquote>
<p>静态 <code>resolve</code> 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果参数是MyPromise实例或thenable对象，直接返回value</span></span><br><span class="line">PromiseA.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value <span class="keyword">instanceof</span> PromiseA || (value &amp;&amp; isFunction(value.then))</span><br><span class="line">    ? value</span><br><span class="line">    : <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(value));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PromiseA.resolve(<span class="number">111</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// 111</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>reject</code>方法：</p>
<blockquote>
<p>静态 <code>reject</code> 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加静态reject方法</span></span><br><span class="line">PromiseA.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(value));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PromiseA.reject(<span class="number">111</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// 111</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>all</code> 方法:</p>
<blockquote>
<p>静态 <code>all</code> 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加静态all方法</span></span><br><span class="line">PromiseA.all = <span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> values = [],</span><br><span class="line">      count = list.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">      <span class="comment">// 数组参数如果不是PromiseA实例，先调用PromiseA.resolve</span></span><br><span class="line">      <span class="keyword">this</span>.resolve(list[i]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        values[i] = res;</span><br><span class="line">        <span class="comment">// 所有状态都变成fulfilled时返回的PromiseA状态就变成fulfilled</span></span><br><span class="line">        --count &lt; <span class="number">1</span> &amp;&amp; resolve(values);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PromiseA.all([</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">222</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">333</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [111, 222, 333]</span></span><br></pre></td></tr></table></figure>
<p><code>race</code> 方法：</p>
<blockquote>
<p>静态 <code>race</code> 方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加静态race方法</span></span><br><span class="line">PromiseA.race = <span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">      <span class="comment">// 只要有一个实例率先改变状态，新的PromiseA的状态就跟着改变</span></span><br><span class="line">      <span class="keyword">this</span>.resolve(p).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PromiseA.race([</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">222</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">333</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 111</span></span><br></pre></td></tr></table></figure>
<h2 id="实现-promiseify-方法"><a href="#实现-promiseify-方法" class="headerlink" title="实现 promiseify 方法"></a>实现 promiseify 方法</h2><p><code>promiseify</code>是将异步回调函数<code>api</code>转换为<code>promise</code>形式。代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态promisify</span></span><br><span class="line">PromiseA.promisify = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      fn.apply(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        args.concat(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          err ? reject(err) : resolve(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实就是把不同异步函数转为<code>Promise</code>的实现。</p>
<h2 id="达到-PromiseA-规范标准"><a href="#达到-PromiseA-规范标准" class="headerlink" title="达到 PromiseA+规范标准"></a>达到 PromiseA+规范标准</h2>]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>Polyfill</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise系列（二） 实现一个自己的Promise</title>
    <url>/blog/es/promise/es6-promise.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个 <code>Promise</code> 就是一个对象，它代表了一个异步操作的最终完成或者失败。大多数人仅仅是使用已创建的<code>Promise</code>实例对象，因此本教程将首先说明怎样使用 <code>Promise</code>，之后说明如何创建<code>Promise</code>。<br>本质上，<code>Promise</code> 是一个绑定了回调的对象，而不是将回调传进函数内部。<br>原生提供了<code>Promise</code>对象。本篇不注重讲解<code>promise</code>的用法，关于用法，可以看阮一峰老师的<code>ECMAScript 6</code>系列里面的<code>Promise</code>部分：<br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ECMAScript 6 : Promise 对象</a><br>我们在最后实现一个<code>es2015</code>版本的<code>PromiseA</code>.<br>注：在本代码中有很多不完善的地方，最后会给出一个<code>es2015</code>的版本，那个版本是比较完善的。<br>本篇博客逐步实现，最终使其符合<code>Promises/A+</code>规范</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>逐步实现：</p>
<ol>
<li><strong>基础版本</strong></li>
<li><strong>支持同步任务</strong></li>
<li><strong>支持状态</strong></li>
<li><strong>支持链式操作</strong></li>
<li><strong>支持串行异步任务</strong></li>
<li><strong>实现 Promise 方法 all、resolve、reject、race 等方法</strong></li>
<li><strong>实现 promiseify 方法</strong></li>
<li><strong>达到 PromiseA+规范</strong></li>
</ol>
<blockquote>
<p>注意事项：这边建议不要使用 <code>setTimeout</code>作为 <code>Promise</code> 的实现。因为 <code>setTimeout</code> 属于 宏任务， 而 <code>Promise</code> 属于 微任务。</p>
</blockquote>
<!-- 不理知道宏任务和微任务请看量一篇博客：[evenloop](http://asyncnode.com/blog/evenloop.html) -->
<p>显示代码请看</p>
<h2 id="基础版本-异步回调"><a href="#基础版本-异步回调" class="headerlink" title="基础版本(异步回调)"></a>基础版本(异步回调)</h2><p>目标</p>
<ul>
<li>可以通过<code>new</code> 关键字创建一个 <code>Promise</code>实例。</li>
<li><code>Promise</code>实例传入的异步方法执行成功就执行注册的成功回调函数，失败就执行注册的失败回调函数。</li>
</ul>
<p>首先实现两个判断函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function">(<span class="params">variable</span>) =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">  executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">  executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  executeAsync = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装我们要调用的callAsync函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callAsync</span>(<span class="params">fn, arg, callback, onError</span>) </span>&#123;</span><br><span class="line">  executeAsync(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback ? callback(fn(arg)) : fn(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      onError(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：判断传入参数是否为<code>function</code>, 根据当前环境降级实现<strong>微任务或宏任务</strong></p>
<p><strong>代码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function">(<span class="params">variable</span>) =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Promise resolver handle is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">null</span>; <span class="comment">// 成功时的值</span></span><br><span class="line">  self.error = <span class="literal">null</span>; <span class="comment">// 失败时的原因</span></span><br><span class="line">  self.onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;; <span class="comment">// 成功的回调函数</span></span><br><span class="line">  self.onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;; <span class="comment">// 失败的回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    self.value = value;</span><br><span class="line">    self.onFulfilled(self.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    self.error = error;</span><br><span class="line">    self.onRejected(self.error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//捕获callback是否报错</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    handle(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//在这里给promise实例注册成功和失败回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.onFulfilled);</span><br><span class="line">  <span class="built_in">console</span>.log(onFulfilled);</span><br><span class="line">  <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">  <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">111</span>);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br><span class="line"><span class="keyword">new</span> PromiseA([]);</span><br></pre></td></tr></table></figure>
<p>判断实例传入的参数是否为<code>function</code>，在<code>then</code>中注册了这个<code>promise</code>实例的成功回调和失败回调，当<code>promise resolve</code>时，当<code>promise resolve</code>时，就把异步执行结果赋值给<code>promise</code>实例的<code>value</code>，并把这个值传入成功回调中执行，失败就把异步执行失败原因赋值给<code>promise</code>实例的<code>error</code>，并把这个值传入失败回调并执行。</p>
<h2 id="支持同步代码"><a href="#支持同步代码" class="headerlink" title="支持同步代码"></a>支持同步代码</h2><p>我们执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在如果我们同步执行<code>resolve(111)</code>的话，我们的<code>then</code>函数还没有被执行，所以后续的<code>then</code>中得回调函数也不会被执行，简单来说就是<code>then</code>函数在<code>resolve(111)</code>的函数之后执行，所以<code>then</code>中得回调也不会被执行。</p>
<p><strong>目标</strong></p>
<ul>
<li><strong>使<code>promise</code>支持同步方法</strong></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function">(<span class="params">variable</span>) =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">  executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">  executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  executeAsync = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Promise resolver handle is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">null</span>; <span class="comment">// 成功时的值</span></span><br><span class="line">  self.error = <span class="literal">null</span>; <span class="comment">// 失败时的原因</span></span><br><span class="line">  self.onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;; <span class="comment">// 成功的回调函数</span></span><br><span class="line">  self.onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;; <span class="comment">// 失败的回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.value = value;</span><br><span class="line">      <span class="built_in">console</span>.log(self.onFulfilled(self.value));</span><br><span class="line">      self.onFulfilled(self.value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.error = error;</span><br><span class="line">      self.onRejected(self.error);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handle(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//在这里给promise实例注册成功和失败回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.onFulfilled);</span><br><span class="line">  <span class="built_in">console</span>.log(onFulfilled);</span><br><span class="line">  <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">  <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br></pre></td></tr></table></figure>
<p>就是在<code>resolve</code>和<code>reject</code>里面用<code>setTimeout</code>进行包裹，使其到<code>then</code>方法执行之后再去执行，这样我们就让<code>Promise</code>支持传入同步方法。</p>
<blockquote>
<p>注：<code>setTimeout</code>其实是最后一种方法，要看环境, 要是支持的话，优先使用<code>MutationObserver</code>(微任务),再是<code>MessageChannel</code>（优先级比定时器高的宏任务）,再是<code>setImmediate</code>（这个兼容性太差，不建议用）再不行就降级为<code>setTimeout</code>了</p>
</blockquote>
<h2 id="支持三种状态"><a href="#支持三种状态" class="headerlink" title="支持三种状态"></a>支持三种状态</h2><p>我们知道在使用<code>Ppromise</code>时，<code>Promise</code>有三种状态：<code>pending(进行中)</code>、<code>fulfilled(已成功)</code>、<code>rejected(已失效)</code>。</p>
<ol>
<li>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，</li>
</ol>
<p>只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就<strong>凝固</strong>了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved（已定型）</code>。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。</p>
<p><strong>目标</strong></p>
<ul>
<li>实现<code>promise</code>的三种状态</li>
<li>实现<code>promise</code>对象的状态改变，改变只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</li>
<li>实现一旦<code>promise</code>状态改变，再对<code>promise</code>对象添加回调函数，也会立即得到这个结果。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function">(<span class="params">variable</span>) =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">  executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">  executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  executeAsync = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Promise resolver handle is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.error = <span class="literal">undefined</span>;</span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  self.onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;;</span><br><span class="line">  self.onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        self.status = FULFILLED;</span><br><span class="line">        self.value = value;</span><br><span class="line">        self.onFulfilled(self.value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        self.status = REJECTED;</span><br><span class="line">        self.error = value;</span><br><span class="line">        self.onRejected(self.error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handle(resolve, reject);</span><br><span class="line">  <span class="comment">//捕获callback是否报错</span></span><br><span class="line">  <span class="comment">// try &#123;</span></span><br><span class="line">  <span class="comment">// &#125; catch (error) &#123;</span></span><br><span class="line">  <span class="comment">//     reject(error);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">    <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">111</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data, error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;); <span class="comment">// 111</span></span><br></pre></td></tr></table></figure>
<p>为了实现上面的目标我们建立了三种状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>，如果是<code>peding</code>状态，我们才会改变<code>promise</code>的状态，并且执行相关状态的操作，并且现在的<code>promise</code>的状态是不可改变的。在<code>then</code>那种我们判断<code>promise</code>的状态已经从<code>pending</code>转换为<code>fulfilled</code>或者<code>rejected</code>就会立刻执行他的状态的回调，并且把结果传入。</p>
<h2 id="支持链式调用（同步）"><a href="#支持链式调用（同步）" class="headerlink" title="支持链式调用（同步）"></a>支持链式调用（同步）</h2><p>大家都知道<code>jquery</code>的链式调用，<code>promise</code>也是支持链式调用。<br>我们首先在这一步实现同步的链式调用。</p>
<p><strong>目标</strong></p>
<ul>
<li><strong>使<code>promise</code>支持链式调用</strong></li>
</ul>
<blockquote>
<p>注：我们把<code>then</code>中的回调存入数组中</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.onFulfilledCallbacks = [];</span><br><span class="line">self.onRejectedCallbacks = [];</span><br></pre></td></tr></table></figure>
<p>当我们执行回调时，也要改成遍历回调数组执行回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.onFulfilledCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value));</span><br><span class="line">self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value));</span><br></pre></td></tr></table></figure>
<p>最后，<code>then</code>方法也要改一下,只需要在最后一行加一个<code>return this</code>即可，这其实和<code>jQuery</code>链式操作的原理一致，每次调用完方法都返回自身实例，后面的方法也是实例的方法，所以可以继续执行。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前传入的参数是否是function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function">(<span class="params">variable</span>) =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 另一个是判断当前执行环境如果实在node中首先使用process.nextTick如果没有使用setImmediate,如果还没有就使用setTimeout</span></span><br><span class="line"><span class="keyword">let</span> executeAsync = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">  executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">  executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  executeAsync = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Promise resolver handle is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.error = <span class="literal">undefined</span>;</span><br><span class="line">  self.onFulfilledCallbacks = [];</span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  <span class="comment">// self.onFulfilled = function (value) &#123; (value) &#125;;</span></span><br><span class="line">  <span class="comment">// self.onRejected = function (value) &#123; (value) &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        self.status = FULFILLED;</span><br><span class="line">        self.value = value;</span><br><span class="line">        <span class="comment">// self.onFulfilled(self.value);</span></span><br><span class="line">        self.onFulfilledCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      executeAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        self.status = REJECTED;</span><br><span class="line">        self.value = error;</span><br><span class="line">        <span class="comment">// self.onRejected(self.value);</span></span><br><span class="line">        self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.error));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handle(resolve, reject);</span><br><span class="line">  <span class="comment">//捕获callback是否报错</span></span><br><span class="line">  <span class="comment">// try &#123;</span></span><br><span class="line">  <span class="comment">// &#125; catch (error) &#123;</span></span><br><span class="line">  <span class="comment">//     reject(error);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型上的then方法</span></span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="comment">// this.onFulfilled = onFulfilled;</span></span><br><span class="line">    <span class="comment">// this.onRejected = onRejected;</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reslove(<span class="number">111</span>);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第一'</span> + data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二'</span> + data);</span><br><span class="line">  &#125;); <span class="comment">// 第一 第二</span></span><br></pre></td></tr></table></figure>
<p>总结： 这个就是最简单的同步<code>then</code>的回调用一个内部数组来储存，最后循环调用。</p>
<h2 id="支持串行异步任务"><a href="#支持串行异步任务" class="headerlink" title="支持串行异步任务"></a>支持串行异步任务</h2><p>我们一般都是用<code>promise.then</code>来写异步任务，在下面完善一下代码</p>
<p><strong>目标</strong></p>
<ul>
<li><strong>使<code>PromiseA</code>支持串行异步操作</strong></li>
<li><strong>支持传入<code>PromiseA</code>对象</strong></li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在上一步已经实现可以链式调用，但是只支持<strong>同步</strong>的链式调用，现在要实现支持一步串行调用。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个promise实例</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'first------'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="comment">// 第二个promise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'second------'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">second</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">    <span class="comment">// 第三个promise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'third------'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 异步串行</span></span><br><span class="line"><span class="comment">// "first------" + new Date()</span></span><br><span class="line"><span class="comment">// "first------" + new Date()</span></span><br><span class="line"><span class="comment">// "first------" + new Date()</span></span><br></pre></td></tr></table></figure>
<p>想要的结果是在<strong>1s</strong>之后输出<code>&#39;first------&#39; + new Date()</code>结果，再经过<strong>2s</strong>之后执行<code>&#39;second------&#39; + new Date()</code>，再等<strong>3s</strong>之后才会执行<code>&#39;third------&#39; + new Date()</code>，但是结果和预想的结果不相同。<br>实际结果是<strong>1s</strong>之后直接就会输出三次<code>first------ + new Date()</code>，因为所有的回调函数都注册在了<code>PromiseA</code>中的<code>onFulfilledCallbacks</code>队列里，在后面<code>resolve</code>后会全部执行，这个并不能满足<strong>异步串行</strong>。<br>需要将每个回调函数注册在对应<code>promise</code>实例的<code>onFulfilledCallbacks</code>里面，然后再返回一下新的<code>promise</code>以做到异步串行效果。</p>
<p>改写代码如下：</p>
<ul>
<li>改写<code>prototype</code>上的<code>then</code>方法</li>
<li>改写<code>resolve</code>、<code>reject</code>上的代码</li>
</ul>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改原型上的then方法</span></span><br><span class="line">PromiseA.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个新的PromiseA对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> fulfilled = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFunction(onFulfilled)) &#123;</span><br><span class="line">        callAsync(</span><br><span class="line">          onFulfilled,</span><br><span class="line">          value,</span><br><span class="line">          (res) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> PromiseA) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回PromiseA对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejectedNext</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          onFulfilledNext(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的PromiseA对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> rejected = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFunction(onRejected)) &#123;</span><br><span class="line">        callAsync(</span><br><span class="line">          onRejected,</span><br><span class="line">          error,</span><br><span class="line">          (res) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> PromiseA) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回PromiseA对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejectedNext</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          onRejectedNext(error);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的PromiseA对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">      <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">      <span class="keyword">case</span> PENDING:</span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.push(fulfilled);</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(rejected);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">      <span class="keyword">case</span> FULFILLED:</span><br><span class="line">        fulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> REJECTED:</span><br><span class="line">        rejected(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着修改 <code>resolve</code> 和 <code>reject</code> ：依次执行队列中的函数</p>
<p>当 <code>resolve</code> 或 <code>reject</code> 方法执行时，依次提取成功或失败<strong>任务队列</strong>当中的函数开始执行，并<strong>清空队列</strong>，从而实现 <code>then</code> 方法的多次调用，实现的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callAsync</span>(<span class="params">fn, arg, callback, onError</span>) </span>&#123;</span><br><span class="line">  executeAsync(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback ? callback(fn(arg)) : fn(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      onError(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// resolve方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 状态一旦定型不可改变</span></span><br><span class="line">  <span class="keyword">if</span> (self.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 改变当前实例状态</span></span><br><span class="line">  self.status = FULFILLED;</span><br><span class="line">  <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">  <span class="keyword">const</span> runFulfilled = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cb;</span><br><span class="line">    <span class="comment">// 循环执行</span></span><br><span class="line">    <span class="keyword">while</span> ((cb = self.onFulfilledCallbacks.shift())) &#123;</span><br><span class="line">      cb(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">  <span class="keyword">const</span> runRejected = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cb;</span><br><span class="line">    <span class="keyword">while</span> ((cb = self.onRejectedCallbacks.shift())) &#123;</span><br><span class="line">      cb(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/* 如果resolve的参数为PromiseA对象，则必须等待（参数PromiseA）对象状态改变后,</span></span><br><span class="line"><span class="comment">    当前PromsieA的状态才会改变，且状态取决于参数PromsieA对象的状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">if</span> (val <span class="keyword">instanceof</span> PromiseA) &#123;</span><br><span class="line">    <span class="comment">// 如果为参数为PromiseA对象，在参数PromiseA对象的then方法中执行后续runFulfilled or runRejected操作</span></span><br><span class="line">    val.then(</span><br><span class="line">      (value) =&gt; &#123;</span><br><span class="line">        self.value = value;</span><br><span class="line">        runFulfilled(value);</span><br><span class="line">      &#125;,</span><br><span class="line">      (err) =&gt; &#123;</span><br><span class="line">        self.value = err;</span><br><span class="line">        runRejected(err);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果参数是普通类型，直接执行runFulfilled</span></span><br><span class="line">    self.value = val;</span><br><span class="line">    runFulfilled(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加reject时执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (self.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">  self.status = REJECTED;</span><br><span class="line">  self.value = err;</span><br><span class="line">  <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">  <span class="keyword">let</span> cb;</span><br><span class="line">  <span class="keyword">while</span> ((cb = self.onRejectedCallbacks.shift())) &#123;</span><br><span class="line">    cb(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  handle(resolve.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  reject(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里面最关键的就是回调函数返回<strong>异步 PromiseA 对象</strong>时，要等<strong>异步 PromiseA 对象</strong>有结果时，当前的实例才能根据前面的异步结果改变自己的状态。</p>
<p>测试一下代码，在第一<code>PromiseA</code>实例的<code>then</code>的回调函数中，返回一个新的<code>PromiseA</code>实例并且在<code>2s</code>之后直接执行当前实例的<code>resolve</code>方法，在下一个<code>then</code>回调函数中再返回一个<code>PromiseA</code>实例，在<code>3s</code>后执行当前实例的<code>resolve</code>，最后一个<code>then</code>传入的回调函数中输出<code>resolve</code>中储存的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'first------'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  <span class="comment">// t1</span></span><br><span class="line">  .then(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="comment">// 第二个promise实例</span></span><br><span class="line">    <span class="comment">// p2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'second------'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// t2</span></span><br><span class="line">  .then(<span class="function">(<span class="params">second</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">    <span class="comment">// 第三个promise实例</span></span><br><span class="line">    <span class="comment">// p3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'third------'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// t3</span></span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 1s之后执行</span></span><br><span class="line"><span class="comment">// "first------" + new Date()</span></span><br><span class="line"><span class="comment">// 在上面的基础上等待2s之后执行</span></span><br><span class="line"><span class="comment">// "second------" + new Date()</span></span><br><span class="line"><span class="comment">// 在上面的基础上等待3s之后执行</span></span><br><span class="line"><span class="comment">// "third------" + new Date()</span></span><br></pre></td></tr></table></figure>
<p>整理一下内部的执行过程：</p>
<ol>
<li>当实例化<code>p1</code>时，在它<code>1s</code>后调用<code>resolve</code>函数，在它的<code>t1</code>中传入一个函数，这个函数返回一个<code>p2</code>实例。</li>
<li><code>t2</code>的执行，要等到<code>p2</code>的状态改变才执行。当执行<code>t2</code>时，又会产生一个<code>p3</code>实例。</li>
<li>等到<code>p3</code>的状态改变时，才会触发后续的<code>t3</code>执行。</li>
</ol>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>Polyfill</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise系列（一） Promise的使用</title>
    <url>/blog/es/promise/es6-promise-one.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/op3EaSXKTCXwYt_uRvhePg" target="_blank" rel="noopener">高级进阶：深度揭秘 Promise 注册微任务和执行过程</a></p>
]]></content>
      <categories>
        <category>ECMAScript6</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中source-map、WebpackPreload、WebpackPrefetch、WebpackChunkName</title>
    <url>/blog/webpack/options/webpack-source-map.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 webpack 中的比如在调试 vue 代码或者 react 代码中，调试打包后的代码时候，我们都会用到一个叫做 soruce-map，我们都是通过 devtool 来配置。比如说在 vue-cli 或者 create-react-app 中都有用到，source-map 有很多种，我们在这里记录一下他们对应的解释。<br>在编写 vue、react 的时候，我们想做懒加载是，有非常适合 chunk splitting 的模块，比如说 vue-router、react-router，在做懒加载切割的时候有三个要注意的不如说 WebpackChunkName、WebpackPreload、WebpackPrefetch 三个配置，他们分别对应 chunk 的 name，和 chunk 代码何时被加载。</p>
<blockquote>
<p><a href="/blog/webpack/docs/webpack-chunkhas-hash-contenthash.html">chunkhas-hash-contenthash</a></p>
</blockquote>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><p>当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。source-map 就是帮忙<strong>追踪 rror(错误) 和 warning(警告)的</strong>。<br>通过下面官方提供的表格一览 devtool 对应 source-map 的配置和速度影响：<br><img src="../../../images/webpack/webpack-1-2.png" alt="webpack source-map"><br>在这个上面那种适合 prod 那种适合 dev 环境，还有构建速度和重新构建速度等等。我们可以在上面的基础上再把所有的配置分为四类，<strong>cheap、inline、eval、module</strong>四种，再在这种基础上看一下他们的区别，当然官方提供了 devtool 各种配置下得具体区别，有兴趣的可以看一下<a href="https://github.com/webpack/webpack/tree/master/examples/source-map" target="_blank" rel="noopener">devtool 各种打包区别</a>。</p>
<p><strong>heap、inline、eval、module 四种解释如下图标所示</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">带有参数</th>
<th style="text-align:center">不同的表现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cheap</td>
<td style="text-align:center">带有 cheap 参数的表示，在追踪 error、warning 时，只显示当前文件的行数，不显示当前在行数中的列数</td>
</tr>
<tr>
<td style="text-align:center">inline</td>
<td style="text-align:center">source map 转换为 DataUrl（base64） 后添加到 bundle 中，不产生 source-map 文件</td>
</tr>
<tr>
<td style="text-align:center">eval</td>
<td style="text-align:center">打包后的模块都使用 eval() 执行，行映射可能不准；不产生独立的 map 文件， 四中带有 eval 的对比请看<a href="https://webpack.docschina.org/configuration/devtool#%E5%AF%B9%E4%BA%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">四中 eval 对比</a></td>
</tr>
<tr>
<td style="text-align:center">module</td>
<td style="text-align:center">增加第三方库的 error、warning 追踪</td>
</tr>
</tbody>
</table>
<p>在下面对比 source-map、eval-source-map、cheap-source-map、cheap-module-source-map、inline-souce-map 来验证我们上面的总结<br>基础代码是在<a href="/blog/webpack/docs/webpack-chunkhas-hash-contenthash.html">另一篇博客</a>中</p>
<h3 id="source-map-1"><a href="#source-map-1" class="headerlink" title="source-map"></a>source-map</h3><p>webpack 中用使用 devtool，修改 webpack.config.js 文件代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>); <span class="comment">// 新增</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    chunk1: <span class="string">'./src/chunk1.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行 webpack 结果如下：<br><img src="../../../images/webpack/webpack-2-1.png" alt="webpack contenthash hash chunkhash"><br>可以看到多了三个文件，就是对应我们业务代码 bundle 的 map 映射。</p>
<h3 id="eval-source-map"><a href="#eval-source-map" class="headerlink" title="eval-source-map"></a>eval-source-map</h3><p>修改 devtool，修改 webpack.config.js 文件代码如下：</p>
<pre><code class="javascript">
</code></pre>
<h3 id="cheap-source-map"><a href="#cheap-source-map" class="headerlink" title="cheap-source-map"></a>cheap-source-map</h3><h3 id="cheap-module-source-map"><a href="#cheap-module-source-map" class="headerlink" title="cheap-module-source-map"></a>cheap-module-source-map</h3><h3 id="inline-souce-map"><a href="#inline-souce-map" class="headerlink" title="inline-souce-map"></a>inline-souce-map</h3><h2 id="WebpackPreload、WebpackPrefetch、WebpackChunkName"><a href="#WebpackPreload、WebpackPrefetch、WebpackChunkName" class="headerlink" title="WebpackPreload、WebpackPrefetch、WebpackChunkName"></a>WebpackPreload、WebpackPrefetch、WebpackChunkName</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>devtool</strong></p>
<ul>
<li>在 dev 环境中推荐使用 cheap-module-eval-source-map</li>
<li>在生产环境不推荐使用 devtool 一般都是使用 false、‘none’，如果线上有错误日志收集的话推荐使用 source-map。</li>
</ul>
<p>注意：如果生产环境上使用了 source-map，你应该将你的服务器配置为，不允许普通用户访问 source map 文件！</p>
]]></content>
      <categories>
        <category>WebPack</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>http中的jwt的实现</title>
    <url>/blog/network/cookie-jwt-seesion-auth2.0/http-jwt.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Http</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Http中的缓存（三） PWA中的serviceworker</title>
    <url>/blog/network/cache/http-cache-serviceworker.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先了解一下<code>PWA（Progressive web apps，渐进式 Web 应用）</code>运用现代的 <code>Web API</code> 以及传统的渐进式增强策略来创建跨平台 <code>Web</code> 应用程序。<br><strong>PWA 的优点</strong><br><code>PWA</code> 是<strong>可被发现</strong>、<strong>易安装</strong>、<strong>可链接</strong>、<strong>独立于网络</strong>、<strong>渐进式</strong>、<strong>可重用</strong>、<strong>响应性</strong>和<strong>安全</strong>的。<br><code>PWA</code>中可以通过<code>Service Worker</code>来实现离线的应用，这个也是 PWA 中一个比较重要的环节，它们主要应用到<strong>Web App</strong>中，已获得更好的体验，并且在现在也在大规模的应用。<br><code>Service Worker</code>是一个事件驱动<code>worker</code>，运行在一个单独的后台进程，是<code>PWA（ProgressiveWeb App）</code>运行的基础。主要用于代理网页请求，可缓存请求结果；可实现离线缓存功能，也拥有单独的作用域范围和运行环境。我们以后把<code>Service Worker</code>简称为<code>SW</code>。</p>
<p>本文大致分为：</p>
<ul>
<li>SW 特性</li>
<li>SW 生命周期和使用</li>
<li>SW 中的缓存策略</li>
<li>SW 一些注意事项</li>
<li>SW 几种缓存策略</li>
<li>SW 中的消息推送</li>
<li>Workerbox 使用</li>
</ul>
<h2 id="SW-的特性"><a href="#SW-的特性" class="headerlink" title="SW 的特性"></a>SW 的特性</h2><p>它们的运行在一个与我们页面的 <code>JavaScript 主线程独立的线程上</code>，并且<code>没有对 DOM 结构</code>的任何访问权限。<br>这引入了与传统 Web 编程不同的方法 - <code>API 是非阻塞的</code>，并且可以在不同的<code>上下文之间发送和接收信息</code>。</p>
<h3 id="SW-使用限制"><a href="#SW-使用限制" class="headerlink" title="SW 使用限制"></a>SW 使用限制</h3><p><code>SW</code>除了<code>work</code>线程的限制外，由于可拦截页面请求，为了保证页面安全，浏览器端对<code>sw</code>的使用限制也不少。</p>
<ul>
<li><strong>无法直接操作 DOM 对象</strong>，也无法访问<code>window</code>、<code>document</code>、<code>parent</code>对象。可以访问<code>navigator</code>、<code>location</code>； <code>SW</code> 通过响应 <code>postMessage</code> 接口发送的消息来与其控制的页面通信，页面可在必要时对 <code>DOM</code> 执行操作。</li>
<li><strong>可代理的页面作用域限制</strong>。默认是<code>sw.js</code>所在<strong>文件目录及子目录的请求可代理</strong>，可在注册时手动设置作用域范围；</li>
<li><strong>必须</strong>在 <code>https</code> 中使用，允许在开发调试的<code>localhost</code>使用。</li>
</ul>
<h3 id="SW-主要作用"><a href="#SW-主要作用" class="headerlink" title="SW 主要作用"></a>SW 主要作用</h3><ul>
<li><strong>可以用来做缓存，以达到提升体验、节省浏览等等</strong></li>
<li><strong>SW 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。</strong></li>
<li><strong>离线缓存接口请求及文件，更新、清除缓存内容；</strong></li>
<li><strong>可分配给 Service Worker 一些任务，并在使用基于 Promise 的方法当任务完成时收到结果。</strong></li>
<li><strong>Service Worker 处于空闲状态会被终止，在下一次需要时重启。</strong></li>
</ul>
<h3 id="SW-兼容性"><a href="#SW-兼容性" class="headerlink" title="SW 兼容性"></a>SW 兼容性</h3><p>可以通过查询<a href="https://caniuse.com/#search=service%20worker" target="_blank" rel="noopener">service worker</a>可以看到他在不同平台或不同浏览器中的兼容性。</p>
<h2 id="SW-生命周期和使用"><a href="#SW-生命周期和使用" class="headerlink" title="SW 生命周期和使用"></a>SW 生命周期和使用</h2><p><code>SW</code> 的生命周期完全独立于网页。<br><code>SW</code> 为网页添加一个类似于 <code>App</code> 的生命周期，它只会<strong>响应系统事件</strong>，就算<strong>浏览器关闭</strong>时操作系统也可以唤醒 <code>SW</code>，这点非常重要，让<code>Web App</code>与 <code>Native App</code> 的能力变得类似了。由于是离线缓存，所以在<strong>初始安装时</strong>、<strong>更新</strong>它们的所走的生命周期是不相同。下面我们就根据这<strong>两种场景结合代码来分析</strong>它的执行步骤。<br><code>SW</code>的生命周期大致分为：<strong>注册</strong>、<strong>更新</strong>、<strong>安装成功</strong>、<strong>安装失败</strong>、<strong>激活</strong>、<strong>销毁</strong>。</p>
<!-- `SW`的事件： `install`、`activate`、`message`、`fetch`、`push`、`async`。 -->
<p><strong>使用 SW 前提条件</strong></p>
<ul>
<li><strong>必须</strong>在 <code>https</code> 中使用，允许在开发调试的<code>localhost</code>使用。</li>
<li>浏览器必须支持 SW</li>
</ul>
<h2 id="初始安装时"><a href="#初始安装时" class="headerlink" title="初始安装时"></a>初始安装时</h2><p>初始安装时大致流程大致如下图：<br><img src="./http-cache-serviceworker/http-cache-4-1.png" alt="http-cache-serviceworker"></p>
<p>大致可以分为<code>注册SW =&gt; 安装SW =&gt; 激活 =&gt; 空闲 =&gt; (缓存和返回请求/终止)</code>，在初始安装时会大致分为这几个步骤，下面就按照这几个步结合代码实现。</p>
<h3 id="注册-Service-Worker"><a href="#注册-Service-Worker" class="headerlink" title="注册 Service Worker"></a>注册 Service Worker</h3><p>用户<strong>首次访问</strong>SW 控制的网站或页面时，<code>sw.js</code>会立刻被下载和解析。我们要在页面中写入<code>JavaScript</code>来注册<code>SW</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断浏览器是否支持serviceWorker</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="comment">// 在页面加载后</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过navigator.serviceWorker.register 注册'./sw.js</span></span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">'./sw.js'</span>)</span><br><span class="line">      .then(<span class="function">(<span class="params">reg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//注册成功</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'注册成功'</span>, reg);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//注册成功</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'注册失败'</span>, err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'当前浏览器不支持SW'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先检浏览器是否支持 SW，如果支持就在浏览器加载后通过<code>register().then</code>注册<strong>sw.js</strong>，并且设置注册成功或者失败的回调函数。</p>
<blockquote>
<p>注意：<code>register()</code> 方法的精妙之处在于服务工作线程文件的位置。<code>SW</code>降接收此网域上所有的事项的<code>featch</code>事件。<br>如果是 Chrome 浏览器可以通过<code>chrome://inspect/#service-workers</code>或者<code>console =&gt; application =&gt; Service Worker</code>查看是否注册成功</p>
</blockquote>
<p>因为现在<code>sw.js</code>中我们的代码是空的，所以在浏览器中的<code>cache stoage</code>是空的，运行效果如下：</p>
<p><img src="./http-cache-serviceworker/http-cache-4-4.png"></p>
<h3 id="安装-Service-Worker"><a href="#安装-Service-Worker" class="headerlink" title="安装 Service Worker"></a>安装 Service Worker</h3><p>在受控页面启动注册流程后，下面就是 SW 获取的第一个事件<code>install</code>，并且只发生一次。传递到 <code>installEvent.waitUntil()</code> 的一个 <code>promise</code> 可表明安装的持续时间以及安装是否成功。</p>
<p>在<code>install</code>中要做三件事<strong>打开缓存</strong>、<strong>缓存文件</strong>、<strong>确认所有需要的资产是否已缓存</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在sw.js中监听对应的安装事件，并预处理需要缓存的文件</span></span><br><span class="line"><span class="comment">// 该部分内容涉及到cacheStorage API</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓存空间名称</span></span><br><span class="line"><span class="keyword">const</span> CACHE_NAME = <span class="string">'sw_cache_v1'</span>;</span><br><span class="line"><span class="comment">// 定义需要缓存的文件目录</span></span><br><span class="line"><span class="keyword">let</span> cachelist = [<span class="string">'./app.js'</span>, <span class="string">'./index.css'</span>];</span><br><span class="line"><span class="comment">// 监听安装事件，返回installEvent对象</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">installEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// waitUntil方法执行缓存方法</span></span><br><span class="line">  installEvent.waitUntil(</span><br><span class="line">    <span class="comment">// cacheStorage API 可直接用caches来替代</span></span><br><span class="line">    <span class="comment">// open方法创建/打开缓存空间，并会返回promise实例</span></span><br><span class="line">    <span class="comment">// then来接收返回的cache对象索引</span></span><br><span class="line">    caches</span><br><span class="line">      .open(CACHE_NAME)</span><br><span class="line">      <span class="comment">// cache对象addAll方法解析（同fetch）并缓存所有的文件</span></span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Opened cache'</span>);</span><br><span class="line">        <span class="keyword">return</span> cache.addAll(cachelist);</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一个事件为<code>install</code>，该事件在<code>Worker</code>执行时立即触发。在<code>install</code>的回调函数中，我们通过<code>caches.open(CACHE_NAME)</code>打开缓存，之后调用<code>cache.addAll()</code>并传入路径数组。这是一个<code>promise</code>链（<code>caches.open()</code>和<code>chaches.addAll()</code>。<code>installEvent.waitUntill()</code>放大带有<code>promise</code>并使用它来判断安装所花时间，以及是否安装成功。</p>
<blockquote>
<p>注意： 第一个事件<code>install</code>，它只能被每个 <strong>SW</strong> 调用一次。如果您更改您的 <strong>SW</strong> 脚本，则浏览器将其视为一个<strong>不同</strong>的 <strong>SW</strong>，并且它将获得自己的 <code>install</code> 事件。<br>如有<strong>任何文件无法下载</strong>，则安装步骤将失败。<br>当前的状态是在等待状态。<br>我们可以直接通过<code>self.skipwaiting()</code>让当前<code>sw</code>立即将状态提升到<code>active</code>。</p>
</blockquote>
<p>当我们安装成功时，效果如下图所示：</p>
<p><img src="./http-cache-serviceworker/http-cache-4-5.png" alt="http-cache-serviceworker"></p>
<p>会多了一个<code>skipWaiting</code>，还有在<code>cache stroage</code>中的当前域名下的<code>service worker</code>对应的缓存文件列表。这个时候我们即使刷新也不会走<code>service worker</code>的缓存的。</p>
<h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p><code>SW</code> 准备控制客户端并处理 <code>push</code> 和 <code>sync</code> 等功能事件时，您将获得一个 <code>activate</code> 事件。但这不意味着调用 <code>.register()</code> 的页面将受控制。如果<strong>第二次加载此演示（换言之，刷新页面）</strong>，该页面将受控制。改写代码<code>sw.js</code>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 一般注册以后，激活需要等到再次刷新页面后再激活</span></span><br><span class="line">  <span class="comment">// 可防止出现等待的情况，这意味着服务工作线程在安装完后立即激活</span></span><br><span class="line">  self.skipWaiting();</span><br><span class="line">&#125;);</span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// cacheStorage API 可直接用caches来替代</span></span><br><span class="line">    <span class="comment">// open方法创建/打开缓存空间，并会返回promise实例</span></span><br><span class="line">    <span class="comment">// then来接收返回的cache对象索引</span></span><br><span class="line">    caches</span><br><span class="line">      .open(CACHE_NAME)</span><br><span class="line">      <span class="comment">// cache对象addAll方法解析（同fetch）并缓存所有的文件</span></span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Opened cache'</span>);</span><br><span class="line">        <span class="keyword">return</span> cache.addAll(cachelist);</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一般在书写的时候，会在<code>install()</code>注册之后直接通过<code>self.skipWaiting();</code>激活当前的<code>SW</code>，在<code>activate</code>中书写<strong>打开缓存等等</strong>的逻辑，就不会出现上面还要<strong>刷新或者手动激活</strong>的问题。效果图如下：</p>
<p><img src="./http-cache-serviceworker/http-cache-4-6.png" alt="http-cache-serviceworker"></p>
<p>但是如果出现<strong>更新 SW</strong>，并且<strong>更新了缓存列表</strong>或者<strong>出现异步资源时</strong>，我们可以通过<code>clients.claim()</code>更新缓存列表。</p>
<h3 id="clients-claim"><a href="#clients-claim" class="headerlink" title="clients.claim"></a>clients.claim</h3><p>激活 <code>SW</code> 后，您可以通过在其中调用 <code>clients.claim()</code> 控制未受控制的客户端。<a href="https://cdn.rawgit.com/jakearchibald/80368b84ac1ae8e229fc90b3fe826301/raw/df4cae41fa658c4ec1fa7b0d2de05f8ba6d43c94/" target="_blank" rel="noopener">google developer</a>中的一个异步加载图片的实例。下面修改代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, (event) =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// cacheStorage API 可直接用caches来替代</span></span><br><span class="line">    <span class="comment">// open方法创建/打开缓存空间，并会返回promise实例</span></span><br><span class="line">    <span class="comment">// then来接收返回的cache对象索引</span></span><br><span class="line">    caches</span><br><span class="line">      .open(CACHE_NAME)</span><br><span class="line">      <span class="comment">// cache对象addAll方法解析（同fetch）并缓存所有的文件</span></span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Opened cache'</span>);</span><br><span class="line">        <span class="keyword">return</span> cache.addAll(cachelist);</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 一般注册以后，激活需要等到再次刷新页面后再激活</span></span><br><span class="line">  <span class="comment">// 可防止出现等待的情况，这意味着服务工作线程在安装完后立即激活</span></span><br><span class="line">  self.skipWaiting();</span><br><span class="line">&#125;);</span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 若缓存数据更改，则在这里更新缓存</span></span><br><span class="line">  <span class="keyword">var</span> cacheDeletePromise = caches.keys().then(<span class="function">(<span class="params">keyList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.all(</span><br><span class="line">      keyList.map(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== CACHE_NAME) &#123;</span><br><span class="line">          <span class="keyword">var</span> deletePromise = caches.delete(key);</span><br><span class="line">          <span class="keyword">return</span> deletePromise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="built_in">Promise</span>.all([cacheDeletePromise]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.clients.claim();</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用于处理更新缓存，新的文件。到现在我们还是没有用到<code>serviceWorker</code>的缓存，下面重头戏来了<strong>缓存和返回请求</strong>。</p>
<h3 id="缓存和返回请求"><a href="#缓存和返回请求" class="headerlink" title="缓存和返回请求"></a>缓存和返回请求</h3><p>上我们已经安装并且激活了<strong>SW</strong>，现在我们要返回一个缓存的响应。<strong>SW</strong>用户转至其他页面或刷新当前页面后，将开始接受<code>fetch</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Cache hit - return response</span></span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在定义的<code>fetch</code>事件中，我们在<code>event.respondWith()</code>中传入来自<code>caches.match()</code>的一个<code>promise</code>。<code>caches.match()</code>这个方法检视该请求，并从服务工作线程所创建的任何缓存中查找缓存的结果。如果命中返回缓存值，否则，将调用<code>fetch</code>以发出网络请求。运行效果如下：</p>
<p><img src="./http-cache-serviceworker/http-cache-4-7.png" alt="http-cache-serviceworker"></p>
<p>如果我们想把新的请求也缓存掉，修改代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Cache hit - return response</span></span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// return fetch(event.request);</span></span><br><span class="line">      <span class="keyword">var</span> requestClone = event.request.clone();</span><br><span class="line">      <span class="keyword">return</span> fetch(requestClone).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span> || response.type !== <span class="string">'basic'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> responseToCache = response.clone();</span><br><span class="line">        caches.open(CACHE_NAME).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          cache.put(event.request, responseToCache);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行操作如下：</p>
<ol>
<li>在 <code>fetch</code> 请求中添加对 <code>.then()</code> 的回调。</li>
<li>获得响应后，<strong>确保响应有效。</strong>、<strong>检查并确保响应的状态为 200。</strong>、<strong>确保响应类型为 basic，亦即由自身发起的请求。 这意味着，对第三方资产的请求也不会添加到缓存。</strong></li>
<li>如果<strong>通过检查</strong>，则克隆响应。</li>
</ol>
<p>没有缓存新请求时效果如下：<br><img src="./http-cache-serviceworker/http-cache-4-8.png" alt="http-cache-serviceworker"></p>
<p>当使用我们下面的代码时，效果图如下：<br><img src="./http-cache-serviceworker/http-cache-4-9.png" alt="http-cache-serviceworker"><br>即使异步请求的<code>png</code>图片也被加入了缓存中。</p>
<h2 id="更新-SW"><a href="#更新-SW" class="headerlink" title="更新 SW"></a>更新 SW</h2><p>在以下情况下会触发更新：</p>
<ul>
<li>导航到一个作用域内的页面。</li>
<li>更新 <code>push</code> 和 <code>sync</code> 等功能事件，除非在前 24 小时内已进行更新检查。</li>
<li>调用 <code>.register()</code>，仅在 <code>SW</code> 网址已发生变化时。</li>
</ul>
<p>当触发更新时，会经过大致如下步骤：</p>
<ol>
<li>更新您的<strong>服务工作线程</strong> <code>JavaScript</code> 文件。 用户导航至您的站点时，浏览器会尝试在<strong>后台重新下载</strong>定义 <code>SW</code> 的脚本文件。 如果 <code>SW</code> 文件与其当前所用文件存在字节<strong>差异</strong>，则将其视为新 <code>SW</code>。</li>
<li><strong>更新</strong>的 <code>SW</code> 与<strong>现有</strong> <code>SW</code> 一起启动，并获取自己的 <code>install</code> 事件。</li>
<li>此时，<strong>旧</strong> <code>SW</code> 仍<strong>控制着</strong>当前页面，因此<strong>新</strong> <code>SW</code> 将进入 <code>waiting</code> 状态。</li>
<li>如果<code>新 Worker</code> 出现<strong>不正常状态代码</strong>（例如，404）、解析失败，在执行中<strong>引发错误</strong>或<strong>在安装期间被拒</strong>，则系统<code>将舍弃新 Worker</code>，但<code>当前 Worker 仍处于活动状态</code>。</li>
<li>安装成功后，<code>更新的 Worker 将 wait</code>，直到<code>现有 Worker</code> 控制零个客户端。（注意，在刷新期间客户端会重叠。）</li>
<li><code>self.skipWaiting()</code> 可防止出现等待情况，这意味着 <code>Service Worker</code> 在安装完后立即激活。</li>
</ol>
<h3 id="更新-SW-代码"><a href="#更新-SW-代码" class="headerlink" title="更新 SW 代码"></a>更新 SW 代码</h3><p>更新一个叫做<code>sw_cache_v2</code>的新的<code>SW</code>缓存，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CACHE_NAME = <span class="string">'sw_cache_v2'</span>;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, (event) =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// cacheStorage API 可直接用caches来替代</span></span><br><span class="line">    <span class="comment">// open方法创建/打开缓存空间，并会返回promise实例</span></span><br><span class="line">    <span class="comment">// then来接收返回的cache对象索引</span></span><br><span class="line">    caches</span><br><span class="line">      .open(CACHE_NAME)</span><br><span class="line">      <span class="comment">// cache对象addAll方法解析（同fetch）并缓存所有的文件</span></span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.add(<span class="string">'index_copy.png'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 一般注册以后，激活需要等到再次刷新页面后再激活</span></span><br><span class="line">  <span class="comment">// 可防止出现等待的情况，这意味着服务工作线程在安装完后立即激活</span></span><br><span class="line">  self.skipWaiting();</span><br><span class="line">&#125;);</span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 若缓存数据更改，则在这里更新缓存</span></span><br><span class="line">  <span class="keyword">var</span> cacheDeletePromise = caches.keys().then(<span class="function">(<span class="params">keyList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.all(</span><br><span class="line">      keyList.map(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== CACHE_NAME) &#123;</span><br><span class="line">          <span class="keyword">var</span> deletePromise = caches.delete(key);</span><br><span class="line">          <span class="keyword">return</span> deletePromise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="built_in">Promise</span>.all([cacheDeletePromise]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.clients.claim();</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Cache hit - return response</span></span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>代码执行效果如下图所示：</p>
<p><img src="./http-cache-serviceworker/http-cache-4-10.png" alt="http-cache-serviceworker"></p>
<p>整个过程我们大致经过了<code>install =&gt; waiting =&gt; activate</code>三个过程。</p>
<h3 id="更新-Install"><a href="#更新-Install" class="headerlink" title="更新 Install"></a>更新 Install</h3><p>我们在代码中把<code>sw_cache_v1</code>更改为<code>sw_cache_v2</code>，我们重新<code>Install</code>了一个新的缓存<code>sw_cache_v2</code>，并且通过添加了一个缓存进去<code>cache.add(&#39;index_copy.png&#39;)</code>。</p>
<h3 id="更新-Waiting"><a href="#更新-Waiting" class="headerlink" title="更新 Waiting"></a>更新 Waiting</h3><p>如果新的缓存安装成功<code>SW</code>后，更新的<code>SW</code>将延迟激活，直到现有<code>SW</code>不再控制任何客户端。此状态为<code>waiting</code>，这是浏览器确保每次只运行一个<code>SW</code>版本的样式。</p>
<h3 id="激活-Activate"><a href="#激活-Activate" class="headerlink" title="激活 Activate"></a>激活 Activate</h3><p>旧 <code>SW</code> 退出时将触发 <code>Activate</code>，新 <code>SW</code> 将能够控制客户端。此时，您可以执行在仍使用旧 <code>Worker</code> 时无法执行的操作，如迁移数据库和清除缓存。<br>在上面的演示中，我维护了一个期望保存的缓存列表，并且在 <code>activate</code>事件中，我删除了所有其他缓存，从而也移除了旧的 <code>sw_cache_v1</code> 缓存。</p>
<blockquote>
<p>不要更新以前的版本。它可能是许多旧版本的 <code>SW</code>。</p>
</blockquote>
<p>如果您将一个 <code>promise</code> 传递到 <code>event.waitUntil()</code>，它将缓冲功能事件（<code>fetch、push、sync</code> 等），直到 <code>promise</code> 进行解析。因此，当您的 <code>fetch</code> 事件触发时，激活已全部完成。</p>
<blockquote>
<p><code>Cache storage API</code> 属于“源存储”（如 <code>localStorage</code> 和 <code>IndexedDB</code>）。如果您在同源上运行许多网站（例如，<code>yourname.github.io/myapp</code>），请注意，不要删除其他网站的缓存。为避免此问题，可以为您的缓存名称提供一个在当前网站上具有唯一性的前缀（例如，myapp-static-v1），并且不要删除缓存，除非它们以 myapp- 开头。</p>
</blockquote>
<h3 id="跳过等待阶段-skipWaiting"><a href="#跳过等待阶段-skipWaiting" class="headerlink" title="跳过等待阶段 skipWaiting"></a>跳过等待阶段 skipWaiting</h3><p>等待阶段表示您每次只能运行一个网站版本，但如果您不需要该功能，您可以通过调用 <code>self.skipWaiting()</code> 尽快将新 <code>SW</code> 激活。<br>这会导致您的 <code>SW</code> 将当前活动的 <code>Worker</code> 逐出，并在进入<strong>等待阶段</strong>时尽快激活自己（或<strong>立即激活</strong>，前提是已经处于<strong>等待阶段</strong>）。这不能让您的 <code>Worker</code> <strong>跳过安装</strong>，只是<strong>跳过等待阶段</strong>。<br><code>skipWaiting()</code> 在等待期间调用还是在之前调用并没有什么不同。一般情况下是在 <code>install</code> 事件中调用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, (event) =&gt; &#123;</span><br><span class="line">  self.skipWaiting();</span><br><span class="line">  event</span><br><span class="line">    .waitUntil</span><br><span class="line">    <span class="comment">// caching etc</span></span><br><span class="line">    ();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>与 <code>clients.claim()</code> 一样，它是一个竞态。</p>
<blockquote>
<p><code>skipWaiting()</code> 意味着新 Service Worker 可能会控制使用较旧 <code>Worker</code> 加载的页面。这意味着页面提取的部分数据将由旧 Service Worker 处理，而新 Service Worker 处理后来提取的数据。如果这会导致问题，则不要使用 <code>skipWaiting()</code>。</p>
</blockquote>
<h3 id="手动更新-update"><a href="#手动更新-update" class="headerlink" title="手动更新 update"></a>手动更新 update</h3><p>当页面<strong>刷新或者执行功能性事件时</strong>，浏览器会<strong>自动</strong>检查更新，其实我们也可以<strong>手动</strong>的来触发更新：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function">(<span class="params">reg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// sometime later…</span></span><br><span class="line">  reg.update();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你希望你的用户访问页面很长时间而且不用刷新，那么你可以每个一段时间调用一次<code>update()</code>。</p>
<h3 id="避免改变-SW-的-URL"><a href="#避免改变-SW-的-URL" class="headerlink" title="避免改变 SW 的 URL"></a>避免改变 SW 的 URL</h3><p>你可能会考虑给每个 <code>SW</code> 不同的 <code>URL</code>。<strong>千万不要这么做！</strong>在 <code>SW</code> 中这么做是“最差实践”，要在原地址上修改 <code>SW</code>。</p>
<p>举个例子来说明为什么：</p>
<ol>
<li><p><code>index.html</code>注册了<code>sw-v1.js</code>作为<code>SW</code>。</p>
</li>
<li><p><code>sw-v1.js</code>对<code>index.html</code>做了缓存，也就是缓存优先（<code>offline-first</code>）。</p>
</li>
<li><p>你更新了<code>index.html</code>重新注册了在新地址的 SW <code>sw-v2.js</code>.</p>
</li>
</ol>
<p>如果你像上面那么做，用户永远也拿不到<code>sw-v2.js</code>，因为<code>index.html</code>在<code>sw-v1.js</code>缓存中，这样的话，如果你想更新为<code>sw-v2.js</code>，还需要更改原来的<code>sw-v1.js</code>。</p>
<h2 id="SW-一些注意事项"><a href="#SW-一些注意事项" class="headerlink" title="SW 一些注意事项"></a>SW 一些注意事项</h2><p>这里主要分为：</p>
<ul>
<li><strong>更新的小技巧</strong></li>
<li><strong>sync 事件</strong></li>
</ul>
<h3 id="更新小技巧"><a href="#更新小技巧" class="headerlink" title="更新小技巧"></a>更新小技巧</h3><p><code>SW</code> 生命周期是专为用户构建的，这就给开发工作带来一定的困难。幸运的是，我们可通过以下几个工具解决这个问题：</p>
<h4 id="Update-on-reload"><a href="#Update-on-reload" class="headerlink" title="Update on reload"></a>Update on reload</h4><p><img src="./http-cache-serviceworker/http-cache-4-11.png" alt="http-cache-serviceworker"></p>
<p>这可使生命周期变得对开发者友好。每次浏览时都将：</p>
<ol>
<li>重新提取 <code>SW</code>。</li>
<li>即使<strong>字节完全相同</strong>，也将其作为新版本安装，这表示运行 <code>install</code> 事件并<strong>更新缓存</strong>。</li>
<li><strong>跳过等待阶段</strong>，以<strong>激活</strong>新 <code>SW</code>。</li>
<li>浏览页面。这意味着<strong>每次浏览时（包括刷新）都将进行更新</strong>，无需重新加载两次或关闭标签。</li>
</ol>
<h4 id="Skip-waiting"><a href="#Skip-waiting" class="headerlink" title="Skip waiting"></a>Skip waiting</h4><p><img src="./http-cache-serviceworker/http-cache-4-12.png" alt="http-cache-serviceworker"></p>
<p>如果您有一个 <code>Worker</code> 在等待，您可以按 <code>DevTools</code> 中的“<code>skip waiting</code>”以立即将其提升到“<code>active</code>”。同时也可以通过<code>self.skipWaiting()</code>来实现。</p>
<h4 id="Shift-reload"><a href="#Shift-reload" class="headerlink" title="Shift-reload"></a>Shift-reload</h4><p>如果您强制重新加载页面 <code>(shift-reload)</code>，则将完全绕过 <code>SW</code>。页面将变得不受控制。此功能已列入规范，因此，它在其他支持 <code>SW</code> 的浏览器中也适用。</p>
<h4 id="处理更新周期"><a href="#处理更新周期" class="headerlink" title="处理更新周期"></a>处理更新周期</h4><p>为支持尽可能多的模式，整个更新周期都是可观察的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function">(<span class="params">reg</span>) =&gt;</span> &#123;</span><br><span class="line">  reg.installing; <span class="comment">// the installing worker, or undefined</span></span><br><span class="line">  reg.waiting; <span class="comment">// the waiting worker, or undefined</span></span><br><span class="line">  reg.active; <span class="comment">// the active worker, or undefined</span></span><br><span class="line"></span><br><span class="line">  reg.addEventListener(<span class="string">'updatefound'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// A wild service worker has appeared in reg.installing!</span></span><br><span class="line">    <span class="keyword">const</span> newWorker = reg.installing;</span><br><span class="line"></span><br><span class="line">    newWorker.state;</span><br><span class="line">    <span class="comment">// "installing" - the install event has fired, but not yet complete</span></span><br><span class="line">    <span class="comment">// "installed"  - install complete</span></span><br><span class="line">    <span class="comment">// "activating" - the activate event has fired, but not yet complete</span></span><br><span class="line">    <span class="comment">// "activated"  - fully active</span></span><br><span class="line">    <span class="comment">// "redundant"  - discarded. Either failed install, or it's been</span></span><br><span class="line">    <span class="comment">//                replaced by a newer version</span></span><br><span class="line"></span><br><span class="line">    newWorker.addEventListener(<span class="string">'statechange'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// newWorker.state has changed</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.addEventListener(<span class="string">'controllerchange'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// This fires when the service worker controlling this page</span></span><br><span class="line">  <span class="comment">// changes, eg a new worker has skipped waiting and become</span></span><br><span class="line">  <span class="comment">// the new active worker.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="sync-事件"><a href="#sync-事件" class="headerlink" title="sync 事件"></a>sync 事件</h3><p><code>Sync事件</code>让你可以先将网络相关任务延迟到用户<strong>有网络</strong>的时候<strong>再执行</strong>。这个功能常被称作“<strong>背景同步</strong>”。这功能可以用于保证任何用户<strong>在离线</strong>的时候所产生<strong>对于网络有依赖</strong>的操作，最终可以在网络再次可用的时候抵达它们的目标。</p>
<p>代码示例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">navigator.serviceWorker.ready.then(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'submit'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    registration.sync.register(<span class="string">'submit'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'sync registered!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们指定在一个按钮的点击事件里，在一个全局的 <code>ServiceWorkerRegistration</code> 对象身上调用 <code>sync.register</code>。</p>
<p>简单地讲，任何你需要确保在<strong>有网络时立刻执行</strong>或者<strong>等到有网再执行</strong>的操作，都需要注册为一个<code>sync事件</code>。</p>
<p>这操作可以是发送一个评论，或者获取用户信息，在 SW 的事件监听器里会如下定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line">self.addEventListener(<span class="string">'sync'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.tag === <span class="string">'submit'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sync!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们监听一个 <code>sync 事件</code>，然后在 <code>SyncEvent</code> 对象上检查 <code>tag</code> 是否匹配我们在点击事件里所设定的 <code>&#39;submit&#39;</code>。</p>
<p>如果多个 <code>tag</code> 标记为 <code>submit</code> 的 <code>sync</code>事件被注册了，<code>sync</code> 事件处理器只会运行一次。</p>
<p>所以在这个例子里，如果用户离线了，然后点击按钮 7 次，当网络再次连上，所有的<code>sync</code>注册都会合而为一，<code>sync</code>事件只会触发一次。</p>
<h4 id="Sync-事件是什么时候触发"><a href="#Sync-事件是什么时候触发" class="headerlink" title="Sync 事件是什么时候触发"></a>Sync 事件是什么时候触发</h4><p>如果用户的网络时联通的，那么<code>sync事件</code>会<strong>立刻触发</strong>并且<strong>立刻执行</strong>你所定义的任务。</p>
<p>而如果用户离线了，<code>sync 事件</code>会在网络恢复后<strong>第一时间触发</strong>。</p>
<h2 id="SW-几种缓存策略"><a href="#SW-几种缓存策略" class="headerlink" title="SW 几种缓存策略"></a>SW 几种缓存策略</h2><ul>
<li>渐进式缓存</li>
<li>仅使用缓存</li>
<li>仅使用网络</li>
<li>缓存优先</li>
<li>网络优先</li>
<li>速度优先</li>
</ul>
<h3 id="渐进式缓存"><a href="#渐进式缓存" class="headerlink" title="渐进式缓存"></a>渐进式缓存</h3><p>对于在<code>install</code>中发现没有缓存，页面<strong>又依赖但又不经常变化</strong>的资源，可以在页面打开或发生用户交互时触发<code>fetch</code>然后使用<code>fetch api</code>再去网络拉取，将返回正常的<code>response缓存</code>起来以便下次使用。</p>
<p><strong>progressive-cache</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Cache hit - return response</span></span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// return fetch(event.request);</span></span><br><span class="line">      <span class="keyword">var</span> requestClone = event.request.clone();</span><br><span class="line">      <span class="keyword">return</span> fetch(requestClone).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span> || response.type !== <span class="string">'basic'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> responseToCache = response.clone();</span><br><span class="line">        caches.open(CACHE_NAME).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          cache.put(event.request, responseToCache);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="仅使用缓存"><a href="#仅使用缓存" class="headerlink" title="仅使用缓存"></a>仅使用缓存</h3><p>在<code>fetch事件</code>中，<strong>仅去匹配资源</strong>，若匹配失败，表现出来的就是前端页面对于该 <strong>资源加载失败</strong>。这里<strong>容错性比较差</strong>，适用于页面资源都是<strong>静态资源</strong>的，且不能使用<strong>不影响安装的资源预缓存</strong>。</p>
<p><strong>cache-only</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SW请求拦截事件</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        caches.open(OFFLINE_CACHE_NAME).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 匹配资源如果命中返回缓存</span></span><br><span class="line">            <span class="keyword">return</span> cache.macth(event.request.url);</span><br><span class="line">        &#125;);</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="仅使用网络"><a href="#仅使用网络" class="headerlink" title="仅使用网络"></a>仅使用网络</h3><p>在<code>fetch事件</code>中，仅将<code>request</code>重新抽出用<code>fetch</code>去网络加载并返回给前端页面。适用于资源大多是<strong>动态资源</strong>、<strong>实时性要求高</strong>的场景。</p>
<p><strong>network-only</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SW请求拦截事件</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 仅使用网络加载</span></span><br><span class="line">  event.respondWith(fetch(event.request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="缓存优先"><a href="#缓存优先" class="headerlink" title="缓存优先"></a>缓存优先</h3><p>简单的资源缓存中使用的就是<strong>缓存优先策略</strong>，<strong>先去缓存匹配</strong>，<strong>匹配失败折回网络</strong>，这算是<strong>最常用、容错性能</strong>好的一种策略。</p>
<p><strong>firstCache</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstCache</span>(<span class="params">cacheName, request</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 打开SW</span></span><br><span class="line">  <span class="keyword">return</span> caches.open(cacheName).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 匹配请求路径</span></span><br><span class="line">    <span class="keyword">return</span> cache.match(request).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// fetch请求</span></span><br><span class="line">      <span class="keyword">var</span> fetchServer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fetch(request).then(<span class="function">(<span class="params">newResponse</span>) =&gt;</span> &#123;</span><br><span class="line">          cache.put(request, newResponse.clone());</span><br><span class="line">          <span class="keyword">return</span> newResponse;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 如果缓存中有数据则返回，否则请求网络数据</span></span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fetchServer();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络优先"><a href="#网络优先" class="headerlink" title="网络优先"></a>网络优先</h3><p>在<code>fetch事件</code>中先去<code>网络fetch</code>，当出现服务器<strong>故障或者网络不良时</strong>，<strong>折回本地缓存</strong>，目的是为了展示最新的数据，对实时性要求比较高但又能够带来良好体验的应用，比如天气类型应用。</p>
<p><strong>firstNet</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstNet</span>(<span class="params">cacheName, request</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 请求网络数据并缓存</span></span><br><span class="line">  <span class="keyword">return</span> fetch(request)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 响应clone</span></span><br><span class="line">      <span class="keyword">var</span> responseCopy = response.clone();</span><br><span class="line">      caches.open(cacheName).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// fetch请求</span></span><br><span class="line">        cache.put(request, responseCopy);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// fetch失败走本地缓存</span></span><br><span class="line">      <span class="keyword">return</span> caches.open(cacheName).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.match(request);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="速度优先"><a href="#速度优先" class="headerlink" title="速度优先"></a>速度优先</h3><p>在<code>fetch事件</code>中<strong>同时发起本地缓存匹配及网络请求</strong>，<strong>谁先返回使用谁的</strong>，该方案<strong>适用于对性能要求比较高</strong>的站点，缩短了缓存优先策略中有可能缓存中没有资源再折回网络的时间消耗。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">networkCacheRace</span>(<span class="params">cacheName, request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer,</span><br><span class="line">    TIMEOUT = <span class="number">500</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 网络好的情况下给网络请求500ms, 若超时则从缓存中取数据</span></span><br><span class="line"><span class="comment">   * 若网络较差且没有缓存, 由于第一个 Promise 会一直处于 pending, 故此时等待网络请求响应</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 缓存请求</span></span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        caches.open(cacheName).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">          cache.match(request).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response) &#123;</span><br><span class="line">              resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, TIMEOUT);</span><br><span class="line">    &#125;),</span><br><span class="line">    fetch(request)</span><br><span class="line">      .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 网络请求</span></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">var</span> responseCopy = response.clone();</span><br><span class="line">        caches.open(cacheName).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">          cache.put(request, responseCopy);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">return</span> caches.open(cacheName).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> cache.match(request);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以在 <code>sw.js</code> 中更改一下缓存策略，从而达到最理想的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/\.(js|css)$/</span>.test(url)) &#123;</span><br><span class="line">    (cacheName = cacheMaps.cache_file) &amp;&amp;</span><br><span class="line">      e.respondWith(networkCacheRace(cacheName, request));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="SW-中的消息推送"><a href="#SW-中的消息推送" class="headerlink" title="SW 中的消息推送"></a>SW 中的消息推送</h2><p><strong>Push 消息</strong></p>
<p>在<code>SW</code>里，通过 <code>push 事件</code>以及浏览器的 <code>Push API</code>，可以实现<code>push消息</code>的功能。<br>在说道<code>web push消息</code>的时候，其实涉及到两个正在完善中的技术：<code>消息提醒</code> 与 <code>信息推送</code>。</p>
<h3 id="消息提醒"><a href="#消息提醒" class="headerlink" title="消息提醒"></a>消息提醒</h3><p>用<code>SW</code>实现消息提醒挺简单直接：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// ask for permission</span></span><br><span class="line">Notification.requestPermission(<span class="function">(<span class="params">permission</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'permission:'</span>, permission);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// display notification</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayNotification</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Notification.permission == <span class="string">'granted'</span>) &#123;</span><br><span class="line">    navigator.serviceWorker.getRegistration().then(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123;</span><br><span class="line">      registration.showNotification(<span class="string">'this is a notification!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line">self.addEventListener(<span class="string">'notificationclick'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 消息提醒被点击的事件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'notificationclose'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 消息提醒被关闭的事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你需要先向用户寻求让你的网页产生消息提醒的权限。之后，你就可以弹出提示信息，然后处理某些事件，比如用户把消息关掉的事件。</p>
<h3 id="信息推送"><a href="#信息推送" class="headerlink" title="信息推送"></a>信息推送</h3><p>信息推送涉及到利用浏览器提供的<code>Push API</code>以及后端的配合实现。要讲解如何使用<code>Push API</code>完全可以再写一篇文章，不过基本的套路如下：</p>
<p><img src="./http-cache-serviceworker/http-cache-4-13.png" alt="http-cache-serviceworker"></p>
<p>这是个略微复杂难懂的过程，已经超出这篇文章的讨论范围。</p>
<h2 id="更好的方案-Workbox"><a href="#更好的方案-Workbox" class="headerlink" title="更好的方案 - Workbox"></a>更好的方案 - Workbox</h2><p>什么是 Workbox ?</p>
<blockquote>
<p>Workbox is a library that bakes in a set of best practices and removes the boilerplate every developer writes when working with service workers.</p>
</blockquote>
<p>其大概意思是它对常见的 <code>SW</code> 操作进行了一层封装, 根据最佳实践方便了开发者的使用。因此在我们快速开发自己的 <code>PWA</code> 应用时使用 <code>Workbox</code> 是最合适不过的了。</p>
<p>它主要有以下几大功能 :</p>
<ul>
<li>Precaching ~ 预缓存</li>
<li>Runtime caching ~ 运行时缓存</li>
<li>Strategies ~ 缓存策略</li>
<li>Request routing ~ 请求路由控制</li>
<li>Background sync ~ 后台同步</li>
<li>Helpful debugge</li>
</ul>
<h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><p>直接修改<code>sw.js</code>的代码，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 导入谷歌提供的 Workbox 库</span></span><br><span class="line">importScripts(</span><br><span class="line">  <span class="string">'https://storage.googleapis.com/workbox-cdn/releases/3.2.0/workbox-sw.js'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!workbox) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Workbox didn't load.`</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Workbox 注册成功, 可以进行下一步的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即激活, 跳过等待</span></span><br><span class="line">workbox.skipWaiting();</span><br><span class="line">workbox.clientsClaim();</span><br><span class="line"></span><br><span class="line"><span class="comment">// workbox.routing.registerRoute()...</span></span><br></pre></td></tr></table></figure>
<p>如果浏览器支持，可以直接引用 API 接口：</p>
<ol>
<li><code>precaching</code>可以在注册成功后直接缓存的文件；</li>
<li><code>routing</code>匹配符合规则的<code>url</code>与<code>strategies</code>合作来完成文件的缓存。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册完成后，即缓存对应的文件列表</span></span><br><span class="line">workbox.precaching.precacheAndRoute([</span><br><span class="line">  <span class="string">'/src/static/js/index.js'</span>,</span><br><span class="line">  <span class="string">'/src/static/css/index/css'</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// routing方法匹配请求文件路径，strategies用来存储对应文件</span></span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">  matchFunction, <span class="comment">// 字符串或者是正则表达式</span></span><br><span class="line">  handler <span class="comment">// 可以使用workbox.strategies缓存策略来缓存</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="workbox-缓存策略"><a href="#workbox-缓存策略" class="headerlink" title="workbox 缓存策略"></a>workbox 缓存策略</h3><p><code>workbox.strategies</code>缓存策略有：</p>
<ol>
<li><code>staleWhileRevalidate</code> 使用已有的缓存，然后发起请求，用请求结果来更新缓存；</li>
<li><code>networkFirst</code> 先发起请求，请求成功后会缓存结果。如果失败，则使用最新的缓存；</li>
<li><code>cacheFirst</code> 总是先使用缓存，如果无匹配的缓存，则发起网络请求并缓存结果；</li>
<li><code>networkOnly</code> 强制发起请求；</li>
<li><code>cacheOnly</code> 强制使用缓存。</li>
</ol>
<p>官方也有给了实现逻辑如下。</p>
<h4 id="Cache-Only"><a href="#Cache-Only" class="headerlink" title="Cache Only"></a>Cache Only</h4><p>只从缓存中读取，当缓存中没有数据时，读取失败。</p>
<p><img src="./http-cache-serviceworker/http-cache-4-15.png" alt="http-cache-serviceworker"></p>
<h4 id="NetWork-Only"><a href="#NetWork-Only" class="headerlink" title="NetWork Only"></a>NetWork Only</h4><p>只通过网络请求进行资源请求，若请求失败，则返回失败响应。</p>
<p><img src="./http-cache-serviceworker/http-cache-4-16.png" alt="http-cache-serviceworker"></p>
<h4 id="NetWork-First"><a href="#NetWork-First" class="headerlink" title="NetWork First"></a>NetWork First</h4><ul>
<li>优先网络请求</li>
<li>网络请求成功时，将结果写入缓存，并将结果直接返回。</li>
<li>网络请求失败时，从缓存中读取结果，若读取结果，则返回，若未读取到，则请求失败。</li>
</ul>
<p>不难看出，这种策略是为了保证在<strong>第一次请求成功之后</strong>，后面多次的请求始终都能返回结果。</p>
<p><img src="./http-cache-serviceworker/http-cache-4-17.png" alt="http-cache-serviceworker"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">workbox.routing.registerRoute(</span><br><span class="line">  /\.(js|css)$/,</span><br><span class="line">  workbox.strategies.networkFirst(&#123;</span><br><span class="line">    <span class="comment">// 给网络请求0.5秒，若仍未返回则从缓存中取数据</span></span><br><span class="line">    networkTimetoutSeconds: <span class="number">0.5</span>,</span><br><span class="line">    cacheName: <span class="string">'css.js'</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="Cache-First"><a href="#Cache-First" class="headerlink" title="Cache First"></a>Cache First</h4><ul>
<li>优先从缓存中读取结果</li>
<li>若缓存中不存在结果，则进行网络请求</li>
<li>网络请求成功时，将结果写入缓存并返回</li>
<li>网络请求失败时，返回失败响应</li>
</ul>
<p><img src="./http-cache-serviceworker/http-cache-4-18.png" alt="http-cache-serviceworker"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">workbox.routing.registerRoute(</span><br><span class="line">  /\.(png|jpg|jpeg|gif|webp)$/,</span><br><span class="line">  <span class="comment">// 对于图片资源使用缓存优先</span></span><br><span class="line">  workbox.strategies.cacheFirst(&#123;</span><br><span class="line">    cacheName: <span class="string">'images'</span>,</span><br><span class="line">    <span class="comment">// 设置最大缓存数量以及过期时间</span></span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> workbox.expiration.Plugin(&#123;</span><br><span class="line">        maxEntries: <span class="number">60</span>,</span><br><span class="line">        maxAgeSeconds: <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="Stale-While-Revalidate"><a href="#Stale-While-Revalidate" class="headerlink" title="Stale-While-Revalidate"></a>Stale-While-Revalidate</h4><ul>
<li>优先查缓存，并同时发起网络请求</li>
<li>若缓存命中且网络请求成功，返回缓存结果，并更新缓存（下次从缓存中读取的数据就是最新的了）</li>
<li>若缓存未命中，则看网络请求是否成功，成功则更新缓存并返回结果，失败则返回失败响应。</li>
</ul>
<p><img src="./http-cache-serviceworker/http-cache-4-14.png" alt="http-cache-serviceworker"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">workbox.routing.registerRoute(</span><br><span class="line">  /\.(js|css)$/,</span><br><span class="line">  workbox.strategies.staleWhileRevalidate(&#123;</span><br><span class="line">    cacheName: <span class="string">'css.js'</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇文章中详细的记录了有关<code>SW</code>的主要功能和能给我们带来的好处。一般在开发中还是推荐使用<code>workbox</code>，最后如果个人有兴趣的可以自己编写示例来验证文章中的代码示例。</p>
<p><strong>SW 主要作用</strong></p>
<ul>
<li><strong>可以用来做缓存，以达到提升体验、节省浏览等等</strong></li>
<li><strong>SW 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。</strong></li>
<li><strong>离线缓存接口请求及文件，更新、清除缓存内容；</strong></li>
<li><strong>可分配给 Service Worker 一些任务，并在使用基于 Promise 的方法当任务完成时收到结果。</strong></li>
<li><strong>Service Worker 处于空闲状态会被终止，在下一次需要时重启。</strong></li>
</ul>
<p><strong>SW 几种策略</strong></p>
<ul>
<li><strong>渐进式缓存</strong></li>
<li><strong>仅使用缓存</strong></li>
<li><strong>仅使用网络</strong></li>
<li><strong>缓存优先</strong></li>
<li><strong>网络优先</strong></li>
<li><strong>速度优先</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.google.com/web/fundamentals/primers/service-workers?hl=zh-CN" target="_blank" rel="noopener">Service Worker：简介  |  Web Fundamentals  |  Google Developers</a><br><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-CN#install" target="_blank" rel="noopener">Service Worker 生命周期  |  Web Fundamentals  |  Google Developers</a><br><a href="https://mp.weixin.qq.com/s/SLG_cDxDo7BaoQqAyLGa-Q" target="_blank" rel="noopener">用 Service Worker 实现前端性能优化</a><br><a href="https://mp.weixin.qq.com/s/aboA9dtCK6t0fzs0JU58Iw" target="_blank" rel="noopener">service worker 实现离线缓存</a> &gt; <a href="https://www.jianshu.com/p/3fb5615f18cf" target="_blank" rel="noopener">【前-workbox-网络摘要】WorkBox 缓存策略</a></p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Cache</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git flow</title>
    <url>/blog/tools/git/git-flow.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git hooks</title>
    <url>/blog/tools/git/git-hooks.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git precommit or husky</title>
    <url>/blog/tools/git/git-precommit.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git merge的使用</title>
    <url>/blog/tools/git/git-merge.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中git rebase的使用</title>
    <url>/blog/tools/git/git-rebase.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase（译注：rebase 的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。<br>同时，比如要要合并多个 commit,就可以用 git rebase -i head~2。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge // 合并分支</span><br><span class="line">git cherry-pick // copy单个commit</span><br><span class="line">git rebase // 衍合</span><br><span class="line">git rebase [startpoint]   [endpoint]  --onto  [branchName] // copy多个commit</span><br><span class="line">git rebase -i  [startpoint]  [endpoint] // 合并多个commit</span><br><span class="line">//  pick：保留该commit（缩写:p）</span><br><span class="line">//  reword：保留该commit，但我需要修改该commit的注释（缩写:r）</span><br><span class="line">//  edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</span><br><span class="line">//  squash：将该commit和前一个commit合并（缩写:s）</span><br><span class="line">//  fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</span><br><span class="line">//  exec：执行shell命令（缩写:x）</span><br><span class="line">//  drop：我要丢弃该commit（缩写:d）</span><br></pre></td></tr></table></figure>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>使用 git merge 合并 master1 和 dev1 分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master1</span><br><span class="line">git merge dev1</span><br></pre></td></tr></table></figure>
<p><img src="../../images/git/1-1.png" alt="git merge"><br>如上图所示：<br>最新的快照 c2 和 c3，还有它们共同的祖先 c1 进行三方合并，合并的结果会产生以下新的 c5，同时太还会对你的 master1 分支上的合并线条产生不好的结果。<br><img src="../../images/git/1-2.jpg" alt="git merge"></p>
<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>我们现在使用 git rebase 来合并 master1 和 dev1 分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev1</span><br><span class="line">git rebase master1</span><br><span class="line">git checkout master1</span><br><span class="line">git merge dev1</span><br></pre></td></tr></table></figure>
<p><img src="../../images/git/1-3.png" alt="git merge"><br>如上图所示：<br>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支  dev1）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 master1）最后一个提交对象（C2）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写  dev1  的提交历史，使它成为  master1  分支的直接下游.<br>把 C3 里产生的改变到 C2 上重演一遍。<br>现在回到 master1 分支，进行一次快进合并.<br><img src="../../images/git/1-4.png" alt="git merge"></p>
<h2 id="git-rebase-startpoint-endpoint-–onto-branchName"><a href="#git-rebase-startpoint-endpoint-–onto-branchName" class="headerlink" title="git rebase [startpoint][endpoint] –onto [branchName]"></a>git rebase [startpoint][endpoint] –onto [branchName]</h2><p>当我们想从 master1 分支上复制 b、c、d 节点复制到 dev1 分支上，如下图所示：<br><img src="../images/git/1-5.png" alt="git rebase [startpoint]   [endpoint]  --onto  [branchName]"><br>master1 分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 302d0381120b55518924d0fa5d91aeb651e7d4fd (HEAD -&gt; master1)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:38:25 2019 +0800</span><br><span class="line"></span><br><span class="line">    d</span><br><span class="line"></span><br><span class="line">commit 9ef980cce33baa48a96f2d989d17330047cdf36b</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:38:04 2019 +0800</span><br><span class="line"></span><br><span class="line">    c</span><br><span class="line"></span><br><span class="line">commit 0d00c05dc3cb28447e35d5d4be23ca76cc32741c</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:37:27 2019 +0800</span><br><span class="line"></span><br><span class="line">    b</span><br><span class="line"></span><br><span class="line">commit 57840ed32293ca5218a9734402b51d6bcad9698d</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:34:50 2019 +0800</span><br><span class="line"></span><br><span class="line">    a</span><br><span class="line"></span><br><span class="line">commit 24b0963b54f65fc58ca2642e81e7cdc7dae1e8ac (origin/develop, master, develop)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Feb 22 13:28:15 2019 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit from Create React App</span><br></pre></td></tr></table></figure>
<p>dev1 分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 1225ea20d48bd16fbcfe1465e84f06292c52fe42 (HEAD -&gt; dev1)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:36:58 2019 +0800</span><br><span class="line"></span><br><span class="line">    e</span><br><span class="line"></span><br><span class="line">commit 57840ed32293ca5218a9734402b51d6bcad9698d</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Mar 1 14:34:50 2019 +0800</span><br><span class="line"></span><br><span class="line">    a</span><br><span class="line"></span><br><span class="line">commit 24b0963b54f65fc58ca2642e81e7cdc7dae1e8ac (origin/develop, master, develop)</span><br><span class="line">Author: zhang.jg &lt;zhangjingguo@unicdata.com&gt;</span><br><span class="line">Date:   Fri Feb 22 13:28:15 2019 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit from Create React App</span><br></pre></td></tr></table></figure>
<p>我们使用命令的形式为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase   [startpoint]   [endpoint]  --onto  [branchName]</span><br></pre></td></tr></table></figure>
<p>其中，[startpoint][endpoint]仍然和上一个命令一样指定了一个编辑区间(前开后闭)，–onto 的意思是要将该指定的提交复制到哪个分支上。<br>所以，在找到 b(7343021a9f5a65c6042bf62589ca02bd7bb95e7f)和 c(d422a0cb01609f9007b5acf8771428d04ef5d963)的提交 hash 后，我们运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase 0d00c05dc^ 302d0381 --onto dev1</span><br></pre></td></tr></table></figure>
<p>如果有冲突解决冲突就解决冲突,如果没有就跳过这一步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>
<p><img src="../images/git/1-6.png" alt="git rebase [startpoint]   [endpoint]  --onto  [branchName]"><br>当前 HEAD 处于<code>游离状态</code>，实际上，此时所有分支的状态应该是这样:<br>![git rebase [startpoint][endpoint] –onto [branchName]](../images/git/1-7.png<br>所以，虽然此时<code>HEAD</code>所指向的内容正是我们所需要的，但是<code>dev1</code>分支是没有任何变化的，git 只是将<code>b-c-d</code>部分的提交内容复制一份粘贴到了<code>dev1</code>所指向的提交后面，我们需要做的就是将<code>dev1</code>所指向的提交 id 设置为当前 HEAD 所指向的提交 id 就可以了，即:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev1</span><br><span class="line">git reset --hard 316ad6d</span><br></pre></td></tr></table></figure>
<p>这时候就完成了。<br><code>git rebase [startpoint] [endpoint] --onto [branchName]</code>还有一种用法。<br>参考 &gt;<code>https://blog.csdn.net/endlu/article/details/51605861</code></p>
<h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>如果只是复制某一两个提交到其他分支，建议使用更简单的命令:git cherry-pick</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout '你的分支'</span><br><span class="line">git cherry-pick '你要copy的id'</span><br><span class="line">git log //查看</span><br></pre></td></tr></table></figure>
<h2 id="git-rebase-i-startpoint-endpoint-合并多个-commit"><a href="#git-rebase-i-startpoint-endpoint-合并多个-commit" class="headerlink" title="git rebase -i [startpoint][endpoint] // 合并多个 commit"></a>git rebase -i [startpoint][endpoint] // 合并多个 commit</h2><p>其中-i 的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint][endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支 HEAD 所指向的 commit(注：该区间指定的是一个前开后闭的区间)。<br>在查看到了 log 日志后，我们运行以下命令：<br>未完待续。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中删除git本地远程分支、本地分支、远程分支</title>
    <url>/blog/tools/git/git-delete.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在项目中使用 git 管理代码后，有些时候会创建很多不同名称的分支，以此区分各个分支代码功能。 而随着代码的合并，以前的分支就可能不再需要保存了，所以就要对没有用的分支进行删除，包括紧急回滚时从中抽取某一个版本记录所创建的临时分支。 这时候就可以使用下面的命令：</p>
<h3 id="删除本地-git-分支"><a href="#删除本地-git-分支" class="headerlink" title="删除本地 git 分支"></a>删除本地 git 分支</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git branch -D branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure>
<h3 id="删除本地-git-远程分支"><a href="#删除本地-git-远程分支" class="headerlink" title="删除本地 git 远程分支"></a>删除本地 git 远程分支</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git branch -D origin/branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure>
<h3 id="删除远程-git-分支"><a href="#删除远程-git-分支" class="headerlink" title="删除远程 git 分支"></a>删除远程 git 分支</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git push origin -D origin/branchName</span><br><span class="line"><span class="comment">// -D 是 -delete缩写</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码中Mixins原理和源码解析</title>
    <url>/blog/vue/principle/vue-mixins.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Mixins</tag>
      </tags>
  </entry>
  <entry>
    <title>Http中的缓存（二） HTTP中的缓存</title>
    <url>/blog/network/cache/http-cache-http.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><strong>HTTP 缓存</strong>相信都不陌生，因为它是在前端性能优化中必不可少的一个环节。在<strong>首次进入或者请求数据</strong>正常传输数据，而当<strong>再次进入或者请求数据</strong>时，可以走本地或者服务器上的缓存，来<strong>节省流量</strong>、<strong>优化性能</strong>、<strong>提高用户体验</strong>、<strong>降低网络负荷</strong>等等。</p>
<p><strong>web 缓存</strong>主要用来缓存<strong>html 文件</strong>、<strong>js 文件</strong>、<strong>css 文件</strong>、<strong>数据</strong>，基本上都是提升<strong>客户端/浏览器</strong>请求到<strong>服务器</strong>之间的速度，当然也可以结合数据压缩如<strong>gzip</strong>、<strong>7z</strong>等等加快响应数据传输。</p>
<p>在整个应用中可以错多层缓存结构这里不多做介绍，因为前面已经大致介绍过了，这里主要介绍和前端比较相关的<strong>HTTP 缓存</strong>。</p>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p>大致分为下面几步来加深对<strong>HTTP 中的缓存</strong>理解和应用场景。</p>
<ol>
<li><strong>必知缓存策略的基础</strong></li>
<li><strong>缓存的判断策略</strong></li>
<li><strong>用户操作对缓存策略的影响</strong></li>
<li><strong>缓存储存的位置</strong></li>
<li><strong>缓存策略之间的对比</strong></li>
</ol>
<h2 id="必知缓存策略的基础"><a href="#必知缓存策略的基础" class="headerlink" title="必知缓存策略的基础"></a>必知缓存策略的基础</h2><p>大致把协议分为<strong>强缓存（过期策略）</strong>和<strong>协商缓存（协商策略）</strong>两类缓存，可能不太准确只是自己的现在的见解，<strong>浏览器/客户端</strong>通过这两种策略决定使用<strong>缓存中的副本</strong>还是从<strong>服务器</strong>中获取最新的资源。</p>
<ul>
<li><strong>强缓存（过期策略）</strong>：也就是缓存副本有效期。<br>一个缓存副本必须满足以下任一条件，浏览器会认为它是有效的，足够新的，而直接从缓存中获取副本并渲染：<ul>
<li><em>含有完整的过期时间控制头信息（HTTP 协议报头），并且仍在有效期内</em></li>
<li><em>浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度</em></li>
</ul>
</li>
<li><strong>协商缓存（协商策略）</strong>：<em>服务器返回资源的时候有时在控制头信息带上这个资源的实体标签 Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如果发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。</em></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">key</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">缓存策略</th>
<th style="text-align:center">首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">指定缓存机制（http 1.0 字段）</td>
<td style="text-align:center">强缓存（过期策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">Cache-COntrol</td>
<td style="text-align:center"><code>Cache-Control</code> 通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。</td>
<td style="text-align:center">强缓存（过期策略）</td>
<td style="text-align:center">响应/请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center"><code>Expires</code> 响应头包含日期/时间， 即在此时候之后，响应过期。</td>
<td style="text-align:center">强缓存（过期策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center"><code>Last-Modified</code> 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center"><code>If-Modified-Since</code> 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <code>200</code>。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center"><code>ETag</code>HTTP 响应头是资源的特定版本的标识符。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center"><code>If-None-Match</code> 是一个条件式请求首部。对于 <code>GET</code> 和 <code>HEAD</code> 请求方法来说，当且仅当服务器上没有任何资源的 <code>ETag</code> 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 <code>200</code> 。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">If-Match（辅助）</td>
<td style="text-align:center"><code>If-Match</code> 的使用表示这是一个条件请求。在请求方法为 <code>GET</code> 和 <code>HEAD</code> 的情况下，服务器仅在请求的资源满足此首部列出的 <code>ETag</code>值时才会返回资源。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since（辅助）</td>
<td style="text-align:center"><code>If-Unmodified-Since</code> 只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 <code>POST</code> 或其他 <code>non-safe</code> 方法的请求。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">请求首部字段</td>
</tr>
<tr>
<td style="text-align:center">Vary（辅助）</td>
<td style="text-align:center"><code>Vary</code> 是一个<code>HTTP</code>响应头部信息，它决定了对于未来的一个请求头，应该用一个缓存的回复(response)还是向源服务器请求一个新的回复。</td>
<td style="text-align:center">协商缓存（协商策略）</td>
<td style="text-align:center">响应首部字段</td>
</tr>
</tbody>
</table>
<!-- 下面四个就多做介绍了，大家可以去**mdn**中观看，下面是mdn中的连接。

- [Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma)
- [If-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match)
- [If-Unmodified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)
- [Vary](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary) -->
<p><em>缓存又分为<strong>强缓存和协商缓存</strong>。其中强缓存包括<code>Expires</code>和<code>Cache-Control</code>，<strong>主要是在过期策略生效时应用的缓存</strong>。弱缓存包括<code>Last-Modified</code>和<code>ETag</code>，<strong>是在协商策略后应用的缓存</strong>。<strong>强弱缓存之间的主要区别在于获取资源时是否会发送请求</strong>。</em></p>
<p><strong>强缓存和协商缓存</strong></p>
<ul>
<li>如果本地缓存过期，则要依靠协商缓存</li>
<li><strong>强缓存</strong>的 http 状态码是 <code>200 OK</code></li>
<li><strong>协商缓存</strong>的 http 状态码是 <code>304 Not Modified</code></li>
</ul>
<h2 id="强缓存（过期策略）"><a href="#强缓存（过期策略）" class="headerlink" title="强缓存（过期策略）"></a>强缓存（过期策略）</h2><p>属于<strong>强缓存（过期策略）</strong>的有如下：</p>
<ul>
<li>Cache-COntrol</li>
<li>Expires</li>
</ul>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><code>Cache-Control</code>用于指定资源的缓存机制，可以同时在<strong>请求和响应头</strong>中设定。但是<code>Cache-Control</code>中的属性也分为<strong>请求和响应</strong>缓存指令，大致分为如下：</p>
<p><strong>缓存请求指令</strong><br>客户端可以在<strong>HTTP 请求</strong>中使用的标准 <code>Cache-Control</code> 指令。</p>
<blockquote>
<p>Cache-Control: max-age=<seconds><br>Cache-Control: max-stale[=<seconds>]<br>Cache-Control: min-fresh=<seconds><br>Cache-control: no-cache<br>Cache-control: no-store<br>Cache-control: no-transform<br>Cache-control: only-if-cached</seconds></seconds></seconds></p>
</blockquote>
<p><strong>缓存响应指令</strong><br>服务器可以在<strong>响应</strong>中使用的标准 <code>Cache-Control</code> 指令。</p>
<blockquote>
<p>Cache-control: must-revalidate<br>Cache-control: no-cache<br>Cache-control: no-store<br>Cache-control: no-transform<br>Cache-control: public<br>Cache-control: private<br>Cache-control: proxy-revalidate<br>Cache-Control: max-age=<seconds><br>Cache-control: s-maxage=<seconds></seconds></seconds></p>
</blockquote>
<p><code>Cache-Control</code>: <code>cache-directive[,cache-directive]</code>。<code>cache-directive</code>为缓存指令，大小写不敏感，共有<strong>12</strong>个与<strong>HTTP</strong>缓存标准相关，如下所示。其中请求指令<em>7</em>种，响应指令<em>9</em>种。<code>Cache-Control</code>可以设置多个缓存指令，以逗号<code>,</code>分隔。</p>
<h4 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h4><ul>
<li><strong>public</strong>： 表明响应可以被<strong>任何对象（包括：发送请求的客户端、代理服务器、CDN 等中间代理服务器等等）缓存</strong>，如下图所示：<br><img src="./http-cache-http/http-cache-3-1.png" alt="http-cache-public"></li>
<li><strong>private</strong>：表明响应只能被<strong>单个用户缓存</strong>，<strong>不能作为共享缓存（即代理服务器不能缓存它）</strong>。<br><img src="./http-cache-http/http-cache-3-2.png" alt="http-cache-public"></li>
<li><strong>no-cache</strong>：指定<strong>不缓存响应</strong>，表明资源<strong>不进行缓存</strong>，但是设置了 <code>no-cache</code> 之后并不代表<strong>浏览器</strong>不缓存，而是在<strong>获取缓存前</strong>要向<strong>服务器确认资源</strong>是否被更改。相当于<code>max-age: 0, must-revalidate</code></li>
<li><strong>no-store</strong>： <strong>绝对禁止缓存，请求和响应都不缓存，每次请求都从服务器获取完整资源</strong>。</li>
</ul>
<h4 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h4><ul>
<li><strong>max-age=<seconds></seconds></strong>: 设置<strong>缓存存储的最大周期</strong>，超过这个时间缓存被认为过期(<strong>单位秒</strong>)。</li>
<li><strong>s-maxage=<seconds></seconds></strong>: 覆盖<code>max-age</code>或者<code>Expires</code>头，但是<strong>仅适用于</strong>共享缓存(比如各个代理)，私有缓存会忽略它。</li>
<li><strong>max-stale[=<seconds>]</seconds></strong>: <strong>指定时间内，即使缓存过期，资源依然有效</strong>。</li>
<li><strong>min-fresh=<seconds></seconds></strong>：<strong>表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应</strong>。</li>
</ul>
<h4 id="重新验证和重新加载"><a href="#重新验证和重新加载" class="headerlink" title="重新验证和重新加载"></a>重新验证和重新加载</h4><ul>
<li><strong>muse-revalidate</strong>: 使用缓存资源之前，<strong>必须先验证状态</strong>，如果页面是<strong>过期的(如 max-age)</strong>，则去服务器进行<strong>获取</strong>。</li>
<li><strong>proxy-revalidate</strong>： 与<code>must-revalidate</code>作用相同，但它<strong>仅适用于共享缓存（例如代理）</strong>，并被私有缓存忽略。</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><strong>no-transform</strong>：强制要求代理服务器不要对资源进行转换，禁止代理服务器对<code>Content-Encoding</code>、<code>Content-Range</code>、<code>Content-Type</code>等字段的修改，因此代理服务器的<code>gzip</code>压缩将<strong>不被允许</strong>。</li>
</ul>
<h4 id="no-cache-和-no-store"><a href="#no-cache-和-no-store" class="headerlink" title="no-cache 和 no-store"></a>no-cache 和 no-store</h4><p>还有一点需要注意的是，<code>no-cache</code>并不是指<strong>不缓存文件</strong>，<code>no-store</code>才是指<strong>不缓存文件</strong>。<code>no-cache</code>仅仅是表明<strong>跳过强缓存</strong>，强制进入<strong>协商策略</strong>。</p>
<h4 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h4><p><strong>禁止缓存</strong><br><code>Cache-Control: no-cache, no-store, must-revalidate</code></p>
<p><strong>缓存静态资源</strong><br><code>Cache-Control:public, max-age=86400</code></p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>指定缓存的<strong>过期时间</strong>，为绝对时间，即某一时刻。</p>
<blockquote>
<p>注意：参考<strong>本地时间</strong>进行比对，在指定时刻后过期。<strong>RFC 2616 建议最大值不要超过 1 年</strong>。</p>
</blockquote>
<h3 id="max-age-与-Expires"><a href="#max-age-与-Expires" class="headerlink" title="max-age 与 Expires"></a>max-age 与 Expires</h3><p><code>Cache-Control</code>中的<code>max-age</code>指令用于指定<strong>缓存过期的相对时间</strong>。资源达到指定时间后过期。该功能与<code>Expires</code>类似。但其<strong>优先级高于 Expires</strong>，如果同时设置<code>max-age</code>和<code>Expires</code>，<code>max-age</code>生效，忽略<code>Expires</code>。</p>
<blockquote>
<p>Cache-Control &gt; Expires</p>
</blockquote>
<h3 id="强缓存大致流程"><a href="#强缓存大致流程" class="headerlink" title="强缓存大致流程"></a>强缓存大致流程</h3><p>强缓的设置流程图大致如下：<br><img src="./http-cache-http/http-cache-3-3.png" alt="http-cache-public"></p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>在没有<strong>强缓存</strong>时，就会走协商缓存，协商缓存大致流程：</p>
<ul>
<li>第一次请求时，服务端返回给客户端一个<strong>key(如 Etag 的资源值、Last-Modified 最后修改时间)</strong>和资源</li>
<li>第二次请求时，客户端带上第一次服务端返回的 key</li>
<li>服务器端验证当前的 key 是否和上次返回给客户端的是否一致，一致返回 304 使用缓存，不一致重新返回 key 和新的资源</li>
</ul>
<p>属于<strong>协商缓存（协商策略）</strong>的有如下：</p>
<ul>
<li>Last-Modified/If-Modified-Since/If-Unmodified-Since</li>
<li>ETag/If-Match/If-None-Match</li>
</ul>
<h3 id="Last-Modified-If-Modified-Since-If-Unmodified-Since"><a href="#Last-Modified-If-Modified-Since-If-Unmodified-Since" class="headerlink" title="Last-Modified/If-Modified-Since/If-Unmodified-Since"></a>Last-Modified/If-Modified-Since/If-Unmodified-Since</h3><p><code>Last-Modified/If-Modified-Since</code>大致流程如下：</p>
<ul>
<li>第一次请求时，服务器会获取资源的最后修改时间通过设置<code>Last-Modified</code>，返回给客户端</li>
<li>后面请求时，客户端(浏览器)会自动带上<code>If-Modified-Since</code>字段</li>
<li>服务器从新获取修改时间与<code>If-Modified-Since</code>中的时间对比，如果没有变化返回<code>304</code>状态码（浏览器得知 304 状态码，资源从缓存中获取），如果改变返回<code>200</code>并且更新资源、更新<code>Last-Modified</code></li>
</ul>
<p>上面的流程是在设置不使用<strong>强缓存</strong>时的场景，这个只是现在的理解可能有很多的不太完善的地方。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p><code>Last-Modified</code>用于标记<strong>请求资源的最后一次修改时间</strong>。</p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Last-Modified: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT</span><br><span class="line"></span><br><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li><strong>GMT(格林尼治标准时间)</strong></li>
<li><code>Last-Modified</code>只能精确到秒，因此不适合在一秒内多次改变的资源。</li>
</ul>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p><code>If-Modified-Since</code> 是一个条件式请求首部，与<code>Last-Modified</code>何用。有两种结果如下：</p>
<ul>
<li><code>If-Modified-Since/Last-Modified</code>相同返回<code>304</code>状态码，客户端使用缓存</li>
<li><code>If-Modified-Since/Last-Modified</code>不相同返回<code>200</code>状态码，返回新的资源</li>
</ul>
<blockquote>
<p><code>If-Modified-Since</code> 只可以用在 <code>GET</code> 或 <code>HEAD</code> 请求中。</p>
</blockquote>
<h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><p><code>If-Unmodified-Since</code>表示资源未修改则正常执行更新，否则返回<code>412(Precondition Failed)</code>状态码的响应。主要有如下两种场景。</p>
<ol>
<li>用于不安全的请求中从而是请求具备条件性（如 POST 或者其他不安全的方法），如请求更新 wiki 文档，<strong>文档未修改时才执行更新</strong>。</li>
<li>与<code>If-Range</code>字段同时使用时，可以用来保证新的片段请求来自一个未修改的文档。</li>
</ol>
<h3 id="ETag-If-Match-If-None-Match"><a href="#ETag-If-Match-If-None-Match" class="headerlink" title="ETag/If-Match/If-None-Match"></a>ETag/If-Match/If-None-Match</h3><p>根据实体内容生成一段<strong>唯一 hash 字符串</strong>，标识资源的状态，由服务端产生。浏览器会将这<strong>串字符串传回服务器</strong>，验证资源是否已经修改，如果没有修改，过程如下：</p>
<p><img src="./http-cache-http/http-cache-3-4.png" alt="http-cache-public"></p>
<p><code>ETag</code> <strong>HTTP 响应头</strong>是资源的特定版本的标识符。<br><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ETag: W / <span class="string">'&lt;etag_value&gt;'</span>;</span><br><span class="line">ETag: <span class="string">'&lt;etag_value&gt;'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>W/ 可选</strong><br><strong>‘W/‘(大小写敏感) </strong>表示使用<strong>弱验证器</strong>。 弱验证器很<strong>容易</strong>生成，但<strong>不利</strong>于比较。 强验证器是<strong>比较的理想</strong>选择，但<strong>很难</strong>有效地生成。</p>
<p><strong>“&lt;etag_value&gt;”</strong><br>实体标签唯一地表示所请求的资源。 它们是位于<strong>双引号</strong>之间的 ASCII 字符串（如“675af34563dc-tr34”）。</p>
<blockquote>
<p>注意：ETag 和 If-None-Match 的值均为双引号包裹的。<br><code>ETag</code>的优先级高于<code>Last-Modified</code>。当<code>ETag</code>和<code>Last-Modified</code>，<code>ETag</code>优先级更高，但不会忽略<code>Last-Modified</code>，需要服务端实现。</p>
</blockquote>
<p><code>ETag</code> 和 <code>If-None-Match</code> 常被用来处理<strong>协商缓存</strong>。而 <code>ETag</code> 和 <code>If-Match</code> 可以 <strong>避免“空中碰撞”</strong>。</p>
<p><code>ETag</code> HTTP 响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web 服务器不需要发送完整的响应。而如果内容发生了变化，使用 <code>ETag</code> 有助于防止资源的<strong>同时更新相互覆盖（“空中碰撞”）</strong>。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>当编辑 MDN 时，当前的 WIki 内容被散列，并在相应中放入<code>Etag</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ETag: <span class="string">'33a64df551425fcc55e4d42a148795d9f25f89d4'</span>;</span><br></pre></td></tr></table></figure>
<p>将更改保存到 WIKI 页面（发布数据）时，POST 请求将包含有<code>ETag</code>值的<code>If-Match</code>头来检车是否为最新版本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">If-Match: <span class="string">"33a64df551425fcc55e4d42a148795d9f25f89d4"</span></span><br></pre></td></tr></table></figure>
<p>如果哈希值不匹配，则意味着文档已经被编辑，抛出 <code>412 ( Precondition Failed)</code> 前提条件失败错误。</p>
<p><code>If-None-Match</code> 是客户端发送给服务器时的请求头，其值是服务器返回给客户端的 <code>ETag</code>，当 <code>If-None-Match</code> 和服务器资源最新的 <code>Etag</code> 不同时，返回最新的资源及其 <code>Etag</code>。</p>
<h2 id="缓存的判断策略"><a href="#缓存的判断策略" class="headerlink" title="缓存的判断策略"></a>缓存的判断策略</h2><p>缓存策略分为<strong>强缓存</strong>和<strong>协商缓存</strong>，首先经过<strong>强缓存</strong>的<strong>过期策略</strong>，才会走后面的<strong>协商缓存</strong>的<strong>协商策略</strong>，大致把缓存分为三个阶段<strong>本地缓存阶段（强缓存）</strong>、<strong>协商缓存阶段（本地+服务器）</strong>、<strong>缓存失败阶段</strong>。</p>
<p>大致在每个阶段中做的什么判断：</p>
<ol>
<li><strong>本地缓存阶段</strong>：如果设置了<strong>强缓存</strong>，那么会现在本地查找该资源，如果发现该资源，而且该资源还没有过期，就使用这个资源副本，完全不会发起<code>http</code>请求到服务器。（主要应用是<strong>强缓存</strong>、<strong>serverWorker</strong>）;</li>
<li><strong>协商缓存阶段</strong>：如果在<strong>本地缓存</strong>找到对应的资源，但是不知道该资源<strong>是否过期或者已经过期</strong>，则发一个 http 请求到服务器，然后服务器<strong>判断</strong>这个请求，如果请求的资源在服务器上没有改动过，则返回<code>304</code>，让浏览器使用本地找到的那个资源；</li>
<li><strong>缓存失败阶段</strong>: 当服务器发现请求的资源<strong>已经修改过</strong>，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回<code>200</code>， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回<code>404</code>。</li>
</ol>
<p>大致流程如下图所示：</p>
<p><img src="./http-cache-http/http-cache-3-5.png" alt="http-cache-public"></p>
<p>这张图中没有包含<code>serverWorker</code>的缓存判断流程 b，但是在后面会有一篇文章专门介绍<strong>serverWorker</strong>，因为他是属于<strong>PWA</strong>中的内容。</p>
<blockquote>
<p><strong>存储策略</strong>发生在<strong>收到请求响应后</strong>，用于决定<strong>是否缓存</strong>相应资源；<strong>过期策略</strong>发生在<strong>请求前</strong>，用于判断缓存<strong>是否过期</strong>；<strong>协商策略</strong>发生在<strong>请求中</strong>，用于判断缓存资源<strong>是否更新</strong>。</p>
</blockquote>
<h2 id="用户操作对缓存策略的影响"><a href="#用户操作对缓存策略的影响" class="headerlink" title="用户操作对缓存策略的影响"></a>用户操作对缓存策略的影响</h2><p>在用户刷新页面（F5）时，会对缓存产生影响，这里就会记录用户操作对缓存产生的影响。用户操作事项如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">用户操作</th>
<th style="text-align:center">强缓存</th>
<th style="text-align:center">协商缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(新标签)地址栏回车</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">(地址不变)地址栏回车</td>
<td style="text-align:center">兼容性问题 Chrome(失效)/Firefox(有效)</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">链接跳转</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">前进/后退</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">从收藏栏打开链接</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">(window.open)新开窗口</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">刷新（Command/Ctrl + R / F5）</td>
<td style="text-align:center">失效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">强制刷新（Command + Shift + R / Ctrl + F5）</td>
<td style="text-align:center">失效</td>
<td style="text-align:center">失效</td>
</tr>
</tbody>
</table>
<p>基本上包含了一些常见的用户操作对<strong>强缓存</strong>和<strong>协商缓存</strong>的影响，大致的判断流程如下：</p>
<p><img src="./http-cache-http/http-cache-3-6.png" alt="http-cache-public"></p>
<p><strong>注意</strong></p>
<blockquote>
<ul>
<li>(地址不变)地址栏回车：它比较特殊，为什么它在<strong>Chrome</strong>是<strong>失效</strong>，在<strong>Firefox</strong>中是<strong>有效</strong>。因为<strong>Chrome</strong>把<strong>地址不变回车</strong>等同于<strong>刷新当前页面</strong>，而在<strong>Firefox</strong>都是作为<strong>新地址回车</strong>处理的。</li>
<li><code>webkit(Chrome内核)</code>资源分为<strong>主资源</strong>和<strong>派生资源</strong>。<strong>主资源</strong>是地址栏输入的 URL 请求返回的<strong>资源</strong>，<strong>派生资源</strong>是主资源中所引用<strong>的 JS、CSS、图片等资源</strong>。</li>
<li>在<code>Chrome</code>下刷新时，只有主资源的缓存应用方式如上图所示，<strong>派生资源</strong>的<strong>缓存应用方式与新标签打开类似</strong>，会判断缓存是否过期。强缓存生效时的区别在于新标签打开为<code>from disk cache</code>，而当前页刷新派生资源是<code>from memory cache</code>。</li>
<li>而在<code>Firefox</code>下，当前页面刷新，所有资源都会如上图所示。</li>
</ul>
</blockquote>
<h2 id="缓存储存的位置"><a href="#缓存储存的位置" class="headerlink" title="缓存储存的位置"></a>缓存储存的位置</h2><p>从缓存的位置上来说分为<strong>四种</strong>，并且各自有优先级，当<strong>依次由上到下</strong>查找缓存且<strong>都没有命中</strong>的时候，才会去请求网络，大致如下：</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p><strong>Service Worker</strong> 是一种独立于主线程之外的 <strong>Javascript</strong> 线程。它可以帮我们实现<strong>离线缓存</strong>、<strong>消息推送</strong>和<strong>网络代理</strong>等功能。</p>
<blockquote>
<p>使用 <code>Service Worker</code>的话，传输协议<strong>必须</strong>为 <code>HTTPS</code>。因为 <code>Service Worker</code> 中涉及到请求拦截，所以必须使用 <code>HTTPS</code> 协议来保障安全。</p>
</blockquote>
<p><strong>Service Worker</strong> 实现缓存大致分为以下几个步骤：</p>
<ul>
<li>首先需要在页面的 <strong>JavaScript 主线程中注册 Service Worker</strong>。</li>
<li>注册成功后后台开始安装步骤， 通常在安装的过程中需要缓存一些静态资源。</li>
<li>安装成功后开始<strong>激活 Service Worker</strong></li>
<li>激活成功后 <strong>Service Worker</strong> 可以控制页面了（<strong>监听 fetch 和 message 事件</strong>），但是只针对在成功注册了 <strong>Service Worker</strong> 后打开的页面。</li>
</ul>
<p>在这里就不细说了，后面有一个单独的章节来讲述<strong>Service Worker</strong>, <strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</strong>。</p>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p><strong>Memory Cache</strong> 是内存中的缓存。主要包含的是当前页面中请求到的数据如<strong>图片（base64）</strong>、<strong>脚本（JavaScript）</strong>、<strong>样式（css）</strong>等静态数据。读取内存中的数据肯定比磁盘中的<strong>快</strong>，但是内存中的<strong>缓存持续性很短</strong>，它会随着当前<strong>Tab 页面关闭，内存中的缓存也就被释放</strong>。</p>
<p>比如在<strong>百度首页</strong>刷新页面，效果如下图所示：<br><img src="./http-cache-http/http-cache-3-7.png" alt="http-cache-public"></p>
<p><strong>preload</strong><br><code>&lt;link&gt;</code> 元素的 <code>rel</code> 属性的属性值<code>preload</code>，<code>&lt;link rel=&quot;preload&quot;&gt;</code>来显示的指定的预加载资源，也会被放入<code>memory cache</code>中。</p>
<p><strong>prefetch</strong><br><code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 已经被许多浏览器支持了相当长的时间，但它是意图预获取一些资源，以备下一个导航/页面使用（比如，当你去到下一个页面时）。<br>浏览器会给使用<code>prefetch</code>的资源一个<strong>相对较低的优先</strong>级与使用<code>preload</code>的资源相比。</p>
<p><strong>subresource</strong><br><code>&lt;link rel=&quot;subresource&quot;&gt;</code>被 Chrome 支持了有一段时间，并且已经有些搔到预加载当前导航/页面（所含有的资源）的痒处了。这些资源会以一个<strong>相当低的优先级</strong>被加载。<br><code>Memory Cache</code>不会轻易的命中一个请求，除了要有<strong>匹配的 URL</strong>，还要有相同的<strong>资源类型</strong>、<strong>CORS 模式</strong>以及一些<strong>其他特性</strong>。<br><code>Memory Cache</code>是不关心<code>HTTP语义</code>的，比如<code>Cache-Control: max-age=0</code>的资源，仍然可以在同一个导航中被重用。但是在特定的情况下，<code>Memory Cache</code>会遵守<code>Cache-Control: no-store</code>指令，不缓存相应的资源。</p>
<blockquote>
<p><code>Memory Cache</code>匹配规则在标准中没有详尽的描述，所以不同的浏览器内核在实现上会有所不同。</p>
</blockquote>
<h3 id="Disk-Cache-HTTP-Cache"><a href="#Disk-Cache-HTTP-Cache" class="headerlink" title="Disk Cache/HTTP Cache"></a>Disk Cache/HTTP Cache</h3><p><code>HTTP Cache</code>也被叫做<code>Disk Cache</code>。从字面的意思上理解<code>Disk Cache</code>就是储存在硬盘上的<strong>缓存</strong>，因此它是持久存储的，是实际存在于文件系统中的。<br>而且<strong>它允许相同的资源在跨会话</strong>，甚至<strong>跨站点</strong>的情况下使用，例如<strong>两个站点都使用了同一张图片</strong>。</p>
<p><code>HTTP Cache</code>会根据<code>HTTP Herder</code>中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<br>当<strong>命中缓存</strong>之后，浏览器会从<strong>硬盘中读取资源</strong>，虽然比起从内存中<strong>读取慢</strong>了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 <code>disk cache</code>。</p>
<blockquote>
<p>凡是<strong>持久性存储</strong>都会面临<strong>容量增长</strong>的问题，<code>disk cache</code> 也不例外。在<strong>浏览器自动清理</strong>时，会有神秘的算法去把“最老的”或者“最可能过时的”资源删除，因此是一个一个删除的。不过每个浏览器识别“最老的”和“最可能过时的”资源的算法不尽相同，可能也是它们差异性的体现。</p>
</blockquote>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p><code>Push Cache</code>（推送缓存）是 <code>HTTP/2</code> 中的内容，当以上三种缓存都没有命中时，它才会被使用。<br><strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong>，在 Chrome 浏览器中只有 5 分钟左右，同时它也<strong>并非严格执行 HTTP 头中的缓存指令</strong>。</p>
<p><code>Push Cache</code> 在国内能够查到的资料很少，也是因为 <code>HTTP/2</code> 在国内不够普及。这里推荐阅读<code>Jake Archibald</code>的 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p>
<ul>
<li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
<p>如果以上<strong>四种缓存都没有命中</strong>的话，那么只能发起<strong>请求来获取资源</strong>了。</p>
<p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：<strong>强缓存和协商缓存</strong>，并且缓存策略都是通过设置 <code>HTTP Header</code> 来实现的。</p>
<h3 id="关于-memory-cache-和-disk-cache"><a href="#关于-memory-cache-和-disk-cache" class="headerlink" title="关于 memory cache 和 disk cache"></a>关于 memory cache 和 disk cache</h3><p>这两种缓存类型存在于 Chrome 中。<br><code>disk cache</code> 存在硬盘，可以存很多，容量上限比内容缓存高很多，而 <code>memory cache</code> 从内存直接读取，速度上占优势，这两个各有各的好处！</p>
<p>因为关于在什么时候用到什么缓存的文档相当的少所以真的不好判断，是当前使用的是哪个缓存，比如下面这个例子：</p>
<p><img src="./http-cache-http/http-cache-3-8.png" alt="http-cache-public"></p>
<h2 id="缓存策略之间的对比"><a href="#缓存策略之间的对比" class="headerlink" title="缓存策略之间的对比"></a>缓存策略之间的对比</h2><p>其实缓存之间也没有太好的对比性，大致可以从<strong>缓存策略</strong>和<strong>缓存位置</strong>两个角度对比缓存的优缺点。</p>
<ul>
<li><strong>强缓存</strong>返回 <strong>http 200 OK 状态码</strong>，而<strong>协商缓存</strong>返回<strong>http 304 Not Modified 状态码</strong></li>
<li><strong>强缓存</strong>中的优先级为： <strong>Cache-Control &gt; Expires</strong></li>
<li><strong>协商缓存</strong>中的优先级： <strong>Etag/If-None-Match &gt; Last-Modified/Last-Since-Modified</strong></li>
<li><strong>协商缓存</strong>中，<strong>Last-Modified</strong>不能记录秒级以下的更新缓存，而<strong>Etag 可以</strong>。但是<strong>Etag 生成唯一资源标识符又比叫困难</strong>，而<strong>Last-Modified 实现起来比价简单</strong></li>
<li><code>Service Worker</code>相对于<code>Disk Cache/Memory Cache</code>配置会麻烦一点，但是<code>Service Worker</code>应用场景更广，性能也会好一点。</li>
<li><code>Service Worker</code>必须要在<code>Https</code>协议中才会生效。</li>
<li><strong>Disk Cache</strong>相对于<strong>Memory Cache</strong>，它的优点在于<strong>容量大、储存周期长、可被多域使用</strong>，缺点在于<strong>读取速度慢</strong></li>
<li><strong>Memory Cache</strong>相对于<strong>Memory Cache</strong>，它的优点在于<strong>速度快、对前端 link 字段支持性</strong>，缺点在于<strong>储存周期短（tab 也关闭）、空间有限</strong></li>
</ul>
<p>它们的值优缺点如上所示，如在<strong>chrome</strong>、<strong>firefox</strong>、<strong>ie</strong>中<strong>Memory cache</strong>和<strong>Disk cache</strong>也是不太相同的。</p>
<h3 id="关于-Chrome、FF、IE-的缓存区别"><a href="#关于-Chrome、FF、IE-的缓存区别" class="headerlink" title="关于 Chrome、FF、IE 的缓存区别"></a>关于 Chrome、FF、IE 的缓存区别</h3><p><strong>Chrome</strong>浏览器的速度比其他两个浏览器的速度更快一点，主要是因为<strong>V8</strong>引擎的执行速度更快，另一方面应该就是它的<strong>缓存策略</strong>的使用。<br>从这四个方面<strong>强缓存</strong>、<strong>协商缓存</strong>、<strong>Disk Cache</strong>、<strong>Memory Cache</strong>来对比，为什么说<strong>Chrome</strong>执行效果比其它的两个浏览器的执行速度和加载速度更快。</p>
<p>就以百度首页为例看一下<strong>Chrome</strong>和<strong>Firefox</strong>的差别。</p>
<p>在<code>Chrome</code>和<code>Firefox</code>中打开<code>https://www.baidu.com/</code>首页，结果如下图所示<br><strong>Firefox</strong>效果如下：<br><img src="./http-cache-http/http-cache-3-9.png" alt="http-cache-public"><br><strong>Chrome</strong>效果如下：<br><img src="./http-cache-http/http-cache-3-10.png" alt="http-cache-public"></p>
<p>我们以百度的<code>bd_logo1.png</code>的请求为例，<code>logo</code>的请求是一个<code>Get</code>请求，同时它被设置了<strong>四个缓存</strong>配置，但是它在两个浏览器中表现并不相同，如下图所示</p>
<p><strong>Firefox</strong>效果如下：<br><img src="./http-cache-http/http-cache-3-12.png" alt="http-cache-public"><br><strong>Chrome</strong>效果如下：<br><img src="./http-cache-http/http-cache-3-11.png" alt="http-cache-public"></p>
<p>首先在<strong>再次请求</strong>时浏览器端都<strong>没有携带协商缓存</strong>需要的头部字段，所以它们肯定走的是<strong>强缓存</strong>，在<strong>强缓存</strong>中<code>Cache-Control</code>的优先级是最高的，所以都是走的<strong>Cache-Control</strong>的策略。</p>
<p>可以看到它们的区别如下几点：</p>
<ul>
<li><strong>状态码</strong>： 首先它们返回的状态码是不同的，<strong>Chrome</strong>返回的状态码是<code>200</code>,<strong>Firefox</strong>返回的状态码是<code>304</code>。</li>
<li><strong>使用的资源</strong>： 可以看到<strong>Chrome</strong>中的资源大小为<code>0(耗时 0ms，也就是 1ms 以内)</code>，那么它使用的本地的资源。而<strong>Firefox</strong>中它是从服务器获取的资源。</li>
</ul>
<h2 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h2><p>在这里我们来一个一个测试<code>expires/cache-control/etag/last-modified/pragma</code>它们是否和我们上面所总结的一致。</p>
<p>测试环境<code>chrome 78.0.3904.70</code>、<code>node 12.9.1</code>、<code>koa 2.x</code>.</p>
<p>整体的目录结构如下图所示：<br><img src="./http-cache-http/http-cache-3-13.png" alt="http-cache-public"></p>
<p>代码可能写的比较粗糙，但是后面会优化一下，公共代码如下：</p>
<p><strong>index.html</strong>代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/index/index.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    测试cache</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/index/rotateX.png"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>app.js</strong>代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> Static = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> Path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.type = mime.getType(<span class="string">'.html'</span>);</span><br><span class="line">  <span class="comment">// console.log(__dirname)</span></span><br><span class="line">  <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(</span><br><span class="line">    Path.resolve(__dirname + <span class="string">'/index/index.html'</span>),</span><br><span class="line">    <span class="string">'UTF-8'</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// console.log(content);</span></span><br><span class="line">  ctx.body = content;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 待优化</span></span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; response, path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(path);</span><br><span class="line">  <span class="keyword">const</span> imageBuffer = <span class="keyword">await</span> fs.readFile(Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>));</span><br><span class="line">  ctx.body = imageBuffer;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待优化</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(</span><br><span class="line">    Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>),</span><br><span class="line">    <span class="string">'UTF-8'</span></span><br><span class="line">  );</span><br><span class="line">  ctx.body = content;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待优化</span></span><br><span class="line">router.get(<span class="string">'/index/index.js'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> content = <span class="keyword">await</span> fs.readFile(</span><br><span class="line">    Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>),</span><br><span class="line">    <span class="string">'UTF-8'</span></span><br><span class="line">  );</span><br><span class="line">  ctx.body = content;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use(Static('./index'))</span></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log()</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'启动成功'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面的代码都是在这个代码上修改，<code>index.js</code>、<code>index.css</code>、<code>rotateX.png</code>自己写就可以，或者去网上下载一个稍微超过<code>2kb</code>大小的文件。</p>
<h3 id="Cache-Control-实例"><a href="#Cache-Control-实例" class="headerlink" title="Cache-Control 实例"></a>Cache-Control 实例</h3><p>使用<code>Cache-Control</code>缓存测试效果，修改代码如下：</p>
<p>修改<strong>app.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 添加代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'max-age='</span> + <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 添加代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'max-age='</span> + <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.js'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 添加代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'max-age='</span> + <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们在通过<code>nodemon app.js</code>运行代码，运行效果大致如下：</p>
<ol>
<li>第一个打开<code>localhost:3000</code>时，因为没有任何缓存所以资源是<code>从服务器中请求</code>来的，如下图所示<br><img src="./http-cache-http/http-cache-3-14.png" alt="http-cache-public"></li>
<li>当我们刷新页面时，因为我们设置了<code>Cache-Control: max-age=10</code>，所以会走<code>本地缓存</code>，如下图所示<br><img src="./http-cache-http/http-cache-3-15.png" alt="http-cache-public"><br>第二次请求，三个请求都来自 <code>memory cache</code>。因为我们没有关闭 TAB，所以浏览器把缓存的应用加到了<code>memory cache</code>。(耗时 0ms，也就是 1ms 以内)</li>
<li>当我们跳转到<code>https://www.baidu.com</code>，再返回页面时，它也会<code>走本地缓存</code>，如下图所示<br><img src="./http-cache-http/http-cache-3-16.png" alt="http-cache-public"><br>因为跳转页面等于是<strong>关闭了 TAB</strong>，<code>memory cache</code> 也随之清空。但是 <code>disk cache</code> 是持久的，于是所有资源来自 <code>disk cache</code>。(大约耗时 3ms，因为文件有点小)而且对比 2 和 3，很明显看到 <code>memory cache</code> 还是比 <code>disk cache</code>快得多的。</li>
</ol>
<h3 id="no-cache-和-no-store-对比"><a href="#no-cache-和-no-store-对比" class="headerlink" title="no-cache 和 no-store 对比"></a>no-cache 和 no-store 对比</h3><p>我们来对比一下<code>no-cache</code>和<code>no-store</code>的区别，修改代码如下：</p>
<p>修改<strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/index/index.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/index/index.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    测试cache</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/index/rotateX.png"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/index/rotateX.png"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 异步请求图片 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span></span><br><span class="line"><span class="javascript">        img.src = <span class="string">'/index/rotateX.png'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(img);</span></span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们暂时不修改缓存的配置，通过<code>nodemon app.js</code>运行代码，运行效果大致如下：</p>
<ul>
<li>同步请求方面，浏览器会<strong>自动</strong>把当次 <code>HTML</code> 中的资源存入到缓存 (<code>memory cache</code>)，这样碰到相同 <code>src</code> 的图片就会自动读取缓存(但不会在 <code>Network</code> 中显示出来)</li>
<li>异步请求方面，浏览器同样是不发请求而<strong>直接读取缓存</strong>返回。但同样不会在 <code>Network</code> 中显示。</li>
</ul>
<p>下面我们修改<strong>app.js</strong>中的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.js'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们运行代码看的效果如下图所示：<br><img src="./http-cache-http/http-cache-3-18.png" alt="http-cache-public"></p>
<ul>
<li>同步请求方面，浏览器会<strong>自动</strong>把当次 <code>HTML</code> 中的资源存入到缓存 (<code>memory cache</code>)，这样碰到相同 <code>src</code> 的图片就会自动读取缓存(但不会在 <code>Network</code> 中显示出来)</li>
</ul>
<p>如果把<code>no-cache</code>修改为<code>no-store</code></p>
<p>修改<strong>app.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-store'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-store'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">router.get(<span class="string">'/index/index.js'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="comment">// 替换原来代码</span></span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-store'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们运行代码看的效果如下图所示：<br><img src="./http-cache-http/http-cache-3-17.png" alt="http-cache-public"></p>
<p>当我们设置了<code>Cache-Control: no-store</code>时，可以看到<code>css</code>、<code>js</code>文件都被请求了两次，<code>png</code>请求了三次。</p>
<ul>
<li>如之前原理所述，虽然 <code>memory cache</code> 是无视 <code>HTTP</code> 头信息的，但是 <code>no-store</code> 是特别的。在这个设置下，<code>memory cache</code> 也不得不每次都请求资源。</li>
<li>异步请求和同步遵循相同的规则，在 <code>no-store</code> 情况下，依然是每次都发送请求，不进行任何缓存。</li>
</ul>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h3><p>这里来设置协商缓存<code>Last-Modified/If-Modified-Since</code>，代码修改如下：</p>
<p>修改<strong>app.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> responseFile = <span class="keyword">async</span> (path, context, encoding) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fileContent = <span class="keyword">await</span> fs.readFile(path, encoding);</span><br><span class="line">  context.type = mime.getType(path);</span><br><span class="line">  context.body = fileContent;</span><br><span class="line">&#125;;</span><br><span class="line">router.get(<span class="string">'/index/rotateX.png'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">'Pragma'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; response, request, path &#125; = ctx;</span><br><span class="line">  <span class="keyword">const</span> imagePath = Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> ifModifiedSince = request.headers[<span class="string">'if-modified-since'</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(ifModifiedSince);</span><br><span class="line">  <span class="keyword">const</span> imageStatus = <span class="keyword">await</span> fs.stat(imagePath);</span><br><span class="line">  <span class="keyword">const</span> lastModified = imageStatus.mtime.toGMTString();</span><br><span class="line">  <span class="keyword">if</span> (ifModifiedSince === lastModified) &#123;</span><br><span class="line">    response.status = <span class="number">304</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.lastModified = lastModified;</span><br><span class="line">    <span class="keyword">await</span> responseFile(imagePath, ctx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>大致流程如下：</p>
<ol>
<li>在<code>Chrome</code>中选中<code>Disable Cache</code>禁用缓存，可以通过下面图片看到服务器端发送给客户端<code>Last-Modified: Thu, 24 Oct 2019 05:12:37 GMT</code>。<br><img src="./http-cache-http/http-cache-3-19.png" alt="http-cache-public"></li>
<li>关闭 <code>disable cache</code> 后再次访问图片时，发现带上了 <code>if-modified-since</code> 请求头，值就是上次请求响应的 <code>last-modified</code> 值，因为图片最后修改时间不变，所以 <code>304 Not Modified</code>。效果如下图所示<br><img src="./http-cache-http/http-cache-3-20.png" alt="http-cache-public"></li>
</ol>
<blockquote>
<p>启用<code>Disable Cache</code>时，我们可以看到<strong>客户端/浏览器端</strong>自动带上了<code>Pragma&#39;:&#39;no-cache&#39;</code>、<code>&#39;Cache-Control&#39;: &#39;no-cache&#39;</code>这两个字段，不适用缓存。</p>
</blockquote>
<h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h3><p>修改<strong>app.js</strong>，通过<code>npm i crypto -D</code>安装<code>crypto</code>,用于生成<code>md5</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理 css 文件</span></span><br><span class="line">router.get(<span class="string">'/index/index.css'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; request, response, path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(path);</span><br><span class="line">  response.set(<span class="string">'pragma'</span>, <span class="string">'no-cache'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ifNoneMatch = request.headers[<span class="string">'if-none-match'</span>];</span><br><span class="line">  <span class="keyword">const</span> imagePath = Path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> hash = crypto.createHash(<span class="string">'md5'</span>);</span><br><span class="line">  <span class="keyword">const</span> imageBuffer = <span class="keyword">await</span> fs.readFile(imagePath);</span><br><span class="line">  hash.update(imageBuffer);</span><br><span class="line">  <span class="keyword">const</span> etag = <span class="string">`"<span class="subst">$&#123;hash.digest(<span class="string">'hex'</span>)&#125;</span>"`</span>;</span><br><span class="line">  <span class="keyword">if</span> (ifNoneMatch === etag) &#123;</span><br><span class="line">    response.status = <span class="number">304</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.set(<span class="string">'etag'</span>, etag);</span><br><span class="line">    ctx.body = imageBuffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="./http-cache-http/http-cache-3-21.png" alt="http-cache-public"></p>
<p>他的过程和<code>Last-Modified/If-Modified-Since</code>，但是因为<code>Last-Modified/If-Modified-Since</code>它不能监听<code>1s</code>以内的资源变化，所以一般用他来做<code>Etag/If-None-Match</code>的补充方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存大致分为：<code>强缓存</code>、<code>协商缓存</code>。</p>
<ul>
<li><code>强缓存</code>: <code>pragma</code>、<code>cache-control</code>、<code>expires</code></li>
<li><code>协商缓存</code>: <code>last-modified/If-modified-since</code>、<code>etag/if-none-match</code></li>
<li><code>强缓存优先级</code>: <code>cache-control &gt; pragma &gt; expires</code></li>
<li><code>协商缓存优先级</code>: <code>etag/if-none-match &gt; last-modified/If-modified-since</code></li>
</ul>
<p>缓存位置分为： <code>Service Worker</code>、<code>Memory Cache</code>、<code>Disk Cache</code>、<code>Push Cache</code>，也是从左到右如果命中就使用。</p>
<p>上面的实例只是比较简单的应用，其实还有很多有意思的实例能加深对缓存的理解，如下：</p>
<ul>
<li><code>pragma</code>、<code>cache-control</code>、<code>expires</code>优先级</li>
<li><code>last-modified/If-modified-since</code>、<code>etag/if-none-match</code>优先级</li>
<li><code>cache-control: no-cache</code>与<code>cache-control: max-age=0, must-revalidate</code>效果是否相同</li>
<li><code>chrome</code>、<code>firefox</code>、<code>ie</code>之间的缓存差别</li>
</ul>
<p>本篇文章有意避开<code>Service Worker</code>的详细介绍，因为会有单独的一篇文章来介绍<code>Service Worker</code>在真实应用的使用。</p>
<blockquote>
<p><a href="https://codesandbox.io/embed/agitated-rain-55pzk?fontsize=14" target="_blank" rel="noopener">在线代码</a>，可以<strong>刷新页面（刷新内部页面）</strong>在<strong>控制台</strong>中查看当前效果</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDYxNTM0OQ==&amp;mid=2247484082&amp;idx=1&amp;sn=2efec72057f7fa448a6c0e258fd80370&amp;chksm=ebf9f568dc8e7c7e7d9e134b023c4cc71528caebd14153922bd8a753eb7330ec04289b4c89cc&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568210174017&amp;sharer_shareid=491f5e3b572f21d39b90888df1c8829b&amp;key=87d0d2afc25bc11ed40773ae28d50dc35909a8612c034880c5d0f249e5ab7525f1e6476a825113b59ad0f71ae424aa90bc5ef63bd55775c844a86d0d7b64c96480f095a3072da752b723851f6685d76b&amp;ascene=1&amp;uin=MTY4MzM5MzY2Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=x2ObXwYE5mF5saSt6Ycrs%2FnJfxgIYByJ8YPenA%2Ft5rl%2FXcqc7s6LVGsTuEjoprxw" target="_blank" rel="noopener">一文搞懂浏览器缓存机制</a><br><a href="https://mp.weixin.qq.com/s/MYEXGtMxa3tj4H2-Wl378w" target="_blank" rel="noopener">关于 http 缓存，这些知识点你可能都不懂</a><br><a href="https://mp.weixin.qq.com/s/b_vo_epjycDsGvczU6ol3Q" target="_blank" rel="noopener">浏览器缓存策略</a><br><a href="https://zhuanlan.zhihu.com/p/44789005" target="_blank" rel="noopener">一文读懂前端缓存</a><br><a href="https://juejin.im/post/5d0f9585e51d4510926a7b68" target="_blank" rel="noopener">通过 koa2 服务器实践探究浏览器 HTTP 缓存机制</a></p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 react的 setState</title>
    <url>/blog/react/principle/react-setState.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>自己手动实现call、apply、bind</title>
    <url>/blog/javascript/polyfill/js-call-apply-bind-polyfill.html</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li><code>将函数设为对象的属性</code></li>
<li><code>执行该函数</code></li>
<li><code>删除该函数</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line">foo.fn = bar;</span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">foo.fn();</span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="keyword">delete</span> foo.fn;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol>
<li><code>传入的参数并不确定</code></li>
<li><code>this 参数可以传 null，当为 null 的时候，视为指向 window</code></li>
<li><code>函数是可以有返回值的！</code></li>
</ol>
<h2 id="call-实现代码"><a href="#call-实现代码" class="headerlink" title="call 实现代码"></a>call 实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="comment">// arguments是类数组对象，遍历之前需要保存长度，过滤出第一个传参</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 避免object之类传入</span></span><br><span class="line">    args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> aArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> oObj = &#123;</span><br><span class="line">  firstName: <span class="string">'joy'</span>,</span><br><span class="line">  lastName: <span class="string">'tony'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callArr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">callArr.call(aArr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calloObj</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">'firstName：'</span> +</span><br><span class="line">    <span class="keyword">this</span>.firstName +</span><br><span class="line">    <span class="string">'/ lastName：'</span> +</span><br><span class="line">    <span class="keyword">this</span>.lastName +</span><br><span class="line">    <span class="string">'/ age：'</span> +</span><br><span class="line">    age</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">calloObj.call(oObj, <span class="number">25</span>); <span class="comment">// "firstName：joy/ lastName：tony/ age：25"</span></span><br></pre></td></tr></table></figure>
<h2 id="apply-实现代码"><a href="#apply-实现代码" class="headerlink" title="apply 实现代码"></a>apply 实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyArr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">applyArr.apply(aArr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyoObj</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">'firstName：'</span> +</span><br><span class="line">    <span class="keyword">this</span>.firstName +</span><br><span class="line">    <span class="string">'/ lastName：'</span> +</span><br><span class="line">    <span class="keyword">this</span>.lastName +</span><br><span class="line">    <span class="string">'/ age：'</span> +</span><br><span class="line">    age</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">calloObj.call(oObj, [<span class="number">25</span>]); <span class="comment">// "firstName：joy/ lastName：tony/ age：25"</span></span><br></pre></td></tr></table></figure>
<h2 id="bind-实现-polyfill"><a href="#bind-实现-polyfill" class="headerlink" title="bind 实现 polyfill"></a>bind 实现 polyfill</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">        <span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">      fToBind = <span class="keyword">this</span>,</span><br><span class="line">      fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">      fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">        <span class="keyword">return</span> fToBind.apply(</span><br><span class="line">          <span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : oThis,</span><br><span class="line">          <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">          aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      <span class="comment">// Function.prototype doesn't have a prototype property</span></span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">    <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Polyfill</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript对于继承的面试题</title>
    <url>/blog/interview-question/javascript/extends-javascript.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>InterviewQuestion</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个stringify、parse</title>
    <url>/blog/interview-question/javascript/javascript-stringify-parse.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>InterviewQuestion</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中对于优先级的面试题</title>
    <url>/blog/interview-question/javascript/priority.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>InterviewQuestion</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>Css怎么实现一个 高度随宽度变化 1:1 或者别的比例的布局</title>
    <url>/blog/interview-question/css/css-padding.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>一个网站的<code>logo</code>它的宽度是不固定的，并且要求它的高度与它的宽度相等也就是正方向，用<code>css</code>实现。<br>在以前的一篇文章中有记录<a href="/blog/css/css-padding.html">深入理解 css 系列 css 中 padding</a>，可以通过<code>padding</code>的百分比是<strong>规定基于父元素的宽度的百分比的内边距。</strong><br>也可以通过<code>vh、vw</code>实现</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="通过-padding-实现"><a href="#通过-padding-实现" class="headerlink" title="通过 padding 实现"></a>通过 padding 实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.header</span> &#123;</span></span><br><span class="line">    wdith: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.header-logo</span> &#123;</span></span><br><span class="line">    padding: 50%;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hedaer-logo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就可以创建一个宽高<code>1:1</code>的正方形，只需要修改<code>header</code>元素的宽度就可以动态修改<code>logo</code>元素的大小。</p>
<h3 id="通过-vh、vw-实现"><a href="#通过-vh、vw-实现" class="headerlink" title="通过 vh、vw 实现"></a>通过 vh、vw 实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.header-logo</span> &#123;</span></span><br><span class="line">    width: 10vh; // 或者vw</span><br><span class="line">    height: 10vh; // 或者vw</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hedaer-logo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把<code>logo</code>元素的宽高通过设置为<code>vh、vw</code>来实现他们的的宽度和高度值都来自与屏幕的<strong>宽或高</strong>。</p>
<h3 id="通过-rem-实现"><a href="#通过-rem-实现" class="headerlink" title="通过 rem 实现"></a>通过 rem 实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">font-size</span>=<span class="string">"12px"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.header-logo</span> &#123;</span></span><br><span class="line">    width: 10rem;</span><br><span class="line">    height: 10rem;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hedaer-logo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过设置<code>html</code>元素上的<code>font-size: 12px</code>，<code>logo</code>元素的宽高通过 rem 控制为<code>10rem</code>也可以实现宽高<code>1:1</code>的元素。</p>
<h3 id="通过-js-实现"><a href="#通过-js-实现" class="headerlink" title="通过 js 实现"></a>通过 js 实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  /* header &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">    &#125; */</span><br><span class="line"><span class="css">  <span class="selector-class">.header-logo</span> &#123;</span></span><br><span class="line">    width: 20%;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dom = <span class="built_in">document</span>.querySelector(<span class="string">'.header-logo'</span>),</span></span><br><span class="line">    nDomWidth = dom.clientWidth;</span><br><span class="line"><span class="javascript">  dom.style.height = nDomWidth + <span class="string">'px'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> nDomWidth = dom.clientWidth;</span></span><br><span class="line"><span class="javascript">    dom.style.height = nDomWidth + <span class="string">'px'</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只设置<code>logo</code>元素的宽度，默认通过 js 获取<code>logo</code>元素的<strong>宽度</strong>赋值给<strong>高度</strong>，后面监听窗口变化适时更新高度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面一共通过<strong>四种方法</strong>来实现的宽高 1:1，并且高度跟随宽度变化。其实上面四种解决方法比较相近，如果有更好的方法请留言探讨，谢谢。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="/blog/css/css-padding.html">深入理解 css 系列 css 中 padding</a></p>
]]></content>
      <categories>
        <category>InterviewQuestion</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 css中margin</title>
    <url>/blog/css/deep-attribute/css-margin.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在平常开发过程中经常用到<strong>margin</strong>属性，但是也会遇到很多的问题，比如说<code>**margin 重叠（BFC）**</code>、<code>**负 margin**</code>等等问题，下面就一个一个来记录问什么会这样。</p>
<p><strong>标准盒模型</strong></p>
<p><img src="./css-margin/css-margin-1-1.png" alt="css margin"></p>
<p>要了解<strong>margin</strong>就要先了解<strong>css</strong>中的<code>**盒子模型（Box Model）**</code>，<code>**标准盒模型**</code>可以分为：<code>外边距(margin)、边框（border）、内边距（padding）、内容区域（content）</code>。在<strong>标准盒模型</strong>中平常所说道的高度只是<strong>content</strong>的高度，不包含<strong>border</strong>的高度，而在<strong>ie 盒模型</strong>中是把<strong>border</strong>算在内的。</p>
<p><strong>margin 属性</strong></p>
<p>margin 有四个属性<code>**margin-top**、**margin-left**、**margin-bottom**、**margin-right**，它们的值可以为**百分比**、**数值（左右可为负数）**、**em、rem、vh、vw**、**auto**</code>等等。</p>
<h2 id="margin-与容器尺寸"><a href="#margin-与容器尺寸" class="headerlink" title="margin 与容器尺寸"></a>margin 与容器尺寸</h2><p>元素尺寸：① 可视尺寸 clientWidth（标准）；② 占据尺寸</p>
<p><img src="./css-margin/css-margin-1-2.png" alt="css margin"></p>
<p>margin 与可视尺寸：<code>**① 适用于没有设定 width/height 的普通 block 元素；② 只适用于水平方向尺寸**</code><br>margin 与占据尺寸：<code>**①block/inline-block 水平元素均适用；② 与有没有设定 width/height 无关；**</code></p>
<p>③ 适用于水平方向和垂直方向。可用于页面的上下留白（padding 兼容性不好）。</p>
<h3 id="margin-与可视尺寸"><a href="#margin-与可视尺寸" class="headerlink" title="margin 与可视尺寸"></a>margin 与可视尺寸</h3><p>特性：</p>
<ul>
<li>适用于没有设定<code>width/height</code>的普通<code>block</code>元素</li>
<li><strong>只适用于水平方向尺寸</strong></li>
</ul>
<p>应用：一侧定宽自适应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"150px"</span> <span class="attr">style</span>=<span class="string">"float:left"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"margin-left:170px;"</span>&gt;</span>图片左浮动....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="./css-margin/css-margin-1-3.png" alt="css margin"></p>
<h3 id="margin-与占据尺寸"><a href="#margin-与占据尺寸" class="headerlink" title="margin 与占据尺寸"></a>margin 与占据尺寸</h3><p>特性：</p>
<ul>
<li><code>block、inline-block</code>水平元素均适应</li>
<li>与有没有设定<code>width、height</code>值无关</li>
<li>适应于水平方向和垂直方向</li>
</ul>
<h2 id="margin-与百分比单位"><a href="#margin-与百分比单位" class="headerlink" title="margin 与百分比单位"></a>margin 与百分比单位</h2><ul>
<li>普通元素的百分比：<strong>相对于容器宽度计算</strong>。</li>
<li>绝对定位元素的百分比：<strong>相对于第一个定位的祖先容器的宽度计算的</strong>。</li>
</ul>
<h2 id="margin-中的重叠"><a href="#margin-中的重叠" class="headerlink" title="margin 中的重叠"></a>margin 中的重叠</h2><h3 id="margin-重叠通常特性"><a href="#margin-重叠通常特性" class="headerlink" title="margin 重叠通常特性"></a>margin 重叠通常特性</h3><ol>
<li><code>block</code>水平元素（不包括<code>float</code>和<code>absolute</code>元素）</li>
<li>不考虑<code>writing-mode</code>，只发生垂直方向（<code>margin-top/margin-bottom</code>）</li>
</ol>
<h3 id="margin-重叠的-3-种情景"><a href="#margin-重叠的-3-种情景" class="headerlink" title="margin 重叠的 3 种情景"></a>margin 重叠的 3 种情景</h3><ol>
<li><strong>相邻的兄弟元素</strong></li>
<li><strong>父级和第一个/最后一个子元素</strong></li>
<li><strong>空的 block 元素</strong></li>
</ol>
<h3 id="父子-margin-重叠其他条件"><a href="#父子-margin-重叠其他条件" class="headerlink" title="父子 margin 重叠其他条件"></a>父子 margin 重叠其他条件</h3><p><strong>margin-top 重叠</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">margin-top 重叠</th>
<th style="text-align:center">解决</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">父元素<strong>非块状格式化上下文</strong>元素</td>
<td style="text-align:center">设置父元素<code>overflow</code>：<code>hidden</code></td>
</tr>
<tr>
<td style="text-align:center">父元素没有<code>border-top</code>设值</td>
<td style="text-align:center">设置父元素<code>border</code></td>
</tr>
<tr>
<td style="text-align:center">父元素没有<code>padding-top</code>值</td>
<td style="text-align:center">设置父元素<code>padding-top</code></td>
</tr>
<tr>
<td style="text-align:center">父元素和第一个子元素之间没有<code>inline</code>元素分隔</td>
<td style="text-align:center"><strong>插入一个内联元素如空格&bsp;</strong></td>
</tr>
</tbody>
</table>
<p><strong>margin-bottom 重叠</strong></p>
<ol>
<li>父元素<strong>非块状格式化上下文</strong>元素</li>
<li>父元素没有<code>border-bottom</code>设置</li>
<li>父元素没有<code>padding-bottom</code>值</li>
<li>父元素和最后一个子元素之间没有<code>inline</code>元素分隔</li>
<li>父元素没有<code>height</code>相关声明</li>
</ol>
<h3 id="空-block-元素-margin-重叠"><a href="#空-block-元素-margin-重叠" class="headerlink" title="空 block 元素 margin 重叠"></a>空 block 元素 margin 重叠</h3><p>条件限制：</p>
<ol>
<li>元素没有<code>border</code>设置</li>
<li>元素没有<code>padding</code>值</li>
<li>里面没有<code>inline</code>元素</li>
<li>没有<code>height、或者min-height</code></li>
</ol>
<h3 id="重叠的计算规则"><a href="#重叠的计算规则" class="headerlink" title="重叠的计算规则"></a>重叠的计算规则</h3><ul>
<li><strong>正正取大值</strong></li>
<li><strong>正负值相加</strong></li>
<li><strong>负负最负值</strong></li>
</ul>
<h3 id="理解-CSS-中的-margin-auto"><a href="#理解-CSS-中的-margin-auto" class="headerlink" title="理解 CSS 中的 margin:auto"></a>理解 CSS 中的 margin:auto</h3><p><code>margin:auto</code>的作用机制：<strong>自动分配剩余空间</strong></p>
<h3 id="垂直居中方法-margin-实现"><a href="#垂直居中方法-margin-实现" class="headerlink" title="垂直居中方法(margin 实现)"></a>垂直居中方法(margin 实现)</h3><p><strong>writing-mode</strong></p>
<p>更改流为垂直方向，但是水平居中失效</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">writing-mode</span>: vertical-lr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-margin/css-margin-1-4.png" alt="css margin"></p>
<p><strong>绝对定位元素的 margin:auto 居中</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-margin/css-margin-1-5.png" alt="css margin"></p>
<h2 id="margin-负值"><a href="#margin-负值" class="headerlink" title="margin 负值"></a>margin 负值</h2><p>为了方便理解负值<code>margin</code>，我们引入参考线的定义，参考线就是就是<code>margin</code>移动的基准点，而<code>margin</code>的值就是移动的数值。<br><code>margin</code>的参考线有两类，一类是<code>top、left</code>，它们以外元素作为参考线;<br>另一类是<code>right、bottom</code>，它们以自身作为参考线。<br>简单点说就是：</p>
<ul>
<li><code>top</code>负值就是以包含块<code>(Containing block)</code> 内容区域的上边或者上方相连元素 <code>margin</code> 的下边线为参考线;</li>
<li><code>left</code>负值就是以包含块<code>(Containing block)</code> 内容区域的左边或者左方相连元素 <code>margin</code> 的右边为参考线;</li>
<li><code>right</code>负值就是以元素本身<code>border</code>的右边为参考线；</li>
<li><code>bottom</code>负值就是以元素本身<code>border</code>的下边为参考线；</li>
</ul>
<p>另外关于包含块的定义具体<a href="http://w3help.org/zh-cn/kb/008/" target="_blank" rel="noopener">请参考 KB008 包含块(Containing block)</a>。</p>
<p><img src="./css-margin/css-margin-1-6.png" alt="css margin"></p>
<p><strong>公用代码</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin: auto;</span><br><span class="line">    border: 1px black solid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.one</span> &#123;</span></span><br><span class="line">    background: orange;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.two</span> &#123;</span></span><br><span class="line">    background: green;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="margin-top-和-margin-left-负值"><a href="#margin-top-和-margin-left-负值" class="headerlink" title="margin-top 和 margin-left 负值"></a>margin-top 和 margin-left 负值</h3><h4 id="margin-top"><a href="#margin-top" class="headerlink" title="margin-top"></a>margin-top</h4><p>修改 css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="./css-margin/css-margin-1-7.png" alt="css margin"></p>
<p>当设置<code>.two</code>的<code>div</code>的<code>margin-top: -50px</code>的时候，它的参考线是<code>div.one</code>的下边，整个<code>div.two</code>向上移动<code>-50px</code>使得<code>div.two</code>覆盖<code>div.one</code>。</p>
<h4 id="margin-left"><a href="#margin-left" class="headerlink" title="margin-left"></a>margin-left</h4><p>修改 css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="./css-margin/css-margin-1-8.png" alt="css margin"></p>
<p>当设置<code>.two</code>的<code>div</code>的<code>margin-left: -50px</code>的时候，它的参考线是<code>div.one</code>的右边线，整个<code>div.two</code>向左移动<code>-50px</code>使的<code>div.two</code>覆盖<code>div.one</code>。</p>
<h3 id="margin-right-和-margin-bottom-负值"><a href="#margin-right-和-margin-bottom-负值" class="headerlink" title="margin-right 和 margin-bottom 负值"></a>margin-right 和 margin-bottom 负值</h3><h4 id="margin-right"><a href="#margin-right" class="headerlink" title="margin-right"></a>margin-right</h4><p>修改 css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="./css-margin/css-margin-1-8.png" alt="css margin"></p>
<p>当设置<code>.one</code>的<code>div</code>的<code>margin-right: -50px</code>的时候，它的参考线是<code>div.one</code>的右边线，整个<code>div.one</code>向左收缩<code>-50px</code>使的<code>div.two</code>覆盖<code>div.one</code>。</p>
<h4 id="margin-bottom"><a href="#margin-bottom" class="headerlink" title="margin-bottom"></a>margin-bottom</h4><p>修改 css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: static;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="./css-margin/css-margin-1-7.png" alt="css margin"></p>
<p>当设置<code>.one</code>的<code>div</code>的<code>margin-bottom: -50px</code>的时候，它的参考线是<code>div.one</code>的下边线，整个<code>div.one</code>向上收缩<code>-50px</code>使的<code>div.two</code>覆盖<code>div.one</code>。</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p><strong>margin 负值下的两端对齐：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 1200px;</span><br><span class="line">    margin: auto;</span><br><span class="line">    background: orange;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.ul</span> &#123;</span></span><br><span class="line">    list-style: none;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    margin-right: -20px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.li</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span>: 386<span class="selector-class">.66px</span>;</span></span><br><span class="line">    height: 300px;</span><br><span class="line">    margin-right: 20px;</span><br><span class="line">    background: green;</span><br><span class="line">    float: left;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li"</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li"</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li"</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="./css-margin/css-margin-1-9.png" alt="css margin"></p>
<p><strong>margin 负值下的等高布局：</strong></p>
<p><img src="./css-margin/css-margin-1-10.png" alt="css margin"></p>
<p><strong>margin 负值下的两栏自适应布局：</strong></p>
<p><img src="./css-margin/css-margin-1-11.png" alt="css margin"></p>
<h2 id="margin-无效情形解析"><a href="#margin-无效情形解析" class="headerlink" title="margin 无效情形解析"></a>margin 无效情形解析</h2><ol>
<li><code>inline</code>水平元素的垂直<code>margin</code>无效前提：</li>
</ol>
<ul>
<li>非替换元素，例如不是<code>&lt;img&gt;</code>元素；</li>
<li>正常书写模式。</li>
</ul>
<ol start="2">
<li><code>margin</code>重叠</li>
<li><code>display:table-cell</code>与<code>margin：display:table-cell/display:table-row</code>等声明的<code>margin</code>无效。</li>
<li><code>position:absolute</code>与<code>margin</code>：绝对定位元素未设置定位方向的<code>margin</code>值”无效“。例如，<code>img{top:10%}</code>的<code>margin-top</code>有效其他均无效。</li>
<li>内联特性导致的<code>margin</code>无效：</li>
</ol>
<h2 id="了解-margin-start-margin-end-属"><a href="#了解-margin-start-margin-end-属" class="headerlink" title="了解 margin-start/margin-end 属"></a>了解 margin-start/margin-end 属</h2><h3 id="webkit-margin-start、-webkit-margin-end"><a href="#webkit-margin-start、-webkit-margin-end" class="headerlink" title="-webkit-margin-start、-webkit-margin-end"></a>-webkit-margin-start、-webkit-margin-end</h3><ul>
<li>正常的流向，<code>margin-start</code>等同于<code>margin-left</code>，两者重叠不累加</li>
<li>如果水平流是从右往左，<code>margin-start</code>等同于<code>margin-right</code></li>
<li>在垂直流下（<code>writing-mode:vertical-*;</code>）,<code>margin-start</code>等同于<code>margin-top</code></li>
</ul>
<h3 id="margin-collaps"><a href="#margin-collaps" class="headerlink" title="margin-collaps"></a>margin-collaps</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">-webkit-margin-collaps: &lt;collaps&gt; | &lt;discard&gt; | &lt;separate&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>collaps</code>,默认，重叠</li>
<li><code>discard</code>，取消重叠，使<code>margin</code>无效</li>
<li><code>separate</code>，取消重叠，不合并</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇文章中介绍主要的<code>margin百分比</code>、<code>margin重叠条件</code>、<code>margin在盒模型中的区域</code>，但是本文总结的<code>margin负值</code>并不是全部情况，比如说<code>div.two</code>设置为<code>margin-right: -50px</code>为什么不会收缩自己的宽度等等。希望大家多多做补充。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.imooc.com/learn/565" target="_blank" rel="noopener">CSS 深入理解之 relative</a><br><a href="https://www.kancloud.cn/dunizb/web-dev-marrow/647633#11_margin_2" target="_blank" rel="noopener">CSS 深入理解之 margin</a><br><a href="https://cloud.tencent.com/developer/article/1053594" target="_blank" rel="noopener">CSS 深入理解学习笔记之 margin</a><br><a href="https://zhuanlan.zhihu.com/p/25892372" target="_blank" rel="noopener">浅谈 margin 负值</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列 css中relative</title>
    <url>/blog/css/deep-attribute/css-relative.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>relative</code>其实是<code>position</code>中的一个属性，<code>positon</code>有五个属性分别为<code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>、<code>sticky</code>，分别代表不同的定位类型。大致分为下面四种：</p>
<p><strong>定位类型</strong></p>
<ul>
<li><strong>定位元素（positioned element）</strong>是其计算后位置属性为 <code>relative</code>, <code>absolute</code>, <code>fixed</code> 或 <code>sticky</code> 的一个元素。</li>
<li><strong>相对定位元素（relatively positioned element）</strong>是计算后位置属性为 <code>relative</code> 的元素。</li>
<li><strong>绝对定位元素（absolutely positioned element）</strong>是计算后位置属性为 <code>absolute</code> 或 <code>fixed</code> 的元素。</li>
<li><strong>粘性定位元素（stickily positioned element）</strong>是计算后位置属性为 <code>sticky</code> 的元素。</li>
</ul>
<p><strong><code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>、<code>sticky</code>取值</strong></p>
<p><strong>static</strong></p>
<p>该关键字指定元素使用正常的布局行为，即元素在文档<strong>常规流</strong>中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code> 属性无效。</p>
<p><strong>relative</strong></p>
<p>该关键字下，元素先放置在未添加定位时的位置，再在<strong>不改变</strong>页面布局的前提下<strong>调整元素</strong>位置（因此会在此元素未添加定位时所在位置留下空白）。<code>position:relative</code> 对 <code>table-*-group</code>, <code>table-row</code>, <code>table-column</code>, <code>table-cell</code>, <code>table-caption</code> 元素无效。</p>
<p><strong>absolute</strong></p>
<p>不为元素预留空间，通过指定<strong>元素相对于最近的非 static 定位祖先元素的偏移</strong>，来确定元素位置。绝对定位的元素可以设置外边距（margins），<strong>且不会与其他边距合并</strong>。</p>
<p><strong>fixed</strong></p>
<p>不为元素预留空间，而是通过指定元素<strong>相对于屏幕视口（viewport）的位置来指定元素位置</strong>。<strong>元素的位置在屏幕滚动时不会改变</strong>。打印时，元素会出现在的每页的固定位置。<strong>fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先</strong>。</p>
<p><strong>sticky（实验属性）</strong></p>
<p>盒位置根据正常流计算(这称为正常流动中的位置)，然后<strong>相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位</strong>。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<strong>position: sticky 对 table 元素的效果与 position: relative 相同</strong>。</p>
<p><strong>语法</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">postion: static | relative | absolute | sticky | fixed;</span><br></pre></td></tr></table></figure>
<h2 id="relative-的特性"><a href="#relative-的特性" class="headerlink" title="relative 的特性"></a>relative 的特性</h2><p>在上面看到<strong>MDN</strong>对<code>relative</code>的定位的一下描述，但是并没有描述的比较通俗，通过下面的实例总结一下<code>relative</code>的特性。</p>
<p><strong>公用代码</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.one</span> &#123;</span></span><br><span class="line">    background: orange;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.two</span> &#123;</span></span><br><span class="line">    background: purple;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="relative-是相对于定位"><a href="#relative-是相对于定位" class="headerlink" title="relative 是相对于定位"></a>relative 是相对于定位</h3><p>直接上代码，修改代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="./css-relative/css-relative-1-1.png" alt="css margin"></p>
<p>把<code>div.one</code>设置<code>position: relative</code>时，并且设置<code>top: 50px</code>时，可以看到<code>div.one</code>的元素相对于自身在正常流中的位置向下移动了<code>50px</code>，它挡住了一半的<code>div.two</code>元素。<br><code>relative</code>的四个定位值<code>top</code>、<code>left</code>、<code>bottom</code>、<code>right</code>是相对自身移动的。</p>
<blockquote>
<p><strong>如果设置了对立属性 top/bottom、left/right 的相对定位元素，它的 top/left 生效，right/bottom 无效。</strong></p>
</blockquote>
<h3 id="relative-不改变布局"><a href="#relative-不改变布局" class="headerlink" title="relative 不改变布局"></a>relative 不改变布局</h3><p><code>margin-top: 负值</code>修改代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行效果如下：<br><img src="./css-relative/css-relative-1-2.png" alt="css margin"></p>
<p>可以看到<code>div.one</code>设置<code>margin-top: -50px;</code>时，它会影响到它相邻的兄弟元素<code>div.two</code>的位置，<code>div.one/div.two</code>都相对于原来的位置<strong>向上</strong>移动了<code>50px</code>。</p>
<p><code>top: -50px;</code>修改代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行效果如下：<br><img src="./css-relative/css-relative-1-3.png" alt="css margin"></p>
<p>可以看到<code>div.one</code>设置<code>postion: relative; top: -50px;</code>时，它不会影响到它相邻的兄弟元素<code>div.two</code>的位置，<code>div.one</code>都相对于原来的位置<strong>向上</strong>移动了<code>50px</code>，而<code>div.two</code>的位置是不变的。</p>
<ul>
<li><code>relative</code>是相对于自身定位的。</li>
<li><code>relative</code>是不会改变布局的</li>
</ul>
<h2 id="relative-的限制作用"><a href="#relative-的限制作用" class="headerlink" title="relative 的限制作用"></a>relative 的限制作用</h2><h3 id="relative-对-absolute-的限制作用"><a href="#relative-对-absolute-的限制作用" class="headerlink" title="relative 对 absolute 的限制作用"></a>relative 对 absolute 的限制作用</h3><p><code>absolute</code>定位的是其<strong>第一个祖先元素定位属性不为 static 属性</strong>。这个就不多赘述，基本上都在用这种布局。<br>如果设置<code>postion: absolute;</code>元素的父元素没有设置<code>position: relative;</code>，那么设置<code>position: absolute;</code>元素的绝对定位就会最外层的<strong>根元</strong>素定位。</p>
<h3 id="relative-对-overflow-的限制作用"><a href="#relative-对-overflow-的限制作用" class="headerlink" title="relative 对 overflow 的限制作用"></a>relative 对 overflow 的限制作用</h3><p>其实这个也比较常用但是一般不会太注意<code>relative</code>对<code>overflow</code>的影响。</p>
<p><strong>父元素不添加 relative</strong></p>
<p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div class="two"&gt;two&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div class="two"&gt;two&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改<strong>css</strong>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下过显示如下图所示：</p>
<p><img src="./css-relative/css-relative-1-4.png" alt="css margin"></p>
<p>可以看到第一个<code>div.box</code>没有设置<code>position: relative;</code>时，子元素设置<code>position: absoulte;</code>时，并且子元素的宽度高度大于父元素的宽度高度时，它会超出父元素的范围。<br>第二个<code>div.box</code>设置了<code>position: relative;</code>时，子元素设置不会超出父元素的宽高范围。</p>
<h3 id="relative-对层级-z-index-的限制作用"><a href="#relative-对层级-z-index-的限制作用" class="headerlink" title="relative 对层级 z-index 的限制作用"></a>relative 对层级 z-index 的限制作用</h3><p>对于一个已经定位的元素（即<code>position</code>属性值不是<code>static</code>的元素），<code>z-index</code> 属性指定：</p>
<ul>
<li>元素在当前堆叠上下文中的堆叠层级。</li>
<li>元素是否创建一个新的本地堆叠上下文。</li>
</ul>
<p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改<strong>css</strong>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background</span>: purple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="./css-relative/css-relative-1-5.png" alt="css margin"></p>
<p>在下面的第一幅图中，设置了<code>margin</code>负值，虽然同时设置了<code>z-index</code>为数值，但是后面的元素依然覆盖了前面的元素，而当增加了定位属性<code>position: relative</code>后，创建了层叠上下文，前面元素的层叠顺序高，虽然同时设置了<code>margin</code>负值，但是后面的元素依然覆盖不了前面的元素。</p>
<h2 id="相对定位-relative-的使用原则-最小化"><a href="#相对定位-relative-的使用原则-最小化" class="headerlink" title="相对定位 relative 的使用原则-最小化"></a>相对定位 relative 的使用原则-最小化</h2><p>虽然<code>relative</code>定位很好用，并且使用的频率很高，但是根据张鑫旭大神总结的布局实践原则，最好基于以下原则为好：</p>
<ul>
<li>尽量避免使用<code>relative</code>，如果要定位某些元素，看能否使用”无依赖的绝对定位”实现；</li>
<li>如果使用场景受限，一定要使用<code>relative</code>，则务必使<code>relative</code>最小化。</li>
</ul>
<p>比如，我们想在某个模块的右上角定位一个图标，如果让你去布局实现的话，你该如何布局呢？十有八九会如下面的方式实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"icon.png"</span> <span class="attr">style</span>=<span class="string">"position: absolute;top:0;right:0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，我们可以采用”relative 的最小化使用原则”的方式实现，其代码如下面的方式实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"icon.png"</span> <span class="attr">style</span>=<span class="string">"position: absolute;top:0;right:0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>position: relative;</code>其实它的特殊性比较少，但是最后的规则尽量要遵循，就是<strong>relative 的最小化使用原则</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.imooc.com/learn/565" target="_blank" rel="noopener">CSS 深入理解之 relative</a><br><a href="https://juejin.im/entry/5b15fdb05188251371242963" target="_blank" rel="noopener">CSS 深入理解之 relative 定位</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">position</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index" target="_blank" rel="noopener">z-index</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>关于this的面试级分析</title>
    <url>/blog/interview-question/javascript/this-priority.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>call、apply 谁的速度更快</li>
<li>隐式绑定、显示绑定、new、箭头函数那个的优先级更高</li>
</ul>
]]></content>
      <categories>
        <category>InterviewQuestion</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>InterviewQuestion</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（五）this的面试题 (未完成)</title>
    <url>/blog/javascript/this/javascript-this-five.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（四）this的面试题</title>
    <url>/blog/javascript/this/javascript-this-four.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（三）自己实现绑定相关方法bind、call、apply、new、Object.create等等</title>
    <url>/blog/javascript/this/javascript-this-three.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上面我们已经了解了多种绑定方式，<strong>默认绑定</strong>、<strong>隐式绑定</strong>、<strong>显示绑定</strong>、<strong>new 绑定、Object.create 绑定</strong>、<strong>箭头函数</strong>。<br>我们本篇文章通过实现多种显示绑定的方法，来加深对<code>this</code>的指向理解和应对开发时不同的场景使用不同的绑定方法。其实还有一部分原因就是在面试的时候，一般来说一面都会笔试或者电话面试都会遇到，让你手写一个<code>call/apply/bind/new/Object.create</code>等等。后面的文章会越来越深入的去理解<code>JavaScript</code>这门语言，等再后面的框架，架构能让我们更好的晋升。</p>
<p>我们首先要实现一个<code>call/apply</code>，因为无论是后面的<code>bind</code>还是<code>new/Object.create</code>都会用到<code>call/apply</code>。</p>
<p>文章大致章节：</p>
<ul>
<li><code>call/apply</code>: <code>call/apply</code>的使用场景，它们两个运行速度，谁更快一点，自己实现<code>call/apply</code></li>
<li><code>bind</code>: <code>bind</code>的使用场景，实现一个<code>bind</code></li>
<li><code>new/Object.create</code>: <code>new/Object.create</code>使用场景，分别实现他们</li>
</ul>
<h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h2><p><code>call()/apply()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<blockquote>
<p>注意：该方法的语法和作用与 <code>apply()</code> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是一个参数列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p>
</blockquote>
<p><code>call/apply</code>是怎么使用，简单使用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFunc = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">testFunc.call(&#123; <span class="attr">name</span>: <span class="string">'call'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;, <span class="string">'call'</span>, <span class="number">20</span>); <span class="comment">// call、20</span></span><br><span class="line">testFunc.apply(&#123; <span class="attr">name</span>: <span class="string">'apply'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;, [<span class="string">'apply'</span>, <span class="number">20</span>]); <span class="comment">// apply 20</span></span><br></pre></td></tr></table></figure>
<h2 id="new-和-Object-create"><a href="#new-和-Object-create" class="headerlink" title="new 和 Object.create"></a>new 和 Object.create</h2><p><code>new 运算符</code>创建一个用户定义的<code>对象类型的实例</code>或具有构造函数的<code>内置对象的实例</code>。会在<code>new</code>的内部改变新生成的<code>对象实例</code>的<code>this</code>，我们可以通过下面的样例看一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> Car(<span class="string">'Eagle'</span>, <span class="string">'Talon TSi'</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car1.make);</span><br><span class="line"><span class="comment">// expected output: "Eagle"</span></span><br><span class="line"></span><br><span class="line">car1.__proto__ === Car.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到在通过<code>new</code>关键字生成的新的对象，它复刻了<code>Car</code>中声明了的多个变量，并且这些变量在<code>Car</code>中都是绑定在<code>Car</code>中的<code>this</code>上。而新生成的<strong>实例对象</strong>同时也拥有所有的属性。我们可以知道<code>new</code>运行的时候会新创建一个对象，这个对象包含所有<code>Car</code>中的<code>this</code>上的对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（二）this的多种绑定方式</title>
    <url>/blog/javascript/this/javascript-this-two.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a href="/blog/javascript/javascript-this-one.html">上一篇文章</a>中我们记录了<code>执行栈</code>、<code>执行上下文</code>、<code>执行上下文生命周期</code>、<code>this的产生</code>等等，在这一篇文章中我们来记录一下<code>this的绑定</code>也就是<code>this</code>的值确定。<br><code>this</code>在<code>创建阶段</code>被创建(确定默认值)，但是在<code>执行阶段</code>会改变<code>this</code>的值。所以一般我们都会说<code>确定this</code>是在<code>执行阶段</code>。</p>
<p>本篇文章章节大致如下：</p>
<ul>
<li>多种绑定<code>this</code>方式</li>
<li>改变<code>this</code>方式 <code>new</code>、<code>Object.create</code></li>
<li>另外三种改变<code>this</code>的方式<code>bind</code>、<code>call</code>、<code>apply</code></li>
<li>异类<code>箭头函数</code></li>
<li>优先级</li>
</ul>
<p>下面我们就慢慢开始一步一步了解<code>this</code>。</p>
<h2 id="多种绑定this方式"><a href="#多种绑定this方式" class="headerlink" title="多种绑定this方式"></a>多种绑定<code>this</code>方式</h2><p>无论是默认的绑定<code>this</code>的规则，还是后面改变<code>this</code>的方法，我们尽量深入的记录，大致目录如下：</p>
<ul>
<li>默认绑定</li>
<li>显示绑定</li>
<li>隐式绑定</li>
<li>bind、call、apply 绑定</li>
<li>new 绑定、Object.create()绑定</li>
<li>箭头函数</li>
</ul>
<p>我们都知道<code>this</code>的值是在运行时绑定的，并且谁调用它，它指向谁。下面我们就开始一步一步的了解<code>this</code>绑定的细节和实现。</p>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p><strong>默认绑定</strong>其实就是在<strong>全局中声明函数</strong>，并且在<strong>全局中调用函数</strong>，这样它不会受到任何调用对象和修饰符的干扰。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defalutsFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">defalutsFunc(); <span class="comment">// windows</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defalutsFuncTwo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// use strict</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">defalutsFuncTwo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>在普通模式下，如果我们是在浏览器端运行代码，<code>this</code>指向<code>window</code>。它在<strong>严格模式</strong>下<code>this</code>会是<code>undefined</code>。</p>
<p>默认绑定多种方式：</p>
<ul>
<li>全局调用函数</li>
<li>IIFE(自执行函数)</li>
<li>匿名函数</li>
</ul>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p><strong>隐式绑定</strong>，其实就是当前调用函数的<code>this</code>会指向当前调用该函数的执行上下文。隐式绑定<code>this</code>是不可靠的，他会因为调用者的不同而不同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scopeObj = &#123;</span><br><span class="line">  name: <span class="string">'scopeObj'</span>,</span><br><span class="line">  scopeFunc: globalFunc</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'globalFunc'</span>;</span><br><span class="line"></span><br><span class="line">scopeObj.scopeFunc(); <span class="comment">// scopeObj</span></span><br><span class="line">globalFunc(); <span class="comment">// globalFunc</span></span><br></pre></td></tr></table></figure>
<p>在<code>scopeObj.scopeFunc()</code>我们其实是在<code>scopeObj</code>这个<code>作用域</code>中调用<code>scopeFunc</code>，这样<code>scopeFunc</code>的<code>this</code>指向<code>scopeObj</code>创建的上下文。 但是<strong>隐式绑定</strong>在传递过程中会丢失<code>this</code>，其实还是看调用它的执行上下文是那个，它的<code>this</code>就会指向当前<strong>执行上下文</strong>。修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcObj = scopeObj.scopeFunc;</span><br><span class="line">funcObj(); <span class="comment">// globalFunc</span></span><br></pre></td></tr></table></figure>
<p>我们又把<code>scopeObj.scopeFunc</code>赋值给了一个普通变量<code>funcObj</code>，在全局作用域中调用了赋值的这个<code>funcObj</code>，所以<code>funcObj</code>的 this 指向了<code>全局</code>的执行上下文。</p>
<blockquote>
<p>其实<code>参数</code>也是一样的效果。</p>
</blockquote>
<h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>因为隐式绑定的丢失问题，所以有了后面的显示绑定<code>call</code>、<code>apply</code>、<code>bind</code>等等的方式。</p>
<p>我们可以通过<code>call</code>、<code>apply</code>它们可以显示的改变<code>this</code>的绑定.</p>
<ul>
<li><code>call</code>: <code>fun.call(thisArg, arg1, arg2, ...)</code>第一个参数<code>this</code>要绑定的值，后面多个参数是要传入方法的参数。</li>
<li><code>apply</code>: <code>func.apply(thisArg, [argsArray])</code> 第一个参数<code>this</code>要绑定的值，可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 <code>func</code> 函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFunc</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scopeObj = &#123;</span><br><span class="line">  name: <span class="string">'scopeObj'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'globalFunc'</span>;</span><br><span class="line"></span><br><span class="line">globalFunc.call(scopeObj, <span class="number">18</span>); <span class="comment">// scopeObj, 18</span></span><br><span class="line">globalFunc.apply(scopeObj, [<span class="number">18</span>]); <span class="comment">// scopeObj, 18</span></span><br><span class="line"></span><br><span class="line">globalFunc(<span class="number">18</span>); <span class="comment">// globalFunc, 18</span></span><br></pre></td></tr></table></figure>
<p>但是即使通过<code>call</code>or<code>apply</code>改变的<code>this</code>值也是会丢失的，在传递的过程中，其实通过显示绑定也并不能保证我们的<code>this</code>一直是绑定的一个值。</p>
<p>我们可以通过在外层包裹一层函数来绑定<code>this</code>，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalObj = &#123;</span><br><span class="line">  name: <span class="string">'globalObj'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleBind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = simpleBind(scopeFunc, globalObj);</span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>); <span class="comment">// globalObj Arguments [Arguments(1), callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line"></span><br><span class="line">func.call(<span class="literal">null</span>, <span class="number">3</span>); <span class="comment">// globalObj Arguments [Arguments(1), callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure>
<p>可以看到我们通过<code>simpleBind</code>中返回一个匿名函数，这样通过<code>call</code>或<code>apply</code>它也只能改变外部匿名函数的<code>this</code>，在<strong>匿名函数内部</strong>我们通过<code>fn.call(obj)</code>给方法默认绑定一个<code>this</code>，这个只是一个简单的<code>bind</code>实现。</p>
<p>也可以直接通过<code>Function.prototype.bind</code>来实现，<code>bind</code>返回一个硬绑定的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeFunc</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> globalObj = &#123;</span><br><span class="line">  name: <span class="string">'globalObj'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = scopeFunc.bind(globalObj);</span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>); <span class="comment">// globalObj 3</span></span><br><span class="line"></span><br><span class="line">func.call(<span class="literal">null</span>, <span class="number">3</span>); <span class="comment">// globalObj 3</span></span><br></pre></td></tr></table></figure>
<p>还有一种方式就是高阶函数，我们传入一下函数来获取当前执行上下文，比如<code>map</code>、<code>forEach</code>等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aData = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'firstName'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'lastName'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">aData.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>它的内部也是使用了<code>call</code>或者<code>apply</code>来改变传入函数的<code>this</code>。如果有兴趣去看一下另一篇博客<a href="https://juejin.im/post/5d786452e51d4561eb0b2719" target="_blank" rel="noopener">Array 常用的方法和实现 reduce、map、filter、forEach</a>来深入了解一下。</p>
<h3 id="new-绑定、Object-create-绑定"><a href="#new-绑定、Object-create-绑定" class="headerlink" title="new 绑定、Object.create()绑定"></a>new 绑定、Object.create()绑定</h3><p><code>new运算符</code>和<code>Object.create()</code>方法也是可以改变<code>this</code>的指向的。<br>首先我们要理解<code>new运算符</code>它具体做了什么操作，大致过程如下：</p>
<ul>
<li>创建一个空的简单 JavaScript 对象（即<code>{}</code>）；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>
<li>将步骤 1 新创建的对象作为<code>this</code>的上下文 ；</li>
<li>如果该函数没有返回对象，则返回<code>this</code>。</li>
</ul>
<p>可以看到在<code>new 运算符</code>中有修改过<code>this</code>的指向，下面我们通过一个示例代码来了解一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'globalFunc'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exampleFunc = <span class="keyword">new</span> globalFunc();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(exampleFunc); <span class="comment">// globalFunc &#123;name: "globalFunc"&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们通过<code>new 运算符</code>调用<code>globalFunc</code>时，我们可以看到<code>globalFunc</code>中的<code>name</code>在<code>exampleFunc</code>中也可以访问到相同的<code>name</code>。</p>
<p>其实我们也可以通过<code>Object.create()</code>来也可以实现一样的效果，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'globalFunc'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exampleFunc = <span class="built_in">Object</span>.create(globalFunc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(exampleFunc); <span class="comment">// globalFunc &#123;name: "globalFunc"&#125;</span></span><br></pre></td></tr></table></figure>
<p>其实<code>Object.create</code>内部和 new 有点类似，但是<code>Object.create</code>它调用的是<code>new Func()</code>用于生成一个对象实例。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>箭头函数外层没有普通函数，严格模式和非严格模式下它的 this 都会指向 window(全局对象)</strong><br><strong>this 对象的指向是可变的，但是在箭头函数中，它是固定的。</strong></p>
<p>普通函数与箭头函数的对比如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对比</th>
<th style="text-align:center">普通函数</th>
<th style="text-align:center">箭头函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>this</code>指向规则</td>
<td style="text-align:center"><code>this</code>总是指向调用它的那个对象</td>
<td style="text-align:center">1.所有箭头函数本身没有<code>this</code> <br>2.箭头函数的 this 在定义的时候捕获自外层第一个普通函数的<code>this</code> <br> 3.如果箭头函数外层没有普通函数,严格模式和非严格模式下它的<code>this</code>都会指向<code>window</code>(全局对象)</td>
</tr>
<tr>
<td style="text-align:center">有无<code>prototype</code></td>
<td style="text-align:center">有</td>
<td style="text-align:center">箭头函数没有<font color="#ff502c">prototype</font>(原型)</td>
</tr>
<tr>
<td style="text-align:center">可否<code>new</code></td>
<td style="text-align:center">可以</td>
<td style="text-align:center">箭头函数作为匿名函数,是不能作为构造函数的(因为箭头函数没有<code>constructor</code>),不能使用 new,不然会报错</td>
</tr>
<tr>
<td style="text-align:center">有无<code>arguments</code></td>
<td style="text-align:center">有</td>
<td style="text-align:center">1.箭头函数的<code>this</code>指向全局,使用会报未声明的错误 <br> 2.箭头函数的<code>this</code>指向普通函数时,它的<font color="#ff502c">argumens</font>继承于改普通函数</td>
</tr>
<tr>
<td style="text-align:center">可否<code>new</code></td>
<td style="text-align:center">可以</td>
<td style="text-align:center">箭头函数作为匿名函数,是不能作为构造函数的(因为箭头函数没有<code>constructor</code>),不能使用 new,不然会报错</td>
</tr>
<tr>
<td style="text-align:center">可否改变<code>this</code>指向</td>
<td style="text-align:center">可以通过<code>call、apply、bind</code>改变<code>this</code>的指向</td>
<td style="text-align:center">箭头函数本身的<code>this</code>指向不能改变,但是可以修改它要捕获的对象的<code>this</code></td>
</tr>
</tbody>
</table>
<p>如果有兴趣的话可以去看另一篇<a href="/blog/es6/es6-arrow-functions.html">arrow-functions（箭头函数）和普通的函数的区别 this（二）</a></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="new-注意事项"><a href="#new-注意事项" class="headerlink" title="new 注意事项"></a>new 注意事项</h3><p><code>new</code>可以很方便构造调用一个函数并且声称一个实例，但是如果我们使用不太小心的话也会带来很多不必要的麻烦。</p>
<p><strong>忘记写 new</strong>运算符，那样我们就得不到我们想要的结果，如果实在全局环境中，那么<strong>函数</strong>的<code>this</code>会绑定到全局。如果实在<strong>严格模式</strong><code>this</code>会绑定为<code>undefined</code>。</p>
<h3 id="bind-call、bind-注意事项"><a href="#bind-call、bind-注意事项" class="headerlink" title="bind/call、bind 注意事项"></a>bind/call、bind 注意事项</h3><p>把<code>null</code>或者<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call、apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认规则。</p>
<h3 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h3><p>硬绑定可以把<code>this</code>强制绑定到指定的对象（<code>new除外</code>），防止函数调用应用<strong>默认绑定规则</strong>。但是会降低函数的灵活性，使用<strong>硬绑定之后就无法使用隐式绑定或者显式绑定来修改</strong><code>this</code>。</p>
<p>如果给<strong>默认绑定指定一个全局对象和 undefined 以外的值</strong>，那就可以实现和硬绑定相同的效果，同时<strong>保留隐式绑定或者显示绑定修改 this 的能力</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> funStack = !<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global) ? obj : <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(funStack, currArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">    bound.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：软绑定版本的<code>foo()</code>可以手动将<code>this</code>绑定到<code>obj2</code>或者<code>obj3</code>上，但如果应用默认绑定，则会将<code>this</code>绑定到<code>obj</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'obj'</span> &#125;,</span><br><span class="line">  obj2 = &#123; <span class="attr">name</span>: <span class="string">'obj2'</span> &#125;,</span><br><span class="line">  obj3 = &#123; <span class="attr">name</span>: <span class="string">'obj3'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj</span></span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.softBind(obj);</span><br><span class="line">fooOBJ(); <span class="comment">// name: obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定规则</span></span><br><span class="line">obj2.foo = foo.softBind(obj);</span><br><span class="line">obj2.foo(); <span class="comment">// name: obj2 &lt;---- 看！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式绑定规则</span></span><br><span class="line">fooOBJ.call(obj3); <span class="comment">// name: obj3 &lt;---- 看！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定丢失，应用软绑定</span></span><br><span class="line">setTimeout(obj2.foo, <span class="number">10</span>); <span class="comment">// name: obj</span></span><br></pre></td></tr></table></figure>
<h2 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h2><p>我们对比<code>显示绑定</code>、<code>隐式绑定</code>、<code>new 绑定</code>、<code>默认绑定</code>，不包含<code>箭头函数</code>的对比，因为<code>箭头函数</code>它本身没有<code>this</code>，它会从它外层的普通函数或者全局获取。</p>
<p>大致对比过程：</p>
<ul>
<li><code>显示绑定</code>与<code>隐式绑定</code>对比</li>
<li><code>默认绑定</code>与<code>隐式绑定</code>对比</li>
<li><code>new 绑定</code>与<code>显示绑定</code>对比</li>
</ul>
<p>我们就通过代码一步一步的记录。</p>
<h3 id="显示绑定与隐式绑定"><a href="#显示绑定与隐式绑定" class="headerlink" title="显示绑定与隐式绑定"></a><code>显示绑定</code>与<code>隐式绑定</code></h3><p>我们直接通过代码来对比。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yinObj = &#123;</span><br><span class="line">  name: <span class="string">'yinObj'</span>,</span><br><span class="line">  func: test</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 首先我们通过隐式绑定</span></span><br><span class="line">yinObj.func(); <span class="comment">// yinObj</span></span><br><span class="line"><span class="comment">// 二次显示绑定</span></span><br><span class="line">yinObj.func.call(&#123; <span class="attr">name</span>: <span class="string">'xianObj'</span> &#125;); <span class="comment">// xianObj</span></span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们知道了<code>显示绑定 &gt; 隐式绑定</code>。</p>
<h3 id="默认绑定与隐式绑定"><a href="#默认绑定与隐式绑定" class="headerlink" title="默认绑定与隐式绑定"></a><code>默认绑定</code>与<code>隐式绑定</code></h3><p><code>默认绑定</code>与<code>隐式绑定</code>对比直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'GlobalName'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yinObj = &#123;</span><br><span class="line">  name: <span class="string">'yinObj'</span>,</span><br><span class="line">  func: test</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 默认绑定</span></span><br><span class="line">test(); <span class="comment">// GlobalName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先我们通过隐式绑定</span></span><br><span class="line">yinObj.func(); <span class="comment">// yinObj</span></span><br></pre></td></tr></table></figure>
<p>我们首相声明一个函数<code>test</code>，然后把这个函数赋值给一个对象<code>yinObj</code>的<code>func</code>属性，然后我们分别在全局和对象中调用<code>test</code>函数，在全局中调用<code>test</code>函数得出的结果是<code>GlobalName</code>，<code>yinObj.func()</code>得出的结果是<code>yinObj</code>。可以得出结果<code>隐式绑定&gt;默认绑定</code>。</p>
<h3 id="new-绑定与显示绑定"><a href="#new-绑定与显示绑定" class="headerlink" title="new 绑定与显示绑定"></a><code>new 绑定</code>与<code>显示绑定</code></h3><p>我们通过代码看<code>new 绑定</code>与<code>显示绑定</code>他们之间的优先级。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> bound = foo.bind(obj1);</span><br><span class="line"><span class="comment">// 返回一个新函数bound，这个新函数内的this指向了obj1</span></span><br><span class="line">bar(<span class="string">'bind name'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// bind name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObject = <span class="keyword">new</span> bar(<span class="string">'new Name'</span>);</span><br><span class="line"><span class="comment">// 调用new 操作符后，bar函数的this指向了返回的新实例baz</span></span><br><span class="line">newObject.name; <span class="comment">// new Name</span></span><br><span class="line">obj1.name; <span class="comment">// bind name</span></span><br></pre></td></tr></table></figure>
<p>在 <code>JavaScript</code>内部，会判断硬绑定函数是否是被 <code>new</code> 调用，如果是的话就会使用新创建的 <code>this</code> 替换硬绑定的 <code>this</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>this</code>在<code>创建阶段</code>被创建(确定默认值)，但是在<code>执行阶段</code>会改变<code>this</code>的值。所以一般我们都会说<code>确定this</code>是在<code>执行阶段</code>。</p>
<p>在本篇文章中我们知道了多种绑定方式如下：</p>
<ul>
<li><strong>默认绑定</strong>：多种绑定方式<strong>全局调用函数</strong>、<strong>IIFE(自执行函数)</strong>、<strong>匿名函数</strong></li>
<li><strong>显示绑定</strong>：可以通过<code>call</code>、<code>apply</code>、<code>bind</code>来显示改变<code>this</code>绑定。</li>
<li><strong>隐式绑定</strong>：通过<strong>赋值的方式</strong>实现隐式绑定。但是很容易丢失。</li>
<li><strong>bind、call、apply 绑定</strong>：和显示绑定相同。</li>
<li><strong>new 绑定、Object.create()绑定</strong>：和显示绑定相同。</li>
<li><strong>箭头函数</strong>: <code>ES6</code>的实现，它本身没有<code>this</code>，它的<code>this</code>从<strong>外层普通函数</strong>或者<strong>全局</strong>获取。</li>
</ul>
<p>多种绑定方式的优先级：<code>new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</code></p>
<p>下一篇文章我们自己来实现多种绑定放法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/LCdthN5snKZvh_5lFDIU3g" target="_blank" rel="noopener">如何理解 javascript 中 this 的绑定？</a><br><a href="https://muyiy.cn/blog/3/3.1.html#_1-%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE" target="_blank" rel="noopener">JavaScript 深入之史上最全–5 种 this 绑定全面解析</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this（一）this是什么？怎么产生的？什么是执行上下文？</title>
    <url>/blog/javascript/this/javascript-this-one.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>this</code>如论是在平常开发中，还是在面试时都是经常会听到，所以有了这篇文章来更系统的记录<code>this</code>从产生到使用。到最后会有一整篇的面试题来介绍<code>this</code>。</p>
<p><code>this</code>是在什么时候产生的呢？<code>this</code>的作用是什么，首先要知道一个概念就是<code>执行上下文</code>。要了解清楚<code>执行上下文</code>，又要了解<code>&quot;调用栈&quot;</code>，要了解调用栈，又要了解<code>作用域</code>中的<code>动态作用域</code>。其实后面还有<code>event loop</code>、<code>线程执行</code>等等，所以学无止境，回头是岸。</p>
<p>还是回到<code>&quot;调用栈&quot;</code>和<code>执行上下文</code>，首先了解这两个概念就能知道<code>this</code>是什么时候产生的，<code>this</code>是什么。</p>
<p>首先介绍几个概念：</p>
<ul>
<li><code>ECS</code>: 执行环境栈，<strong>Execution Context Stack</strong>。</li>
<li><code>EC</code>: 函数执行环境（或执行上下文），<strong>Execution Context</strong>。</li>
<li><code>VO</code>: 变量对象，<strong>variable Object</strong>。</li>
<li><code>AO</code>: 活动对象，<strong>Active Object</strong>。</li>
<li><code>S</code>: 作用域，<strong>Scope</strong>。</li>
<li><code>SC</code>: 作用域链，<strong>Scope Chain</strong>。</li>
</ul>
<p>首先<code>执行栈</code>中包含<code>执行上下文</code>，<code>执行上下文</code>中包含有<code>活动变量</code>、<code>变量对象</code>、<code>作用域</code>，一层一层的作用域又会形成<code>作用域链</code>。它们之间都是有关联的。</p>
<h2 id="“调用栈”"><a href="#“调用栈”" class="headerlink" title="“调用栈”"></a>“调用栈”</h2><p>什么是<code>调用栈</code>其实也是常说的<code>执行栈</code>，它其实应该叫做<code>执行上下文堆栈</code>会更准确一些。我们还是把它简称为<code>执行栈</code>。<br>因为 JavaScript 解释器被实现为单线程。这意味着<code>JavaScript 引擎</code>只能同时执行一件事，其它需要执行的事情会被放到一个栈里面储存，这个栈就叫做<code>执行栈</code>。<br><code>执行栈</code>是一种拥有<code>LIFO（后进先出）</code>数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p>
<h3 id="执行栈执行过程"><a href="#执行栈执行过程" class="headerlink" title="执行栈执行过程"></a>执行栈执行过程</h3><p>当 <code>JavaScript 引擎</code>第一次遇到你的脚本时，它会创建一个<code>全局</code>的<code>执行上下文</code>并且压入当前<code>执行栈</code>。每当引擎遇到一个函数调用，它会为该函数创建一个<code>新的执行上下文并</code>压入栈的<code>顶部</code>。</p>
<p>引擎会执行那些<code>执行上下文位于栈顶的函数</code>。当该函数执行结束时，执行上下文<code>从栈中弹出</code>，控制流程到达当前栈中的下一个上下文。</p>
<p>首先我们看一张比较经典的图。</p>
<p><img src="./javascript-this-one/javascript-this-1-1.jpg" alt="this-one"></p>
<p>一个简单的实例，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'global name'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'inside first function'</span>);</span><br><span class="line">  second();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'inside second function'</span>);</span><br><span class="line">  three();</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'inside global Execution Context'</span>);</span><br></pre></td></tr></table></figure>
<p>执行效果如下图所示：</p>
<p><img src="./javascript-this-one/javascript-this-1-2.png" alt="this-one"></p>
<p>当上述代码在浏览器加载时，<code>JavaScript 引擎</code>创建了一个<code>全局执行上下文</code>并把它压入当前<code>执行栈</code>。当遇到 <code>first()</code> 函数调用时，<code>JavaScript 引擎</code>为该函数<code>创建</code>一个新的<code>执行上下文</code>并把它压入<code>当前执行栈</code>的顶部。</p>
<p>当从 <code>first()</code> 函数内部调用 <code>second()</code> 函数时，<code>JavaScript 引擎</code>为 <code>second()</code> 函数创建了一个<code>新的执行上下文</code>并把它压入当前<code>执行栈的顶部</code>。当 <code>second()</code> 函数执行完毕，它的<code>执行上下文</code>会从当前栈<code>弹出</code>，并且控制流程到达下一个<code>执行上下文</code>，即 <code>first()</code> 函数的执行上下文。<br>当 <code>first()</code> 执行完毕，它的执行上下文从栈<code>弹出</code>，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中<code>移除</code>全局执行上下文。</p>
<p>有 5 个需要记住的关键点，关于<strong>执行栈（调用栈）</strong>：</p>
<ul>
<li>单线程。</li>
<li>同步执行。</li>
<li>一个全局上下文。</li>
<li>无限制函数上下文。</li>
<li>每次函数被调用创建新的执行上下文，包括调用自己。</li>
</ul>
<p><strong>一个在线实例</strong></p>
<p>因为代码太多了这里就不展示了，gif 也比较大，所以只放了一个外国友人的在线实例。有兴趣的可以去看一下。</p>
<p>在线代码体验<a href="https://codepen.io/njmcode/pen/dMPmGq" target="_blank" rel="noopener">执行栈执行过程</a>，如果访问比较慢可以看<a href="https://github.com/Braveheartforyou/Blog-Static/tree/master/callStack" target="_blank" rel="noopener">执行栈执行过程 demo</a>把代码下载到本地运行查看。</p>
<h2 id="执行上下文周期"><a href="#执行上下文周期" class="headerlink" title="执行上下文周期"></a>执行上下文周期</h2><p>在上面执行栈整个过程中，我们知道每次调用函数时都会创建一个<strong>执行上下文</strong>，现在我们要了解在<code>JavaScript 引擎</code>内部是怎么创建<strong>执行上下文</strong>.<br>在创建完成之后会执行上下文，当执行完成之后会回收当前上下文。</p>
<p>创建执行上下文大致分为三步：</p>
<ul>
<li>创建阶段</li>
<li>执行阶段</li>
<li>回收阶段</li>
</ul>
<h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p><strong>创建阶段</strong></p>
<p>在每次执行函数时都会走<code>创建执行上下文</code>，创建上下文会经历下面这几个事件：</p>
<ul>
<li>创建<code>作用域</code>并且形成<code>作用域链（Scope Chain）</code>：定义了变量的可访问范围，控制变量的生命周期。</li>
<li>创建<code>变量(variables)</code>、<code>函数(functions)</code>、<code>参数(arguments)</code>： 变量和函数在创建时都会存在<code>Hosting(变量提升)</code>，就是会提前到最前面声明，但是不赋值。</li>
<li>确定<code>this</code>的值：<code>this</code>的复杂之处就在于它不是声明时就能确定，一般情况来说它是调用时确定的。(箭头函数除外)</li>
</ul>
<p>我看的有挺多文章的创建的整体顺序是不太一样的，我认为他的顺序是当前我文章中的顺序。会先创建<code>作用域</code>再会创建<code>变量</code>，最后确定<code>this</code>的值。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">executionContextObj = &#123;</span><br><span class="line">    <span class="string">'scopeChain'</span>: &#123;<span class="comment">// 作用域链&#125;,</span></span><br><span class="line">    <span class="string">'variables'</span>: &#123;<span class="comment">// 变量、函数、参数&#125;,</span></span><br><span class="line">    <span class="string">'this'</span>: &#123;<span class="comment">// 运行时才能确定&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在我们知道什么是<code>执行上下文</code>，我们也知道<code>this</code>就是<code>执行上下文</code>创建中产生的。但是它的值并不能在创建的时候确定，而是要到调用时才知道。</p>
<blockquote>
<p>其实作用域的本质是一套规则，它定义了变量的可访问范围，控制变量的可见性和生命周期。</p>
</blockquote>
<h3 id="创建作用域链"><a href="#创建作用域链" class="headerlink" title="创建作用域链"></a>创建作用域链</h3><p>作用域链又可以叫做<code>词法环境</code>，<a href="http://ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">官方的 ES6</a> 文档把词法环境定义为。</p>
<blockquote>
<p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。</p>
</blockquote>
<p>简单来说词法环境是一种持有<strong>标识符—变量映射</strong>的结构。（这里的<strong>标识符</strong>指的是变量/函数的名字，而<strong>变量</strong>是对实际对象[包含函数类型对象]或原始数据的引用）。</p>
<p>词法环境有两种类型：</p>
<ul>
<li><code>全局环境（在全局执行上下文中）</code>: 是<code>没有</code>外部环境引用的<code>词法环境</code>。全局环境的外部环境引用是 <code>null</code>。它的<code>this</code>的值指向全局对象。</li>
<li><code>函数环境</code>: 函数内部用户定义的变量存储在<code>环境记录器</code>中。并且<code>引用的外部环境</code>可能是全局环境，或者任何包含此内部函数的外部函数。</li>
</ul>
<p>在<code>函数环境</code>中，有两个概念来保证它既可以访问管理自己内部的变量等等，又可以访问外部的变量，下面我们就来介绍这两个概念：</p>
<ul>
<li><strong>环境记录器</strong>：是存储变量和函数声明的实际位置。</li>
<li><strong>外部环境的引用</strong>：它可以访问其父级词法环境（作用域）。</li>
</ul>
<p><strong>环境记录器</strong>又分为两种：</p>
<ul>
<li><strong>声明式环境记录器</strong>：存储变量、函数和参数<code>（在函数环境中）</code>。</li>
<li><strong>对象环境记录器</strong>：用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系 <code>(在全局环境中)</code>。</li>
</ul>
<p>总结一下<code>词法环境</code>分为两种<strong>全局环境</strong>、<strong>函数环境</strong>，<code>函数环境</code>又包含两个概念<strong>环境记录器</strong>、<strong>引用的外部环境</strong>，而<code>环境记录器</code>又分为两种<strong>声明式环境记录器</strong>、<strong>对象环境记录器</strong>。来张图解释一下吧。</p>
<p><img src="./javascript-this-one/javascript-this-1-3.png" alt="this-one"></p>
<p><strong>注意</strong></p>
<ul>
<li>对于<code>函数环境</code>，<code>声明式环境记录器</code>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <code>length</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">        Type: <span class="string">"Object"</span>,</span><br><span class="line">        <span class="comment">// 在这里绑定标识符</span></span><br><span class="line">        &#125;</span><br><span class="line">        outer: <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">FunctionExectionContext = &#123;</span></span><br><span class="line"><span class="xml">    LexicalEnvironment: &#123;</span></span><br><span class="line"><span class="xml">        EnvironmentRecord: &#123;</span></span><br><span class="line"><span class="xml">        Type: "Declarative",</span></span><br><span class="line"><span class="xml">        // 在这里绑定标识符</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line">        outer: &lt;Global or outer function environment reference&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h3><p>在<code>创建变量</code>之前首先要<code>创建变量环境</code>，什么是<code>变量环境</code>呢？</p>
<p><code>变量环境</code>也是一个词法环境，它也有<code>环境记录器</code>用来记录<code>变量声明语句</code>在执行上下文中创建的绑定关系。</p>
<p><code>变量环境</code>和<code>词法环境</code>的区别在于<code>变量环境</code>被用来<code>存储函数</code>声明和<code>变量（let 和 const）绑定</code>，而<code>词法环境</code>只用来<code>存储 var 变量绑定</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>执行上下文看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">    ThisBinding: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    LexicalEnvironment: &#123;</span></span><br><span class="line"><span class="xml">        EnvironmentRecord: &#123;</span></span><br><span class="line"><span class="xml">        Type: "Object",</span></span><br><span class="line"><span class="xml">        // 在这里绑定标识符</span></span><br><span class="line"><span class="xml">        a: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,</span></span><br><span class="line"><span class="xml">        b: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,</span></span><br><span class="line"><span class="xml">        multiply: <span class="tag">&lt; <span class="attr">func</span> &gt;</span></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line">        outer: &lt;null&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">        Type: "Object",</span><br><span class="line">        // 在这里绑定标识符</span><br><span class="line">        c: undefined,</span><br><span class="line">        &#125;</span><br><span class="line">        outer: &lt;null&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">    ThisBinding: &lt;Global Object&gt;,</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">        Type: "Declarative",</span><br><span class="line">        // 在这里绑定标识符</span><br><span class="line">        Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">        Type: "Declarative",</span><br><span class="line">        // 在这里绑定标识符</span><br><span class="line">        g: undefined</span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有遇到调用函数 <code>multiply</code> 时，<code>函数执行上下文</code>才会被创建。</li>
</ul>
<p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。<br>这是因为在创建阶段时，引擎检查代码找出<code>变量和函数声明</code>，虽然<code>函数声明完全存储在环境</code>中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p>
<p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大致创建过程如下：</p>
<ul>
<li>初始化作用域链：</li>
<li>创建变量对象：<ul>
<li>创建 arguments 对象，检查上下文，初始化参数名称和值并创建引用的复制。</li>
<li>扫描上下文的函数声明：<ul>
<li>为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。</li>
<li>如果函数的名字已经存在，引用指针将被重写。</li>
</ul>
</li>
<li>扫面上下文的变量声明：<ul>
<li>为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为 undefined</li>
<li>如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。</li>
</ul>
</li>
</ul>
</li>
<li>求出上下文内部“this”的值。</li>
</ul>
<p><code>词法环境</code>分为两种<strong>全局环境</strong>、<strong>函数环境</strong>，<code>函数环境</code>又包含两个概念<strong>环境记录器</strong>、<strong>引用的外部环境</strong>，而<code>环境记录器</code>又分为两种<strong>声明式环境记录器</strong>、<strong>对象环境记录器</strong>。</p>
<p>在上面只是简单的讲解了<code>变量提升</code>，如果有兴趣再多了解一下<code>变量声明提升、函数声明提升</code>可以去看我的另一篇文章<a href="/blog/javascript/scope/hoisting.html">JavaScript 中的变量提升</a>，里面又很多比较好的实例。</p>
<h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><p>在上面我们介绍了<code>创建阶段</code>，现在主要介绍一下<code>执行阶段</code>。<br><strong>激活/代码执行阶段</strong></p>
<ul>
<li>在<strong>当前上下文上运行/解释函数代码</strong>，并随着代码一行行执行指派变量的值。</li>
</ul>
<p>一个<strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name;</span><br><span class="line"><span class="keyword">const</span> age;</span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'everybody'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastName = <span class="string">'lastName'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testTwo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'testArgs'</span>);</span><br></pre></td></tr></table></figure>
<p><code>创建阶段</code>我们用伪代码来表示一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局执行上下文</span></span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    scopeChain: &#123;...&#125;, <span class="comment">// 只存在环境记录器（它的记录器叫做对象环境记录器） 不存在外部环境的引用</span></span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        <span class="comment">// name 未初始化</span></span><br><span class="line">        <span class="comment">// age 未初始化</span></span><br><span class="line">        firstName: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>: &#123;....&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数执行上下文</span></span><br><span class="line">testExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123;...&#125;, <span class="comment">// 存在环境记录器（它的记录器叫做声明式环境记录器） 不存在外部环境的引用</span></span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        args: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="string">'testArgs'</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        args: <span class="string">'testArgs'</span>,</span><br><span class="line">        lastName: <span class="literal">undefined</span>,</span><br><span class="line">        testTwo: pointer to <span class="function"><span class="keyword">function</span> <span class="title">testTwo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>执行阶段</code>我们用伪代码描述一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局执行上下文</span></span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    scopeChain: &#123;...&#125;, <span class="comment">// 只存在环境记录器（它的记录器叫做对象环境记录器） 不存在外部环境的引用</span></span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        name: <span class="literal">undefined</span>, <span class="comment">// 初始化 没有找到变量的值，它被复制为 undefined</span></span><br><span class="line">        age: <span class="literal">undefined</span>, <span class="comment">// 初始化 没有找到变量的值，它被复制为 undefined</span></span><br><span class="line">        firstName: <span class="string">'everybody'</span> <span class="comment">// 赋值为 everybody</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>: &#123;....&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数执行上下文</span></span><br><span class="line">testExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123;...&#125;, <span class="comment">// 存在环境记录器（它的记录器叫做声明式环境记录器） 不存在外部环境的引用</span></span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        args: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="string">'testArgs'</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        args: <span class="string">'testArgs'</span>,</span><br><span class="line">        lastName: <span class="string">'lastName'</span>, <span class="comment">// 赋值为lastName</span></span><br><span class="line">        testTwo: pointer to <span class="function"><span class="keyword">function</span> <span class="title">testTwo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">    <span class="title">this</span>: </span>&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>let/const</code>是在<code>执行阶段</code>才初始化的，初始化完成就会被赋值。<br><code>arguments</code>是在<code>创建阶段</code>就被创建和赋值。<br><code>functions</code>也是在<code>创建阶段</code>就被创建和赋值。<br><code>variables</code>是在<code>创建阶段</code>被创建，但是没有赋值，在<code>执行阶段</code>被赋值。</p>
<p><strong>functions 赋值式</strong>只会声明不会赋值。</p>
<blockquote>
<p>如果 <code>JavaScript 引擎</code>不能在源码中声明的实际位置找到 <code>let 变量的值</code>，它会被赋值为 <code>undefined</code>。</p>
</blockquote>
<h2 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h2><p>就是在函数执行完成会把当前的执行上下文回收掉，但是全局执行上下文是不会被回收的，只有关闭当前线程/进程才会把全局执行上下文清楚掉。</p>
<h2 id="总结全文"><a href="#总结全文" class="headerlink" title="总结全文"></a>总结全文</h2><p>到现在我们知道<code>this</code>是<code>执行上下文</code>中的一部分，它产生在<code>创建阶段</code>(绑定默认值)，<code>改变this</code>在发生在<code>执行阶段</code>.<br>我们也知道什么是<code>执行栈</code>它是怎么运转的，也知道了<code>执行上下文</code>的生命周期的细节，所以本篇文章到此为止。<br>如果有哪里有问题欢迎留言，谢谢！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">What is the Execution Context &amp; Stack in JavaScript?</a><br><a href="https://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">了解 JavaScript 的执行上下文</a><br><a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="noopener">[译] 理解 JavaScript 中的执行上下文和执行栈</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （六）闭包面试题</title>
    <url>/blog/javascript/scope/javascript-clouser-three.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （五）作用域面试题</title>
    <url>/blog/javascript/scope/javascript-scope-three.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （四）闭包的作用</title>
    <url>/blog/javascript/scope/javascript-clouser-two.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （三）</title>
    <url>/blog/javascript/scope/javascript-clouser-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （二）理解作用域链</title>
    <url>/blog/javascript/scope/javascript-scope-two.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域和闭包 （一）理解作用域</title>
    <url>/blog/javascript/scope/javascript-scope-one.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins配置前端不同环境打包不同的文件</title>
    <url>/blog/vue/cli/jenkins-fornt.html</url>
    <content><![CDATA[<h2 id="vue-cli-配置"><a href="#vue-cli-配置" class="headerlink" title="vue-cli 配置"></a>vue-cli 配置</h2><p>vue-cli <code>2.x</code>版本，因为自己不太习惯 3.x 的这种配置，很多配置不容易写进去，同时 3.x 也在不断的修 bug,所以没有升级.<br>最新代码在<a href="https://github.com/Braveheartforyou/vue-cli-jenkins.git" target="_blank" rel="noopener">github</a>，这个项目基本上是一些打包优化，缓存，等等并不是后台模版，你可以在这个项目上再搭建自己的东西，直接只是提供了一个项目比较基础的一些东西。</p>
<h2 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h2><p>在<code>package.json</code>文件中的<code>scripts</code>添加三个字段:</p>
<ul>
<li>“build:sit”: “cross-env API_ROOT=sit node build/build.js”,</li>
<li>“build:uat”: “cross-env API_ROOT=uat node build/build.js”,</li>
<li>“build:prod”: “cross-env API_ROOT=prod node build/build.js”</li>
</ul>
<p>其中<code>cross-env</code>包是为了兼容 liunx 和 window 不同系统都可以把 <font color="green">API_ROOT<code>参数传进进程中. ![jenkins_vue_cli](./jenkins-fornt/vue_build/jenkins_vue_cli.png) 然后配置</code>config<code>文件夹下的&lt;font color=&quot;green&quot;&gt;dev.env.js、prod.env.js</code></font></p>
<h3 id="dev-env-js"><a href="#dev-env-js" class="headerlink" title="dev.env.js"></a>dev.env.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> prodEnv = <span class="built_in">require</span>(<span class="string">'./prod.env'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断环境 运行不同的api</span></span><br><span class="line"><span class="comment"> * 登录地址切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (process.env.API_ROOT) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'sit'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = merge(prodEnv, &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"development"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://localhost:3800/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://localhost:3800/public_api"'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="prod-env-js"><a href="#prod-env-js" class="headerlink" title="prod.env.js"></a>prod.env.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前环境 打包不同的 api地址  login地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (process.env.API_ROOT) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'sit'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://localhost:3800/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-sit.com/api"'</span>,</span><br><span class="line">      version: <span class="string">'v1.0.0'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'uat'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://youapi-uat.com/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-uat.com/api"'</span>,</span><br><span class="line">      version: <span class="string">'v1.0.0'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'prod'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">      API_URL: <span class="string">'"http://youapi-prod.com/api"'</span>,</span><br><span class="line">      API_PUBLIC: <span class="string">'"http://youpublicapi-prod.com/api"'</span>,</span><br><span class="line">      version: <span class="string">'v1.0.0'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后也是最重要的也就是我们要有一个统一的调用地址，如果不是统一的一个，那就多声明几个模块如<code>PAYMENT、PRODUCT</code>等来区分不同环境的不同后台接口<br><img src="./jenkins-fornt/vue_build/jenkins_vue_cli2.png" alt="jenkins_vue_cli2"></p>
<h2 id="jenkins-配置"><a href="#jenkins-配置" class="headerlink" title="jenkins 配置"></a>jenkins 配置</h2><ul>
<li>新建一个 构建一个自由风格的软件项目</li>
<li>配置》源码管理》Git(git 地址和 ssh 帐号密码、拉去代码的分支)<br><img src="./jenkins-fornt/vue_build/jenkins_vue_cli3.png" alt="jenkins_vue_cli3"></li>
<li>锁定编译环境 node 版本为 8.9.3 或者别的<br><img src="./jenkins-fornt/vue_build/jenkins_vue_cli4.png" alt="jenkins_vue_cli4"></li>
<li>jenkins 前端的构建脚本<br><img src="./jenkins-fornt/vue_build/jenkins_vue_cli5.png" alt="jenkins_vue_cli5"><br>这个只是最简单的打包发送到对应的服务器，其实你在这个时候还可以做很多其他的事，如运行单元测试、sonar 平台质量检测、备份等等</li>
</ul>
]]></content>
      <categories>
        <category>VueCli</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
        <tag>Deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>函数编程系列 ———— 简介函数式编程中的一些概念</title>
    <url>/blog/funcitonal/docs/functional-introduction.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Funcitonal</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Funcitonal</tag>
      </tags>
  </entry>
  <entry>
    <title>函数编程系列 ———— 函数柯里化</title>
    <url>/blog/funcitonal/docs/functional-currying.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Funcitonal</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Funcitonal</tag>
      </tags>
  </entry>
  <entry>
    <title>react中redux的使用简介</title>
    <url>/blog/react/redux-mobox-rxjs/react-redux.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单的Redux</title>
    <url>/blog/react/redux-mobox-rxjs/react-redux1.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单的react-redux</title>
    <url>/blog/react/redux-mobox-rxjs/react-redux2.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的context应用场景和使用方法</title>
    <url>/blog/react/docs/react-context.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的renderProps的使用</title>
    <url>/blog/react/principle/react-render-props.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的使用immutable作用和如何优化项目</title>
    <url>/blog/react/lib/react-immutable.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理 （二）html中的css、javascript、dom之间的解析和相互阻塞关系</title>
    <url>/blog/html/render/html-style-javascript.html</url>
    <content><![CDATA[<p><strong><em>将欲取之，必先与之，是谓微明。柔弱胜刚强。——老子</em></strong></p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们在看一些前端优化规则的时候，比如雅虎军规等等，都有看到 <code>style 写在 head 中</code>，但是<code>外链 script 写在 body</code> 的最后，以优化性能，都知道应该怎么做，但是不知道其中的原理。<br>如果还不知道浏览器渲染的原理的，看一看<a href="/blog/html/render/html-style-javascript.html">浏览器渲染原理</a>这一篇文章。其实这个就是考验大家对 <code>html 中的 css、javascript、dom</code> 之间的解析和相互阻塞关系。</p>
<h2 id="JavaScript-会阻塞-CSS、DOM-吗"><a href="#JavaScript-会阻塞-CSS、DOM-吗" class="headerlink" title="JavaScript 会阻塞 CSS、DOM 吗"></a>JavaScript 会阻塞 CSS、DOM 吗</h2><h3 id="提出自己观点"><a href="#提出自己观点" class="headerlink" title="提出自己观点"></a>提出自己观点</h3><p>当我们把 script 标签写到页面的顶部时，dom 树在解析的时候检测到 script 标签是，会加载 script 里面的内容并且执行。我们假设在<code>执行</code>javascript 会<code>阻塞 dom</code>的解析和渲染，<code>阻塞 css</code>的解析和加载。</p>
<h3 id="验证自己的观点"><a href="#验证自己的观点" class="headerlink" title="验证自己的观点"></a>验证自己的观点</h3><p>在验证之前我们先把 chrome 的网速调到 40kb 每秒的下载和上传数据<br><strong>第一步</strong><br><img src="./html-style-javascript/html-1.png" alt="html operation"><br><strong>第二步</strong><br><img src="./html-style-javascript/html-2.png" alt="html operation"></p>
<p>我们来验证这个结论:<br>html 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        console.log('start load');</span></span><br><span class="line"><span class="regexp">        function h () &#123;</span></span><br><span class="line"><span class="regexp">            console.log(document.querySelectorAll('h1'))</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">        setTimeout(h, 0);</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        h1 &#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        console.log('end load');</span></span><br><span class="line"><span class="regexp">        setTimeout(h, 0);</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;测试阻塞加载&lt;/</span>h1&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>
<p>在<code>加载到</code>jquery 文件后，会先下载远程的 jquery 并且<code>执行</code>他，他会<code>阻塞 dom 的解析和渲染</code>，<code>css 解析和渲染</code>，一直是白屏，等 jquery<code>执行完成</code>了才接着解析 Dom 和 cssom 并且渲染，console.log 打印 h1 标签也是空数组。<br>如下图所示：<br><img src="./html-style-javascript/html-gif.gif" alt="html operation"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>javascript 加载会阻塞 css 解析和渲染<br>javascript 加载会阻塞 dom 解析和渲染</p>
</blockquote>
<h2 id="css-加载会阻塞-JavaScript-的加载和执行、会阻塞-Dom-的解析和渲染？"><a href="#css-加载会阻塞-JavaScript-的加载和执行、会阻塞-Dom-的解析和渲染？" class="headerlink" title="css 加载会阻塞 JavaScript 的加载和执行、会阻塞 Dom 的解析和渲染？"></a>css 加载会阻塞 JavaScript 的加载和执行、会阻塞 Dom 的解析和渲染？</h2><h3 id="提出自己观点-1"><a href="#提出自己观点-1" class="headerlink" title="提出自己观点"></a>提出自己观点</h3><p>因为上面我们已经验证过 JavaScript 会阻塞 Dom 的解析和渲染，同时也会解析 cssom 的解析和渲染，所以我们假设 css 的加载会<code>阻塞</code>Dom 的<code>解析</code>和<code>渲染</code>，会<code>阻塞</code>JavaScript 的<code>加载</code>和<code>执行</code>。</p>
<h3 id="验证我们的假设"><a href="#验证我们的假设" class="headerlink" title="验证我们的假设"></a>验证我们的假设</h3><p>在上面的代码基础上修改代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        console.log('start load');</span></span><br><span class="line"><span class="regexp">        function h () &#123;</span></span><br><span class="line"><span class="regexp">            console.log(document.querySelectorAll('h1'))</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">        setTimeout(h, 0);</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">    &lt;link href=<span class="string">"https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        h1 &#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        console.log('end load');</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;测试阻塞加载&lt;/</span>h1&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>
<p>执行结果如下图所示<br><img src="./html-style-javascript/html-gif1.gif" alt="html operation"></p>
<h4 id="css-加载对-Dom-的阻塞"><a href="#css-加载对-Dom-的阻塞" class="headerlink" title="css 加载对 Dom 的阻塞"></a>css 加载对 Dom 的阻塞</h4><p>如果按我们假设的 <code>css 加载会阻塞 Dom 的解析和渲染</code>，那么执行的结果，应该是<code>首先是白屏</code>，然后 <code>h1 标签的 nodeList</code> 应该是为<code>空数组</code>的，但是在执行的时我们看到 <code>h1 标签的 nodeList 是有值的</code>，注（还有 <code>setTimeout 的作用是为了在下一个 Task 最先执行，感觉并不会影响我们的实验的结果</code>。）<br>这表示我们一开始的假设是有问题的，<code>css 加载会阻塞 Dom 的渲染有阻塞，但是并不会阻塞 Dom 的解析</code>。</p>
<h4 id="css-加载对-JavaScript-的阻塞"><a href="#css-加载对-JavaScript-的阻塞" class="headerlink" title="css 加载对 JavaScript 的阻塞"></a>css 加载对 JavaScript 的阻塞</h4><p>css 加载会对后续的 JavaScript 的执行会造成阻塞。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong><em>css 加载对 Dom 的解析没有阻塞，但是对于 Dom 的渲染造成了阻塞。</em></strong><br><strong><em>css 加载对 JavaScript 的执行会造成阻塞</em></strong></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>如果还不了解整体的渲染流程可以看以前我前面的文章，<a href="/blog/html/render/html-style-javascript.html">浏览器渲染原理 （一）在网址中输入一个网站后面都做了什么</a></p>
<ul>
<li><code>**_JavaScript 的加载会阻塞 Dom 的解析和渲染，并且也会阻塞 css 的解析和渲染。_**</code></li>
<li><code>**_Css 的加载会阻塞 Dom 的渲染，并不会阻塞 Dom 的解析，也会阻塞 JavaScript 的执行。_**</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b88ddca6fb9a019c7717096" target="_blank" rel="noopener">css 加载会造成阻塞吗？</a></p>
]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>Render</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的继承对比 继承（二）</title>
    <url>/blog/javascript/extends/javascript-constructor-propotype.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript实现一个自己的new 继承 （三）</title>
    <url>/blog/javascript/extends/javascript-new.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>node中的垃圾回收机制</title>
    <url>/blog/node/docs/node-gc.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Node</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome中的preformance 性能监控</title>
    <url>/blog/monitor/perfromance/preformance.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Perfromance</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Browser</tag>
        <tag>Perfromance</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的BFC简介</title>
    <url>/blog/css/docs/css-docs-bfc.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>**块格式化上下文（Block Formatting Context，BFC）**</code> 是 Web 页面的可视化 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<blockquote>
<p>注意：一个 BFC 的范围包含<code>创建该上下文元素的所有子元素</code>，但不包括<code>创建了新 BFC 的子元素的内部元素</code>。这从另一方角度说明，<code>一个元素不能同时存在于两个 BFC 中</code>。因为如果<code>一个元素能够同时处于两个 BFC</code> 中，那么就意味着这个元素能与两个 BFC 中的元素发生作用，就违反了 BFC 的隔离作用。</p>
</blockquote>
<p>下列方式会创建<strong>块格式上下文</strong>：</p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 <code>float</code> 不是 <code>none</code>）</li>
<li>绝对定位元素（元素的 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>）</li>
<li>行内块元素（元素的 <code>display</code> 为 <code>inline-block</code>）</li>
<li>表格单元格（元素的 <code>display</code>为 <code>table-cell</code>，HTML 表格单元格默认为该值）</li>
<li>表格标题（元素的 <code>display</code> 为 t<code>able-caption</code>，HTML 表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 <code>display</code>为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是<code>HTML table</code>、<code>row</code>、<code>tbody</code>、<code>thead</code>、<code>tfoot</code>的默认属性）或 <code>inline-table</code>）</li>
<li><code>overflow</code> 值不为 <code>visible</code> 的块元素</li>
<li><code>display</code> 值为 <code>flow-root</code> 的元素</li>
<li><code>contain</code> 值为 <code>layout</code>、<code>content</code>或 <code>strict</code> 的元素</li>
<li>弹性元素（<code>display</code>为 <code>flex</code> 或 <code>inline-flex</code>元素的直接子元素）</li>
<li>网格元素（<code>display</code>为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li>
<li>多列容器（元素的 <code>column-count</code> 或 <code>column-width</code> 不为 <code>auto</code>，包括 <code>column-count</code> 为 1）</li>
<li><code>column-span</code> 为 all 的元素始终会创建一个新的<code>BFC</code>，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>
</ul>
<p>块格式化上下文包含创建它的元素内部的所有内容。</p>
<p><strong>表现</strong></p>
<p>在<strong>BFC(Block formatting contexts)</strong>中，在<strong>包含块</strong>内一个盒子一个盒子不重叠地<strong>垂直排列</strong>，两个兄弟盒子直接的垂直距离由 <code>margin</code>决定。<strong>浮动</strong>也是如此（虽然有可能两个盒子的距离会因为 floats 而变小），除非该盒子再创建一个新的<code>BFC</code>。</p>
<h2 id="三中文档流的定位方案"><a href="#三中文档流的定位方案" class="headerlink" title="三中文档流的定位方案"></a>三中文档流的定位方案</h2><p>我们常说的文档流其实分为<strong>定位流</strong>、<strong>浮动流</strong>、<strong>普通流三种</strong>。而普通流其实就是指<code>BFC</code>中的<code>FC</code>。<code>FC(Formatting Context)</code>，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的<code>FC</code>有<code>BFC(Block Formatting Contexts)、IFC</code>，还有<code>GFC(GridLayout Formatting Contexts)</code>和<code>FFC(Flex Formatting Contexts)</code>。</p>
<p>大致的文档流分类</p>
<ul>
<li>普通文档流<code>(Normal flow)</code></li>
<li>浮动<code>(Floats)</code></li>
<li>绝对定位<code>(Absolute positioning)</code></li>
</ul>
<h3 id="普通文档流"><a href="#普通文档流" class="headerlink" title="普通文档流"></a>普通文档流</h3><ul>
<li><strong>在普通文档流中，盒一个接着一个排列；</strong></li>
<li><strong>在块级格式化上下文里面， 它们竖着排列；</strong></li>
<li><strong>在行内格式化上下文里面， 它们横着排列；</strong></li>
<li><strong>当 position 为 static 或 relative，并且 float 为 none 时会触发普通文档流；</strong></li>
<li><strong>对于静态定位(static positioning)，position: static，盒的位置是普通文档流布局里的位置；</strong></li>
<li><strong>对于相对定位(relative positioning)，position: relative，盒偏移位置由 top、bottom、left、right 属性定义。即使有偏移，仍然保留原有的位置，其它普通文档流不能占用这个位置。</strong></li>
</ul>
<h3 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动(Floats)"></a>浮动(Floats)</h3><ul>
<li><strong>左浮动元素尽量靠左、靠上，右浮动同理</strong></li>
<li><strong>这导致普通文档流环绕在它的周边，除非设置 clear 属性</strong></li>
<li><strong>浮动元素不会影响块级元素的布局</strong></li>
<li><strong>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</strong></li>
<li><strong>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</strong></li>
<li><strong>不超过它的包含块，除非元素本身已经比包含块更宽</strong></li>
<li><strong>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的</strong></li>
</ul>
<h3 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位(Absolute positioning)"></a>绝对定位(Absolute positioning)</h3><ul>
<li><strong>绝对定位方案，盒从普通文档流中被移除，不影响普通文档流的布局；</strong></li>
<li><strong>它的定位相对于它的包含块，相关 CSS 属性：top、bottom、left、right；</strong></li>
<li><strong>如果元素的属性 position 为 absolute 或 fixed，它是绝对定位元素；</strong></li>
<li><strong>对于 position: absolute，元素定位将相对于上级元素中最近的一个 relative、fixed、absolute，如果没有则相对于 body；</strong></li>
</ul>
<h2 id="BFC-大致规则"><a href="#BFC-大致规则" class="headerlink" title="BFC 大致规则"></a>BFC 大致规则</h2><ul>
<li><strong>内部的 Box 会在垂直方向上一个接一个的放置</strong></li>
<li><strong>内部的 Box 垂直方向上的距离由 margin 决定。（完整的说法是：属于同一个 BFC 的两个相邻 Box 的 margin 会发生折叠，不同 BFC 不会发生折叠。）</strong></li>
<li><strong>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明 BFC 中子元素不会超出他的包含块，而 position 为 absolute 的元素可以超出他的包含块边界）</strong></li>
<li><strong>BFC 的区域不会与 float 的元素区域重叠</strong></li>
<li><strong>计算 BFC 的高度时，浮动子元素也参与计算</strong></li>
</ul>
<p><strong>普通文档流布局</strong></p>
<ul>
<li><strong>浮动的元素是不会被父级计算高度</strong></li>
<li><strong>非浮动元素会覆盖浮动元素的位置</strong></li>
<li><strong>margin 会传递给父级元素</strong></li>
<li><strong>两个相邻元素上下的 margin 会重叠</strong></li>
</ul>
<h2 id="开发中的使用"><a href="#开发中的使用" class="headerlink" title="开发中的使用"></a>开发中的使用</h2><ul>
<li><strong>BFC 可以防止 margin 折叠</strong></li>
<li><strong>可以阻止元素被浮动元素覆盖</strong></li>
<li><strong>多列布局中使用 BFC</strong></li>
<li><strong>可以包含浮动元素</strong></li>
</ul>
<h3 id="BFC-可以防止-margin-折叠"><a href="#BFC-可以防止-margin-折叠" class="headerlink" title="BFC 可以防止 margin 折叠"></a>BFC 可以防止 margin 折叠</h3><p>了解边距合并是另一个被低估的 <code>CSS</code> 技能。在下一个示例中，假设有一个背景颜色为灰色的 <code>div</code>。<br>这个 div 包含两个标签 p。外部 div 元素的 margin-bottom 为 <code>40</code> 像素，标签 p 的顶部和底部 margin 都是 20 像素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am paragraph one and I have a margin top and bottom of 20px;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am paragraph one and I have a margin top and bottom of 20px;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">40px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(233, 78, 119);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：<br><img src="./css-docs-bfc/bfc-1-1.png" alt="bfc"><br>可以看到它和外层<code>div</code>的<code>margin-bottom</code>也有重叠，两个相邻的 p 段落的<code>margin</code>也有重叠。<br>在 CSS 当中，<strong>相邻</strong>的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个<strong>单独</strong>的外边距。这种合并外边距的方式被称为<strong>折叠</strong>，并且因而所结合成的外边距称为<strong>折叠外边距</strong>。折叠的结果按照如下规则计算：</p>
<ul>
<li><strong>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</strong></li>
<li><strong>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</strong></li>
<li><strong>两个外边距一正一负时，折叠结果是两者的相加的和。</strong></li>
</ul>
<blockquote>
<p>产生折叠的必备条件：margin 必须是邻接的!</p>
</blockquote>
<p>如果我们把盒子设为 <strong>BFC</strong>，它现在包含了标签 <code>p</code> 和它们的<strong>边距</strong>，这样它们就不会<strong>折叠</strong>，我们可以看到边距后面容器的<strong>灰色背景</strong>。<br>修改 css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">40px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="./css-docs-bfc/bfc-1-2.png" alt="bfc"></p>
<h3 id="可以阻止元素被浮动元素覆盖、可以包含浮动元素"><a href="#可以阻止元素被浮动元素覆盖、可以包含浮动元素" class="headerlink" title="可以阻止元素被浮动元素覆盖、可以包含浮动元素"></a>可以阻止元素被浮动元素覆盖、可以包含浮动元素</h3><p>你将熟悉 <strong>BFC</strong> 的这种行为，因为使用<strong>浮动</strong>的任何列类型布局都是这样工作的。如果一个项目创建了一个 BFC，那么该项目将<strong>不会包裹</strong>任何浮动元素。在下面的例子中，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>I am a floated element.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    I am textI am textI am textI am textI am textI am textI am textI am textI am</span><br><span class="line">    textI am textI am text</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#00ff00</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ff00ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：<br><img src="./css-docs-bfc/bfc-1-3.png" alt="bfc"><br>我可以通过将包裹文本的 div 设置为 BFC 来防止这种包裹行为。新增 css 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-docs-bfc/bfc-1-4.png" alt="bfc"><br>这实际上是我们创建具有多个列的浮动布局的方法。浮动项还为该项创建了一个 BFC，因此，如果右边的列比左边的列高，那么我们的列就不会相互环绕。</p>
<h3 id="在多列布局中使用-BFC"><a href="#在多列布局中使用-BFC" class="headerlink" title="在多列布局中使用 BFC"></a>在多列布局中使用 BFC</h3><p><strong>如果我们创建一个占满整个容器宽度的多列布局，在某些浏览器中最后一列有时候会掉到下一行。这可能是因为浏览器四舍五入了列宽从而所有列的总宽度会超出容器。但如果我们在多列布局中的最后一列里创建一个新的 BFC，它将总是占据其他列先占位完毕后剩下的空间</strong>。<br>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>column 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>column 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span>column 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">31.33%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">1%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="./css-docs-bfc/bfc-1-5.png" alt="bfc"><br>添加以下样式创建一个 BFC:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.column</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: none;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-docs-bfc/bfc-1-6.png" alt="bfc"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/ifg6jtxK9iwIc6JfUkT8OQ" target="_blank" rel="noopener">理解 CSS 布局和 BFC</a><br><a href="https://mp.weixin.qq.com/s/gS-HPWZnrwaEM-X3vDEPyQ" target="_blank" rel="noopener">CSS 中重要的 BFC</a><br><a href="https://mp.weixin.qq.com/s/Ywxlr3nex--2-qTG2KjLGA" target="_blank" rel="noopener">前端进阶之你真的知道 BFC 是什么吗？</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>docs</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的BEM</title>
    <url>/blog/css/docs/css-docs-bem.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>**BEM 其实是一种 CSS 书写规范中的一种**</code>，使用 <code>BEM 规范</code>来<code>命名 CSS</code>，组织 HTML 中选择器的结构，利于 CSS 代码的维护，使得代码结构更清晰（弊端主要是名字会稍长）。<br>BEM 代表的是<code>**块（block）**、**元素（element）**、**修饰符（modifier）**</code>，是由 Yandex 团队提出的一种前端命名方法论。</p>
<p>在选择其中，由一下三种符号来表示扩展的关系：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-   中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</span><br><span class="line">__  双下划线：双下划线用来连接块和块的子元素</span><br><span class="line">_   单下划线：单下划线用来描述一个块或者块的子元素的一种状态</span><br><span class="line"></span><br><span class="line">type-block__element_modifier</span><br></pre></td></tr></table></figure>
<h2 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h2><p>一个快是设计或者布局的一部分，它有具体且唯一的意义，语义上的或视觉上的。<br>在大多数情况下，任何<code>**独立的页面元素**</code>（或复杂或简单）都可以被视作一个块。它的 HTML 容器会有一个<code>**唯一的 CSS 类名**</code>，也就是这个块的名字。<br>针对块的 CSS 类名会加一些前缀（ ui-），这些前缀在 CSS 中有类似 <strong>命名空间</strong> 的作用。<br>一个块的正式（实际上是半正式的）定义有下面三个基本原则：</p>
<ol>
<li>CSS 中只能使用类名（不能是 ID）。</li>
<li>每一个块名应该有一个命名空间（前缀）</li>
<li>每一条 CSS 规则必须属于一个块。</li>
</ol>
<p>一个自定义列表样例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">// css</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常会把<code>ul</code>看做一个完整得块，所以在<code>ul</code>上面定义一个块的<code>class</code>为<code>list</code>。</p>
<h2 id="元素（element）"><a href="#元素（element）" class="headerlink" title="元素（element）"></a>元素（element）</h2><p>块中的子元素是块的子元素，并且子元素的子元素在 <strong>bem</strong> 里也被认为是块的直接子元素。<strong>一个块中元素的类名必须用父级块的名称作为前缀</strong>。<br>在上面的例子上扩展如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span>列表项一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span>列表项二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">// css</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.list__item</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为每一个<code>li</code>都是<code>ul</code>的子元素，所以在<code>li</code>上定义一个为<code>list__item</code>的<code>class</code>。</p>
<h2 id="修饰符（modifier）"><a href="#修饰符（modifier）" class="headerlink" title="修饰符（modifier）"></a>修饰符（modifier）</h2><p>一个“修饰符”可以理解为一个块的<strong>特定状态</strong>，标识着它持有一个<strong>特定的属性</strong>。<br>在上面的例子上扩展如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item list__item_active"</span>&gt;</span>列表项一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span>列表项二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">// css</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.list</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.list__item</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.list__item_active</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假如<code>ul</code>是一个<code>menu</code>，它的第一项默认是<strong>选中状态</strong>给第一项添加一个选中的<code>class</code>为<code>list__item_active</code>。</p>
<h2 id="书写原则"><a href="#书写原则" class="headerlink" title="书写原则"></a>书写原则</h2><ol>
<li><strong>原则上不会出现<em>2 层以上</em>选择器嵌套</strong></li>
</ol>
<p>使用<code>BEM</code>原则，用命名来解耦，所有类名都为一层，增加效率和复用性</p>
<ol start="2">
<li><strong>两层选择器嵌套出现在<code>.mod-xxx__item_current</code>子元素的情况</strong></li>
</ol>
<p>请看下面一个样例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"xxx__item"</span>&gt;</span></span><br><span class="line">    第一项</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"xxx__product-name"</span>&gt;</span>我是名称<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"xxx__ming-zi-ke-yi-hen-chang"</span>&gt;</span>看类名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"xxx__link"</span>&gt;</span>我是link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"xxx__item xxx__item_current"</span>&gt;</span></span><br><span class="line">    第二项 且 当前选择项</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"xxx__product-name"</span>&gt;</span>我是名称<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"xxx__item-link"</span>&gt;</span>我是link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"xxx__item xxx__item_hightlight"</span>&gt;</span></span><br><span class="line">    第三项 且 特殊高亮</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"xxx__product-name"</span>&gt;</span>我是名称<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"xxx__item-link"</span>&gt;</span>我是link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 常规写法：</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.xxx</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item_current</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line">  // 嵌套写法</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item_current</span> <span class="selector-class">.mod-xxx__link</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 推荐：</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.xxx</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item_hightlight</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__product-name</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__link</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__ming-zi-ke-yi-hen-chang</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 嵌套写法</span><br><span class="line"><span class="css">  <span class="selector-class">.xxx__item_current</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.xxx__link</span> &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="BEM-解决问题"><a href="#BEM-解决问题" class="headerlink" title="BEM 解决问题"></a>BEM 解决问题</h2><p>组件之间的完全解耦，不会造成命名空间的污染，如：<code>.mod-xxx ul li</code> 的写法带来的潜在的嵌套风险。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BEM 规则的应用规则如下：</p>
<ul>
<li><code>一个独立的（语义上或视觉上），可以复用而不依赖其它组件的部分，可作为一个块（Block）</code></li>
<li><code>属于块的某部分，可作为一个元素（Element）</code></li>
<li><code>用于修饰块或元素，体现出外形行为状态等特征的，可作为一个修饰器（Modifier）</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Tencent/tmt-workflow/wiki/%E2%92%9B-%5B%E8%A7%84%E8%8C%83%5D--CSS-BEM-%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">[规范] CSS BEM 书写规范</a><br><a href="https://www.cnblogs.com/imwtr/p/8521031.html" target="_blank" rel="noopener">使用 BEM 命名规范来组织 CSS 代码</a><br><a href="https://www.w3cplus.com/css/mindbemding-getting-your-head-round-bem-syntax.html" target="_blank" rel="noopener">BEM 思想之彻底弄清 BEM 语法</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>node中的node-lru的使用和lru的作用</title>
    <url>/blog/node/docs/node-lru.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Node</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie、localStorage、sessionStorage、session深入理解</title>
    <url>/blog/network/cookie-jwt-seesion-auth2.0/cookie-session-storage.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在以前经常用到的<code>cookie</code>、<code>session</code>，但在<strong>H5</strong>中新引入了新的浏览器本地缓存方案。因为大家使用的不太规范用来作为本地储存工具，在下次请求时会默认带上<code>cookie</code>中的数据导致浪费性能和流量。</p>
<p>下面就从开始介绍为什么产生的<code>cookie</code>，它的出现是为了解决什么问题，它有什么问题；后面<code>localStorage</code>是为什么产生，它又解决了那部分的问题。最后是<code>cookie</code>、<code>session</code>、<code>localStorage</code>、<code>sessionStorage</code>之间的对比。</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>首先了解为什么会产生<code>cookie</code>?<code>cookie</code>是什么?</p>
<h3 id="cookie是什么、cookie产生原因"><a href="#cookie是什么、cookie产生原因" class="headerlink" title="cookie是什么、cookie产生原因"></a>cookie是什么、cookie产生原因</h3><p>在<code>HTTP</code>请求建立连接时，有一个<strong>客户端</strong>、<strong>服务端</strong>它们两个之间建立的连接。但是<code>HTTP</code>协议每次建立连接都是独立，也可以说是<code>HTTP</code>协议是无状态的连接。</p>
<ul>
<li>第一次建立连接，客户在<strong>客户端</strong>中登录，<strong>服务端</strong>验证登录信息，生成<strong>Token</strong>为以后的请求不需要从新登录</li>
<li>第二次建立连接，<strong>客户端</strong>携带服务端在登录成功时返回的<strong>Token</strong>，但是这个<strong>Token</strong>要储存在哪里？一般会存在<strong>cookie</strong>里。</li>
</ul>
<p>简单总结一下就是，因为<code>HTTP</code>协议是无状态的所以客户端需要一个<code>cookie</code>来储存起来。<br><!-- **`Cookie`实际上是一小段的文本信息**，**用来服务端和客户端之间传递信息**。 --><br><strong><code>HTTP Cookie</code>（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</strong></p>
<p><code>Cookie</code>主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h3><p>当服务器收到<code>HTTP</code>请求时，服务器可以在响应头里面添加一个<code>Set-Cookie</code>选项。浏览器收到响应后通常会保存下<code>Cookie</code>，之后对该服务器每一次请求中都通过<code>Cookie</code>请求头部将<code>Cookie</code>信息发送给服务器。</p>
<p>在创建<code>Cookie</code>是可以设置很多属性，如<code>Expires</code>、<code>Max-Age</code>、<code>Domain</code>、<code>Path</code>、<code>Secure</code>、<code>HttpOnly</code>，因为它会自动携带到服务器端，同时又支持服务器端设置。所以有很多的方面要注意，比如<strong>时效性</strong>、<strong>作用域</strong>、<strong>安全性</strong>。下面就从这三个方面来解释他属性的作用。</p>
<h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>如果在<code>Set-Cookie</code>时不通过<code>Expries</code>、<code>Max-Age</code>两个字段设置<code>Cookie</code>的时效性，那么这个<code>Cookie</code>是一个简单的<strong>会话期Cookie</strong>。它在关闭浏览器是会被自动删除。</p>
<p>如果设置了<code>Expries</code>、<code>Max-Age</code>那么这个<code>Cookie</code>在指定时间内都是有效的。</p>
<blockquote>
<p>提示：当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
</blockquote>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>Domain</code> 和 <code>Path</code> 标识定义了<code>Cookie</code>的作用域：即<code>Cookie</code>应该发送给哪些<code>URL</code>。</p>
<p><code>Domain</code> 标识指定了哪些主机可以接受<code>Cookie</code>。如果不指定，默认为<strong>当前文档的主机（不包含子域名）</strong>。如果指定了<code>Domain</code>，则一般包含子域名。</p>
<p><code>Path</code> 标识指定了主机下的哪些路径可以接受<code>Cookie</code><strong>（该URL路径必须存在于请求URL中）</strong>。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>标记为 <code>Secure</code> 的<code>Cookie</code>只应通过被<code>HTTPS</code>协议加密过的请求发送给服务端。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过<code>Cookie</code>传输，因为<code>Cookie</code>有其固有的不安全性，<code>Secure</code> 标记也无法提供确实的安全保障。</p>
<blockquote>
<p>从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用Cookie的 Secure 标记。</p>
</blockquote>
<p>为避免跨域脚本 <strong>(XSS)</strong> 攻击，通过<strong>JavaScript</strong>的 <code>Document.cookie</code> <strong>API</strong>无法访问带有 <code>HttpOnly</code> 标记的<code>Cookie</code>，它们只应该发送给服务端。</p>
<h3 id="客户端操作Cookie"><a href="#客户端操作Cookie" class="headerlink" title="客户端操作Cookie"></a>客户端操作Cookie</h3><p>通过<code>Document.cookie</code>属性可创建新的<code>Cookie</code>，也可通过该属性访问非<code>HttpOnly</code>标记的<code>Cookie</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">documnet.cookie</span><br><span class="line"><span class="comment">// 这里就不多做赘述，有一篇文章专门讲解了</span></span><br></pre></td></tr></table></figure>
<h3 id="cookie的特点"><a href="#cookie的特点" class="headerlink" title="cookie的特点"></a>cookie的特点</h3><p><strong>优点</strong></p>
<ul>
<li>储存用户信息（用户token）</li>
<li>标记用户行为（uuid、埋点）</li>
</ul>
<p><strong>弊端</strong></p>
<ul>
<li><code>Cookie</code>会被附加在每个<code>HTTP</code>请求中，所以无形中增加了流量</li>
<li><code>Cookie</code>可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的<code>Cookie</code>功能；</li>
<li>由于在<code>HTTP</code>请求中的<code>Cookie</code>是明文传递的，潜在的安全风险，<code>Cookie</code> 可能会被篡改</li>
<li><p><code>Cookie</code>数量和长度的限制。每个域名(Domain)下<br><strong>IE6或IE6-(IE6以下版本)：最多20个cookie</strong><br><strong>IE7或IE7+(IE7以上版本)：最多50个cookie</strong><br><strong>FF:最多50个cookie</strong><br><strong>Opera:最多30个cookie</strong><br><strong>Chrome和safari没有硬性限制</strong><br>当超过单个域名限制之后，再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会清理近期最少使用的cookie，FF会随机清理cookie；</p>
</li>
<li><p>每个<code>Cookie</code>长度不能超过<strong>4KB</strong></p>
</li>
</ul>
<h3 id="cookie安全问题"><a href="#cookie安全问题" class="headerlink" title="cookie安全问题"></a>cookie安全问题</h3><p><code>Cookie</code>面临什么样的安全问题，常见的<strong>xss</strong>、<strong>csrf</strong>等等下面开始。</p>
<p><strong>xss 和 防御xss</strong></p>
<p>如果在服务器端<code>Set-Cookie</code>时没有设置<code>HttpOnly=true</code>时，在浏览器端就可以通过<code>document.cookie</code>来读取和修改<code>Cookie</code>中的值，这是十分安全的会造成<code>xss</code>。当<code>Cookie</code>中有关键性信息是要设置<code>HttpOnly=true</code>。</p>
<p><strong>防止中间人劫持 和 中间人劫持</strong></p>
<p>大致的分布图是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">         DNS</span><br><span class="line">     &lt;-----&gt;</span><br><span class="line">用户          中间人       外网</span><br><span class="line">     &lt;-----&gt;</span><br><span class="line">       HTTP</span><br></pre></td></tr></table></figure>
<p>当使用<code>HTTPS</code>协议和购买正规的<code>CA证书</code>时，即使中间人劫持也无法解密。并且在<code>Set-Cookie</code>设置<code>Secure=true</code>时<code>Cookie</code>只应通过被<code>HTTPS</code>协议加密过的请求发送给服务端。</p>
<p><strong>csrf 和 csrf防御</strong></p>
<p>CSRF: 跨站请求伪造<code>（CSRF）</code>是一种冒充受信任用户，向服务器发送非预期请求的攻击方式。</p>
<p>例如，这些非预期请求可能是通过在跳转链接后的 URL 中加入恶意参数来完成:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://www.example.com/index.php?action=delete&amp;id=123"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于在 <code>https://www.example.com</code> 有权限的用户，这个 <code>&lt;img&gt;</code> 标签会在他们根本注意不到的情况下对 <code>https://www.example.com</code> 执行这个操作，即使这个标签根本不在 <code>https://www.example.com</code> 内亦可。</p>
<p><code>SameSite Cookie</code>允许服务器要求某个<code>cookie</code>在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击<code>（CSRF）</code>。但目前<code>SameSite Cookie</code>还处于实验阶段，并不是所有浏览器都支持。</p>
<ul>
<li><code>strict</code>：浏览器在任何跨域请求中都不会携带<code>Cookie</code>，这样可以有效的防御<code>CSRF</code>攻击，但是对于有多个子域名的网站采用主域名存储用户登录信息的场景，每个子域名都需要用户重新登录，造成用户体验非常的差。</li>
<li><code>lax</code>：相比较<code>strict</code>，它允许从三方网站跳转过来的时候使用<code>Cookie</code>。</li>
</ul>
<p><strong>其他防御</strong></p>
<ul>
<li>设置<code>cookie</code>有效期时间</li>
<li>防止<code>cookie</code>是明文，服务器端生成密钥验证</li>
<li>生成随机数和<code>cookie</code>发送给服务器端</li>
<li><code>flash编程安全</code>，审核<code>flash代码</code>，尽量不要用<code>flash</code>用最新的视频<code>vedio</code> + <code>https</code> + <code>socket</code>或者动画</li>
</ul>
<p>到此<code>cookie</code>的<strong>产生原因</strong>、<strong>作用</strong>、<strong>特点/缺点</strong>、<strong>安全问题</strong>。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>session是什么？</strong><br><code>Session</code>是一种记录客户状态的机制，不同于<code>Cookie</code>的是<code>Cookie</code>保存在客户端浏览器中，而Session保存在服务器上。避免了在客户端<code>Cookie</code>中存储敏感数据。</p>
<h3 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h3><p><code>Session</code>从字面意思上可以理解为<strong>会话</strong>，谁与谁的会话呢？其实是<strong>客户端浏览器与服务器之间一系列交互的动作称为一个 Session</strong>。</p>
<p><strong>创建Session（java）</strong></p>
<ol>
<li><code>Session</code>在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建<code>Session</code>的方法， 在<code>Java</code>中是通过调用<code>HttpServletRequest</code>的<code>getSession</code>方法(使用true作为参数)创建的。 创建<code>Session</code>的同时，服务器会为该<code>Session</code>生成唯一的<code>session id</code>， 这个<code>session id</code>在随后的请求中会被用来重新获得已经创建的<code>Session</code>。</li>
<li><code>Session</code>被创建之后，就可以调用<code>Session</code>相关的方法往<code>Session</code>中增加内容了， 而这些内容只会保存在服务器中，发到客户端的只有<code>session id</code></li>
<li>当客户端再次发送请求的时候，会将这个<code>session id</code>带上， 服务器接受到请求之后就会依据<code>session id</code>找到相应的<code>Session</code>，从而再次使用<code>Session</code>。</li>
</ol>
<h3 id="Session的生命周期"><a href="#Session的生命周期" class="headerlink" title="Session的生命周期"></a>Session的生命周期</h3><p><code>Session</code>保存在服务器端。为了获得更高的存取速度，服务器一般把<code>Session</code>放在内存中。 每个用户都会有一个独立的<code>Session</code>。 如果<code>Session</code>内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。 因此，<code>Session</code>里的信息应该尽量精简。</p>
<p><code>Session</code>在用户第一次访问服务器的时候自动创建。 需要注意只有访问<code>JSP、Servlet</code>等程序时才会创建<code>Session</code>， 只访问<code>HTML、IMAGE</code>等静态资源并不会创建<code>Session</code>。 如果尚未生成<code>Session</code>，也可以使用<code>request.getSession(true)</code>强制生成<code>Session</code>。</p>
<p><code>Session</code>生成后，只要用户继续访问，服务器就会更新<code>Session</code>的最后访问时间，并维护该<code>Session</code>。 用户每访问服务器一次，无论是否读写<code>Session</code>，服务器都认为该用户的<code>Session&quot;活跃(active)&quot;了一次</code>。</p>
<h3 id="Session的有效期"><a href="#Session的有效期" class="headerlink" title="Session的有效期"></a>Session的有效期</h3><p>由于会有越来越多的用户访问服务器，因此<code>Session</code>也会越来越多。 为防止内存溢出，服务器会把长时间内没有活跃的<code>Session</code>从内存删除。 这个时间就是<code>Session</code>的超时时间。如果超过了超时时间没访问过服务器，<code>Session</code>就自动失效了。</p>
<p><code>Session</code>的超时时间为<code>maxInactiveInterval</code>属性， 可以通过对应的<code>getMaxInactiveInterval()</code>获取，通过<code>setMaxInactiveInterval(longinterval)</code>修改。</p>
<p><code>Session</code>的超时时间也可以在<code>web.xml</code>中修改。 另外，通过调用<code>Session</code>的<code>invalidate()</code>方法可以使<code>Session</code>失效。</p>
<p>三种方法让<code>Session</code>失效：</p>
<ul>
<li><strong>服务器意外关闭</strong>。（服务器正常关闭时session是会被服务器保存在服务器的 session.ser 文件中（在work文件夹下））</li>
<li><code>session自杀</code>： 调用<code>session.invalidate()</code>方法可以立即杀死<code>session</code>；</li>
<li>可以在服务器下的<code>web.xml</code>文件中的 <code>&lt;session-timeout&gt; 30 &lt;/session-timeout&gt;</code> 修改这是默认值(默认30分钟)，是以分为单位。</li>
</ul>
<h3 id="浏览器关闭session会失效"><a href="#浏览器关闭session会失效" class="headerlink" title="浏览器关闭session会失效?"></a>浏览器关闭session会失效?</h3><p>在几年前看很多网上的资料时有的会说<code>session</code>会在浏览器关闭时会失效。为什么会失效？怎么能让它不失效？</p>
<p><strong>为什么会失效？</strong></p>
<p>下面梳理一下<code>session</code>为什么会在浏览器关闭时失效，其实这样说并不准确：</p>
<ol>
<li>在服务器端生成<code>session</code>，并且把<code>sessionid</code>通过<code>set-cookie</code>发送给浏览器</li>
<li>以后每次请求除了图片、静态文件请求，其它的请求都会带上<strong>服务端</strong>写入浏览器中<code>cookie</code></li>
<li><strong>服务端</strong>接收到<code>sessionid</code>，通过<code>sessionid</code>找到对应的<code>session</code>信息</li>
<li>当浏览器关闭时，当前域名中设置的<code>cookie</code>会被清空</li>
<li>再下次请求使，服务端接收到的<code>session</code>为<code>null</code>，服务端就会认为当前用户是一个新的用户，重新登录或者直接设置新的<code>sessionid</code></li>
</ol>
<p>上面也就是为什么会说<code>session</code>会在浏览器关闭时会失效。</p>
<p><strong>怎么能让它不失效？</strong></p>
<p>在<code>Set-Cookie</code>时设置<code>Expries</code>或<code>Max-Age</code>，其实就是设置<code>Cookie</code>的失效时间。<br>或者直接把<code>Sessionid</code>储存在本地。</p>
<h2 id="web-Storage"><a href="#web-Storage" class="headerlink" title="web Storage"></a>web Storage</h2><p><strong>Web Storage API</strong>提供机制， 使浏览器能以一种比使用<code>Cookie</code>更直观的方式存储键/值对。</p>
<p>Web Storage 包含如下两种机制：</p>
<ul>
<li><code>sessionStorage</code> 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</li>
<li><code>localStorage</code> 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</li>
</ul>
<p><strong>应注意，无论数据存储在 localStorage 还是 sessionStorage ，它们都特定于页面的协议。</strong></p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>只读的<code>localStorage</code> 属性允许你访问一个<code>Document</code> 源（<code>origin</code>）的对象 <code>Storage</code>；存储的数据将保存在浏览器会话中。存储在 <code>localStorage</code> 的数据可以长期保留。</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code> 属性允许你访问一个 <code>session Storage</code> 对象。存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。<strong>在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话</strong>，这点和 session cookies 的运行方式不同。</p>
<h3 id="localStorage和sessionStorage区别"><a href="#localStorage和sessionStorage区别" class="headerlink" title="localStorage和sessionStorage区别"></a>localStorage和sessionStorage区别</h3><p>存储在 <code>localStorage</code> 的数据可以长期保留，而存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>session</code>和<code>cookie</code>的区别：</p>
<ul>
<li><code>session</code>储存在服务端，<code>cookie</code>储存在客户端</li>
<li><code>session</code>比<code>cookie</code>更安全，因为<code>session</code>储存在服务端</li>
<li><code>session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。</li>
<li><code>cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现<code>session</code>的一种方式。</li>
</ul>
<p><code>web storage</code>和<code>cookie</code>的区别：</p>
<ul>
<li><code>web storages</code>和<code>cookie</code>的作用不同，<code>web storage</code>是用于本地大容量存储数据(<code>web storage</code>的存储量大到5MB);而<code>cookie</code>是用于客户端和服务端间的信息传递；</li>
<li><code>web storage</code>有<code>setItem</code>、<code>getItem</code>、<code>removeItem</code>、<code>clear</code>等方法，<code>cookie</code>需要我们自己来封装<code>setCookie</code>、<code>getCookie</code>、<code>removeCookie</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">HTTP cookies</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">Web Storage API</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">Window.localStorage</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener">Window.sessionStorage</a><br><a href="https://mp.weixin.qq.com/s/RJuHkTYd7pSS_RhHeuh0iQ" target="_blank" rel="noopener">这一次把cookie给你说透彻！</a><br><a href="https://mp.weixin.qq.com/s/sycJeIBY_2h0h6SwUTWI9A" target="_blank" rel="noopener">深入理解Session和Cookie的区别</a><br><a href="https://mp.weixin.qq.com/s/VeodMTKbwCdodx0fZjTlhw" target="_blank" rel="noopener">详解cookie和session的运作机制（上篇）</a><br><a href="https://mp.weixin.qq.com/s/Idl0eheciAck5WznXqO0Lw" target="_blank" rel="noopener">面试稳了！这才是cookie，session与token的真正区别</a></p>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的requestAnimationFrame</title>
    <url>/blog/javascript/effect/javascript-requestAnimationFrame.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Http中的缓存（一） 多级缓存结构</title>
    <url>/blog/network/cache/http-cache-multiple.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>缓存</strong>相信现在这个词大家都不陌生，因为在当前的应用中被广泛的应用。因为<strong>缓存</strong>会带来更高的<strong>性能</strong>、<strong>用户体验</strong>，同时也会<strong>节省流量</strong>、<strong>离线体验</strong>等等好处。</p>
<p>关于缓存的文章分为三篇：<strong>多级缓存结构</strong>、<strong>HTTP 缓存详解</strong>、<strong>离线缓存</strong></p>
<h3 id="缓存的分层"><a href="#缓存的分层" class="headerlink" title="缓存的分层"></a>缓存的分层</h3><p><strong>缓存</strong>大致分为如下：</p>
<ul>
<li><strong>客户端/浏览器缓存</strong></li>
<li><strong>http/服务器缓存</strong></li>
<li><strong>cdn 缓存</strong></li>
<li><strong>代理服务器缓存</strong></li>
<li><strong>后端进程缓存 redis、lru 等等</strong></li>
<li><strong>分布式缓存</strong></li>
<li><strong>数据库</strong></li>
</ul>
<p>可以在下面几层做缓存大致如下：</p>
<p><img src="./http-cache-multiple/http-cache-1-1.png" height="300" alt="http-cache"></p>
<h3 id="多层缓存流程"><a href="#多层缓存流程" class="headerlink" title="多层缓存流程"></a>多层缓存流程</h3><p>整个的缓存判断流程是：</p>
<ol>
<li><strong>用户刷新页面发出请求</strong></li>
<li>客户端/浏览器是否命中<code>serviceWorker</code>、<strong>强缓存（缓存策略）</strong>、<strong>协商缓存</strong></li>
<li><strong>cdn 缓存</strong></li>
<li><strong>代理服务器缓存</strong></li>
<li><strong>进程缓存</strong></li>
<li><strong>分布式缓存</strong></li>
<li><strong>数据库</strong></li>
</ol>
<p>这里主要记述<strong>客户端/浏览器缓存</strong>、<strong>http/服务器缓存</strong>的一些使用和细节。</p>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p><code>HTTP</code>缓存基本上可以分为两类： <strong>一类强缓存（有效期策略）</strong>、<strong>另一类 协商缓存（资源唯一标识符）</strong>。它们缓存在不同的位置，按照分类为：<strong>本地硬盘缓存</strong>、<strong>本地内存缓存</strong>。当时对于一些不同的文件类型要用不同的缓存来做，同时让它们缓存在不同的位置。<br>跟随<strong>移动端</strong>应用的发展，为了提高用户离线的体验，延伸出了不同<strong>离线缓存方案</strong>大致有两种实现方式：<strong>AppCache</strong>、<strong>ServiceWorker</strong>两种方式。</p>
<p>在这里一些详细的实现方式和细节不多做解释，在下片文章<a href="/blog/http/http-etag-cache.html">Http 中的缓存（二） HTTP 中的缓存</a>来详细的记录，比如<strong>有限期是怎么验证的</strong>、<strong>详细的配置</strong>、<strong>不同的本地缓存储存在那</strong>、<strong>它们之间的对比和适用缓存文件</strong>等等。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>强缓存</strong>可以用三种实行方式： <code>cache-control</code>、<code>Expires</code>、<code>Pragma</code>它们都是通过<strong>有效期</strong>来决定是否命中缓存的。</p>
<p>大致的优先级如下： 在本地 <code>Cache-Control &gt; Expires，Pragma 在不支持 Cache-Control</code> 时生效。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存</strong>可以用两种种实行方式： <code>Last-Modified/If-Modified-Since</code>、<code>Etag/If-None-Match</code>它们的实现方式是不同的。</p>
<p><strong>Last-Modified/If-Modified-Since</strong>是通过<strong>有限期</strong>来检验是否使用缓存，而<strong>Etag/If-None-Match</strong>它是通过<strong>唯一资源标识符</strong>来判断是否使用缓存。<br>同时它们的整体流程也是不同，比如说<strong>Last-Modified/If-Modified-Since</strong>返回的<strong>HTTP 状态</strong>为<strong>200 状态码</strong>，而<strong>Etag/If-None-Match</strong>它返回的是<strong>304 状态码</strong>。</p>
<h3 id="储存位置"><a href="#储存位置" class="headerlink" title="储存位置"></a>储存位置</h3><p>从缓存位置上来看，分为<strong>4 种</strong>，<strong>从上往下依次检查</strong>是否命中，如果但都没有命中则重新发起请求。</p>
<ul>
<li><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 <code>Service Worker</code>的话，传输协议必须为 <code>HTTPS</code>。</li>
<li><code>Memory Cache</code> 也就是<strong>内存</strong>中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。</li>
<li><code>Disk Cache</code> 也就是存储在硬盘中的缓存。</li>
<li><code>Push Cache</code>（推送缓存）是 <code>HTTP/2</code> 中的内容，当以上三种缓存都没有命中时，它才会被使用。</li>
</ul>
<p>它们之间是有优缺点的，比如说静态资源适用于<code>Memory Cache</code>。</p>
<h3 id="用户操作对缓存的影响"><a href="#用户操作对缓存的影响" class="headerlink" title="用户操作对缓存的影响"></a>用户操作对缓存的影响</h3><p>当用户的操作比如<strong>地址栏回车</strong>、<strong>前进回退</strong>、<strong>F5 刷新</strong>、<strong>Ctrl+F5 强制刷新</strong>等等对缓存的影响。大致如下图所示：</p>
<p><img src="./http-cache-multiple/http-cache-1-2.png" alt="http-cache"></p>
<p>在这里就不细究了不然这篇文章太长了。</p>
<h2 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h2><p><strong>CND</strong>的全称是<strong>Content Delivery NetWork</strong>内容分发网络。<strong>HTTP</strong>缓存主要是对一些<strong>客户端/浏览器</strong>中的静态资源和<strong>不长更新的数据</strong>资源。<br><strong>CDN</strong>是在<strong>客户端</strong>和<strong>服务器</strong>端加设的一层，可以让<strong>CDN</strong>为应用服务器提供缓存，如果在 <strong>CDN</strong> 上缓存，就不用再请求应用服务器了。并且 <strong>HTTP</strong> 缓存提到的两种策略同样可以在 <strong>CDN</strong>服务器执行。</p>
<h3 id="CDN-流程"><a href="#CDN-流程" class="headerlink" title="CDN 流程"></a>CDN 流程</h3><p><strong>CDN</strong>缓存流程大致如下：<br><img src="./http-cache-multiple/http-cache-1-3.png" alt="http-cache"></p>
<ul>
<li>客户端发送 <code>URL</code> 给 <code>DNS</code> 服务器。</li>
<li><code>DNS</code> 通过域名解析，把请求指向 <code>CDN</code> 网络中的 <code>DNS</code> 负载均衡器。</li>
<li><code>DNS</code> 负载均衡器将最近 <code>CDN</code> 节点的 <code>IP</code> 告诉 <code>DNS</code>，<code>DNS</code> 告之客户端最新 <code>CDN</code> 节点的 <code>IP</code>。</li>
<li>客户端请求最近的 <code>CDN</code> 节点。</li>
<li><code>CDN</code> 节点从应用服务器获取资源返回给客户端，同时将静态信息缓存。</li>
</ul>
<blockquote>
<p>注意：客户端下次互动的对象就是 <code>CDN</code> 缓存了，<code>CDN</code> 可以和应用服务器同步缓存信息。</p>
</blockquote>
<p><code>CDN</code> 接受客户端的请求，它就是离客户端最近的服务器，它后面会链接多台服务器，起到了缓存和负载均衡的作用。</p>
<h2 id="负载均衡缓存"><a href="#负载均衡缓存" class="headerlink" title="负载均衡缓存"></a>负载均衡缓存</h2><p>说完客户端（<code>HTTP</code>）缓存和 <code>CDN</code> 缓存，我们离应用服务越来越近了，在到达应用服务之前，请求还要经过<strong>负载均衡器</strong>。</p>
<p>虽说它的主要工作是对<strong>应用服务器进行负载均衡</strong>，但是它也可以作<strong>缓存</strong>。可以把一些修改频率不高的数据缓存在这里，例如：用户信息，配置信息。通过服务定期刷新这个缓存就行了。</p>
<p><img src="./http-cache-multiple/http-cache-1-4.png" alt="http-cache"></p>
<p>以 <code>Nginx</code> 为例，我们看看它是如何工作的：</p>
<ul>
<li>用户请求在达到应用服务器之前，会<strong>先访问 Nginx 负载均衡器</strong>，如果发现<strong>有缓存信息</strong>，直接<strong>返回</strong>给用户。</li>
<li>如果<strong>没有发现</strong>缓存信息，<strong>Nginx 回源</strong>到应用服务器获取信息。</li>
<li>另外，有一个<strong>缓存更新服务</strong>，定期把应用服务器中<strong>相对稳定</strong>的信息更新到 <strong>Nginx 本地缓存</strong>中。</li>
</ul>
<h2 id="进程内缓存"><a href="#进程内缓存" class="headerlink" title="进程内缓存"></a>进程内缓存</h2><p>通过了<strong>客户端</strong>，<strong>CDN</strong>，<strong>负载均衡器</strong>，我们终于来到了应用服务器。应用服务器上部署着一个个应用，这些应用以进程的方式运行着，那么在进程中的缓存是怎样的呢？</p>
<p><strong>进程内缓存又叫托管堆缓存</strong>，以 Java 为例，这部分缓存放在<strong>JVM 的托管堆</strong>上面，同时会受到<strong>托管堆回收算法</strong>的影响。</p>
<p>由于其运行在内存中，对<strong>数据的响应速度很快</strong>，通常我们会把热点数据放在这里。</p>
<p>在<strong>进程内缓存没有命中</strong>的时候，我们会去<strong>搜索进程外的缓存或者分布式缓存</strong>。这种缓存的好处是<strong>没有序列化和反序列化</strong>，是<strong>最快的缓存</strong>。<strong>缺点是缓存的空间不能太大</strong>，<strong>对垃圾回收器的性能有影响</strong>。</p>
<p>目前比较流行的实现有 <strong>Ehcache</strong>、<strong>GuavaCache</strong>、<strong>Caffeine</strong>。这些架构可以很方便的把一些热点数据放到<strong>进程内的缓存</strong>中。</p>
<p>这里我们需要关注几个缓存的回收策略，具体的实现架构的回收策略会有所不同，但大致的思路都是一致的：</p>
<ul>
<li><strong>FIFO（First In First Out）</strong>：先进先出算法，最先放入缓存的数据最先被移除。</li>
<li><strong>LRU（Least Recently Used）</strong>：最近最少使用算法，把最久没有使用过的数据移除缓存。</li>
<li><strong>LFU（Least Frequently Used）</strong>：最不常用算法，在一段时间内使用频率最小的数据被移除缓存。</li>
</ul>
<p>在分布式架构的今天，多应用中如果采用进程内存缓存会存在数据一致性的问题。</p>
<p>这里推荐两个方案：</p>
<ul>
<li><strong>消息队列修改方案</strong></li>
<li><strong>Timer 修改方案</strong></li>
</ul>
<h3 id="消息队列修改方案"><a href="#消息队列修改方案" class="headerlink" title="消息队列修改方案"></a>消息队列修改方案</h3><p>应用在<strong>修改完自身缓存数据和数据库数据</strong>之后，给消息队列<strong>发送数据变化通知</strong>，其他<strong>应用订阅了消息通知</strong>，在收到通知的时候<strong>修改缓存数据</strong>。</p>
<p><img src="./http-cache-multiple/http-cache-1-5.png" alt="http-cache"></p>
<h3 id="Timer-修改方案"><a href="#Timer-修改方案" class="headerlink" title="Timer 修改方案"></a>Timer 修改方案</h3><p>为了<strong>避免耦合</strong>，<strong>降低复杂性</strong>，对“实时一致性”不敏感的情况下。每个应用都会<strong>启动一个 Timer</strong>，<strong>定时</strong>从数据库拉取最新的数据<strong>更新缓存</strong>。</p>
<p>不过在有的应用更新数据库后，其他节点通过 Timer 获取数据之间，会读到脏数据。这里需要控制好 Timer 的频率，以及应用与对实时性要求不高的场景。</p>
<p><img src="./http-cache-multiple/http-cache-1-11.png" alt="http-cache"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>场景一</strong>：<strong>只读数据</strong>，可以考虑在进程启动时加载到内存。当然，把数据加载到类似 Redis 这样的进程外缓存服务也能解决这类问题。</p>
</li>
<li><p><strong>场景二</strong>：<strong>高并发</strong>，可以考虑使用进程内缓存，例如：秒杀。</p>
</li>
</ul>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>说完进程内缓存，自然就过度到<strong>进程外缓存</strong>了。与进程内缓存不同，进程外缓存在应用运行的进程之外，它拥有<strong>更大的缓存容量</strong>，并且可以部署到<strong>不同的物理节点</strong>，通常会用<strong>分布式缓存</strong>的方式实现。</p>
<p>分布式缓存是与应用分离的缓存服务，最大的特点是，自身是一个独立的应用/服务，与本地应用隔离，<strong>多个应用可直接共享一个或者多个缓存应用/服务</strong>。</p>
<p><img src="./http-cache-multiple/http-cache-1-6.png" height="300" alt="http-cache"></p>
<p>既然是分布式缓存，缓存的数据会分布到不同的缓存节点上，每个缓存节点缓存的数据大小通常也是<strong>有限制</strong>的。</p>
<p>数据被缓存到不同的节点，为了能方便的访问这些节点，需要引入<strong>缓存代理</strong>，类似 Twemproxy。他会帮助请求找到对应的缓存节点。</p>
<p>同时如果缓存节点增加了，这个代理也会只能识别并且把新的缓存数据分片到新的节点，做横向的扩展。</p>
<p>为了<strong>提高缓存的可用性</strong>，会在原有的缓存节点上加入 <strong>Master/Slave 的设计</strong>。当缓存数据写入 <strong>Master 节点</strong>的时候，会<strong>同时同步</strong>一份到 <strong>Slave 节点</strong>。</p>
<p>一旦 <strong>Master</strong> 节点失效，可以通过代理直接切换到 <strong>Slave</strong> 节点，这时 <strong>Slave 节点就变成了 Master 节点</strong>，保证缓存的正常工作。</p>
<p>每个缓存节点还会提供缓存过期的机制，并且会把缓存内容定期以快照的方式保存到文件上，方便缓存崩溃之后启动预热加载。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>当缓存做成分布式的时候，数据会根据一定的规律分配到每个缓存应用/服务上。</p>
<p>如果我们把这些<strong>缓存应用/服务叫做缓存节点</strong>，每个节点一般都可以<strong>缓存一定容量的数据</strong>，例如：Redis 一个节点可以缓存 2G 的数据。</p>
<p>如果需要缓存的数据量比较大就需要扩展多个缓存节点来实现，这么多的缓存节点，客户端的请求不知道访问哪个节点怎么办？缓存的数据又如何放到这些节点上？</p>
<p>缓存代理服务已经帮我们解决这些问题了，例如：Twemproxy 不但可以帮助缓存路由，同时可以管理缓存节点。</p>
<p>这里有介绍三种缓存数据分片的算法，有了这些<strong>算法缓存代理</strong>就可以方便的找到分片的数据了。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p><code>Hash</code> 表是最常见的数据结构，实现方式是，对数据记录的<strong>关键值</strong>进行 <code>Hash</code>，然后再对需要分片的缓存节点个数进行取模得到的余数进行数据分配。</p>
<p>例如：有三条记录数据分别是 <code>R1，R2，R3</code>。他们的 ID 分别是 <code>01，02，03</code>，假设对这三个记录的 ID 作为关键值进行 Hash 算法之后的结果依旧是 <code>01，02，03</code>。</p>
<p>我们想把这三条数据放到三个缓存节点中，可以把这个结果分别对 3 这个数字取模得到余数，这个余数就是这三条记录分别放置的缓存节点。</p>
<p><img src="./http-cache-multiple/http-cache-1-7.png" alt="http-cache"></p>
<p><strong>Hash 算法是某种程度上的平均放置，策略比较简单，如果要增加缓存节点，对已经存在的数据会有较大的变动。</strong></p>
<h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p>一致性 <code>Hash</code> 是将数据按照特征值<strong>映射</strong>到一个*<strong>*首尾相接</strong>的 <code>Hash</code>环上，同时也将缓存节点映射到这个环上。</p>
<p>如果要缓存数据，通过数据的<strong>关键值（Key）</strong>在环上找到自己存放的位置。这些数据按照自身的 <code>ID</code> 取 <code>Hash</code> 之后得到的值按照<strong>顺序</strong>在<strong>环上排列</strong>。</p>
<p><img src="./http-cache-multiple/http-cache-1-8.png" alt="http-cache"></p>
<p>如果这个时候要<strong>插入</strong>一条新的数据其 <code>ID</code> 是 <code>115</code>，那么就应该插入到如下图的位置</p>
<p><img src="./http-cache-multiple/http-cache-1-9.png" alt="http-cache"></p>
<p>同理如果要<strong>增加</strong>一个<strong>缓存节点</strong> <code>N4 150</code>，也可以放到如下图的位置。</p>
<p><img src="./http-cache-multiple/http-cache-1-10.png" alt="http-cache"></p>
<p><strong>这种算法对于增加缓存数据，和缓存节点的开销相对比较小。</strong></p>
<h4 id="Range-Based-算法"><a href="#Range-Based-算法" class="headerlink" title="Range Based 算法"></a>Range Based 算法</h4><p>这种方式是按照关键值（例如 <code>ID</code>）将数据划分成不同的区间，每个缓存节点负责一个或者多个区间。跟一致性哈希有点像。</p>
<p>例如：存在三个缓存节点分别是 <code>N1，N2，N3</code>。他们用来存放数据的区间分别是，<code>N1(0, 100]</code>， <code>N2(100, 200]</code>， <code>N3(300, 400]</code>。</p>
<p>那么数据根据自己 <code>ID</code> 作为关键字做 <code>Hash</code> 以后的结果就会分别对应放到这几个区域里面了。</p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>根据事物的两面性，在<strong>分布式缓存带来高性能</strong>的同时，我们也需要重视它的可用性。那么哪些潜在的风险是我们需要防范的呢？</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>当<strong>缓存失效</strong>，<strong>缓存过期被清</strong>除，缓存<strong>更新</strong>的时候。请求是<strong>无法命中缓存</strong>的，这个时候请求会直接<strong>回源到数据库</strong>。</p>
<p>如果上述情况<strong>频繁发生</strong>或者<strong>同时发生</strong>的时候，就会造成大面积的<strong>请求直接到数据库</strong>，造成<strong>数据库访问瓶颈</strong>。我们称这种情况为<strong>缓存雪崩</strong>。</p>
<p>从如下两方面来思考解决方案：</p>
<p>缓存方面：</p>
<ul>
<li><p><strong>避免缓存同时失效，不同的 key 设置不同的超时时间</strong>。</p>
</li>
<li><p>增加<strong>互斥锁</strong>，<strong>对缓存的更新操作进行加锁保护，保证只有一个线程进行缓存更新</strong>。缓存一旦失效可以通过缓存快照的方式迅速重建缓存。对缓存节点增加主备机制，当主缓存失效以后切换到备用缓存继续工作。</p>
</li>
</ul>
<p>设计方面，这里给出了几点建议供大家参考</p>
<ul>
<li><strong>熔断机制</strong>：某个缓存节点<strong>不能工作</strong>的时候，需要通知<strong>缓存代理不要</strong>把请求路由到该节点，减少用户等待和请求时长。</li>
<li><strong>限流机制</strong>：在<strong>接入层和代理层可以做限流</strong>，当缓存服务无法支持高并发的时候，前端可以把无法响应的请求放入到队列或者丢弃。</li>
<li><strong>隔离机制</strong>：<strong>缓存无法提供服务或者正在预热重建的时候</strong>，把该请求放入队列中，这样该请求因为被隔离就不会被路由到其他的缓存节点。</li>
<li>如此就不会因为这个节点的问题影响到其他节点。当缓存重建以后，再从队列中取出请求依次处理。</li>
</ul>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存一般是 <code>Key</code>，<code>Value</code> 方式存在，一个 <code>Key</code> 对应的 <code>Value</code> 不存在时，请求会回源到数据库。</p>
<p>假如对应的 <code>Value</code> 一直不存在，则会频繁的请求数据库，对数据库造成访问压力。如果有人利用这个漏洞攻击，就麻烦了。</p>
<p>解决方法：如果一个 <code>Key</code> 对应的 <code>Value</code> 查询返回为空，我们仍然把这个空结果缓存起来，如果这个值没有变化下次查询就不会请求数据库了。</p>
<p>将所有可能存在的数据哈希到一个足够大的 <code>Bitmap</code> 中，那么不存在的数据会被这个 <code>Bitmap</code> 过滤器拦截掉，避免对数据库的查询压力。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>在数据请求的时候，某一个缓存<strong>刚好失效或者正在写入缓存</strong>，同时这个缓存数据可能会在<strong>这个时间点被超高并发请求</strong>，成为“热点”数据。</p>
<p>这就是缓存击穿问题，这个和缓存雪崩的区别在于，这里是<strong>针对某一个缓存</strong>，前者是针对多个缓存。</p>
<p>解决方案：导致问题的原因是在同一时间读/写缓存，所以<strong>只有保证同一时间只有一个线程写</strong>，写完成以后，其他的请求再使用缓存就可以了。</p>
<p>比较常用的做法是使用 <strong>mutex（互斥锁）</strong>。在缓存失效的时候，不是立即写入缓存，而是先设置一个<code>**mutex（互斥锁）**</code>。当缓存被写入完成以后，再放开这个锁让请求进行访问。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多层缓存结构：</p>
<p><strong>缓存结构</strong>大致分为如下：</p>
<ul>
<li><strong>客户端/浏览器缓存</strong></li>
<li><strong>http/服务器缓存</strong></li>
<li><strong>cdn 缓存</strong></li>
<li><strong>代理服务器缓存</strong></li>
<li><strong>后端进程缓存 redis、lru 等等</strong></li>
<li><strong>分布式缓存</strong></li>
<li><strong>数据库</strong></li>
</ul>
<p>其中，前两种缓存静态数据，后三种缓存动态数据：</p>
<ul>
<li><strong>HTTP 缓存包括强缓存（缓存策略）和协商缓存</strong>。</li>
<li><strong>CDN 缓存和 HTTP 缓存是好搭档</strong>。</li>
<li><strong>负载均衡器缓存相对稳定资源，需要服务协助工作</strong>。</li>
<li><strong>进程内缓存，效率高，但容量有限制，有两个方案可以应对缓存同步的问题</strong>。</li>
<li><strong>分布式缓存容量大，能力强，牢记三个性能算法并且防范三个缓存风险</strong>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.im/post/5d86cf7f6fb9a06b211724e7?utm_source=gold_browser_extension#heading-13" target="_blank" rel="noopener">一篇文章让你明白你多级缓存的分层架构</a></li>
</ul>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Http系列(-) Http发展历史</title>
    <url>/blog/network/http/http-http2.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Hyper Text Transfer Protocol（超文本传输协议）</strong>,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。</p>
<p><strong>超文本传输 ​​ 协议（HTTP）</strong>是用于传输诸如 HTML 的超媒体文档的<strong>应用层协议</strong>。它被设计用于 Web 浏览器和 Web 服务器之间的通信，但它也可以用于其他目的。<br><strong>HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。也要通过三次握手，四次挥手。</strong></p>
<p><strong>HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统</strong>。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。</p>
<p><strong>HTTP 协议工作于客户端-服务端架构为上</strong>。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="./http-http2/http2.0-1-1.png" alt="http2.0"></p>
<h2 id="HTTP-协议版本"><a href="#HTTP-协议版本" class="headerlink" title="HTTP 协议版本"></a>HTTP 协议版本</h2><p>大致版本可以分为以下四个：</p>
<ul>
<li>HTTP/0.9</li>
<li>HTTP/1.0</li>
<li>HTTP/1.1</li>
<li>HTTP/2</li>
</ul>
<p>发展的历史如下：<br><img src="./http-http2/http2.0-1-2.png" alt="http2.0"></p>
<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>HTTP 是基于 <code>TCP/IP 协议的应用层协议</code>。<strong>它不涉及数据包（packet）传输</strong>，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。<br>最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令 GET。</p>
<blockquote>
<p>GET /index.html</p>
</blockquote>
<p>上面命令表示，<strong>TCP 连接（connection）建立后</strong>，客户端向服务器请求（request）网页 index.html。协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>
<p>服务器发送完毕，就关闭 TCP 连接。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>1996 年 5 月，HTTP/1.0 版本发布，内容大大增加。<br>相对于 HTTP/0.9 大致增加了如下几点：</p>
<ul>
<li>首先，<strong>任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础</strong>。</li>
<li>其次，<strong>除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段</strong>。</li>
<li>再次，<strong>HTTP 请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据</strong>。</li>
<li>其他的新增功能还包括状态码<strong>（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）</strong>等。</li>
</ul>
<p>当时其实也存在一些别的问题如下：</p>
<ul>
<li><strong>HTTP/1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求</strong>。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</li>
<li><strong>TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）</strong>。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>1997 年 1 月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了 20 年后的今天，直到现在还是最流行的版本。</p>
<p>相对于 HTTP/1.0 版本 HTTP/1.1 做了一些优化大致如下：</p>
<ul>
<li><p><strong>长连接：</strong> <code>HTTP 1.1 支持长连接（PersistentConnection）</code>和<code>请求的流水线（Pipelining）处理</code>，在一个 TCP 连接上可以传送<code>多个 HTTP 请求和响应</code>，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中<code>默认开启 Connection： keep-alive</code>，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p>
</li>
<li><p><strong>缓存处理：</strong>在 HTTP1.0 中主要使用 header 里的<code>If-Modified-Since,Expires</code>来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如<code>Entity tag</code>，<code>If-Unmodified-Since</code>, <code>If-Match</code>, <code>If-None-Match</code>等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p><strong>带宽优化及网络连接的使用</strong>，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，<code>并且不支持断点续传功能</code>，HTTP1.1 则在请求头引入了<code>range 头域</code>，它允许只请求资源的某个部分，即返回码是<code>206（Partial Content）</code>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li><p><strong>错误通知的管理</strong>，在 HTTP1.1 中新增了<strong>24 个错误状态响应码</strong>，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p><strong>Host 头处理</strong>，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</p>
</li>
</ul>
<p>但是同时也存在一些问题如下：</p>
<ul>
<li>虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。<strong>这称为”队头堵塞”（Head-of-line blocking）</strong>。</li>
<li>HTTP1.x 在传输数据时，所有传输的内容都是<code>明文</code>，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li>
<li>HTTP1.x 在使用时，<code>header 里携带的内容过大</code>，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</li>
<li>虽然 HTTP1.x 支持了 keep-alive，来弥补多次创建连接产生的延迟，但是 keep-alive 使用多了同样会给<code>服务端带来大量的性能压力</code>，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive 可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li>
</ul>
<h2 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h2><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。<br>这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。SPDY 可以说是综合了 HTTPS 和 HTTP 两者有点于一体的传输协议，主要解决：</p>
<ul>
<li><strong>降低延迟</strong>，针对 HTTP 高延迟的问题，SPDY 优雅的采取了<code>**多路复用（multiplexing）**</code>。多路复用通过多个请求 stream 共享一个 tcp 连接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。</li>
<li><strong>请求优先级（request prioritization）</strong>。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。<code>SPDY 允许给每个 request 设置优先级</code>，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li>
<li><strong>header 压缩</strong>。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li>
<li><strong>基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性</strong>。</li>
<li><strong>服务端推送（server push）</strong>，采用了 SPDY 的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。</li>
</ul>
<p>SPDY 构成图：<br><img src="./http-http2/http2.0-1-3.png" alt="http2.0"></p>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p><code>HTTP/2</code> 可以说是 <code>SPDY</code> 的升级版（其实原本也是基于 <code>SPDY</code> 设计的），但是<code>HTTP2.0</code> 跟 <code>SPDY</code> 仍有不同的地方，主要是以下两点：</p>
<ul>
<li><code>HTTP2.0</code> 支持明文 <code>HTTP</code> 传输，而 <code>SPDY</code> 强制使用 <code>HTTPS</code></li>
<li><code>HTTP2.0</code> 消息头的压缩算法采用 <code>HPACK</code>，而非 <code>SPDY</code> 采用的 <code>DEFLATE</code></li>
</ul>
<p>HTTP/2 的新特性:</p>
<ul>
<li>二进制分帧：<code>HTTP/2</code> 的所有帧都采用二进制编码</li>
<li>多路复用 (<code>Multiplexing</code>)</li>
<li>请求优先级</li>
<li><code>header</code> 压缩</li>
<li>服务端推送</li>
</ul>
<h3 id="二进制分帧：HTTP-2-的所有帧都采用二进制编码"><a href="#二进制分帧：HTTP-2-的所有帧都采用二进制编码" class="headerlink" title="二进制分帧：HTTP/2 的所有帧都采用二进制编码"></a>二进制分帧：HTTP/2 的所有帧都采用二进制编码</h3><p>先理解几个概念：</p>
<ul>
<li><strong>帧</strong>：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。</li>
<li><strong>消息</strong>：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li>
<li><strong>流</strong>：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；</li>
</ul>
<p>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</strong><br><img src="./http-http2/http2.0-1-4.png" alt="http2.0"></p>
<h4 id="帧、流、消息的关系"><a href="#帧、流、消息的关系" class="headerlink" title="帧、流、消息的关系"></a>帧、流、消息的关系</h4><p><strong>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成</strong>。<br><strong>帧是流中的数据单位。一个数据报的 header 帧可以分成多个 header 帧，data 帧可以分成多个 data 帧。</strong></p>
<h3 id="多路复用-Multiplexing"><a href="#多路复用-Multiplexing" class="headerlink" title="多路复用 (Multiplexing)"></a>多路复用 (Multiplexing)</h3><p><strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息</strong>。即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。多路复用原理图：<br><img src="./http-http2/http2.0-1-5.png" alt="http2.0"></p>
<h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><ul>
<li>把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。</li>
<li>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。</li>
<li>HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。</li>
</ul>
<h3 id="header-压缩"><a href="#header-压缩" class="headerlink" title="header 压缩"></a>header 压缩</h3><p>HTTP1.x 的 header 带有大量信息，而且每次都要<strong>重复发送</strong>，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自<strong>cache 一份 header fields 表</strong>，既<code>避免了重复 header 的传输</code>，又<code>减小了需要传输的大小</code>。<br>为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略：</p>
<ul>
<li><strong>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，不再重复发送 header</strong></li>
<li><strong>首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</strong></li>
<li><strong>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值</strong></li>
</ul>
<p>两次请求不相同的 header，传说的 header 如下图所示：<br><img src="./http-http2/http2.0-1-10.png" alt="http2.0"></p>
<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p><strong>Server Push 即服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”</strong>。<br>服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求，服务端可以提前给客户端推送必要的资源，这样可以减少请求延迟时间，例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不是等到 HTML 解析到资源时发送请求，大致过程如下图所示：<br><img src="./http-http2/http2.0-1-11.png" alt="http2.0"></p>
<p>注意：<br><strong>所有推送的资源都遵守同源策略</strong>。<br><strong>服务器必须遵循请求- 响应的循环，只能借着对请求的响应推送资源</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 http/0.9 到 http/2 的发展，有了很多的优化点如下：</p>
<ul>
<li>二进制分帧：HTTP/2 的所有帧都采用二进制编码</li>
<li>多路复用 (Multiplexing)</li>
<li>请求优先级</li>
<li>header 压缩</li>
<li>服务端推送<br>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用<code>二进制编码</code>，HTTP/2 的通过支持请求与响应的<code>多路复用</code>来减少延迟，通过<code>压缩 HTTP 首部字段</code>将协议开销降至最低，同时增加对<code>请求优先级</code>和<code>服务器端推送</code>的支持。<br>在上面也分别描述的大致优化的细节，后面会有一个专门来讲从多个 Tcp 请求到多路复用的发展。<!-- 在HTTP/2中优化在对请求做了很多优化主要是多路复用，各个版本对比大致如下：
**HTTP/0.9**
<img src="../../images/http/http2.0-1-6.png" alt="http2.0" width="50%"/>
上图：连接无法复用
**HTTP/1.0**
<img src="../../images/http/http2.0-1-7.png" alt="http2.0" width="50%"/>
上图：设置Connection:Keep-Alive，保持连接在一段时间内不断开。
**HTTP/1.1**
<img src="../../images/http/http2.0-1-8.png" alt="http2.0" width="50%"/>
上图：HTTPpipelining：建立多个连接
**HTTP/2**
<img src="../../images/http/http2.0-1-9.png" alt="http2.0" width="50%"/>
上图：多路复用 -->
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/fwRzZ8RWouyAhBiYDe9M7w" target="_blank" rel="noopener">HTTP 协议入门</a><br><a href="https://mp.weixin.qq.com/s/x-KE9B3s6GyJbS-T3oya4w" target="_blank" rel="noopener">HTTP,HTTP2.0,SPDY,HTTPS 你应该知道的一些事</a><br><a href="https://mp.weixin.qq.com/s/0m4R31gSV-DfY_-VOSb_jA" target="_blank" rel="noopener">http2.0 的时代真的来了…</a></p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Http2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Https系列（二） https怎么建立连接的 （未完成）</title>
    <url>/blog/network/https/http-https.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Https</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>Https系列 (一) https和http的区别</title>
    <url>/blog/network/https/https.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Https</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript类型转换（一） 常见数据类型</title>
    <url>/blog/javascript/type/javascript-Type-conversion.html</url>
    <content><![CDATA[<p><strong><em>莫逆于心，遂相与为友。——庄子</em></strong></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>JavaScript 中的内置类型，七中类型中的又分为两大类：<strong>基本类型（值类型）和引用类型</strong><br>基本类型有六种：<strong>null</strong>、<strong>number</strong>、<strong>string</strong>、<strong>undefined</strong>、<strong>boolean</strong>、<strong>symbol</strong><br>引用类型：<strong>object</strong><br>所有基本类型的值都是<strong>不可改变</strong>的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。<br>变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p>
<p><strong>基本类型</strong> 是储存在<code>栈</code>中<br><strong>引用类型</strong> 引用数据类型的<code>值</code>是保存在<code>堆内存</code>中的对象。JavaScript<code>不允许</code>直接访问堆内存中的位置，堆内存中的<code>值地址引用</code>保存在<code>栈</code>中，我们都是操作<code>栈中</code>的地址引用。</p>
<p><strong>如果想看数据结构如堆、栈、链表等等，可以在本站搜索。</strong></p>
<p>如下图所示：</p>
<p><img src="../../../images/javascript/javascript-type.png" alt="javascript-type" width="60%" style="margin: 0 auto;"></p>
<p>如果不知道怎么判断数据类型的请看另一篇文章 <a href="/blog/javascript/type/javascript-bool-type.html">JavaScript 类型判断</a></p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>像基本类型如果<strong>String、Boolean、Number</strong>我们就不细写了，讲一下里面比较特殊的。如 <strong>null、undefined、NaN、symbol</strong>等等。</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>值<code>null</code>是一个字面量，他不像<strong>undefined</strong>是一个<strong>全局对象</strong>的一个<strong>属性</strong>。<strong>null</strong>是表示缺少的标识，知识变量未被指向任何对象，也可以看做是一个<strong>空指针对象</strong>。</p>
<p>如果我们在浏览器中赋值 <strong>null</strong>,他会报错如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chrome Google Chrome 已是最新版本</span></span><br><span class="line"><span class="comment">// 版本 75.0.3770.100（正式版本） （64 位）</span></span><br><span class="line"><span class="literal">null</span> = <span class="string">'111'</span>;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>
<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p><strong>undefined</strong>它是一个 JavaScript<strong>基本类型</strong>。它也是一个<strong>全局的属性</strong>undefined 表示 undefined，undefined 也可以表示一个被<strong>声明</strong>没有被<strong>赋值</strong>的<strong>变量</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">undefined 属性的属性特性：</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">writable</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">enumerable</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">configurable</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
<p>在现代浏览器<code>（JavaScript 1.8.5/Firefox 4+）</code>，自 <code>ECMAscript5</code> 标准以来 <code>undefined</code> 是一个不能被配置<code>（non-configurable）</code>，<code>不能被重写（non-writable）的属性</code>。即便事实并非如此，也要避免去重写它。</p>
<p>如果我们在浏览器中赋值 <strong>undefined</strong>, 因为他的 <code>writable</code> 是为 <code>false</code>,所以我们的赋值没有生效，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chrome Google Chrome 已是最新版本</span></span><br><span class="line"><span class="comment">// 版本 75.0.3770.100（正式版本） （64 位）</span></span><br><span class="line"><span class="literal">undefined</span> = <span class="string">'111'</span>;</span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><strong>全局属性</strong> <code>NaN</code> 的值表示<strong>不是</strong>一个数字（Not-A-Number），<code>NaN</code>是一种特殊的<code>Number</code>类型.<br><code>NaN</code> 属性的初始值就是 <code>NaN</code>，和 <code>Number.NaN</code> 的值一样。在现代浏览器中（ES5 中），<code>NaN</code> 属性是一个不可配置（non-configurable），不可写<code>（non-writable）</code>的属性。但在 ES3 中，这个属性的值是可以被更改的，但是也应该避免覆盖。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>NaN</strong> 属性的属性特性：</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">writable</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">enumerable</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">configurable</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
<p>如果我们在浏览器中赋值 <strong>NaN</strong>, 因为他的<code>writable</code>是为<code>false</code>,所以我们的赋值没有生效，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chrome Google Chrome 已是最新版本</span></span><br><span class="line"><span class="comment">// 版本 75.0.3770.100（正式版本） （64 位）</span></span><br><span class="line"><span class="literal">NaN</span> = <span class="string">'111'</span>;</span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>判断 NaN</strong><br>我们必须使用 <strong>Number.isNaN()</strong> 或 <strong>isNaN()</strong> 函数和比较中<strong>不等于</strong>它<strong>自己</strong>来判断是否为 NaN，为什么 NaN 不等于 NaN 自己，这是因为 NaN 它使表示一个<strong>集合</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p>这个技术术语页面同时描述了一种称为 “<strong>symbol</strong>” 的数据类型，还有一个像类的函数 “<strong>Symbol()</strong>”，用来创建 <strong>symbol</strong> 数据类型实例。</p>
<p>数据类型 “<strong>symbol</strong>” 是一种原始数据类型，该类型的性质在于这个类型的值可以用来创建匿名的对象属性。该数据类型通常被用作一个对象属性的键值——当你想让它是私有的时候。<br><code>Symbol</code> 是 JavaScript 的 原始数据类型 ，Symbol 实例是唯一且不可改变的.<br>符号类型是唯一的并且是不可修改的, 并且也可以用来作为 Object 的 key 的值(如下). 在某些语言当中也有类似的原子类型(Atoms).<br>我们只能通过<code>Symbol(&#39;ssss&#39;)</code>声明<code>symbol</code>，不能通过<code>new</code>声明<code>Symbol</code>.</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在计算机科学中, 对象是指内存中的可以被 标识符引用的一块区域.<br>在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。<br>ECMAScript 定义的对象中有两种属性：数据属性和访问器属性。</p>
<p><strong>数据属性</strong><br>数据属性的特性(Attributes of a data property)</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[[Value]]</td>
<td style="text-align:center">任何 Javascript 类型</td>
<td style="text-align:center">包含这个属性的数据值。</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">[[Writable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 false，则该属性的 [[Value]] 特性 不能被改变。</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">[[Enumerable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 true，则该属性可以用 for…in 循环来枚举。</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">[[Configurable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 false，则该属性不能被删除，并且 除了 [[Value]] 和 [[Writable]] 以外的特性都不能被改变。</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<p>还有一些过时的数据属性<strong>Read-only</strong>、<strong>DontEnum</strong>、<strong>DontDelete</strong><br><strong>访问器属性</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[[Get]]</td>
<td style="text-align:center">函数对象或者 undefined</td>
<td style="text-align:center">该函数使用一个空的参数列表，能够在有权访问的情况下读取属性值。另见 get。</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">[[Set]]</td>
<td style="text-align:center">函数对象或者 undefined</td>
<td style="text-align:center">该函数有一个参数，用来写入属性值，另见 set。</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">[[Enumerable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 true，则该属性可以用 for…in 循环来枚举。</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">[[Configurable]]</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果该值为 false，则该属性不能被删除，并且 除了 [[Value]] 和 [[Writable]] 以外的特性都不能被改变。</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>注意：这些特性只有 JavaScript 引擎才用到，因此你不能直接访问它们。所以特性被放在两对方括号中，而不是一对。</li>
</ul>
</blockquote>
<h4 id="“标准的”-对象-和函数"><a href="#“标准的”-对象-和函数" class="headerlink" title="“标准的” 对象, 和函数"></a>“标准的” 对象, 和函数</h4><p><strong>对象</strong><br>一个 Javascript 对象就是键和值之间的映射.。键是一个字符串（或者 Symbol） ，值可以是任意类型的值。 这使得对象非常符合 哈希表。<br><strong>函数</strong><br>函数是一个附带可被调用功能的常规对象。<br><strong>日期</strong><br>当你想要显示日期时，毋庸置疑，使用内建的 Date 对象。<br><strong>数组和类型数组</strong><br>数组是一种使用整数作为键(integer-key-ed)属性和长度(length)属性之间关联的常规对象。<br>Int8Array、Uint8Array、Uint8ClampedArray 、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array、Float64Array<br><strong>键控集: Maps, Sets, WeakMaps, WeakSets</strong><br>Map, Set, WeakMap, WeakSet</p>
<h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>JavaScript 是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。这意味着我们不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="string">'one'</span>; <span class="comment">// one is a String now</span></span><br><span class="line">one = <span class="number">456</span>; <span class="comment">// one is a Number now</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。<br>JavaScript 中的内置类型，七中类型中的又分为两大类：基本类型（值类型）和引用类型</p>
<p>基本类型有六种：<strong>null</strong>、<strong>number</strong>、<strong>string</strong>、<strong>undefined</strong>、<strong>boolean</strong>、<strong>symbol</strong><br>引用类型：<strong>object</strong></p>
<p>所有基本类型的值都是<strong>不可改变</strong>的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。</p>
<p><strong>基本类型</strong> 是储存在<code>栈</code>中</p>
<p><strong>引用类型</strong> 引用数据类型的<code>值</code>是保存在<code>堆内存</code>中的对象。JavaScript<code>不允许</code>直接访问堆内存中的位置，堆内存中的<code>值地址引用</code>保存在<code>栈</code>中，我们都是操作<code>栈中</code>的地址引用。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>http-fetch现在新的fetch请求方法</title>
    <url>/blog/network/fetch/http-fetch.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Http</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>基于tcp的socket</title>
    <url>/blog/network/socket/http-socket.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Http</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是尾递归？ 尾递归和普通的递归的区别</title>
    <url>/blog/algorithm/other/algorithm-other-tailCall.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先解释什么是<code>尾递归</code>和<code>尾调用</code>，后面再来解释什么是<code>斐波拉契数列</code>，怎么用<code>JavaScript</code>实现<code>斐波拉契数列</code>，尾递归和它有什么关联。<br>本文文章大致章节如下：</p>
<ul>
<li>理解调用栈</li>
<li>什么是尾调用和尾调用优化</li>
<li>什么是尾递归</li>
<li>什么是斐波拉契数列</li>
</ul>
<p>通过上面的几个章节一步一步加深理解。</p>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>首先要了解什么是<code>调用栈</code>，后面才能更好的了解<code>尾递归</code>和<code>尾调用</code>。</p>
<p><strong>调用栈</strong>是<strong>解释器（就像浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制</strong>。简单来说就是能够通过<code>调用栈</code>追踪到那个函数正在执行，执行的函数中又调用了那个函数。可能这样说还是不太具体，我们可以把它更具体一下。</p>
<p>首先引入一个概念：<code>栈帧</code>，<strong>栈帧</strong>是指一个函数调用单独分配的那部<strong>分栈空间</strong>。<code>栈帧</code>中有两种比较重要的帧<code>当前帧</code>、<code>调用帧</code>，先看一张图：</p>
<p><img src="./algorithm-other-tailCall/algorithm-1-1.png" alt="algorithm-tailCall"></p>
<p>当运行中的程序<code>调用另一个函数时</code>，就要进入一个<code>新的栈帧</code>，<code>原来函数</code>的栈帧称为<code>调用者的帧</code>，<code>新的栈帧</code>称为<code>当前帧</code>。<br>那么<code>调用栈</code>大致是怎么执行的呢？大致步骤如下：</p>
<ul>
<li>每调用一个函数，解释器就会把该函数添加进<code>调用栈</code>并开始执行。</li>
<li>正在<code>调用栈</code>中<strong>执行的函数(调用者帧)</strong>还<code>调用了其它函数</code>，那么<code>新函数(当前帧)</code>也将会被<code>添加进调用栈</code>，一旦这个函数被调用，便会立即执行。</li>
<li><code>新函数(当前帧)</code>执行完毕后，解释器将其<code>清出调用栈</code>，继续执行<strong>执行的函数(调用者帧)</strong>环境下的剩余的代码。</li>
<li>当分配的<code>调用栈空间</code>被占满时，会引发<code>“堆栈溢出”(递归爆栈)</code>。</li>
</ul>
<p>在线代码体验<a href="https://codepen.io/njmcode/pen/dMPmGq" target="_blank" rel="noopener">调用栈执行过程</a>，如果访问比较慢可以看<a href="https://github.com/Braveheartforyou/Blog-Static/tree/master/callStack" target="_blank" rel="noopener">调用栈执行过程 demo</a>把代码下载到本地运行查看。</p>
<p>执行效果大致如下：<br><img src="./algorithm-other-tailCall/algorithm-1-3.png" alt="algorithm-tailCall"><br>因为 gif 文件过大，就放一张图片好了。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>我们也可以通过<code>chrome</code>中的控制台，通过<code>console.trace()</code>来追踪当前的调用栈，如下图所示：<br><img src="./algorithm-other-tailCall/algorithm-1-2.png" alt="algorithm-tailCall"></p>
<p>或者通过在代码中<code>打断点调试</code>看到当前调用栈：<br><img src="./algorithm-other-tailCall/algorithm-1-4.png" alt="algorithm-tailCall"></p>
<p>其实<code>调用栈</code>和<code>事件轮询(event loop)</code>有很大的关联，如果对<code>事件轮询(event loop)</code>有兴趣的话看我另一篇文章<a href="/blog/javascript/eventloop/evenloop.html">事件轮询/事件模型</a>。</p>
<h2 id="尾调用和尾调用优化"><a href="#尾调用和尾调用优化" class="headerlink" title="尾调用和尾调用优化"></a>尾调用和尾调用优化</h2><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p><code>尾调用</code>是函数式编程中一个很重要的概念，当一个<code>函数执行时</code>的<code>最后一个步骤</code>是返回<code>另一个函数</code>的<code>调用</code>，这就叫做<code>尾调用</code>。<br>什么样算尾调用，什么不算尾调用呢？</p>
<p>注意这里函数的调用方式是无所谓的，以下方式均可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">函数调用:     func(···)</span><br><span class="line">方法调用:     obj.method(···)</span><br><span class="line">call调用:     func.call(···)</span><br><span class="line">apply调用:    func.apply(···)</span><br></pre></td></tr></table></figure>
<p>并且只有下列表达式会包含尾调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">条件操作符:      ? :</span><br><span class="line">逻辑或:         ||</span><br><span class="line">逻辑与:         &amp;&amp;</span><br><span class="line">逗号:           ,</span><br></pre></td></tr></table></figure>
<p><strong>不是尾调用</strong>的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不是尾调用 调用函数后还有复制操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notCallStack</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = otherFunc(name);</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是尾调用 调用函数后还有拼接操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notCallStack</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> otherFunc(name) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g()有可能是尾调用，f()不是</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="function">(<span class="params">x</span>) =&gt;</span> (x ? f() : g());</span><br></pre></td></tr></table></figure>
<p><strong>是尾调用</strong>的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾调用正确示范1.0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾调用正确示范2.0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是<code>尾调用</code>，下面我们就可以通过<code>尾调用</code>去优化执行栈的调用过程。</p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>函数在调用的时候会在<code>调用栈（call stack）</code>中存有记录，每一条记录叫做一个<code>调用帧（call frame）</code>，每调用一个函数，就向栈中<code>push</code>一条记录，函数执行结束后<code>依次向外弹出</code>，直到<code>清空调用栈</code>，参考下图：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  two();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  three();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line">one();</span><br></pre></td></tr></table></figure>
<p>执行过程如下下图所示：</p>
<p><img src="./algorithm-other-tailCall/algorithm-1-5.png" alt="algorithm-tailCall"></p>
<p>我们在一个函数中调用另一个函数，但是并没有通过<code>return</code>来结束当前函数的执行，<code>JS引擎</code>会认为当前的函数并没有执行完成，会在执行当前函数调用的函数，等他执行完成才会释放当前函数。</p>
<ul>
<li><code>one函数</code>执行时，会把<code>one函数</code>添加进<code>调用栈</code>中，<code>one函数</code>现在为<code>当前帧</code>。</li>
<li>在<code>one函数</code>中又调用了<code>two函数</code>，当时在调用<code>two函数</code>时没有<code>return</code>，所以会把<code>two函数</code>添加进<code>调用栈</code>。现在<code>one函数</code>为<code>调用者帧</code>，而<code>two函数</code>为<code>当前帧</code></li>
<li>在<code>two函数</code>中又调用<code>three函数</code>，执行过程与<code>two函数</code>执行相同。</li>
<li>当<code>three函数</code>执行完成时（默认返回 undefined），<code>three函数</code>就会被<code>调用栈</code>弹出并且被销毁。再在后面逐步销毁<code>two函数</code>、<code>one函数</code>，到此<code>调用栈为空</code>。</li>
</ul>
<p>下面通过尾调用优化，修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">“use strict”;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> two();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> three();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">one();</span><br></pre></td></tr></table></figure>
<p>执行效果如下图所示：</p>
<p><img src="./algorithm-other-tailCall/algorithm-1-6.png" alt="algorithm-tailCall"></p>
<ul>
<li><code>one函数</code>执行时，会把<code>one函数</code>添加进<code>调用栈</code>中，<code>one函数</code>现在为<code>当前帧</code>。</li>
<li>在<code>one函数</code>中又调用了<code>two函数</code>，当时在调用<code>two函数</code>添加了<code>return</code>，<code>调用栈</code>会把<code>one函数</code>弹出，当前<code>调用栈</code>中只有一个<code>two函数</code>。</li>
<li>在<code>two函数</code>中又调用<code>three函数</code>，因为有<code>return</code>当前<code>调用栈</code>中只有<code>three函数</code>。</li>
<li>当<code>three函数</code>执行完成后，<code>调用栈</code>弹出<code>three函数</code>，此时<code>调用栈</code>当前为空。</li>
</ul>
<blockquote>
<p>注意： 无论是通过<code>console.trace()</code>,还是通过<code>chrome</code>断点查看<code>call stack</code>都并没有改变<code>调用栈</code>，意思就是和上面的一样，应该是<code>chrome</code>禁止了尾调用优化。(暂无找到原因–我佛了)<br>safari 中是好的</p>
</blockquote>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p><strong>递归</strong></p>
<p>递归是指在<code>函数</code>的定义中使用<code>函数自身</code>的一种方法。<code>函数调用自身</code>即称为递归。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个死循环，会造成页面或者进程假死，也就是堆栈溢出。</p>
<p><strong>尾递归</strong></p>
<p>当一个函数在最后调用自身就叫做<strong>尾递归</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尾调用优化只在严格模式下有效。<br>尾调用优化后，每次 return 的内层函数的调用记录会取代外层函数的调用记录，调用栈中始终只保持了一条调用帧。</p>
</blockquote>
<h3 id="尾递归作用"><a href="#尾递归作用" class="headerlink" title="尾递归作用"></a>尾递归作用</h3><p>比如我们要实现一个阶加，可以用尾递归实现，下面直接上代码。</p>
<p>环境<code>chrome 78.0.3904.70</code>，硬件<code>mac pro 16G i5</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">  <span class="keyword">return</span> num + factorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">factorial(<span class="number">4</span>); <span class="comment">// 24</span></span><br><span class="line">factorial(<span class="number">20</span>); <span class="comment">// 2432902008176640000</span></span><br><span class="line">factorial(<span class="number">100000</span>); <span class="comment">//  Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<p>根据我们上面知道调用栈的知识，如果我们传入一下<code>100000</code>，它在执行过程中它会把<code>每次执行</code>的函数添加进<code>调用栈</code>，只有在<code>最后被调用的函数执行完成</code>，才会把调用栈中的函数一个个<code>弹出和销毁</code>。<code>100000</code>个函数已经超出了浏览器最大的内存范围了，所以会造成栈溢出错误。</p>
<p>即使加上<code>&quot;use strict&quot;;</code>也还是会报错。</p>
<blockquote>
<p><code>尾调用优化</code>和<code>尾递归</code>在<code>firfox</code>和<code>chrome</code>中会报错，<code>safari</code>在<code>尾优化不会报错</code>但是<code>尾递归还是会报错</code>。<br>如果真的想感受尾优化的威力可以去<code>node v.6.x</code>版本中通过<code>--harmony_tailcalls参数</code>，<code>node</code>新的版本并已经移除了这个参数</p>
</blockquote>
<h2 id="斐波拉契数列"><a href="#斐波拉契数列" class="headerlink" title="斐波拉契数列"></a>斐波拉契数列</h2><blockquote>
<p><code>斐波那契数列（Fibonacci sequence）</code>，又称<code>黄金分割数列</code>、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p>
</blockquote>
<p>简单的说，斐波那契数列中的<code>每一项都是前两项的和</code>。<br>即<code>F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;2，n∈N*）</code></p>
<h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><p>我们通过递归实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span> || num === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">  <span class="comment">// console.log(factorial(num - 1) + factorial(num - 2));</span></span><br><span class="line">  <span class="keyword">return</span> factorial(num - <span class="number">1</span>) + factorial(num - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过<code>console.trace()</code>可以看到在执行过程中，<code>调用栈</code>中最多会存在<code>4</code>个函数信息，这十个信息是每一层次调用的详细信息（如参数、局部变量、返回地址等等），以确保该层次的操作完成，这也是造成<code>栈溢出</code>的原因。</p>
<p>测试代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">factorial(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 展开来看如下</span></span><br><span class="line">factorial(<span class="number">3</span>) +</span><br><span class="line">  factorial(<span class="number">2</span>)(factorial(<span class="number">2</span>) + factorial(<span class="number">1</span>)) +</span><br><span class="line">  (factorial(<span class="number">1</span>) + factorial(<span class="number">0</span>))(factorial(<span class="number">1</span>)) +</span><br><span class="line">  factorial(<span class="number">0</span>) +</span><br><span class="line">  factorial(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="尾递归版本"><a href="#尾递归版本" class="headerlink" title="尾递归版本"></a>尾递归版本</h3><p>通过<code>尾递归来优化</code>上面的问题，其实在现在<code>浏览器</code>或者<code>node</code>中都没有作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num, num1 = <span class="number">0</span>, num2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">  <span class="keyword">return</span> factorial(num - <span class="number">1</span>, num2, num1 + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">factorial(<span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 展开显示</span></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">factorial(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">factorial(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">factorial(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">factorial(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">factorial(<span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当num-1为0时，直接返回num1</span></span><br></pre></td></tr></table></figure>
<p>可以发现当使用尾递归优化时，展开看到的<code>调用栈</code>中只会有当前执行的函数，不会储存上层的数据，这样就会减少内存的使用。<br><code>尾递归</code>的本质实际上就是将方法需要的上下文通过方法的参数传递进下一次调用之中，以达到去除上层依赖。</p>
<blockquote>
<p>chrome/firefox 测试无效，node 新版本测试无效<br>Proper tail calls have been implemented but not yet shipped given that a change to the feature is currently under discussion at TC39.意思就是人家已经做好了，但是就是还不能。</p>
</blockquote>
<h3 id="尾递归的问题"><a href="#尾递归的问题" class="headerlink" title="尾递归的问题"></a>尾递归的问题</h3><ul>
<li>首先，由于引擎<code>消除尾递归是隐式的</code>，函数是否符合尾调用而被消除了尾递归很难被程序员自己辨别。</li>
<li>其次，尾调用优化<code>要求除掉尾调用执行时的调用堆栈</code>，这将导致执行流中的<code>堆栈信息丢失</code>。</li>
</ul>
<h3 id="多种实现方式"><a href="#多种实现方式" class="headerlink" title="多种实现方式"></a>多种实现方式</h3><p><strong>循环实现</strong></p>
<p>可以通过循环实现，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    x = y;</span><br><span class="line">    y = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">factorial(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><strong>公式实现</strong></p>
<p>通过<code>Math</code>来实现，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公式法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sqrtFive = <span class="built_in">Math</span>.sqrt(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> res =</span><br><span class="line">      (<span class="built_in">Math</span>.pow(<span class="number">0.5</span> + sqrtFive / <span class="number">2</span>, n) - <span class="built_in">Math</span>.pow(<span class="number">0.5</span> - sqrtFive / <span class="number">2</span>, n)) /</span><br><span class="line">      sqrtFive;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">factorial(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p><strong>函数柯里化</strong></p>
<p>通过柯里化实现，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailCalls</span>(<span class="params">num, num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">  <span class="keyword">return</span> tailCalls(num - <span class="number">1</span>, num2, num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailCalls(num, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实上面的柯里化只能称为模仿柯里化实现。</p>
<p><strong>性能对比</strong></p>
<p>我们把<code>普通递归</code>、<code>尾递归</code>、<code>普通循环</code>、<code>公式法</code>、<code>柯里化</code>它们的性能对比。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span> || num === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> factorial(num - <span class="number">1</span>) + factorial(num - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归</span></span><br><span class="line">(<span class="string">'use strict'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailfactorial</span>(<span class="params">num, num1 = <span class="number">0</span>, num2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> factorial(num - <span class="number">1</span>, num2, num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loopfactorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    x = y;</span><br><span class="line">    y = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公式法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mathfactorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sqrtFive = <span class="built_in">Math</span>.sqrt(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> res =</span><br><span class="line">      (<span class="built_in">Math</span>.pow(<span class="number">0.5</span> + sqrtFive / <span class="number">2</span>, n) - <span class="built_in">Math</span>.pow(<span class="number">0.5</span> - sqrtFive / <span class="number">2</span>, n)) /</span><br><span class="line">      sqrtFive;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailCalls</span>(<span class="params">num, num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tailCalls(num - <span class="number">1</span>, num2, num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryfactorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailCalls(num, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line">factorial(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line">tailfactorial(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line">loopfactorial(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line">mathfactorial(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line">curryfactorial(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// default: 0.10205078125ms 普通递归</span></span><br><span class="line"><span class="comment">// default: 0.112060546875ms 尾递归</span></span><br><span class="line"><span class="comment">// default: 0.052978515625ms 循环</span></span><br><span class="line"><span class="comment">// default: 0.06591796875ms 公式</span></span><br><span class="line"><span class="comment">// default: 0.052978515625ms 柯里化</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过上面的测试，可以看到<code>递归</code>速度都是比较慢的，<code>循环</code>的速度是比较快的。</p>
<ul>
<li><strong>慎用直接递归的方式，不仅会带来极差的运行效率，同时会导致浏览器直接无响应。</strong></li>
<li><strong>尾递归</strong>有着与循环同样优秀的计算性能，使用尾递归可以同时拥有着<strong>循环的性能</strong>以及递归的数学表达能力。</li>
</ul>
<h2 id="PTC-与-STC"><a href="#PTC-与-STC" class="headerlink" title="PTC 与 STC"></a>PTC 与 STC</h2><p>ES6 标准规定了 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-preparefortailcall" target="_blank" rel="noopener">尾调用不会创建额外的调用帧</a>。<br>在严格模式下 <a href="https://v8.dev/blog/modern-javascript" target="_blank" rel="noopener">尾调用不会造成调用栈溢出</a>。<br><code>Proper Tail Calls(PTC)</code>已经实现了，但是还未部署，该功能仍然在<a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">TC39</a>标准委员会中讨论。</p>
<h3 id="PTC"><a href="#PTC" class="headerlink" title="PTC"></a>PTC</h3><p>什么是<code>Proper Tail Calls(PTC)</code>?如果有兴趣可以去看原文的解释<a href="https://webkit.org/blog/6240/ecmascript-6-proper-tail-calls-in-webkit/" target="_blank" rel="noopener">原文</a>。</p>
<blockquote>
<p>Typically when calling a function, stack space is allocated for the data associated with making a function call. This data includes the return address, prior stack pointer, arguments to the function, and space for the function’s local values. This space is called a stack frame. A call made to a function in tail position will reuse the stack space of the calling function.</p>
</blockquote>
<p>简单来说就是<strong>比如说一个递归程序，我们调用函数时，内存会帮函数分配返回地址、先前堆栈指针、内部变量参数称为 stack frame。在尾部位置对函数的调用将重用调用函数的堆栈空间。</strong></p>
<p>要触发<code>PTC</code>就要满足一下条件：</p>
<ul>
<li><code>strict mode</code>严格模式下</li>
<li>普通函数或者箭头函数</li>
<li>不能是生成器(generator)函数</li>
<li>被调用函数的返回值由调用函数返回。</li>
</ul>
<p><code>PTC</code>是能提升性能的一种策略，但是他也存在很多的限制。</p>
<p><strong>PTC</strong>存在的限制</p>
<p><strong>兼容性</strong></p>
<p>因为在推行一些新的策略或者方案是，就是标准是否支持它，也就是兼容性。标准的兼容性、浏览器的兼容性是一段很长的路。</p>
<p><strong>调试难度</strong></p>
<p>在<code>PTC</code>的实现中，许多调用帧都<code>被抛弃</code>了，导致很难再调用栈中调试他们的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bar(n * <span class="number">2</span>); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 由于尾调用优化</span></span><br><span class="line"><span class="comment">// 在Error.stack或者开发者工具中，foo的调用帧被丢掉了。</span></span><br></pre></td></tr></table></figure>
<p><strong>Error.stack</strong></p>
<p>启用<code>PTC</code>导致<code>Javascript异常</code>有了不一致的<code>error.stack</code>信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    output without PTC</span></span><br><span class="line"><span class="comment">    Error</span></span><br><span class="line"><span class="comment">        at bar</span></span><br><span class="line"><span class="comment">        at foo</span></span><br><span class="line"><span class="comment">        at Global Code</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    output with PTC (note how it appears that bar is called from Global Code)</span></span><br><span class="line"><span class="comment">    Error</span></span><br><span class="line"><span class="comment">        at bar</span></span><br><span class="line"><span class="comment">        at Global Code</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>
<h3 id="STC"><a href="#STC" class="headerlink" title="STC"></a>STC</h3><p>语义上的尾调用（<code>Syntactic Tail Call</code>）是针对上述<code>PTC</code>的问题而提出的建议。</p>
<p><code>STC</code>采用类似于 <code>return continue</code> 的语法来明确标识出要进行<code>尾调用优化</code>，而在<code>非尾调用</code>的场景下使用该语法会<code>抛出语法错误异常</code>。<br>该语法有三种实现形式：</p>
<p><strong>语法级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, acc = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">continue</span> factorial(n - <span class="number">1</span>, acc * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数级</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#function() &#123; /* all calls in tail position are tail calls */ &#125;</span><br></pre></td></tr></table></figure>
<p><strong>表达式/调用点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    !<span class="keyword">return</span> expr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本篇文章了解了什么是<code>调用栈</code>、<code>尾调用</code>、<code>尾调用</code>、<code>斐波拉切数列</code>，怎么实现<code>斐波拉切数列</code>，多种方法对比。<br>尽量少使用<code>递归</code>因为递归的比较消耗性能，虽然有<code>尾递归优化</code>但是各大浏览器都并没有部署，所以尽量使用循环来实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/entry/592e8a2d0ce463006b510b34" target="_blank" rel="noopener">JavaScript 调用栈、尾递归和手动优化</a><br><a href="https://segmentfault.com/a/1190000014747296" target="_blank" rel="noopener">尾调用优化——记一道面试题的思考</a><br><a href="https://imweb.io/topic/584d33049be501ba17b10aaf#5-1-ptc-" target="_blank" rel="noopener">朋友你听说过尾递归吗</a><br><a href="https://imweb.io/topic/5a244260a192c3b460fce275" target="_blank" rel="noopener">尾递归的后续探究</a><br><a href="https://juejin.im/post/5acdd7486fb9a028ca53547c" target="_blank" rel="noopener">尾调用和尾递归</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（一）线性表 （顺序表、链表、栈和队列）</title>
    <url>/blog/algorithm/data-structure/algorithm-structure-structure.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（二）二叉树</title>
    <url>/blog/algorithm/data-structure/algorithm-structure-tree.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（二）二叉树（先序遍历、中序遍历、后续遍历）</title>
    <url>/blog/algorithm/interview-question/algorithm-structure-for.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（二）二叉树(广度优先、深度优先)</title>
    <url>/blog/algorithm/interview-question/algorithm-structure-Depth~Breadth.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的页面性能优化</title>
    <url>/blog/monitor/perfromance/preformance-awaly.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/PDD3GxFyYptwEl0q_XaW2g" target="_blank" rel="noopener">深度系统梳理前端性能优化</a></p>
]]></content>
      <categories>
        <category>Perfromance</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Browser</tag>
        <tag>Perfromance</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中的class的babel的实现</title>
    <url>/blog/es/polyfill/es6-polyfill-class.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ECMAScript6</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Polyfill</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中的async用babel的实现</title>
    <url>/blog/es/polyfill/es6-polyfill-async.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ECMAScript6</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Polyfill</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中的for...of用babel的实现</title>
    <url>/blog/es/polyfill/es6-polyfill-for-of.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ECMAScript6</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Polyfill</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型系列（三）Function、Object、null等等的关系和鸡蛋问题</title>
    <url>/blog/javascript/prototype/javascript-prototype-two.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="./javascript-prototype-two/javascript-prototype-1-3.jpg" width="50%" alt="JavaScript-prototype"></p>
<p>基本上都知道原型链的尽头指向<code>null</code>，那么<code>Function.prototype</code>、<code>Object.prototype</code>、<code>null</code>、<code>Function.prototype.__proto__</code>、<code>Object.prototype.__proto__</code>、<code>function、object</code>之间的关系是什么，下面慢慢来记录一下。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><strong>Object</strong> 构造函数创建一个对象包装器。<strong>JavaScript</strong>中的所有对象都来自 <code>Object</code>；所有对象从<code>Object.prototype</code>继承方法和属性，尽管它们可能被覆盖。</p>
<p><strong><em>Object 作为构造函数时，其 [[Prototype]] 内部属性值指向 Function.prototype</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="./javascript-prototype-two/javascript-prototype-1-9.png" alt="JavaScript-prototype"></p>
<h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p><code>Object.prototype</code> 表示 <code>Object</code> 的原型对象，其 <code>[[Prototype]]</code> 属性是 <code>null</code>，访问器属性 <code>__proto__</code> 暴露了一个对象的内部 <code>[[Prototype]]</code> 。<code>Object.prototype</code>是浏览器底层根据 ECMAScript 规范创造的一个对象。</p>
<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>通过<strong>字面量</strong>实例化一个<code>object</code>，它的<code>__proto__</code>指向<code>Object.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>而通过<strong>new Object</strong>实例化一个<code>object</code>，它的<code>__proto__</code>指向<code>Object.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4" target="_blank" rel="noopener">摘录来自 ECMAScript 5.1 规范</a></p>
<blockquote>
<p>对象类型的成员，标准内置构造器 Function 的一个实例，并且可做为子程序被调用。<br>注： 函数除了拥有命名的属性，还包含可执行代码、状态，用来确定被调用时的行为。函数的代码不限于 ECMAScript。</p>
</blockquote>
<p><strong>Function 构造函数</strong>创建一个新的<code>Function</code>对象。在<strong>JavaScript</strong>中每个函数实际上都是一个<code>Function</code>对象。</p>
<h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p>全局的<code>Function</code>对象<strong>没有</strong>自己的属性和方法, 但是因为它本身也是<strong>函数</strong>，所以它也会通过原型链从<code>Function.prototype</code>上继承部分属性和方法。<code>Function.prototype</code>也是一个“函数对象“，其<code>[[prototype]]</code>内部属性值指向<code>Object.prototype</code>。</p>
<p>Function.prototype 的 [[Class]] 属性是 Function，所以这是一个函数，但又不大一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype; <span class="comment">// ƒ () &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.prototype; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>用 Function.prototype.bind 创建的函数对象没有 prototype 属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Function</span>.prototype.bind();</span><br><span class="line">foo.prototype; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><code>Function.prototype</code> 是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 <code>prototype</code> 属性，不然 <code>Function.prototype.prototype…</code> 将无休无止并且没有存在的意义。</p>
<p><code>Function.prototype.__proto__</code>指向<code>Object.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Function-proto"><a href="#Function-proto" class="headerlink" title="Function.proto"></a>Function.<strong>proto</strong></h3><p><code>Function</code> 构造函数是一个函数对象，其 <code>[[Class]]</code> 属性是 <code>Function</code>。<code>Function</code> 的 <code>[[Prototype]]</code> 属性指向了 <code>Function.prototype</code>，即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="./javascript-prototype-two/javascript-prototype-1-8.png" alt="JavaScript-prototype"></p>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>实例化一个<code>Function</code>，它的<code>__proto__</code>指向<code>Function.prototype</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo.__proto__ =&gt; Function.prototype =&gt; Function.prototype.__proto__ =&gt; Object.prototype =&gt; Object.prototype.__proto__ =&gt; null</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-和-Function-的鸡和蛋的问题"><a href="#Object-和-Function-的鸡和蛋的问题" class="headerlink" title="Object 和 Function 的鸡和蛋的问题"></a>Object 和 Function 的鸡和蛋的问题</h2><p>经过上面对<code>Object</code>和<code>Function</code>的阐述，延伸出来几个问题如下：</p>
<ul>
<li><p>在忽滤<code>null</code>在原型链上时，原型链的尽头（root）是<code>Object.prototype</code>。所有对象均从<code>Object.prototype</code>继承属性。<br><img src="./javascript-prototype-two/javascript-prototype-1-10.png" alt="JavaScript-prototype"></p>
</li>
<li><p><code>Function.prototype</code>和<code>Function.__proto__</code>为同一对象。<br><img src="./javascript-prototype-two/javascript-prototype-1-11.png" alt="JavaScript-prototype"><br>这意味着： <code>Object/Array/String</code>等等<strong>构造函数</strong>本质上和<code>Function</code>一样，均继承于<code>Function.prototype</code>。</p>
</li>
<li><p><code>Function.prototype</code>直接继承 root（<code>Object.prototype</code>）。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function.prototype继承了Object.prototype</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object Array Function 等等构造函数继承了Function.prototype</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过上面代码知道继承的原型链大致是： <strong>Object.prototype(root)&lt;—Function.prototype&lt;—Function|Object|Array…</strong>。</p>
<p>上面的会出现一个比较奇特的现象如下：</p>
<ul>
<li>第一问</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype;</span><br></pre></td></tr></table></figure>
<p><code>Function</code>对象是不是由<code>Function</code>构造函数创建的实例？</p>
<ul>
<li>第二问</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>为什么<code>Function instanceof Object</code>为<code>true</code>，<code>Object instanceof Function</code>也为<code>true</code>，那么他们到底是什么关系？</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>先要了解清楚<code>Function.prototype</code>和<code>Object构造函数</code>如下：<br>回归规范，摘录 2 点：</p>
<ul>
<li><code>Function.prototype</code>是个不同于一般函数（对象）的函数（对象）。</li>
</ul>
<blockquote>
<p>The Function prototype object is itself a Function object (its [[Class]] is “Function”) that, when invoked, accepts any arguments and returns undefined.<br>The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object (15.2.4). The initial value of the [[Extensible]] internal property of the Function prototype object is true.<br>The Function prototype object does not have a valueOf property of its own; however, it inherits the valueOf property from the Object prototype Object.</p>
</blockquote>
<p>上面的可以总结为：</p>
<ul>
<li><code>Function.prototype</code>像普通函数一样可以调用，但总是返回<code>undefined</code>。</li>
<li>普通函数实际上是<code>Function</code>的实例，即普通函数继承于<code>Function.prototype</code>。<code>func.__proto__ === Function.prototype</code>。</li>
<li><code>Function.prototype</code>继承于<code>Object.prototype</code>，并且没有<code>prototype</code>这个属性。<code>func.prototype</code>是普通对象，<code>Function.prototype.prototype</code>是<code>null</code>。</li>
<li><p>所以，<code>Function.prototype</code>其实是个另类的函数，可以独立于/先于 Function 产生。</p>
</li>
<li><p><code>Object</code>本身是个（构造）函数，是<code>Function</code>的实例，即<code>Object.__proto__</code>就是<code>Function.prototype</code>。</p>
</li>
</ul>
<blockquote>
<p>The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object.<br>The value of the [[Prototype]] internal property of the Object prototype object is null, the value of the [[Class]] internal property is “Object”, and the initial value of the [[Extensible]] internal property is true.</p>
</blockquote>
<h3 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h3><p><code>Function</code>对象是由<code>Function</code>构造函数创建的一个实例？</p>
<p>Yes 的部分：<br>按照 <code>JavaScript</code> 中“实例”的定义，<code>a</code> 是 <code>b</code>的实例即 <code>a instanceof b</code> 为 <code>true</code>，默认判断条件就是 <code>b.prototype</code> 在 <code>a</code> 的原型链上。而 <code>Function instanceof Function</code> 为 true，本质上即 <code>Object.getPrototypeOf(Function) === Function.prototype</code>，正符合此定义。</p>
<p>No 的部分：<br><code>Function</code> 是 <code>built-in</code> 的对象，也就是并不存在“<code>Function</code>对象由<code>Function</code>构造函数创建”这样显然会造成鸡生蛋蛋生鸡的问题。实际上，当你直接写一个函数时（如 <code>function f() {}</code> 或 <code>x =&gt; x</code>），也不存在调用 <code>Function</code> 构造器，只有在显式调用 <code>Function</code> 构造器时（如 <code>new Function(&#39;x&#39;, &#39;return x&#39;)</code> ）才有。</p>
<p>个人偏向先有的<code>Function.prototype</code>，再有的<code>function Function</code>，所有构造函数本质上都是集成于<code>Function.prototype</code><br>，所以<code>Function.__proto__ === Function.prototype</code>。</p>
<h3 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function.__proto__、Function.prototype指向同一个对象，Function.prototype.__proto__指向Object.prototype</span></span><br><span class="line"><span class="comment">// Function.__proto__ =&gt; Function.prototype.__proto__ =&gt; Object.prototype =&gt; Object.prototype.__proto__ =&gt; null</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object作为构造函数继承自Function.prototype</span></span><br><span class="line"><span class="comment">// Object.__proto__ =&gt; Function.prototype</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object作为构造函数继承自Function.prototype，Function.prototype__proto__指向Object.prototype</span></span><br><span class="line"><span class="comment">// Object.__proto__ =&gt; Function.prototype =&gt; Function.prototype.__proto__ =&gt; Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Function构造函数也是继承自Function.prototype</span></span><br><span class="line"><span class="comment">// Function.__proto__ =&gt; Function.prototype</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>总结一下：<strong>先有 <code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code> 继承 <code>Object.prototype</code> 而产生，最后，<code>Function</code> 和 <code>Object</code> 和其它构造函数继承 <code>Function.prototype</code> 而产生。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Object.prototype</code>是浏览器底层根据 <code>ECMAScript</code> 规范创造的一个对象。</li>
<li><code>Function.prototype</code>直接继承的<code>Object.prototype</code>，同样它也是由是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 <code>prototype</code> 属性。<code>Function.prototype.prototype</code>为<code>undefined</code>。</li>
<li><strong>先有 <code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code> 继承 <code>Object.prototype</code> 而产生，最后，<code>Function</code> 和 <code>Object</code> 和其它构造函数继承 <code>Function.prototype</code> 而产生。</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="noopener">MDN Object.prototype</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype" target="_blank" rel="noopener">MDN Function.prototype</a><br><a href="https://github.com/creeperyang/blog/issues/9" target="_blank" rel="noopener">从<strong>proto</strong>和 prototype 来深入理解 JS 对象和原型链</a><br><a href="https://github.com/jawil/blog/issues/13" target="_blank" rel="noopener">从探究 Function.<strong>proto</strong>===Function.prototype 过程中的一些收获</a><br><a href="https://juejin.im/post/5cb4861ff265da036504efbc#heading-5" target="_blank" rel="noopener">【进阶 5-3 期】深入探究 Function &amp; Object 鸡蛋问题</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型系列（二）什么是原型继承</title>
    <url>/blog/javascript/prototype/javascript-prototype-one.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="./javascript-prototype-one/javascript-prototype-1-3.jpg" width="50%" alt="JavaScript-prototype"></p>
<p>在上一节上面介绍了原型和原型链，即每个对象拥有一个<strong>原型对象</strong>，通过 <code>__proto__</code> 指针指向上一个<strong>原型</strong> ，并从中<strong>继承方法和属性</strong>，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>，这种关系被称为<code>原型链(prototype chain)</code>。</p>
<p><code>继承</code>是面向对象编程语言的一大核心功能点，<code>JavaScript</code>是面向对象的只不过是比较特殊的面向对象的语言。它不像<code>Java</code>是基于类的面向对象，而<code>javaScript</code>是基于<code>prototype</code>的面向对象。</p>
<p>会用一篇文章来介绍什么面向对象，<code>javascript</code>是怎么实现<code>继承</code>、<code>封装</code>、<code>多态</code>和<code>javascript</code>面向对象的特殊之处。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p><code>JavaScript</code> 对象是动态的属性“包”（指其自己的属性）。<code>JavaScript</code> 对象有一个指向一个<strong>原型对象</strong>的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，<strong>依次层层</strong>向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p>原型链继承的本质是<strong>重写原型对象，代之以一个新类型的实例</strong>。将父类的实例作为子类的原型。看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'subtype'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将父类的实例作为子类的原型</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line">sub.constructor === SubType; <span class="comment">// true</span></span><br><span class="line">Sub.prototype.constructor === SubType; <span class="comment">// true</span></span><br><span class="line">sub.name = <span class="string">'sub'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sub.getName()); <span class="comment">// sub</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>基于原型的方法所有子类都可以复用</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>多个实例对引用类型的操作会被篡改</li>
<li>子类型的原型上的 constructor 属性被重写了</li>
<li>创建子类型实例时无法向父类型的构造函数传参</li>
</ul>
<p>主要分析一下它的缺点暂时不分析它的优点。</p>
<h3 id="引用类型被修改"><a href="#引用类型被修改" class="headerlink" title="引用类型被修改"></a>引用类型被修改</h3><p>因为本质上每个实例的<code>__proto__</code>都会指向构造函数的<code>prototype</code>，实例上都是保存了一个<strong>引用地址</strong>，所以当<code>prototype</code>中的引用类型修改所有实例都会被改变。在上面代码基础上修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'subtype'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SubType.prototype.Arr = [<span class="string">'sub'</span>, <span class="string">'subtype'</span>, <span class="string">'Sub'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将父类的实例作为子类的原型</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">sub2.Arr.push(<span class="string">'push'</span>);</span><br><span class="line"></span><br><span class="line">sub1.Arr; <span class="comment">// ["sub", "subtype", "Sub", "push"]</span></span><br><span class="line">sub2.Arr; <span class="comment">// ["sub", "subtype", "Sub", "push"]</span></span><br></pre></td></tr></table></figure>
<p>在构造函数<code>SubType.prototype</code>新增<code>Arr</code>属性并且赋值为<code>[&#39;sub&#39;, &#39;subtype&#39;, &#39;Sub&#39;]</code>，通过<code>new</code>关键字实例化两个实例<code>sub1</code>、<code>sub1</code>,当修改了<code>sub2.Arr</code>的时候，<code>sub1.Arr</code>的也会被影响。</p>
<h3 id="实例-constructor-被重写"><a href="#实例-constructor-被重写" class="headerlink" title="实例 constructor 被重写"></a>实例 constructor 被重写</h3><p>子类型原型上的 <code>constructor</code> 属性被重写, 执行 <code>Sub.prototype = new SubType()</code> 后原型被覆盖，<code>Sub.prototype</code> 上丢失了 <code>constructor</code> 属性， <code>Sub.prototype</code> 指向了 <code>SubType.prototype</code>，而 <code>SubType.prototype.constructor</code> 指向了 <code>SubType</code>，所以 <code>Sub.prototype.constructor</code> 指向了 <code>SubType</code>。<br>如下图所示：<br><img src="./javascript-prototype-one/javascript-prototype-1-6.png" alt="JavaScript-prototype"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'subtype'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将父类的实例作为子类的原型</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="comment">// 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。</span></span><br><span class="line">Sub.prototype.constrcutor = Sub;</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">Sub.prototype.constrcutor === Sub; <span class="comment">// true</span></span><br><span class="line">sub.__proto__.constrcutor === Sub; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过<code>Sub.prototype.constrcutor = Sub;</code>把<code>Sub.prototype.constrcutor</code>指向<code>Sub</code>，如果所示：<br><img src="./javascript-prototype-one/javascript-prototype-1-7.png" alt="JavaScript-prototype"></p>
<blockquote>
<p>给子类型原型添加属性和方法必须在替换原型之后，原因在第二点已经解释过了，因为子类型的原型会被覆盖。</p>
</blockquote>
<h3 id="属性遮蔽"><a href="#属性遮蔽" class="headerlink" title="属性遮蔽"></a>属性遮蔽</h3><p>在<code>Sub.prototype</code>上添加<code>getName</code>方法，当调用<code>sub</code>上得<code>getName</code>时，访问到的是<code>Sub.prototype.getName</code>而不是访问到<code>SubType.prototype.getName</code>，这种情况称为<strong>属性遮蔽（property shadowing）</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'subtype'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将父类的实例作为子类的原型</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="comment">// 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。</span></span><br><span class="line">Sub.prototype.constrcutor = Sub;</span><br><span class="line"><span class="comment">// 添加getName属性</span></span><br><span class="line">Sub.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Sub.prototype.getName'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">sub.getName(); <span class="comment">// Sub.prototype.getName</span></span><br></pre></td></tr></table></figure>
<p>可以通过<code>__proto__</code>调用原型链上的属性即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sub.__proto__.__proto__.getName()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="实现一个-new"><a href="#实现一个-new" class="headerlink" title="实现一个 new"></a>实现一个 new</h2><hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获取第一个参数，构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Preson = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象；</span></span><br><span class="line">  obj.__proto__ = Preson.prototype;</span><br><span class="line">  <span class="comment">// 绑定this指向，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Preson.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里不多做赘述了，详细内容我另一片博客<a href="/blog/javascript/javascript-extends.html">javascript 中实现一个自己的 new</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每个对象拥有一个原型对象，通过<code>__proto__</code> 指针指向上一个原型 ，并从中<strong>继承方法和属性</strong>，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>，这种关系被称为 <strong>原型链</strong>。</li>
<li>当访问一个对象的属性 / 方法时，它不仅仅在该对象上查找，还会查找该对象的原型，以及该对象的原型的原型，<strong>一层一层向上查找</strong>，直到找到一个名字匹配的属性 / 方法或到达原型链的末尾<strong>null</strong>。</li>
<li>原型链的构建依赖于 <code>__proto__</code>，一层一层最终链接到 <code>null</code>。</li>
<li><code>instanceof</code> 原理就是一层一层查找 <code>__proto__</code>，如果和 <code>constructor.prototype</code> 相等则返回 <code>true</code>，如果一直没有查找成功则返回 <code>false</code>。</li>
<li>原型链继承的本质是<strong>重写原型对象，代之以一个新类型的实例</strong>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener">对象原型</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a><br><a href="https://www.muyiy.cn/blog/5/5.2.html#%E5%BC%95%E8%A8%80" target="_blank" rel="noopener">图解原型链及其继承优缺点</a><br><a href="https://mp.weixin.qq.com/s/oEyMZl-7q3pczK1GpnoqSA" target="_blank" rel="noopener">一篇文章理解 JS 继承</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型系列（一）构造函数、原型和原型链</title>
    <url>/blog/javascript/prototype/javascript-prototype.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先要了解几个属性<code>constructor</code>、<code>prototype</code>、<code>[[prototype]]</code>、<code>__proto__</code>分别作用是什么，还要理解几个概念<strong>原型</strong>、<strong>原型链</strong>、<strong>构造函数</strong>。</p>
<p>结合代码先把上面的的属性和记录清楚。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>constrcutor</code>是一种用于创建和初始化<code>class</code>创建的对象的特殊方法。<br><code>构造函数</code>本身就是一个函数，与普通函数<code>没有</code>任何区别，不过为了规范一般将其<code>首字母</code>大写。<code>构造函数</code>和<code>普通函数</code>的区别在于，使用 <code>new</code> 生成实例的函数就是<code>构造函数</code>，直接调用的就是<code>普通函数</code>。下面示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorFun</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new关键字创建实例</span></span><br><span class="line"><span class="keyword">let</span> constructorfun = <span class="keyword">new</span> ConstructorFun();</span><br></pre></td></tr></table></figure>
<p>其实<code>ConstructorFun</code>就是一个普通函数，但是在通过<code>new</code>关键字生成实例的时候，就可以把这个函数叫做<strong>构造函数</strong>;</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>除了<code>null</code>、<code>undefined</code>其他无论是通过<code>new</code>生成的实例，还是通过字面量生成的<strong>变量</strong>，普通的函数都是有<code>constructor</code>属性的。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorFun</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new关键字创建实例</span></span><br><span class="line"><span class="keyword">var</span> constructorfun = <span class="keyword">new</span> ConstructorFun();</span><br><span class="line">constructorfun.constructor === ConstructorFun; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number.constructor); <span class="comment">// ƒ Number() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数扩展"><a href="#构造函数扩展" class="headerlink" title="构造函数扩展"></a>构造函数扩展</h3><ul>
<li><code>let a = {}</code> 其实是 <code>let a = new Object()</code> 的语法糖</li>
<li><code>let a = []</code> 其实是 <code>let a = new Array()</code> 的语法糖</li>
<li><code>function Foo()</code>{ … } 其实是 var Foo = new Function(…)</li>
<li><strong>可以使用 <code>instanceof</code> 判断一个函数是否为一个变量的构造函数</strong></li>
</ul>
<p>手动实现一个<code>instanceof</code>函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟实现instanceof</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//left 表示左表达式，right 表示右表达式</span></span><br><span class="line">  <span class="keyword">let</span> cur = left.__proto__; <span class="comment">// 取的cur的隐式原型</span></span><br><span class="line">  <span class="keyword">let</span> parent = right.prototype; <span class="comment">// 取的right的显式原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果cur为null 直接返回false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur === parent) &#123;</span><br><span class="line">      <span class="comment">// 如果cur与parent相同 返回true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur.__proto__; <span class="comment">// 上面两个条件都不满足，继续向上一层原型链查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="constructor-的值是否可更改"><a href="#constructor-的值是否可更改" class="headerlink" title="constructor 的值是否可更改"></a>constructor 的值是否可更改</h3><p><strong>对于引用类型来说<code>constructor</code> 属性值是可以修改的，但是对于基本类型来说是只读的。</strong></p>
<blockquote>
<p>注意：<code>null</code> 和 <code>undefined</code> 是没有 <code>constructor</code> 属性的。</p>
</blockquote>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>官方解释原型：”JavaScript 常被描述为一种<strong>基于原型的语言（prototype-based language）</strong>————每个对象拥有一个<strong>原型对象</strong>，对象以其原型为模板、从原型继承方法和属性。”<br>每个函数都有一个特殊的属性就叫作<code>原型（prototype）</code>，请看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype);</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：<br><img src="./javascript-prototype/javascript-prototype-1-1.png" alt="JavaScript-prototype"><br><code>Foo.prototype</code>上有两个属性，一个是<code>constructor</code>它指向了函数本身；另一个是<code>__proto__</code>它指向了<code>Object.prototype</code>。</p>
<p>构造函数<code>Foo</code>有一个指向原型的指针，原型<code>Foo.prototype</code>有一个指向构造函数的指针<code>Foo.prototype.constructor</code>，用下面的图来表示更清晰一点：<br><img src="./javascript-prototype/javascript-prototype-1-2.png" alt="JavaScript-prototype"></p>
<p>其实更重要的是任何一个<code>prototype</code>对象都有一个<code>constructor</code>属性，指向这个构造函数。</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>在上面看到<code>__proto__</code>这个属性，每个实例对象（object）都有一个<code>隐式原型</code>属性(称之为<code>__proto__</code>)指向了创建该对象的构造函数的<code>原型</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="./javascript-prototype/javascript-prototype-1-3.png" alt="JavaScript-prototype"></p>
<p>当通过<code>new Foo()</code>生成的实例对象<code>foo</code>，它有一个<code>__proto__</code>属性指向<code>Foo.prototype</code>，可以通过以下代码验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.__proto__ === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Foo</code>、<code>Foo.prototype</code>、<code>Foo.prototype.constructor</code>、<code>foo.__proto__</code>三者的关系如下图所示：</p>
<p><img src="./javascript-prototype/javascript-prototype-1-4.png" alt="JavaScript-prototype"></p>
<p><code>__proto__</code> 属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 <code>Object.getPrototypeOf()</code>。</p>
<blockquote>
<p>通过改变一个对象的 <code>[[Prototype]]</code> 属性来改变和继承属性会对性能造成非常严重的影响，并且性能消耗的时间也不是简单的花费在 <code>obj.__proto__ = ...</code> 语句上, 它还会影响到所有继承自该 <code>[[Prototype]]</code> 的对象，如果你关心性能，你就不应该修改一个对象的 <code>[[Prototype]]</code>。</p>
</blockquote>
<p>如果要读取或修改对象的 <code>[[Prototype]]</code> 属性，建议使用如下方案，但是此时设置对象的 <code>[[Prototype]]</code> 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf();</span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf();</span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf();</span><br></pre></td></tr></table></figure>
<p>如果要创建一个新对象，同时继承另一个对象的 <code>[[Prototype]]</code> ，推荐使用 <code>Object.create()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  age: <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(p);</span><br></pre></td></tr></table></figure>
<h3 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h3><p><code>[[Prototype]]</code> 是对象的一个内部属性，外部代码无法直接访问。</p>
<blockquote>
<p>遵循 ECMAScript 标准，<code>someObject.[[Prototype]]</code> 符号用于指向 someObject 的<strong>原型</strong></p>
</blockquote>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><hr>
<p>每个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>。这种关系被称为<code>原型链 (prototype chain)</code>，通过原型链一个对象会拥有定义在其他对象中的属性和方法。看一面一张经典的图可能更直观：</p>
<p><img src="./javascript-prototype/javascript-prototype-1-3.jpg" width="50%" alt="JavaScript-prototype"></p>
<p>看一下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.__proto__ === Foo.prototype; <span class="comment">// true</span></span><br><span class="line">foo.__proto__.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line">foo.__proto__.__proto__.__proto__ === <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下面的图可以很好的展示上面的代码<code>prototype</code>和<code>__proto__</code>指向问题。<br><img src="./javascript-prototype/javascript-prototype-1-5.png" alt="JavaScript-prototype"></p>
<h2 id="特殊的-Symbol"><a href="#特殊的-Symbol" class="headerlink" title="特殊的 Symbol"></a>特殊的 Symbol</h2><p><code>Symbol</code>是基础数据类型，它可以通过<code>Symbol(123)</code>生成实例，不能通过<code>new Symbol()</code>生成实例，<code>Symbol</code>不是构造函数，但是它有<code>constructor</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sSymbol = <span class="built_in">Symbol</span>(<span class="string">'symbol'</span>);</span><br><span class="line"><span class="keyword">let</span> errSymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">'symbol'</span>); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.constructor; <span class="comment">// ƒ Symbol() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每一个函数对象都有一个<code>prototype</code>属性，指向函数对象的原型，原型对象上有一个<code>constructor</code>属性指向<strong>构造函数</strong>本身。</li>
<li>引用类型 <code>constructor</code> 属性值是可以<strong>修改</strong>的，但是对于基本类型来说是<strong>只读</strong>的，当然 <code>null</code> 和 <code>undefined</code> 没有 <code>constructor</code> 属性。</li>
<li><code>__proto__</code> 属性在 <code>ES6</code> 时被标准化，但因为性能问题并不推荐使用，推荐使用 <code>Object.getPrototypeOf()</code>。</li>
<li><code>__proto__</code> 是每个实例上都有的属性，<code>prototype</code> 是构造函数的属性，在实例上并不存在，所以这两个并不一样，但 <code>foo.__proto__</code> 和 <code>Foo.prototype</code> 指向同一个对象。</li>
<li>每个对象拥有一个原型对象，通过<code>__proto__</code>指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>，这就是原型链。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.muyiy.cn/blog/5/5.1.html#%E5%BC%95%E8%A8%80" target="_blank" rel="noopener">重新认识构造函数、原型和原型链</a><br><a href="https://mp.weixin.qq.com/s/y49klI7seb3tlP4hx2A_Lg" target="_blank" rel="noopener">JS 系列二：原型与原型链</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener">对象原型</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列 css中float</title>
    <url>/blog/css/deep-attribute/css-float.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>float CSS</code>属性指定一个元素应沿其容器的左侧或右侧放置，<code>允许文本和内联元素**环绕**它</code>。该元素从网页的正常流动(文档流)中<strong>移除</strong>，尽管仍然保持部分的<strong>流动性</strong>（与绝对定位<strong>相反</strong>）。</p>
<p><strong>浮动元素是 float 的计算值非 none 的元素。</strong><br>基本上可以认为：<strong>“让 block 元素无视 float 元素，让 inline 元素像流水一样围绕着 float 元素实现浮动布局。”</strong></p>
<h2 id="float-特性"><a href="#float-特性" class="headerlink" title="float 特性"></a>float 特性</h2><p><code>float</code>有三种特性：</p>
<ul>
<li><code>包裹性</code></li>
<li><code>高度破坏性</code></li>
<li><code>没有任何margin合并</code></li>
</ul>
<h3 id="包裹性"><a href="#包裹性" class="headerlink" title="包裹性"></a>包裹性</h3><p><strong>包裹性： 包裹性指的是元素尺寸刚好容纳内容，并且不会超越父级元素的宽度</strong>。</p>
<p>具有包裹性的其他属性：</p>
<ul>
<li><code>display:inline-block/table-cell/...</code></li>
<li><code>position:absolute/fixed/sticky</code></li>
<li><code>overflow:hidden/scroll</code></li>
</ul>
<p>通过一个实例来看一下什么是包裹性：</p>
<p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container fl"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">background-clip</span>: content-box; <span class="comment">/*将背景裁剪到内容框，方便看浮动元素效果*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fl</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="./css-float/css-float-1-1.png" alt="css margin"></p>
<p>可以看到下面的元素的宽度就是它内部文本信息的宽度，而上面的元素是占了整个一行的元素。</p>
<h3 id="包裹性的原理"><a href="#包裹性的原理" class="headerlink" title="包裹性的原理"></a>包裹性的原理</h3><p>浮动之所以会产生包裹性这样的效果是<strong>因为 float 属性会改变元素 display 属性最终的计算值</strong>。</p>
<p><code>float</code>属性对<code>display</code>属性的影响如下：</p>
<ul>
<li><strong>inline ——》 block</strong></li>
<li><strong>inline-block ——》 block</strong></li>
<li><strong>inline-table ——》 table</strong></li>
<li><strong>table-row ——》 block</strong></li>
<li><strong>table-row-group ——》 block</strong></li>
<li><strong>table-column ——》 block</strong></li>
<li><strong>table-column-group ——》 block</strong></li>
<li><strong>table-caption ——》 block</strong></li>
<li><strong>table-header-group ——》 block</strong></li>
<li><strong>table-footer-group ——》 blcok</strong></li>
<li><strong>flex ——》 flex</strong></li>
<li><strong>inline-flex ——》 inline-flex【inline-flex 在 chrome 下测试，float 后 display:flex】</strong></li>
<li><strong>other ——》unchanged</strong></li>
</ul>
<p>可以自己自行测试在不同浏览其中的表现，<strong>chrome</strong>测试方法如下：</p>
<p><strong>修改 css 如下</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fl</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过<strong>chrome</strong>的控制台首先查看<strong>Styles</strong>面板，可以看到<code>display: inline-block;float: left;</code>属性生效，如下：<br><img src="./css-float/css-float-1-2.png" alt="css margin"></p>
<p>然后再查看<strong>Computed</strong>面板查看真正生效到元素上的所有属性，如下：<br><img src="./css-float/css-float-1-3.png" alt="css margin"></p>
<p>可以看到<code>display: flex;</code>属性，得以验证上面的结论。</p>
<h3 id="高度破坏性"><a href="#高度破坏性" class="headerlink" title="高度破坏性"></a>高度破坏性</h3><p><strong>破坏性是指元素浮动后可能导致父元素高度塌陷</strong>。</p>
<p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nofl"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="./css-float/css-float-1-4.png" alt="css margin"></p>
<p>在<code>div.container</code>元素没有设置高度时，<code>div.nofl</code>不设置<code>float: left;</code>时元素的高度会撑开父元素的高度。而<code>div.fl</code>元素设置了<code>float: left;</code>元素的高度不会包含在父元素的高度内。</p>
<p><strong>其他破坏性的属性</strong>：</p>
<ul>
<li>display:none</li>
<li>position:absolute/fixed/sticky</li>
</ul>
<p><strong>浮动破坏性原理：</strong><br>因为浮动元素被从文档<strong>正常流中移除</strong>了，<strong>父元素</strong>当然还处在<strong>正常流</strong>中，所以父元素<strong>不能</strong>被浮动元素<strong>撑大</strong>。</p>
<h3 id="没有任何-margin-合并"><a href="#没有任何-margin-合并" class="headerlink" title="没有任何 margin 合并"></a>没有任何 margin 合并</h3><p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl one"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl two"</span>&gt;</span></span><br><span class="line">    测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改<strong>css</strong>如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">background-clip</span>: content-box; <span class="comment">/*将背景裁剪到内容框，方便看浮动元素效果*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fl</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./css-float/css-float-1-5.png" alt="css margin"></p>
<p>根据效果图可以看到<code>div.one</code>和<code>div.two</code>都是有<code>margin: 10px;</code>的属性，但是它们之间的<code>margin</code>并没有重合。如果没有<code>float: left</code>属性的话，<code>div.one</code>的下边距和<code>div.two</code>的上边距会发生合并，也就是说它们合并后的外间距就会是<code>10px</code>。</p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>在上面的实例中就用到了<code>clear</code>清除浮动属性，它可以解决<code>float</code>带来一些副作用比如说<code>高度破坏性</code>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">clear: none | left | right | both;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>none：默认值，允许两边都有浮动对象；</strong></li>
<li><strong>left：不允许左侧有浮动对象；</strong></li>
<li><strong>right：不允许右侧有浮动对象；</strong></li>
<li><strong>both：两侧不允许有浮动对象。</strong></li>
</ul>
<p>具体原理：在元素上外边距之上增加清除空间，比如清除左浮动会让元素的上外边距刚好在左边浮动元素的下外边距之下。</p>
<p>清除浮动课两大类方法：</p>
<ul>
<li>在兄弟元素最后一个设置 clear:both</li>
<li>父元素生成 BFC(IE8+)或者 hashlayout(IE6/IE7)</li>
</ul>
<h3 id="兄弟元素清除"><a href="#兄弟元素清除" class="headerlink" title="兄弟元素清除"></a>兄弟元素清除</h3><p>修改<strong>html</strong>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ....省略代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注释掉 */</span></span><br><span class="line"><span class="comment">/* .container::after &#123;</span></span><br><span class="line"><span class="comment">    content: "";</span></span><br><span class="line"><span class="comment">    display: block;</span></span><br><span class="line"><span class="comment">    clear: both;</span></span><br><span class="line"><span class="comment">    overflow: hidden;</span></span><br><span class="line"><span class="comment">    zoom: 1;</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line"><span class="comment">/* ....省略代码  */</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在没有添加<code>.clearfix { clear: both; }</code>时显示如图一，在添加<code>.clearfix</code>后显示为图二。</p>
<p><strong>图一</strong><br><img src="./css-float/css-float-1-6.png" alt="css margin"></p>
<p><strong>图二</strong><br><img src="./css-float/css-float-1-5.png" alt="css margin"></p>
<p>这种方式也是有很多不好的地方，比如增加了一个<strong>无用标签</strong>、<strong>结构更复杂</strong>、<strong>比较难复用</strong>。</p>
<h3 id="父元素添加-after-伪元素"><a href="#父元素添加-after-伪元素" class="headerlink" title="父元素添加 after 伪元素"></a>父元素添加 after 伪元素</h3><p>为了解决上面兄弟元素的问题，引出父元素的 after 伪元素。</p>
<p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'.'</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="comment">/* IE &lt; 8 */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * For IE 6/7 only</span></span><br><span class="line"><span class="comment">    * Include this rule to trigger hasLayout and contain floats.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样可以实现与上面想同的效果并且不会产生兄弟元素产生的问题</strong>。</p>
<h3 id="父元素生成-BFC（IE8-）-或-haslayout-IE6-IE7"><a href="#父元素生成-BFC（IE8-）-或-haslayout-IE6-IE7" class="headerlink" title="父元素生成 BFC（IE8+） 或 haslayout(IE6/IE7)"></a>父元素生成 BFC（IE8+） 或 haslayout(IE6/IE7)</h3><p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></span><br><span class="line">  内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></span><br><span class="line">    测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容测试内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'.'</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*IE6和IE7*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h2><h3 id="一列自适应一列固定布局"><a href="#一列自适应一列固定布局" class="headerlink" title="一列自适应一列固定布局"></a>一列自适应一列固定布局</h3><p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">    测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'.'</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="./css-float/css-float-1-7.png" alt="css margin"></p>
<p>还有<strong>圣杯和双飞翼布局</strong>，这里就不一一列举，可在本在中查找。</p>
<h2 id="float-布局和-inline-block-布局对比"><a href="#float-布局和-inline-block-布局对比" class="headerlink" title="float 布局和 inline-block 布局对比"></a>float 布局和 inline-block 布局对比</h2><p><code>float</code>和<code>inline-block</code>都能让元素排成一排，那么应该如何抉择？下面对比一下。</p>
<ul>
<li>文档流：<strong>浮动元素脱离正常流，让文字环绕。<code>inline-block</code> 仍然在正常流中</strong>。</li>
<li>水平位置：<strong>不能通过给父元素设置 <code>text-align:center</code> 让浮动元素无法水平居中【因为脱离文档流】，而 <code>inline-block</code> 可以</strong>。</li>
<li>垂直对齐：<strong>浮动元素紧贴顶部，<code>inline-block</code> 默认基线对齐，可通过 <code>vertical-align</code> 调整</strong>。</li>
<li>空白：<strong>浮动忽略空白元素彼此紧靠，<code>inline-block</code> 保留空白</strong>。</li>
</ul>
<p>其实<code>float</code>和<code>inline-block</code>看个人喜好和具体的场景。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>float</code>即使到现在还没有淘汰，虽然现在有很多更方便的布局如<code>flex</code>、<code>colmun</code>、<code>grid</code>等等，现在还有很多场景在应用，所以还是要仔细学习。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/starof/p/4608962.html" target="_blank" rel="noopener">深入理解 css 浮动</a><br><a href="https://segmentfault.com/a/1190000014554601#articleHeader4" target="_blank" rel="noopener">【前端 Talkking】CSS 系列——CSS 深入理解之 float 浮动</a></p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解css系列 css中border</title>
    <url>/blog/css/deep-attribute/css-border.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Css</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 css 系列 css 中 absolute</title>
    <url>/blog/css/deep-attribute/css-absolute.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Css</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（五）JavaScript中的Mixin、extends、object.assign的实现</title>
    <url>/blog/javascript/extends/javascript-extends-six.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（四）JavaScript多种继承方式，各自的优缺点</title>
    <url>/blog/javascript/extends/javascript-extends-five.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（三）JavaScript多种继承方式，各自的优缺点</title>
    <url>/blog/javascript/extends/javascript-extends-four.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（二）JavaScript怎么实现Java中的 继承、多态、封装</title>
    <url>/blog/javascript/extends/javascript-extends-three.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承系列（一）JavaScript中有类？基于原型的继承</title>
    <url>/blog/javascript/extends/javascript-extends-two.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的作用域和作用域链</title>
    <url>/blog/javascript/scope/javascript-scope.html</url>
    <content><![CDATA[<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<h3 id="最外层的函数、变量拥有全局作用域"><a href="#最外层的函数、变量拥有全局作用域" class="headerlink" title="最外层的函数、变量拥有全局作用域"></a>最外层的函数、变量拥有全局作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sGl = <span class="string">'全局变量'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fGL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _sGl = <span class="string">'局部变量'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(_sGl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sGl); <span class="comment">// 全局变量</span></span><br><span class="line">fGL(); <span class="comment">// 局部变量</span></span><br></pre></td></tr></table></figure>
<h3 id="没有使用-var-关键字声明的变量也都是全局变量。"><a href="#没有使用-var-关键字声明的变量也都是全局变量。" class="headerlink" title="没有使用 var 关键字声明的变量也都是全局变量。"></a>没有使用 var 关键字声明的变量也都是全局变量。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">'全局变量'</span>;</span><br><span class="line">  alert(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:全局变量</span></span><br></pre></td></tr></table></figure>
<h3 id="所有-window-对象的属性拥有全局作用域"><a href="#所有-window-对象的属性拥有全局作用域" class="headerlink" title="所有 window 对象的属性拥有全局作用域"></a>所有 window 对象的属性拥有全局作用域</h3><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域：<code>函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行。</code>也就是说词法作用域取决于源码，通过静态分析就能确定，因此<code>词法作用域也叫做静态作用域</code><br>在通常情况下，变量的查询从最近接的绑定上下文开始，向外部逐渐扩展，直到查询到第一个绑定，一旦完成查找就结束搜索。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gl = <span class="string">'全局变量'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fGl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gl = <span class="string">'局部变量'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(gl);</span><br><span class="line">&#125;</span><br><span class="line">fGl(); <span class="comment">// 局部变量</span></span><br></pre></td></tr></table></figure>
<h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>在编程实践中，最容易低估和过度滥用的概念就是动态作用域，因为很少有语言支持这种方式为绑定解析方案。</p>
<p>动态作用域与词法作用域相对而言的，不同于词法作用域在定义时确定，<code>动态作用域在执行时确定，其生存周期到代码片段执行为止</code>。动态变量存在于动态作用域中，<code>任何给定的绑定的值，在确定调用其函数之前，都是不可知的</code>。</p>
<p>在代码执行时，对应的作用域链常常是保持静态的。然而当遇到 with 语句、call 方法、apply 方法和 try-catch 中的 catch 时，会改变作用域链的。以 with 为例，在遇到 with 语句时，会将传入的对象属性作为局部变量来显示，使其便于访问，也就是说把一个新的对象添加到了作用域链的顶端，这样必然影响对局部标志符的解析。<code>当 with 语句执行完毕后，会把作用域链恢复到原始状态</code>。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with之前</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123; <span class="attr">name</span>: <span class="string">'jeri'</span> &#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with之后，作用域链恢复</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure>
<p>在作用域链中有动态作用域时，this 引用也会变得更加复杂，不再指向第一次创建时的上下文，而是由调用者确定。比如在使用 apply 或 call 方法时，传入它们的第一个参数就是被引用的对象。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalThis(); <span class="comment">// 输出:Window &#123;document: document,external: Object…&#125;</span></span><br><span class="line">globalThis.call(&#123; <span class="attr">name</span>: <span class="string">'jeri'</span> &#125;); <span class="comment">// 输出:Object &#123;name: "jeri"&#125;</span></span><br><span class="line">globalThis.apply(&#123; <span class="attr">name</span>: <span class="string">'jeri'</span> &#125;, []); <span class="comment">// 输出:Object &#123;name: "jeri"&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域，顾名思义就是在定义函数时候产生的作用域，这个作用域也可以称为<code>局部作用域</code>。和全局作用域相反，函数作用域一般只在函数的代码片段内可访问到，外部不能进行变量访问。在函数内部定义的变量存在于函数作用域中，其生命周期随着函数的执行结束而结束。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'jeri'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">with</span> (&#123; <span class="attr">name</span>: <span class="string">'with'</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 输出:with</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能访问函数作用域</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在 JavaScript 中，<code>函数也是对象</code>，实际上，JavaScript 里<code>一切</code>都是<code>对象</code>。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是<code>[[Scope]]</code>，由 ECMA-262 标准第三版定义，该内部属性包含了<code>函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链</code>，<code>它决定了哪些数据能被函数访问</code>。<code>它用来保证对执行环境有权访问的变量和函数的有序访问</code>。<br>当一个函数创建后，它的作用域会被创建此函数的作用域中可访问的数据对象填充</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./javascript-scope/scope1.jpg" alt="JavaScript-scope"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义函数执行的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。<br>这些值按照它们出现在函数中的顺序被复制到运行期的上下文的作用域中，它们共同组成一个新的对象，叫“活动对象(activation object)”,该对象包含了函数的所有局部变量、命名参数、参数集合以及 this,然后此对象会被推入作用域链前端，当运行期上下文被销毁时，活动对象也随之销毁。<br><img src="./javascript-scope/scope2.jpg" alt="JavaScript-scope"><br>在全局作用域中创建的函数,其作用域链会自动成为作用域中的一员。而当函数执行时,其活动对象就会成为作用域中的第一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// output:global</span></span><br><span class="line">  name = <span class="string">'change'</span>;</span><br><span class="line">  <span class="comment">// 函数内部可以修改全局变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// output:change</span></span><br><span class="line">  <span class="comment">// 先查询活动对象</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="string">'18'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// output:18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行完毕，执行环境销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// output:Uncaught ReferenceError: age is not defined</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是 JavaScript 的一个比较重要的东西，关于这个问题有很多文章进行讲述，然而依然有相当数量的程序员对这个概念理解不透彻，我就是其中一个，闭包报的官方定义为：<code>一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也该是表达式的一部分</code>。 一句话概括就是：<code>闭包就是一个函数，捕获作用域内的外部绑定</code>。这些绑定是为之后使用而被绑定，即使作用域已经销毁。</p>
<h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><p><code>自由变量与闭包的关系是，自由变量闭合于闭包的创建</code>。闭包背后的逻辑是，如果一个函数内部有其他函数，那么这些内部函数可以访问在这个外部函数中声明的变量（这些变量就称之为自由变量）。然而，这些变量可以被内部函数捕获，从高阶函数（返回另一个函数的函数称为高阶函数）中 return 语句实现“越狱”，以供以后使用。内部函数在没有任何局部声明之前（既不是被传入，也不是局部声明）使用的变量就是被捕获的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">captured</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">free</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = free + captured;</span><br><span class="line">    <span class="built_in">console</span>.log(ret);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">add10(<span class="number">2</span>); <span class="comment">// 输出:12</span></span><br></pre></td></tr></table></figure>
<p>从上例可知，外部函数中的变量 captured 被执行加法的返回函数捕获，内部函数从未声明过 captured 变量，却可以引用它。<br>如果我们再创建一个加法器将捕获到同名变量 captured，但有不同的值，因为这个加法器是在调用 makeAdder 之后被创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add16 = makeAdder(<span class="number">16</span>);</span><br><span class="line">add16(<span class="number">18</span>); <span class="comment">// 输出:34</span></span><br><span class="line">add10(<span class="number">10</span>); <span class="comment">// 输出:20</span></span><br></pre></td></tr></table></figure>
<p>每一个新的加法器函数都保留了自己创建时捕获的 captured 实例。</p>
<h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h3><p><code>在 JavaScript 中，当变量在一定作用域内声明，然后在另一个同名变量在一个较低的作用域声明，会发生变量的遮蔽</code>。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'jeri'</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'tom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">glbShadow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'fun'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// 输出:fun</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glbShadow();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:tom</span></span><br></pre></td></tr></table></figure>
<p>当在一个变量同一作用域内声明了多次时，最后一次声明会生效，会遮蔽以前的声明。</p>
<p>变量声明的遮蔽很好理解，然而<code>函数参数的遮蔽就略显复杂</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = [<span class="string">'Value is'</span>, shadowed].join(<span class="string">' '</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">argShadow(<span class="number">108</span>); <span class="comment">// output:Value is 108</span></span><br><span class="line"></span><br><span class="line">argShadow(); <span class="comment">// output:Value is</span></span><br></pre></td></tr></table></figure>
<p>函数 argShadow 的参数 shadowed 覆盖了全局作用域内的同名变量。即使没有传递任何参数，仍然绑定的是 shadowed，并没有访问到全局变量 shadowed = 0。<br><code>任何情况下，离得最近的变量绑定优先级最高</code>。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shadowed = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">var</span> str = [<span class="string">'Value is'</span>, shadowed].join(<span class="string">' '</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">varShadow(<span class="number">108</span>); <span class="comment">// output:Value is 123</span></span><br><span class="line"></span><br><span class="line">varShadow(); <span class="comment">// output:Value is 123</span></span><br></pre></td></tr></table></figure>
<p>varShadow(108)打印出来的并不是 108 而是 123，即使没有参数传入也是打印的 123，先访问离得最近的变量绑定。<br>遮蔽变量同样发生在闭包内部，实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(shadowed); <span class="comment">// output:108</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(shadowed); <span class="comment">// output:2</span></span><br><span class="line">    <span class="keyword">var</span> ret = shadowed + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ret); <span class="comment">// output:3</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closureShadow = captureShadow(<span class="number">108</span>);</span><br><span class="line"></span><br><span class="line">closureShadow(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>典型的误区</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    ret[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> test0 = test()[<span class="number">0</span>]();</span><br><span class="line"><span class="built_in">console</span>.log(test0); <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test1 = test()[<span class="number">1</span>]();</span><br><span class="line"><span class="built_in">console</span>.log(test1); <span class="comment">//输出：5</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子可知，test 这个函数执行之后返回一个函数数组，表面上看数组内的每个函数都应该返回自己的索引值，然而并不是如此。当外部函数执行完毕后，外部函数虽然其执行环境已经销毁，但闭包依然保留着对其中变量绑定的引用，仍然驻留在内存之中。当外部函数执行完毕之后，才会执行内部函数，而这时内部函数捕获的变量绑定已经是外部函数执行之后的最终变量值了，所以这些函数都引用的是同一个变量 i=5。<br>另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔1秒输出一个5</span></span><br></pre></td></tr></table></figure>
<p>按照我们的推断，上例应该输出 1,2,3,4,5。然而，事实上输出的是连续 5 个 5。为什么出现这种诡异的状况呢？其本质上还是由闭包特性造成的，闭包可以捕获外部作用域的变量绑定。<br>上面这个函数片段在执行时，其内部函数和外部函数并不是同步执行的，因为当调用 setTimeout 时会有一个延时事件排入队列，等所有同步代码执行完毕后，再依次执行队列中的延时事件，而这个时候 i 已经 是 5 了。</p>
<p>那怎么解决这个问题呢？我们是不是可以在每个循环执行时，给内部函数传进一个变量的拷贝，使其在每次创建闭包时，都捕获一个变量绑定。因为我们每次传参不同，那么每次捕获的变量绑定也是不同的，也就避免了最后输出 5 个 5 的状况。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包具有非常强大的功能，函数内部可以引用外部的参数和变量，但其参数和变量不会被垃圾回收机制回，常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。但，闭包也是 javascript 语言的一大特点，主要应用闭包场合为：<code>设计私有的方法和变量</code>。</p>
<h3 id="模拟私有变量"><a href="#模拟私有变量" class="headerlink" title="模拟私有变量"></a>模拟私有变量</h3><p>从上文的叙述我们知道，变量的捕获发生在创建闭包的时候，那么我们可以把闭包捕获到的变量做为私有变量。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closureDemo = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> PRIVATE = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    inc: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (PRIVATE += n);</span><br><span class="line">    &#125;,</span><br><span class="line">    dec: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (PRIVATE -= n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> testInc = closureDemo.inc(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testInc); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testDec = closureDemo.dec(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testDec); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">closureDemo.div = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PRIVATE / n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testDiv = closureDemo.div(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testDiv);</span><br><span class="line"><span class="comment">//输出：Uncaught ReferenceError: PRIVATE is not defined</span></span><br></pre></td></tr></table></figure>
<p>自执行函数 closureDemo 执行完毕之后，自执行函数作用和 PRIVATE 变量随之销毁，但 PRIVATE 仍滞留在内存中，也就是加入了到了 closureDemo.inc 和 closureDemo.dec 的作用域链中，闭包也就完成了变量捕获。但之后新加入的 closureDemo.div 并不能在作用域中继续寻找到 PRIVATE 了。因为，函数只有被调用时才会执行函数里面的代码，变量的捕获也只发生在创建闭包时，所以之后新加入的 div 方法并不能捕获 PRIVATE。</p>
<h3 id="创建特权方法"><a href="#创建特权方法" class="headerlink" title="创建特权方法"></a>创建特权方法</h3><p>通过闭包我们可以创建私有作用域，那么也就可以创建私有变量和私有函数。创建私有函数的方式和声明私有变量方法一致，只要在函数内部声明函数就可以了。当然，既然可以模拟私有变量和私有函数，我们也可以利用闭包这个特性，创建特权方法。实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">var</span> privateVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MyObj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  MyObj.prototype.pubulicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVar++;</span><br><span class="line">    <span class="keyword">return</span> privateFun();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>上面这个实例创建了一个私有作用域，并封装了一个构造函数和对应的方法。需要注意的是在上面的实例中，在声明 MyObj 这个函数时，使用的是不带 var 的函数表达式，我们希望产生的是一个全局函数而不是局部的，不然我们依然在外部无法访问。所以，MyObj 就成为了一个全局变量，能够在外部进行访问，我们在原型上定义的方法 publicMethod 也就可以使用，通过这个方法我们也就可以访问私有函数和私有变量了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/syfwhu/p/4839562.html" target="_blank" rel="noopener">http://www.cnblogs.com/syfwhu/p/4839562.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型（四）IF 转换规则</title>
    <url>/blog/javascript/type/javascript-IF-False-options.html</url>
    <content><![CDATA[<p><strong><em>多言多败，多事多害。——《训蒙增广》</em></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 JavaScript 中使用 if 的时候，自己如果不注意的话很可能出现判断进错，其实在 JavaScript 中只有`固定的几个值会转为 false，其它的统一认为为 true。</p>
<ul>
<li><code>false</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>空字符串&#39; &#39;</code></li>
<li><code>数字零 0</code></li>
<li><code>NaN</code></li>
</ul>
<p>其他的全部都算为 true,<code>&#39;false&#39;</code>、<code>&#39;0&#39;</code>也是为 true,其实这也是一种隐性的类型转换。和 == 又有不同。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>由于逻辑表达式是<code>从左往右</code>计算的，由于运算符优先级的存在，下面的表达式的结果却不相同。如下例所示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>) || <span class="literal">true</span>; <span class="comment">// 结果为 true</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; (<span class="literal">true</span> || <span class="literal">true</span>); <span class="comment">// 结果为 false</span></span><br></pre></td></tr></table></figure>
<p>右侧被小括号括起来的操作变成了独立的表达式。<br><code>转换规则</code>:</p>
<ul>
<li>将 AND 转换为 OR</li>
<li>将 OR 转换为 AND</li>
<li>删除嵌套的 AND</li>
<li>删除嵌套的 OR<br>可参考 &gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators</a></li>
</ul>
<h3 id="逻辑与-amp-amp"><a href="#逻辑与-amp-amp" class="headerlink" title="逻辑与(&amp;&amp;)"></a>逻辑与(&amp;&amp;)</h3><p>尽管 <code>&amp;&amp;</code> 和 <code>||</code> 运算符能够使用<code>非布尔值</code>的操作数, 但它们依然被看作是<code>布尔操</code>作符，因为它们的返回值总是能够被转换为<code>布尔值</code>。<br>expr1 &amp;&amp; expr2<br>如果<code>expr1</code>能转换为<code>false</code>则返回<code>expr1</code>,否则返回<code>expr2</code>。因此，与布尔值一起使用时，如果<code>两个</code>操作数都为<code>true</code>时<code>&amp;&amp;</code>返回<code>true</code>,否则返回<code>false</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a1 = <span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// t &amp;&amp; t 结果为 true</span></span><br><span class="line">a2 = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// t &amp;&amp; f 结果为 false</span></span><br><span class="line">a3 = <span class="literal">false</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// f &amp;&amp; t 结果为 false</span></span><br><span class="line">a4 = <span class="literal">false</span> &amp;&amp; <span class="number">3</span> == <span class="number">4</span>; <span class="comment">// f &amp;&amp; f 结果为 false</span></span><br><span class="line">a5 = <span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span>; <span class="comment">// t &amp;&amp; t 结果为 Dog</span></span><br><span class="line">a6 = <span class="literal">false</span> &amp;&amp; <span class="string">'Cat'</span>; <span class="comment">// f &amp;&amp; t 结果为 false</span></span><br><span class="line">a7 = <span class="string">'Cat'</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// t &amp;&amp; f 结果为 false</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与(||)"></a>逻辑与(||)</h3><p>expr1 &amp;&amp; expr2<br>如果<code>expr1</code>能转换为<code>true</code>则返回<code>expr1</code>,否则返回<code>expr2</code>。因此，与布尔值一起使用时，如果<code>任意一个</code>操作数为<code>true</code>时<code>||</code>返回<code>true</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">o1 = <span class="literal">true</span> || <span class="literal">true</span>; <span class="comment">// t || t 结果为 true</span></span><br><span class="line">o2 = <span class="literal">false</span> || <span class="literal">true</span>; <span class="comment">// f || t 结果为 true</span></span><br><span class="line">o3 = <span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">// t || f 结果为 true</span></span><br><span class="line">o4 = <span class="literal">false</span> || <span class="number">3</span> == <span class="number">4</span>; <span class="comment">// f || f 结果为 false</span></span><br><span class="line">o5 = <span class="string">'Cat'</span> || <span class="string">'Dog'</span>; <span class="comment">// t || t 结果为 Cat</span></span><br><span class="line">o6 = <span class="literal">false</span> || <span class="string">'Cat'</span>; <span class="comment">// f || t 结果为 Cat</span></span><br><span class="line">o7 = <span class="string">'Cat'</span> || <span class="literal">false</span>; <span class="comment">// t || f 结果为 Cat</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非(!)"></a>逻辑非(!)</h3><p>!expr 如果单个表达式能转换为<code>true</code>的话返回<code>false</code>，否则返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">n1 = !<span class="literal">true</span>; <span class="comment">// !t 结果为 false</span></span><br><span class="line">n2 = !<span class="literal">false</span>; <span class="comment">// !f 结果为 true</span></span><br><span class="line">n3 = !<span class="string">'Cat'</span>; <span class="comment">// !t 结果为 false</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 JavaScript 中使用 if 的时候，自己如果不注意的话很可能出现判断进错，其实在 JavaScript 中只有<code>固定的几个值会转为 false，其它的统一认为为 true</code>。</p>
<ul>
<li><code>false</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>空字符串&#39; &#39;</code></li>
<li><code>数字零 0</code></li>
<li><code>NaN</code></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中垃圾回收机制</title>
    <url>/blog/javascript/ram/javascript-GC.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://mp.weixin.qq.com/s/m_cwfM0PgivmmCKaK-TviQ" target="_blank" rel="noopener">Chrome 浏览器垃圾回收机制与内存泄漏分析</a></p>
<font color="#ff502c">JavaScript 创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。</font> 后一个过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理。<font color="#ff502c">而不是别人所说的:编写 JavaScript 程序时，所需内存的分配以及无用内存的回收完全实现自动管理</font>但是他会按照固定的时间间隔（或代码执行中预定的收集时间）周期性地执行这一操作<br><br>## 内存生命周期<br><br>其实别的语言的内存声明周期基本是那个是一致的：<br><br>1. 分配你所需要的内存<br>2. 使用分配到内存（读、写）<br>3. 不需要时将其释放\归还<br><br>### JavaScript 的内存分配<br><br>1. JavaScript 在定义变量时就完成了内存分配<br>2. 通过函数调用分配内存<br><br>### 内存释放<br><br>当内存不再需要使用时释放，高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。<br><br>## 两种垃圾回收方式<br><br>浏览器的内存处理基本分为两种，<font color="#ff502c">引用技术垃圾收集</font>、<font color="#ff502c">标记清除</font>两种，下面一一介绍。<br><br>### 引用计数<br><br>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br><font color="#ff502c">但是他有比较大的限制，就是当对象循环引用，引用计数不会回收它</font>

<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>垃圾收集器会按照固定的时间间隔周期性的执行这一操作。<br>从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。<br>简单来讲就是，当变量进入环境时，就是将变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。<br>收集器在运行时会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。剩下的在被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量。最后，垃圾收集器完成内存清除，销毁那些带有标记的值并收回它们所占用的内存空间。<br>这中算法是没有循环引用限制的</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发中mock数据的几种办法</title>
    <url>/blog/farmework/mockData/mockData.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在项目开发中，有很多时候是在后台接口还没开发好，有的是 api 接口都没写，有的是有 api 接口但是没有数据，不管是那种，都是在大家都对数据格式，接口的方式都是有统一了的，才能做 mock 数据，不然的话数据格式变化，接口内容变化，基本上前端 mock 不 mocK 数据基本上没什么用，还是等于对接两遍。</p>
<ul>
<li>我自己的建议，当有接口 api 的时候，但是没有真实数据的时候，我推荐用<code>mock.js</code>来解决问题，不需要自己再用 express，或者别的框架自己发布本地接口，直接在 ajax 返回数据的时候改变 response 的 data 数据</li>
<li>另一种就是完全都没有后台接口的时候，要自己本地跑起来接口或者别的地方要有接口 api 才可以 mock 数据，建议使用<code>easy-mock</code></li>
</ul>
<h3 id="mock-js"><a href="#mock-js" class="headerlink" title="mock.js"></a>mock.js</h3><ul>
<li>首先：<br>可以在自己项目中的 package.json 中添加 mock.js 和版本号<code>&quot;mockjs&quot;: &quot;^1.0.1-beta3&quot;</code>可以通过在 github 中看他的 tag 号，使用他最稳定的版本，通过<code>npm install</code>or<code>cnpm install</code>or<code>yarn</code>都是可以的，这个完全看自己的网络了。</li>
<li>然后：<br>在自己的<code>api</code>同级创建一个<code>mock 文件夹</code>在里面再创建一个叫做，mock.js 的文件。我只是简单的做一个 demo,具体的 mock 怎么构思和构建要看自己的业务，可以见一个总开关来控制是否 mock 数据，和子开关来控制是否 mock 子接口，如<code>process.env.NODE_ENV</code> 或者别的全局来判断是否开启 mock 数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span>;</span><br><span class="line"><span class="keyword">let</span> Random = Mock.Random; <span class="comment">// 这个只是 其中的一种形式 还有其他两种</span></span><br><span class="line"><span class="keyword">const</span> oMsgData = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'list|10'</span>: [&#123;</span><br><span class="line">    name: <span class="string">'@cname'</span>,</span><br><span class="line">    id: <span class="string">'@increment'</span>,</span><br><span class="line">    content: <span class="string">'@csentence'</span>,</span><br><span class="line">    createTime: <span class="string">'@date'</span>,</span><br><span class="line">    isRead: <span class="built_in">Number</span>(Random.boolean()),</span><br><span class="line">    isTop: <span class="built_in">Number</span>(Random.boolean()),</span><br><span class="line">    state: <span class="built_in">Number</span>(Random.boolean()),</span><br><span class="line">    type: <span class="string">'@increment'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// console.log(JSON.stringify(oMsgData, null, 4));</span></span><br><span class="line"><span class="comment">// console.log(oMsgData);</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; rurl 要替换的接口路径名</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; rtype 要替换的接口请求方式</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; data 要替换的接口的response的data</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">// 他会自动帮你填写 域名和端口号 rurl rtype response.data</span></span><br><span class="line"><span class="comment">Mock.mock('/api/notice/noticeListAdmin', 'post', &#123;oMsgData&#125;);</span></span><br></pre></td></tr></table></figure>
<p>具体的参数我这个就不讲了，首先引入<code>Mock.js</code>,然后可以通过<code>&#39;@cname&#39;</code>生成随机的名字，也可以通过<code>Mock.Random.cname()</code>生成随机名字。<br>[参考] <a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a> 这个是 mock.js 的官方文档，里面有 mock 的具体用法.</p>
<h3 id="easy-mock"><a href="#easy-mock" class="headerlink" title="easy-mock"></a>easy-mock</h3><p>这种是在线方式的，完全可以在他这个里面创建一套符合自己的 api 接口，具体当可以看下面的连接，这个我感觉没什么好讲的了，因为感觉自己归纳的也没有人家文档好，反正是挺好的。<br>[easy-mock] <a href="https://easy-mock.com/docs" target="_blank" rel="noopener">https://easy-mock.com/docs</a></p>
]]></content>
      <categories>
        <category>MockData</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>MockData</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中float精度问题</title>
    <url>/blog/javascript/effect/float-Operation.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在用到 JavaScript 中 <code>float 类型</code>的值来运算时,会产生<code>精度不准</code>的问题。<br>例如：<br><img src="./float-Operation/float.jpg" alt="float operation"><br>可以看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure>
<p>它得到的值是不精准的，简单来说，你的电脑做着正确的<code>二进制浮点运算</code>，但问题是你输入的是十进制的数，电脑以二进制运算，这两者并不是总是转化那么好的。<br>同时在调用<code>Number.toFixed</code>在不同的<code>浏览器</code>也会得到不同的结果。<br><a href="https://www.zhihu.com/question/20679634" target="_blank" rel="noopener">想了解更详细的请参考</a></p>
<h3 id="精度运算丢失"><a href="#精度运算丢失" class="headerlink" title="精度运算丢失"></a>精度运算丢失</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通精度丢失</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> !== <span class="number">0.3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 大整数运算</span></span><br><span class="line"><span class="number">9999999999999999</span> === <span class="number">10000000000000001</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">9007199254740992</span>;</span><br><span class="line">x + <span class="number">1</span> === x; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="toFixed-在不同浏览器的表现"><a href="#toFixed-在不同浏览器的表现" class="headerlink" title="toFixed 在不同浏览器的表现"></a>toFixed 在不同浏览器的表现</h3><h4 id="IE6-10"><a href="#IE6-10" class="headerlink" title="IE6-10"></a>IE6-10</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.35</span>).toFixed(<span class="number">1</span>); <span class="comment">// 1.4 正确</span></span><br><span class="line">(<span class="number">1.335</span>).toFixed(<span class="number">2</span>); <span class="comment">// 1.34  正确</span></span><br><span class="line">(<span class="number">1.3335</span>).toFixed(<span class="number">3</span>); <span class="comment">// 1.334 正确</span></span><br><span class="line">(<span class="number">1.33335</span>).toFixed(<span class="number">4</span>); <span class="comment">// 1.3334 正确</span></span><br><span class="line">(<span class="number">1.333335</span>).toFixed(<span class="number">5</span>); <span class="comment">// 1.33334 正确</span></span><br><span class="line">(<span class="number">1.3333335</span>).toFixed(<span class="number">6</span>); <span class="comment">// 1.333334 正确</span></span><br></pre></td></tr></table></figure>
<h4 id="chrome44-firefox41-里对于最后一位是-5-的有时竟然没有进位"><a href="#chrome44-firefox41-里对于最后一位是-5-的有时竟然没有进位" class="headerlink" title="chrome44/firefox41 里对于最后一位是 5 的有时竟然没有进位"></a>chrome44/firefox41 里对于最后一位是 5 的有时竟然没有进位</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.35</span>).toFixed(<span class="number">1</span>); <span class="comment">// 1.4 正确</span></span><br><span class="line">(<span class="number">1.335</span>).toFixed(<span class="number">2</span>); <span class="comment">// 1.33  错误</span></span><br><span class="line">(<span class="number">1.3335</span>).toFixed(<span class="number">3</span>); <span class="comment">// 1.333 错误</span></span><br><span class="line">(<span class="number">1.33335</span>).toFixed(<span class="number">4</span>); <span class="comment">// 1.3334 正确</span></span><br><span class="line">(<span class="number">1.333335</span>).toFixed(<span class="number">5</span>); <span class="comment">// 1.33333 错误</span></span><br><span class="line">(<span class="number">1.3333335</span>).toFixed(<span class="number">6</span>); <span class="comment">// 1.333333 错误</span></span><br></pre></td></tr></table></figure>
<h2 id="JS-数字丢失精度的原因"><a href="#JS-数字丢失精度的原因" class="headerlink" title="JS 数字丢失精度的原因"></a>JS 数字丢失精度的原因</h2><p>计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 <code>3.1415926...，1.3333...</code> 等。JS 遵循 <code>IEEE 754 规范</code>，采用双精度存储<code>（double precision）</code>，占用<code>64 bit</code>。如图<br><img src="./float-Operation/float_bug.png" alt="float operation"></p>
<p><strong>意义</strong></p>
<ul>
<li><code>1 位用来表示符号位</code></li>
<li><code>11 位用来表示指数</code></li>
<li><code>52 位表示尾数</code></li>
</ul>
<p>浮点数，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> &gt;&gt; <span class="number">0.0001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span>…（<span class="number">1001</span>无限循环）</span><br><span class="line"><span class="number">0.2</span> &gt;&gt; <span class="number">0.0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span>…（<span class="number">0011</span>无限循环）</span><br></pre></td></tr></table></figure>
<p>此时只能模仿十进制进行四舍五入了，但是二进制只有 <code>0 和 1</code> 两个，于是变为<code>0 舍 1 入</code>。这即是计算机中部分浮点数运算时<code>出现误差</code>，丢失精度的根本原因。</p>
<p>大整数的<code>精度丢失和浮点数本质上是一样</code>的，尾数位最大是<code>52</code>位，因此 JS 中能精准表示的最大整数是 <code>Math.pow(2, 53)</code>，十进制即 <code>9007199254740992</code>。</p>
<p>大于 <code>9007199254740992</code> 的可能会丢失精度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">9007199254740992</span>     &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.000</span> <span class="comment">// 共计 53 个 0</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">1</span> &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.001</span> <span class="comment">// 中间 52 个 0</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">2</span> &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.010</span> <span class="comment">// 中间 51 个 0</span></span><br></pre></td></tr></table></figure>
<p>实际上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> + <span class="number">1</span>; <span class="comment">// 丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">2</span>; <span class="comment">// 未丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">3</span>; <span class="comment">// 丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">4</span>; <span class="comment">// 未丢失</span></span><br></pre></td></tr></table></figure>
<p>以上，可以知道看似有穷的数字, 在计算机的二进制表示里却是无穷的，由于存储位数限制因此存在<code>“舍去”</code>，精度丢失就发生了。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="运算丢失精度"><a href="#运算丢失精度" class="headerlink" title="运算丢失精度"></a>运算丢失精度</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * floatObj 包含加减乘除四个方法，能确保浮点数运算不丢失精度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们知道计算机编程语言里浮点数计算会存在精度丢失问题（或称舍入误差），其根本原因是二进制和实现位数限制有些数无法有限表示</span></span><br><span class="line"><span class="comment"> * 以下是十进制小数对应的二进制表示</span></span><br><span class="line"><span class="comment"> *      0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）</span></span><br><span class="line"><span class="comment"> *      0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）</span></span><br><span class="line"><span class="comment"> * 计算机里每种数据类型的存储是一个有限宽度，比如 JavaScript 使用 64 位存储数字类型，因此超出的会舍去。舍去的部分就是精度丢失的部分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ** method **</span></span><br><span class="line"><span class="comment"> *  add / subtract / multiply /divide</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ** explame **</span></span><br><span class="line"><span class="comment"> *  0.1 + 0.2 == 0.30000000000000004 （多了 0.00000000000004）</span></span><br><span class="line"><span class="comment"> *  0.2 + 0.4 == 0.6000000000000001  （多了 0.0000000000001）</span></span><br><span class="line"><span class="comment"> *  19.9 * 100 == 1989.9999999999998 （少了 0.0000000000002）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * floatObj.add(0.1, 0.2) &gt;&gt; 0.3</span></span><br><span class="line"><span class="comment"> * floatObj.multiply(19.9, 100) &gt;&gt; 1990</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> floatObj = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 判断obj是否为一个整数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(obj) === obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100</span></span><br><span class="line"><span class="comment">   * @param floatNum &#123;number&#125; 小数</span></span><br><span class="line"><span class="comment">   * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">   *   &#123;times:100, num: 314&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toInteger</span>(<span class="params">floatNum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = &#123; <span class="attr">times</span>: <span class="number">1</span>, <span class="attr">num</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> isNegative = floatNum &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isInteger(floatNum)) &#123;</span><br><span class="line">      ret.num = floatNum;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> strfi = floatNum + <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> dotPos = strfi.indexOf(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">var</span> len = strfi.substr(dotPos + <span class="number">1</span>).length;</span><br><span class="line">    <span class="keyword">var</span> times = <span class="built_in">Math</span>.pow(<span class="number">10</span>, len);</span><br><span class="line">    <span class="keyword">var</span> intNum = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.abs(floatNum) * times + <span class="number">0.5</span>, <span class="number">10</span>);</span><br><span class="line">    ret.times = times;</span><br><span class="line">    <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">      intNum = -intNum;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.num = intNum;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 核心方法，实现加减乘除运算，确保不丢失精度</span></span><br><span class="line"><span class="comment">   * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param a &#123;number&#125; 运算数1</span></span><br><span class="line"><span class="comment">   * @param b &#123;number&#125; 运算数2</span></span><br><span class="line"><span class="comment">   * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数</span></span><br><span class="line"><span class="comment">   * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params">a, b, digits, op</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o1 = toInteger(a);</span><br><span class="line">    <span class="keyword">var</span> o2 = toInteger(b);</span><br><span class="line">    <span class="keyword">var</span> n1 = o1.num;</span><br><span class="line">    <span class="keyword">var</span> n2 = o2.num;</span><br><span class="line">    <span class="keyword">var</span> t1 = o1.times;</span><br><span class="line">    <span class="keyword">var</span> t2 = o2.times;</span><br><span class="line">    <span class="keyword">var</span> max = t1 &gt; t2 ? t1 : t2;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">        <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">          <span class="comment">// 两个小数位数相同</span></span><br><span class="line">          result = n1 + n2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">          <span class="comment">// o1 小数位 大于 o2</span></span><br><span class="line">          result = n1 + n2 * (t1 / t2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// o1 小数位 小于 o2</span></span><br><span class="line">          result = n1 * (t2 / t1) + n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result / max;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'subtract'</span>:</span><br><span class="line">        <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">          result = n1 - n2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">          result = n1 - n2 * (t1 / t2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result = n1 * (t2 / t1) - n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result / max;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'multiply'</span>:</span><br><span class="line">        result = (n1 * n2) / (t1 * t2);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'divide'</span>:</span><br><span class="line">        result = (n1 / n2) * (t2 / t1);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加减乘除的四个接口</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operation(a, b, digits, <span class="string">'add'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operation(a, b, digits, <span class="string">'subtract'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operation(a, b, digits, <span class="string">'multiply'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operation(a, b, digits, <span class="string">'divide'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exports</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    subtract: subtract,</span><br><span class="line">    multiply: multiply,</span><br><span class="line">    divide: divide</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="toFixed-兼容封装"><a href="#toFixed-兼容封装" class="headerlink" title="toFixed 兼容封装"></a>toFixed 兼容封装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFixed</span>(<span class="params">num, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> times = <span class="built_in">Math</span>.pow(<span class="number">10</span>, s);</span><br><span class="line">  <span class="keyword">var</span> des = num * times + <span class="number">0.5</span>;</span><br><span class="line">  des = <span class="built_in">parseInt</span>(des, <span class="number">10</span>) / times;</span><br><span class="line">  <span class="keyword">return</span> des + <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尾数位最大是<code>52</code>位，当出现不能<strong>无限循环的二进制时</strong>，只能通过四舍五入来储存。<br>这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie_function</title>
    <url>/blog/javascript/effect/javascript-cookie-function.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Cookie-在客户端-JavaScript-中"><a href="#Cookie-在客户端-JavaScript-中" class="headerlink" title="Cookie 在客户端 JavaScript 中"></a>Cookie 在客户端 JavaScript 中</h3><p>用 JavaScript 操作<code>Cookie</code>，用原声的接口<code>document.cookie</code>属性是比较难用的，所以封装一个添加、修改、删除的操作方法还是很有必要的。<br>同时要注意的是： Cookie 的所有<code>name</code>和<code>value</code>都是要经过<code>URI</code>编码的，必须使用<code>decodeURICompoent()</code>来编码。</p>
<h2 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a>创建 Cookie</h2><p>在浏览器端可以通过<code>document.cookie</code>来创建<code>cookie</code>，但是<code>cookie</code>只能是字符串形式并且格式必须是<code>url</code>格式，所以就要自行封装方法来使用。</p>
<p>代码封装如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params &#123;String&#125; key 键名</span></span><br><span class="line"><span class="comment"> * @params &#123;String&#125; value 键值</span></span><br><span class="line"><span class="comment"> * @params &#123;String&#125; options 配置项 如 readOnly expires path secure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">key, value, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否有document</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认配置</span></span><br><span class="line">  <span class="keyword">var</span> defalutConfig = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 合并配置</span></span><br><span class="line">  <span class="keyword">var</span> options = extend(defalutConfig, &#123;&#125;, options);</span><br><span class="line">  <span class="comment">// 判断expires是否为数字</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options.expires === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> days = options.expires,</span><br><span class="line">      t = (options.expires = <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    t.setMilliseconds(t.getMilliseconds() + days * <span class="number">864e5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断value是否为object，是的话通过JSON.stringify序列化</span></span><br><span class="line">  <span class="keyword">var</span> value =</span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call(value) !== <span class="string">'[object Object]'</span></span><br><span class="line">      ? <span class="built_in">String</span>(value)</span><br><span class="line">      : <span class="built_in">JSON</span>.stringify(value);</span><br><span class="line">  <span class="built_in">document</span>.cookie = [</span><br><span class="line">    <span class="built_in">encodeURIComponent</span>(key),</span><br><span class="line">    <span class="string">'='</span>,</span><br><span class="line">    value,</span><br><span class="line">    options.expires ? <span class="string">'; expires='</span> + options.expires.toUTCString() : <span class="string">''</span>, <span class="comment">// use expires attribute, max-age is not supported by IE</span></span><br><span class="line">    options.path ? <span class="string">'; path='</span> + options.path : <span class="string">''</span>,</span><br><span class="line">    options.domain ? <span class="string">'; domain='</span> + options.domain : <span class="string">''</span>,</span><br><span class="line">    options.secure ? <span class="string">'; secure'</span> : <span class="string">''</span></span><br><span class="line">  ].join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @descriptor 合并options</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;,</span><br><span class="line">    args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">    len = args.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> options = args[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">      result[key] = options[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setCookie(<span class="string">'token'</span>, <span class="string">'asd1231asdas123sfdsdf3453asas121asd'</span>, &#123;</span><br><span class="line">  expires: <span class="number">1</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  domain: <span class="string">'localhost'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// "token=asd1231asdas123sfdsdf3453asas121asd; expires=Fri, 20 Sep 2019 06:46:09 GMT; path=/; domain=localhost"</span></span><br></pre></td></tr></table></figure>
<h2 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h2><p>可以通过<code>document.cookie</code>获取<code>cookie</code>，但是要转换为对象，实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.replace(<span class="regexp">/(%[0-9A-Z]&#123;2&#125;)+/g</span>, <span class="built_in">decodeURIComponent</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params &#123;Stirng&#125; key 要获取的键值</span></span><br><span class="line"><span class="comment"> * @params &#123;Boolean&#125; json 是否返回json格式</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125; 返回cookie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">key, json</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否存在document</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明变量</span></span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;,</span><br><span class="line">    cookies = <span class="built_in">document</span>.cookie ? <span class="built_in">document</span>.cookie.split(<span class="string">'; '</span>) : [],</span><br><span class="line">    len = cookies.length;</span><br><span class="line">  <span class="comment">// 循环获取cookie，拼接or匹配 key</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 以‘=’分割数组</span></span><br><span class="line">    <span class="keyword">var</span> parts = cookies[i].split(<span class="string">'='</span>),</span><br><span class="line">      cookie = parts.slice(<span class="number">1</span>).join(<span class="string">'='</span>);</span><br><span class="line">    <span class="keyword">if</span> (!json &amp;&amp; cookie.charAt(<span class="number">0</span>) === <span class="string">''</span>) &#123;</span><br><span class="line">      cookie = cookie.slice(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过decodeURIComponent 解码</span></span><br><span class="line">      <span class="keyword">var</span> name = decode(parts[<span class="number">0</span>]);</span><br><span class="line">      cookie = decode(cookie);</span><br><span class="line">      <span class="comment">// 根据实参json返回不同的数据类型</span></span><br><span class="line">      <span class="keyword">if</span> (json) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cookie = <span class="built_in">JSON</span>.parse(cookie);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result[name] = cookie;</span><br><span class="line">      <span class="keyword">if</span> (key === name) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回数据</span></span><br><span class="line">  <span class="keyword">return</span> key ? result[key] : result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">getCookie(<span class="string">'user'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// &#123;name: "admin", age: 18&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 cookie</h2><p>同样通过<code>setCookie</code>来实现删除<strong>cookie</strong>，只是传入特定参数<code>expires: -1</code>，实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">key, options</span>) </span>&#123;</span><br><span class="line">  setCookie(key, <span class="string">''</span>, extend(options, &#123; <span class="attr">expires</span>: <span class="number">-1</span> &#125;));</span><br><span class="line">  <span class="keyword">return</span> !getCookie(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">removeCookie(<span class="string">'token'</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>到此<code>cookie</code>的操作到此结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章比较简单，记录了对<code>cookie</code>的<strong>增删改查</strong>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSEffect</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue官方的vue-cli一些优化打包方式的配置和方法，懒加载和dll优化方式</title>
    <url>/blog/vue/cli/vue-build-dll.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>我用了官方脚手架 vue-cli，有两个页面<code>ppt_model.vue</code>和 <code>ppt_model1.vue</code>,在两个页面中分别引入了 echarts、jquery<br>他<code>默认</code>会把所有的报都打包到 <code>app.js</code>和<code>vendor.js</code>中。<br>运行<code>npm run build --report</code><br>如下图所示：<br>在 cmd 中显示打包信息<br><img src="./vue-build-dll/vue_build/vue_build_dos1.jpg" alt="cmd build"><br>在页面中显示打包信息<br><img src="./vue-build-dll/vue_build/vue_build_dos2.jpg" alt="html build"></p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>使用 vue-router 官方推荐的懒加载,基本语法是 <code>component: resolve =&gt; require([&#39;../view/ppt_model.vue&#39;], resolve)</code><br>会把每一个页面分开打包成一个 js 文件，当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。<br>参考 &gt; <a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/advanced/lazy-loading.html</a><br>打包如下所示：<br>在 cmd 中显示打包信息<br><img src="./vue-build-dll/vue_build/vue_build_dos3.jpg" alt="cmd build"><br>在页面中显示打包信息<br><img src="./vue-build-dll/vue_build/vue_build_dos4.jpg" alt="html build"><br>其中的<code>static/js/0.66e1ff74acbd166fa927.js</code>对应的是<code>ppt_model.vue</code>页面<br><code>static/js/1.f09ddc0b737b2466f148.js</code>对应的是<code>ppt_model1.vue</code>页面</p>
<h2 id="webpack-官方提供的-DllReferencePlugin"><a href="#webpack-官方提供的-DllReferencePlugin" class="headerlink" title="webpack 官方提供的 DllReferencePlugin"></a>webpack 官方提供的 DllReferencePlugin</h2><p>这个插件是在 webpack 主配置文件中设置的， 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。<br>简单的说，就是把静态的插件库打包到一个静态文件里，同时生成对静态文件引用的 json 文件，通过 webpack 的 DllReferencePlugin 插件实现，打包的优化.<br>首先创建一个名为<code>webpack.dll.config.js</code>文件，内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'vue-router'</span>, <span class="string">'echarts'</span>, <span class="string">'jquery'</span>, <span class="string">'vue'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'../static/js'</span>),</span><br><span class="line">    filename: <span class="string">'dll.[name].js'</span>,</span><br><span class="line">    library: <span class="string">'[name]'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'dll'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]'</span>,</span><br><span class="line">      context: path.resolve(__dirname, <span class="string">'client'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在你的项目文件夹目录 cmd 中运行<code>webpack --config ./build/webpack.dll.config.js</code>在<code>build</code>中新建了一个<code>dll</code>中有一个<code>vendor-manifest.json</code>和，在<code>static(最外层的 static)</code>中新建一个<code>dll.vendor.js</code>。<br>在<code>build</code>文件中<code>webpack.prod.conf.js</code>添加一段代码<br>在打包前记得在 index.html 最下方，因为打包生成的 js,<code>&lt;script src=&quot;./static/js/dll.vendor.js&quot;&gt;&lt;/script&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记得在plugins中添加</span></span><br><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">"client"</span>),</span><br><span class="line">    manifest: <span class="built_in">require</span>(<span class="string">"./dll/vendor-manifest.json"</span>)</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>再运行<code>npm run build --report</code><br>运行结果如图所示：<br>在 cmd 中显示打包信息<br><img src="./vue-build-dll/vue_build/vue_build_dos6.jpg" alt="cmd build"><br>在页面中显示打包信息<br><img src="./vue-build-dll/vue_build/vue_build_dos7.jpg" alt="html build"></p>
<p><code>**注意**</code><br>在打包前记得在 index.html 最下方，引入打包生成的 js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>dq2.0<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./static/js/dll.vendor.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html" target="_blank" rel="noopener">webpack dll</a><br>本地可以预览页面效果，接口是不能调用的，dist 中的 index.html</p>
]]></content>
      <categories>
        <category>VueCli</category>
      </categories>
      <tags>
        <tag>VueCli</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>实现经典的三列布局</title>
    <url>/blog/css/layout-flow/css-Classic-layout.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>圣杯布局和双飞翼布局解决的问题是一样的，就是两边<code>定宽</code>，中间<code>自适应</code>的三栏布局，<code>中间栏</code>要在放在文档流前面以<code>优先渲染</code>。</p>
<h3 id="区别和统一"><a href="#区别和统一" class="headerlink" title="区别和统一"></a>区别和统一</h3><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是<code>三栏</code>全部 float 浮动，但左右两栏加上负 margin 让其跟中间栏 div 并排，以形成三栏布局。</p>
<p>不同在于解决”中间栏 div 内容不被遮挡“问题的思路不一样：<br>圣杯布局，为了中间 div 内容不被遮挡，将中间 div 设置了左右 padding-left 和 padding-right 后，将左右两个 div 用相对布局 position: relative 并分别配合 right 和 left 属性，以便左右两栏 div 移动后不遮挡中间 div。</p>
<p>双飞翼布局，为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置。</p>
<p>简单说起来就是”双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了“，而不是你题目中说的”去掉 relative”就是双飞翼布局“。</p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>圣杯布局，为了中间 div 内容不被遮挡，将中间 div 设置了左右 padding-left 和 padding-right 后，将左右两个 div 用相对布局 position: relative 并分别配合 right 和 left 属性，以便左右两栏 div 移动后不遮挡中间 div。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_continer"</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_left"</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_right"</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>先设置<code>container</code>的左右<code>padding</code>值来摆正<code>con_continer 的位置</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*圣杯布局*/</span></span><br><span class="line"><span class="comment">/*摆正中间栏的位置*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*清除浮动*/</span></span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置三栏高度*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span>,</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span>,</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置三栏为左浮动 float:left*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="./css-Classic-layout/shengbei1.jpg" alt="css 圣杯布局"></p>
<p>左右栏通过添加<code>负的 margin</code>放到正确的位置了<br>修改如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">// 通过margin-left为-100% 左侧栏 覆盖到中间栏上，再通过相对定位的负的left值来让他在左边</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 通过margin-left为-200px 右侧栏 覆盖到中间栏上，再通过相对定位的负的right值来让他在右边</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>双飞翼布局，为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_continer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_left"</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"con_right"</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*双飞翼布局*/</span></span><br><span class="line"><span class="comment">/*清除浮动*/</span></span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置三栏高度*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span>,</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span>,</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span>,</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置三栏为左浮动 float:left*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="./css-Classic-layout/shengbei2.jpg" alt="css 圣杯布局"><br>左右栏通过添加<code>负的 margin</code>放到正确的位置了<br>修改如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">// 通过margin-left为-100% 左侧栏 覆盖到中间栏上，再通过相对定位的负的left值来让他在左边</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line">// 通过margin-left为-200px 右侧栏 覆盖到中间栏上，再通过相对定位的负的right值来让他在右边</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line">// 设置 con_continer内部 内容的margin来防止覆盖</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.con_continer</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">180px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的结局为这样</p>
<p><img src="./css-Classic-layout/shengbei3.jpg" alt="css 圣杯布局"></p>
]]></content>
      <categories>
        <category>Css</category>
        <category>未完成</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中Number一些新增的方法和属性</title>
    <url>/blog/es/docs/es6-Number.html</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Number 对象主要用于：</p>
<ul>
<li><code>如果参数无法被转为数字，则返回 NaN.</code></li>
<li><code>早非构造器上下文中（如：没有 new 操作符），Number 能被用来执行类型转换</code></li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Number-EPSTION"><a href="#Number-EPSTION" class="headerlink" title="Number.EPSTION"></a><code>Number.EPSTION</code></h3><p>两个可表示(representable)数之间的最小间隔。<br><code>EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16，或者 2-52。</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0.2</span>;</span><br><span class="line">y = <span class="number">0.3</span>;</span><br><span class="line">z = <span class="number">0.1</span>;</span><br><span class="line">equal = <span class="built_in">Math</span>.abs(x - y + z) &lt; <span class="built_in">Number</span>.EPSILON;</span><br></pre></td></tr></table></figure>
<h3 id="Number-MAX-SAFE-INTEGER-Number-MIN-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER-Number-MIN-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER Number.MIN_SAFE_INTEGER"></a><code>Number.MAX_SAFE_INTEGER Number.MIN_SAFE_INTEGER</code></h3><p>Number.MAX_SAFE_INTEGER 常量表示在 JavaScript 中最大的安全整数（maxinum safe integer)（253 - 1）。<br>Number.MIN_SAFE_INTEGER 代表在 JavaScript 中最小的安全的 integer 型数字 (-(253 - 1)).<br><code>MAX_SAFE_INTEGER 常量值为 9007199254740991。</code><br><code>MIN_SAFE_INTEGER 的值是-9007199254740991.</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER; <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>; <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="comment">// -9007199254740991</span></span><br><span class="line">  (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>); <span class="comment">// -9007199254740991</span></span><br></pre></td></tr></table></figure>
<h3 id="Number-MAX-VALUE-Number-MIN-VALUE"><a href="#Number-MAX-VALUE-Number-MIN-VALUE" class="headerlink" title="Number.MAX_VALUE Number.MIN_VALUE"></a><code>Number.MAX_VALUE Number.MIN_VALUE</code></h3><p>Number.MAX_VALUE 属性表示在 JavaScript 里所能表示的最大数值<br>Number.MIN_VALUE 属性表示在 JavaScript 中所能表示的最小的正值<br><code>MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 &quot;Infinity&quot;。</code><br><code>MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (&quot;underflow values&quot;) 的值将会转换为 0。</code><br>因为 MAX_VALUE 是 Number 对象的一个静态属性，所有应该直接使用，Number.MAX_VALUE ，而不是作为一个创建的 Number 实例的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num1 * num2 &lt;= <span class="built_in">Number</span>.MAX_VALUE) &#123;</span><br><span class="line">  func1();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num1 / num2 &gt;= <span class="built_in">Number</span>.MIN_VALUE) &#123;</span><br><span class="line">  func1();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Number-NaN-Number-prototype"><a href="#Number-NaN-Number-prototype" class="headerlink" title="Number.NaN Number.prototype"></a><code>Number.NaN Number.prototype</code></h3><p>Number.NaN 表示“非数字”（Not-A-Number）。和 NaN 相同。<br>Number.prototype 属性表示 Number 构造函数的原型。<br><code>所有 Number 实例都继承自 Number.prototype。修改 Number 构造函数的原型对象会影响到所有 Number 实例。.</code><br><code>不必创建一个 Number 实例来访问该属性，使用 Number.NaN 来访问该静态属性。</code></p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p><code>constructor</code><br>返回创建该实例对象的构造函数。默认为 Number 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Properties inherited <span class="keyword">from</span> <span class="built_in">Object</span>:</span><br><span class="line">__parent__, __proto__</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>实例本身的方法 Number.isFinite()、Number.isInteger()、Number.isNaN()、Number.isSafeInteger()、Number.parseFloat()、Number.parseInt()<br>prototype 原型上的方法 Number.prototype.toExponential()、Number.prototype.toFixed()、Number.prototype.toLocaleString()、Number.prototype.toPrecision()、Number.prototype.toSource()、Number.prototype.toString()、Number.prototype.valueOf()</p>
<h3 id="Number-isFinite-Number-isSafeInteger"><a href="#Number-isFinite-Number-isSafeInteger" class="headerlink" title="Number.isFinite() Number.isSafeInteger()"></a>Number.isFinite() Number.isSafeInteger()</h3><p>Number.isFinite() 方法用来检测传入的参数是否是一个有穷数（finite number）。<br>Number.isSafeInteger() 方法用来判断传入的参数值是否是一个“安全整数”（safe integer）。一个安全整数是一个符合下面条件的整数</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(value);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="comment">// 要被检测有穷性的值</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">2e64</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'0'</span>); <span class="comment">// false, 全局函数 isFinite('0') 会返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(testValue);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// testValue</span></span><br><span class="line"><span class="comment">// 需要检测的参数。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 一个布尔值 表示给定的值是否是一个安全整数（safe integer）。</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">'3'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3.1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3.0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>和<code>全局的 isFinite()</code>函数相比，<code>这个方法不会强制将一个非数值的参数转换成数值</code>，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。<br>Number.isSafeInteger() 安全整数范围为 -(253 - 1)到 253 - 1 之间的整数，包含 -(253 - 1)和 253 - 1。</p>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h3><p>Number.isInteger() 方法用来判断给定的参数是否为整数。<br>如果被检测的值是整数，则返回 true，否则返回 false。注意 NaN 和正负 Infinity 不是整数。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(value);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="comment">// 要判断此参数是否为整数</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 判断给定值是否是整数的 Boolean 值。</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">-100000</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">0.1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="built_in">Math</span>.PI); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">'10'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger([<span class="number">1</span>]); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h3><p>Number.isNaN() 方法确定传递的值是否为 NaN 和其类型是 Number。它是原始的全局 isNaN()的更强大的版本。</p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(value);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="comment">// 要被检测是否是 NaN 的值。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 一个布尔值，表示给定的值是否是 NaN。</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="built_in">Number</span>.NaN); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这几个如果使用全局的 isNaN() 时，会返回 true。</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'NaN'</span>); <span class="comment">// false，字符串 "NaN" 不会被隐式转换成数字 NaN。</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(&#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'blabla'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的都返回 false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">37</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'37'</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'37.37'</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">' '</span>);</span><br></pre></td></tr></table></figure>
<h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>在 JavaScript 中，NaN 最特殊的地方就是，<code>我们不能使用相等运算符（== 和 ===）来判断一个值是否是 NaN</code>，因为<code>NaN == NaN</code> 和<code>NaN === NaN</code>都会返回<code>false</code>。因此，必须要有一个判断值是否是 NaN 的方法。<br><code>同样：</code><br>和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。</p>
<h3 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt() Number.parseFloat()"></a>Number.parseInt() Number.parseFloat()</h3><p>Number.parseFloat() 方法可以把一个字符串解析成浮点数。该方法与全局的 parseFloat() 函数相同，并且处于 ECMAScript 6 规范中（用于全局变量的模块化）。<br>Number.parseInt() 方法可以根据给定的进制数把一个字符串解析成整数。</p>
<h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.parseInt(string, radix);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="comment">// 被解析的值。如果不是一个字符串，则将其转换为字符串。字符串开头的空白符将会被忽略。</span></span><br><span class="line"><span class="comment">// radix</span></span><br><span class="line"><span class="comment">// 一个整数值，指定转换中采用的基数。总是指定该参数可以保证结果可预测。当忽略该参数时，不同的实现环境可能产生不同的结果。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(string);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="comment">// 被解析的字符串。</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">'3.14'</span>); <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">'314e-2'</span>); <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">'FF2'</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p><code>该方法和全局的 parseInt() 函数是同一个函数：</code><br><code>该方法和全局的 parseFloat() 函数是同一个函数：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">验证<span class="built_in">Number</span>.parseInt、<span class="built_in">Number</span>.parseFloat与全局的 <span class="built_in">parseInt</span>、<span class="built_in">parseFloat</span>是相同的</span><br><span class="line"><span class="built_in">Number</span>.parseInt === <span class="built_in">parseInt</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat === <span class="built_in">parseFloat</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"F"</span>, <span class="number">16</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"17"</span>, <span class="number">8</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"15"</span>, <span class="number">10</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"Hello"</span>, <span class="number">8</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"546"</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>parseInt 函数将其第一个参数转换为字符串，解析它，并返回一个整数或 NaN。如果不是 NaN，返回的值将是作为指定<code>基数（基数）</code>中的数字的第一个参数的整数。<br>例如：radix<code>参数为 10</code> 将会把第一个参数看作是一个数的<code>十进制</code>表示,如果不属于 radix 参数所指定的基数中的字符那么该字符和气候的字符创都将被忽略。<br>在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：</p>
<ul>
<li>如果字符串 string 以”0x”或者”0X”开头, 则基数是 16 (16 进制).</li>
<li>如果字符串 string 以”0”开头, 基数是 8（八进制）或者 10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用 10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出 radix 参数的值。</li>
<li>如果字符串 string 以其它任何值开头，则基数是 10 (十进制)。<br>需要注意的是：<br><code>如果第一个字符不能被转换成数字，parseInt 返回 NaN。</code></li>
</ul>
<h3 id="Number-prototype-toFixed-、Number-prototype-toPrecision"><a href="#Number-prototype-toFixed-、Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toFixed()、Number.prototype.toPrecision()"></a>Number.prototype.toFixed()、Number.prototype.toPrecision()</h3><p>toFixed() 方法使用定点表示法来格式化一个数。<br>toPrecision() 方法以指定的精度返回该数值对象的字符串表示。</p>
<h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">numObj.toFixed(digits);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// digits</span></span><br><span class="line"><span class="comment">// 小数点后数字的个数；介于 0 到 20 （包括）之间，实现环境可能支持更大范围。如果忽略该参数，则默认为 0。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 一个数值的字符串表现形式，不使用指数记数法，而是在小数点后有 digits 位数字。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numObj = <span class="number">12345.6789</span>;</span><br><span class="line">numObj.toFixed(); <span class="comment">// 返回 "12346"：进行四舍五入，不包括小数部分</span></span><br><span class="line">numObj.toFixed(<span class="number">1</span>); <span class="comment">// 返回 "12345.7"：进行四舍五入</span></span><br><span class="line">numObj.toFixed(<span class="number">6</span>); <span class="comment">// 返回 "12345.678900"：用0填充</span></span><br><span class="line">(<span class="number">1.23e20</span>).toFixed(<span class="number">2</span>); <span class="comment">// 返回 "123000000000000000000.00"</span></span><br><span class="line">(<span class="number">1.23e-10</span>).toFixed(<span class="number">2</span>); <span class="comment">// 返回 "0.00"</span></span><br><span class="line">(<span class="number">2.34</span>).toFixed(<span class="number">1</span>); <span class="comment">// 返回 "2.3"</span></span><br><span class="line">-(<span class="number">2.34</span>).toFixed(<span class="number">1</span>); <span class="comment">// 返回 -2.3 （由于操作符优先级，负数不会返回字符串）</span></span><br><span class="line">(<span class="number">-2.34</span>).toFixed(<span class="number">1</span>); <span class="comment">// 返回 "-2.3" （若用括号提高优先级，则返回字符串）</span></span><br><span class="line"></span><br><span class="line">numObj.toPrecision(precision);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// precision</span></span><br><span class="line"><span class="comment">// 可选。一个用来指定有效数个数的整数。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 以定点表示法或指数表示法表示的一个数值对象的字符串表示，四舍五入到 precision 参数指定的显示数字位数。</span></span><br><span class="line"><span class="keyword">var</span> numObj = <span class="number">5.123456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'numObj.toPrecision()  is '</span> + numObj.toPrecision()); <span class="comment">//输出 5.123456</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'numObj.toPrecision(5) is '</span> + numObj.toPrecision(<span class="number">5</span>)); <span class="comment">//输出 5.1235</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'numObj.toPrecision(2) is '</span> + numObj.toPrecision(<span class="number">2</span>)); <span class="comment">//输出 5.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'numObj.toPrecision(1) is '</span> + numObj.toPrecision(<span class="number">1</span>)); <span class="comment">//输出 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：在某些情况下会以指数表示法返回</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1234.5</span>).toPrecision(<span class="number">2</span>)); <span class="comment">// "1.2e+3"</span></span><br></pre></td></tr></table></figure>
<p>该数值在必要时进行四舍五入，另外在必要时会用 0 来填充小数部分，以便小数部分有指定的位数。</p>
<h3 id="Number-prototype-toLocaleString-、Number-prototype-toString-、Number-prototype-valueOf"><a href="#Number-prototype-toLocaleString-、Number-prototype-toString-、Number-prototype-valueOf" class="headerlink" title="Number.prototype.toLocaleString()、Number.prototype.toString()、Number.prototype.valueOf()"></a>Number.prototype.toLocaleString()、Number.prototype.toString()、Number.prototype.valueOf()</h3><p>toString() 方法返回指定 Number 对象的字符串表示形式。<br>valueOf() 方法返回一个被 Number 对象包装的原始值。</p>
<h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">numObj.toString([radix]);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// radix</span></span><br><span class="line"><span class="comment">// 指定要用于数字到字符串的转换的基数(从2到36)。如果未指定 radix 参数，则默认值为 10。</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count.toString()); <span class="comment">// 输出 '10'</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">17</span>).toString()); <span class="comment">// 输出 '17'</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">17.2</span>).toString()); <span class="comment">// 输出 '17.2'</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x.toString(<span class="number">2</span>)); <span class="comment">// 输出 '110'</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">254</span>).toString(<span class="number">16</span>)); <span class="comment">// 输出 'fe'</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">-10</span>).toString(<span class="number">2</span>)); <span class="comment">// 输出 '-1010'</span></span><br><span class="line"></span><br><span class="line">numObj.valueOf();</span><br><span class="line"><span class="keyword">var</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numObj); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = numObj.valueOf();</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<p>Number 对象覆盖了 Object 对象上的 toString() 方法，它不是继承的 Object.prototype.toString()。对于 Number 对象，toString() 方法以指定的基数返回该对象的字符串表示。<br>valueOf()该方法通常是由 JavaScript 引擎在内部隐式调用的，而不是由用户在代码中显式调用的</p>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Array系列(二) 一些常用array的扩展方法（二）</title>
    <url>/blog/es/docs/es6-Array1.html</url>
    <content><![CDATA[<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><hr>
<p>every(): 对数组中的每一项运行给函数，如果该函数对每一项都返回 true,则返回 true.<br>filter(): 对数组中的每一项运行给函数，如果该函数会返回 true 的项目成的数组。<br>forEach(): 对数组中的每一项运行给函数，这个项目没有返回值.<br>map(): 对数组中的每一项运行给函数，返回每次函数调用的结果组成的数组。<br>some(): 对数组中的每一项运行给函数，如果该函数对任何项都返回 true,则返回 true.</p>
<h3 id="every-some"><a href="#every-some" class="headerlink" title="every()/some()"></a>every()/some()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> everyResult1 = numbers.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(everyResult1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter() 过滤"></a>filter() 过滤</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// [3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>方法对数组的每个元素执行一次提供的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> array.forEach(callback(currentValue, index, array)&#123;</span><br><span class="line">     <span class="comment">//do something</span></span><br><span class="line"> &#125;, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"> array.forEach(callback[, thisArg])</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"> <span class="comment">// callback</span></span><br><span class="line">   <span class="comment">//   为数组中每个元素执行的函数，该函数接收三个参数：</span></span><br><span class="line"> <span class="comment">// currentValue(当前值)</span></span><br><span class="line">    <span class="comment">//  数组中正在处理的当前元素。</span></span><br><span class="line"> <span class="comment">// index(索引)</span></span><br><span class="line">    <span class="comment">//  数组中正在处理的当前元素的索引。</span></span><br><span class="line"> <span class="comment">// array</span></span><br><span class="line"> <span class="comment">// forEach()方法正在操作的数组。</span></span><br><span class="line"> <span class="comment">// thisArg可选</span></span><br><span class="line">    <span class="comment">//  可选参数。当执行回调 函数时用作this的值(参考对象)。</span></span><br><span class="line"> <span class="comment">// 返回值</span></span><br><span class="line">    <span class="comment">// undefined.</span></span><br></pre></td></tr></table></figure>
<p>callback 函数会被依次传入三个参数：</p>
<font color="#ff502c">数组当前项的值</font><br><font color="#ff502c">数组当前项的索引</font><br><font color="#ff502c">数组对象本身</font><br><font color="yellow">注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要这样，使用 forEach()方法是错误的，你可以用一个简单的循环作为替代。如果您正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用 Array.every 或 Array.some。如果可用，新方法 find() 或者 findIndex() 也可被用于真值测试的提早终止。</font>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br>参数与 forEach 相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> doubles = numbers.map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 一个新数组，每个元素都是回调函数的结果。</span></span><br></pre></td></tr></table></figure>
<p>返回值<font color="#ff502c">一个新数组，每个元素都是回调函数的结果。</font></p>
<h2 id="栈方法-队列方法"><a href="#栈方法-队列方法" class="headerlink" title="栈方法/队列方法"></a>栈方法/队列方法</h2><p>栈是一种 LIFO(Last-In-First-Out,后进先出)的数据结构，也就是最新添加的项被移除。<br>push() 添加到数组末尾<br>pop() 删除到数组末尾<br>shift() 添加到数组头部<br>unshift() 删除到数组头部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">arr.push(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [4, 5, 6, 7, 8]</span></span><br><span class="line">arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [4, 5, 6, 7]</span></span><br><span class="line">arr.unshift(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 4, 5, 6, 7]</span></span><br><span class="line">arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>
<h2 id="位置方法-indexOf-、lastIndexOf-、find-、findIndex"><a href="#位置方法-indexOf-、lastIndexOf-、find-、findIndex" class="headerlink" title="位置方法 indexOf()、lastIndexOf()、find()、findIndex()"></a>位置方法 indexOf()、lastIndexOf()、find()、findIndex()</h2><p>接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。<br>indexOf()方法从数组开头<br>lastIndexOf()方法则从数组的末尾</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p>
<p><strong>未完待续。。。。。</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中的async方法的使用和实现原理</title>
    <url>/blog/es/docs/es6-AsyncFuntion.html</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>AsyncFunction</code> 构造函数 创建一个新的 async function 对象。在 JavaScript 中，每个异步函数实际上都是一个 AsyncFunction 对象。<br><code>async function</code> 关键字可以用来定义一个异步函数表达式。<code>返回一个 Promise</code><br>它就是 <code>Generator</code> 函数的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add1 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = resolveAfter2Seconds(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">var</span> b = resolveAfter2Seconds(<span class="number">30</span>);</span><br><span class="line">  <span class="keyword">return</span> x + (<span class="keyword">await</span> a) + (<span class="keyword">await</span> b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add1(<span class="number">10</span>).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// prints 60 after 2 seconds.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add2 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">30</span>);</span><br><span class="line">  <span class="keyword">return</span> x + a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add2(<span class="number">10</span>).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// prints 60 after 4 seconds.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">async function [name]([param1[, param2[, ..., paramN]]]) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// name</span></span><br><span class="line">    <span class="comment">// 函数名称。 可以省略，以此来声明一个匿名的函数。也是用于本地调用函数体的一个名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// paramN</span></span><br><span class="line">    <span class="comment">// 传入函数的参数名</span></span><br><span class="line"><span class="comment">// statements</span></span><br><span class="line">    <span class="comment">// 函数体内的语句声明</span></span><br></pre></td></tr></table></figure>
<h4 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h4><p>async 函数返回一个 Promise 对象。<br>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>async function 表达式非常类似于 async function 声明语句，并且几乎拥有等同的语法。他们之间主要的区别在于函数名称，async function 表达式可以省略函数名称来创建一个匿名的函数。另见 functions 章节获取更多信息。</p>
<h3 id="async-函数对-Generator-函数的改进，体现在以下四点。"><a href="#async-函数对-Generator-函数的改进，体现在以下四点。" class="headerlink" title="async 函数对 Generator 函数的改进，体现在以下四点。"></a>async 函数对 Generator 函数的改进，体现在以下四点。</h3><h4 id="内置执行器。"><a href="#内置执行器。" class="headerlink" title="内置执行器。"></a>内置执行器。</h4><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块,而<code>async</code>函数自带执行器，也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> result = asyncReadFile();</span><br></pre></td></tr></table></figure>
<h4 id="更好的语义"><a href="#更好的语义" class="headerlink" title="更好的语义"></a>更好的语义</h4><p><code>async</code>和<code>await</code>，比起<code>\*</code>和<code>yield</code>，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p>
<h4 id="返回值是-Promise。"><a href="#返回值是-Promise。" class="headerlink" title="返回值是 Promise。"></a>返回值是 Promise。</h4><p><code>async</code>函数的返回值是 <code>Promise</code>对象，这比 <code>Generator</code>函数的返回值是 <code>Iterator</code>对象方便多了。你可以用<code>then</code>方法指定下一步的操作。<br>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个<code>Promise</code> 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">asyncPrint(<span class="string">'hello wrold'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p><code>await</code> 操作符被用于等待由一个 async function 返回的一个 Promise。如果不是，会被转成一个立即 resolve 的 Promise 对象。</p>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>await 表达式会造成异步函数停止执行并且等待 promise 的解决，当值被 resolved，异步函数会恢复执行以及返回 resolved 值。如果该值不是一个 promise，它将会被转换成一个 resolved 后的 promise。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。那么整个 async 函数都会中断执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await Promise.reject('出错了');</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">  .then(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul>
<li>第一点，前面已经说过，await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。因为只有 getFoo 完成以后，才会执行 getBar,完全可以让他们同事触发。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三点，await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。 正确的写法是采用 for 循环。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> db.post(doc);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">        <span class="keyword">await</span> db.post(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Array系列(一) 一些常用array的扩展方法</title>
    <url>/blog/es/docs/es6-Array.html</url>
    <content><![CDATA[<!--## Array中常用的属性，或者方法-->
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><hr>
<h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><p>length 属性表示一个无符号 32-bit 整数，返回一个数组中的元素个数。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h2><p>Array.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// arrayLike 想要转换成真实数组的类数组对象或可遍历对象。</span></span><br><span class="line"><span class="comment">// mapFn(可选) 可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。</span></span><br><span class="line"><span class="comment">// thisArg(可选) 可选参数，执行 mapFn 函数时 this 的值。</span></span><br><span class="line"><span class="comment">// 返回值 返回一个新的Array类型的实例</span></span><br></pre></td></tr></table></figure>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Array.from() 允许你从下面两者来创建数组：</p>
<ul>
<li>类数组对象（拥有一个 length 属性和若干索引属性的任意对象）</li>
<li>可遍历对象（你可以从它身上迭代出若干个元素的对象，比如有 Map 和 Set 等）<br>Array.from() 方法有一个可选参数 mapFn，让你可以在最后生成的数组上再执行一次 map 方法后再返回。也就是说 Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg), 除非创建的不是可用的中间数组。 这对一些数组的子类,如 typed arrays 来说很重要, 因为中间数组的值在调用 map() 时需要是适当的类型。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array from a String</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// ["f", "o", "o"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array from a Set</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'foo'</span>, <span class="built_in">window</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(s);</span><br><span class="line"><span class="comment">// ["foo", window]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array from a Map</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">Array</span>.from(m);</span><br><span class="line"><span class="comment">// [[1, 2], [2, 4], [4, 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array from an Array-like object (arguments)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Using arrow functions and Array.from</span></span><br><span class="line"><span class="comment">// Using an arrow function as the map function to</span></span><br><span class="line"><span class="comment">// manipulate the elements</span></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x + x);</span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate a sequence of numbers</span></span><br><span class="line"><span class="comment">// Since the array is initialized with `undefined` on each position,</span></span><br><span class="line"><span class="comment">// the value of `v` below will be `undefined`</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">5</span> &#125;, (v, i) =&gt; i);</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h2><p>Array.isArray() 用于确定传递的值是否是一个 Array。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(obj);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// obj</span></span><br><span class="line"><span class="comment">// 需要检测的值。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 如果对象是 Array，则为true; 否则为false。</span></span><br></pre></td></tr></table></figure>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>如果对象是 Array ，则返回 true，否则为 false。<br>有关更多详细信息，请参阅文章以绝对精确度确定 JavaScript 对象是否为数组。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的函数调用都返回 true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]);</span><br><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="comment">// 鲜为人知的事实：其实 Array.prototype 也是一个数组。</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数调用都返回 false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray();</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="string">'Array'</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123; <span class="attr">__proto__</span>: <span class="built_in">Array</span>.prototype &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="兼容性代码"><a href="#兼容性代码" class="headerlink" title="兼容性代码"></a>兼容性代码</h3><p>假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展运算符（spread）"><a href="#扩展运算符（spread）" class="headerlink" title="扩展运算符（spread）"></a>扩展运算符（spread）</h2><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，array.push(…items)和 add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// elementN</span></span><br><span class="line"><span class="comment">// 任意个参数，将按顺序成为返回数组中的元素。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 新的 Array 实例。</span></span><br><span class="line"><span class="built_in">Array</span>.of(element0[, element1[, ...[, elementN]]])</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>); <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h3 id="兼容旧环境"><a href="#兼容旧环境" class="headerlink" title="兼容旧环境"></a>兼容旧环境</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.of) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.of = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h2><p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = old_array.concat(value1[, value2[, ...[, valueN]]])</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// valueN</span></span><br><span class="line"><span class="comment">// 需要与原数组合并的数组或非数组值。详见下文。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 新的 Array 实例。</span></span><br></pre></td></tr></table></figure>
<h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式:</p>
<ul>
<li>对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.</li>
<li>字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里.</li>
</ul>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个数组合并为一个新数组</span></span><br><span class="line"><span class="keyword">var</span> alpha = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> numeric = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> three = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// 组成新数组 ["a", "b", "c", 1, 2, 3]; 原数组 alpha 和 numeric 未被修改</span></span><br><span class="line"><span class="keyword">var</span> alphaNumeric = alpha.concat(numeric);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组成新数组["a", "b", "c", 1, 2, 3, 4, 5, 6]; 原数组 num1, num2, num3 未被修改</span></span><br><span class="line"><span class="keyword">var</span> nums = num1.concat(num2, num3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个数组和多个非数组值合并为一个新数组</span></span><br><span class="line"><span class="comment">// 组成新数组 ["a", "b", "c", 1, 2, 3], 原alpha数组未被修改</span></span><br><span class="line"><span class="keyword">var</span> alphaNumeric1 = alpha.concat(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-copyWithin"><a href="#Array-prototype-copyWithin" class="headerlink" title="Array.prototype.copyWithin()"></a>Array.prototype.copyWithin()</h2><p>copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.copyWithin(target);</span><br><span class="line">arr.copyWithin(target, start);</span><br><span class="line">arr.copyWithin(target, start, end);</span><br><span class="line">arr.copyWithin(目标索引, [源开始索引], [结束源索引]);</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// target</span></span><br><span class="line"><span class="comment">// 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。    如果 start 被忽略，copyWithin 将会从0开始复制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。 如果 end 被忽略，copyWithin 将会复制到 arr.length。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 改变了的数组。</span></span><br></pre></td></tr></table></figure>
<h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>参数 target,start 和 end 必须为整数。<br>如果 start 为负，则其指定的索引位置等同于 length+start，length 为数组的长度。end 也是如此。<br>copyWithin 方法不要求其 this 值必须是一个数组对象；除此之外，copyWithin 是一个可变方法，它可以改变 this 对象本身，并且返回它，而不仅仅是它的拷贝。<br>copyWithin 就像 C 和 C++ 的 memcpy 函数一样，且它是用来移动 Array 或者 TypedArray 数据的一个高性能的方法。复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。<br>copyWithin 函数是设计为通用的，其不要求其 this 值必须是一个数组对象。<br>The copyWithin 是一个可变方法，它不会改变 this 的 length，但是会改变 this 本身的内容，且需要时会创建新的属性。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 1, 2]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 3, 4]</span></span><br><span class="line"></span><br><span class="line">[].copyWithin.call(&#123; <span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span> &#125;, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2015 Typed Arrays are subclasses of Array</span></span><br><span class="line"><span class="keyword">var</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On platforms that are not yet ES2015 compliant:</span></span><br><span class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-prototype-entries-、Array-prototype-keys-、Array-prototype-values-遍历数组"><a href="#Array-prototype-entries-、Array-prototype-keys-、Array-prototype-values-遍历数组" class="headerlink" title="Array.prototype.entries()、Array.prototype.keys()、Array.prototype.values() 遍历数组"></a>Array.prototype.entries()、Array.prototype.keys()、Array.prototype.values() 遍历数组</h2><p>ES6 提供三个新的方法——entries()，keys()和 values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<ul>
<li>entries() 方法返回一个新的 Array Iterator 对象，该对象包含数组中每个索引的键/值对。</li>
<li>keys() 方法返回一个新的 Array 迭代器，它包含数组中每个索引的键。</li>
<li>values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'w'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>];</span><br><span class="line"><span class="keyword">let</span> eArr = arr.values();</span><br><span class="line"><span class="comment">// 您的浏览器必须支持 for..of 循环</span></span><br><span class="line"><span class="comment">// 以及 let —— 将变量作用域限定在 for 循环中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> eArr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(letter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种 迭代方式</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'w'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>];</span><br><span class="line"><span class="keyword">let</span> eArr = arr.values();</span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// w</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// y</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// k</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// o</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// p</span></span><br></pre></td></tr></table></figure>
<p>可以通过 for…of 来循环数组</p>
<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>在 javascript 中所有的对象都具有 toLocaleString()、toString()、valueOf()方法。</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf()); <span class="comment">// [red,blue,green]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.toLocaleString()); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">','</span>)); <span class="comment">// red,blue,green</span></span><br><span class="line"><span class="comment">// 在默认情况下都会以逗号分隔的字符串的形式返回数组项</span></span><br></pre></td></tr></table></figure>
<h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>如果数组中的某一项的值是 null 或者 undefined,那么该只在 join()、toLocaleString()、toString()、valueOf()方法返回的结果中以空字符串表示</p>
<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>reverse() 方法会反转数组项的顺序。 sort()方法按升序排列数组项</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reverse() 数组反转</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">values.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(values); <span class="comment">// [8, 7, 6, 5, 4, 3, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort() 排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values1 = [<span class="string">'2'</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">65</span>, <span class="number">2</span>];</span><br><span class="line">values1.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(values1); <span class="comment">//  [1, "2", 2, 2, 3, 4, 4, 5, 65]</span></span><br></pre></td></tr></table></figure>
<p><strong>未完待续。。。。。</strong></p>
]]></content>
      <categories>
        <category>ECMAScript6</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>retina屏高清屏的具体原理</title>
    <url>/blog/mobile/bug/ios-bug-retina.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随着 2012 年苹果发布第一款 Retina Macbook Pro（以下简称 RMBP），Retina 屏幕开始进入笔记本行业。两年过去了，RMBP 的市场占有率越来越高，且获得了一大批设计师朋友的青睐，网站对于 Retina 屏幕的适配也变成了迫在眉睫的问题。</p>
<ul>
<li>1、一种具有备超高像素密度的液晶屏</li>
<li>2、同样大小的屏幕上显示的像素点由 1 个变为多个<br>在不同的屏幕上，CSS 像素所呈现的物理尺寸是一致的，而不同的是 CSS 像素所对应的物理像素具数是不一致的。在普通屏幕下 1 个 CSS 像素对应 1 个物理像素，而在 Retina 屏幕下，1 个 CSS 像素对应的却是 4 个物理像素。<br><img src="../../images/ios_bug/retina-web-3.jpg" alt="css3 3d transfrom"></li>
</ul>
<h3 id="物理像素（physical-pixel）"><a href="#物理像素（physical-pixel）" class="headerlink" title="物理像素（physical pixel）"></a>物理像素（physical pixel）</h3><p>物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。<br><img src="../../images/ios_bug/retina-web-1.jpg" alt="css3 3d transfrom"></p>
<h3 id="设备独立像素-density-independent-pixel"><a href="#设备独立像素-density-independent-pixel" class="headerlink" title="设备独立像素(density-independent pixel)"></a>设备独立像素(density-independent pixel)</h3><p>设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说 CSS 像素)，然后由相关系统转换为物理像素。</p>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。</p>
<h3 id="设备像素比-device-pixel-ratio"><a href="#设备像素比-device-pixel-ratio" class="headerlink" title="设备像素比(device pixel ratio)"></a>设备像素比(device pixel ratio)</h3><p>设备像素比简称为 dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：<br><code>设备像素比 ＝ 物理像素 / 设备独立像素</code><br>在 JavaScript 中，可以通过 window.devicePixelRatio 获取到当前设备的 dpr。而在 CSS 中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio 和 -webkit-max-device-pixel-ratio 进行媒体查询，对不同 dpr 的设备，做一些样式适配(这里只针对 webkit 内核的浏览器和 webview)。<br>dip 或 dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip 可以用来辅助区分视网膜设备还是非视网膜设备。</p>
<ul>
<li>devicePixelRatio 在大多数浏览器是值得信赖的。</li>
<li>在 iOS 设备，screen.width 乘以 devicePixelRatio 得到的是物理像素值。</li>
<li>在 Android 以及 Windows Phone 设备，screen.width 除以 devicePixelRatio 得到的是设备独立像素(dips)值。</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>通过判断 devicePixelRatio 的值来加载不同尺寸的图片</p>
<ul>
<li><code>针对普通显示屏(devicePixelRatio = 1.0、1.3)，加载一张 1 倍的图片</code></li>
<li><code>针对高清显示屏(devicePixelRatio &gt;= 1.5、2.0、3.0)，加载一张 2 倍大的图片</code><br>dpr 为 3 的手机比较小，建议用两倍的图片</li>
</ul>
<h3 id="Media-Queries-判断当前的-dpr"><a href="#Media-Queries-判断当前的-dpr" class="headerlink" title="Media Queries 判断当前的 dpr"></a>Media Queries 判断当前的 dpr</h3><p>通过媒体查询结合 devicePixelRatio 可以区分普通的显示屏和高清显示屏，<code>兼容行比较好</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">  <span class="comment">/* 普通显示屏(设备像素比例小于等于1.3)使用1倍的图 */</span></span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(img_1x.png);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio: <span class="number">1.5</span>) &#123;</span><br><span class="line">  <span class="selector-class">.css</span> &#123;</span><br><span class="line">    <span class="comment">/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图  */</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(img_2x.png);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio: <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="selector-class">.css</span> &#123;</span><br><span class="line">    <span class="comment">/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图  */</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(img_2x.png);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="image-set-设计-retina-背景图"><a href="#image-set-设计-retina-背景图" class="headerlink" title="image-set 设计 retina 背景图"></a>image-set 设计 retina 背景图</h3><p>image-set，它是 Webkit 的私有属性，也是 Css4 的一个属性。<code>目前支持苹果的 retina 显示屏和部分 android 显示屏</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../img/bank_ico.png) no-repeat; <span class="comment">/* 不支持image-set的显示屏 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-webkit-image-set</span>(</span><br><span class="line">    url(../img/bank_ico.png) <span class="number">1</span>x,</span><br><span class="line">    <span class="comment">/* 支持image-set的浏览器的[普通屏幕]下 */</span> <span class="built_in">url</span>(../img/bank_ico_retina.png) <span class="number">2</span>x</span><br><span class="line">  ); <span class="comment">/* 支持image-set的浏览器的[Retina屏幕] */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文<br>参考: <a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html</a> © w3cplus.com<br>参考：<a href="http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/</a><br>参考：<a href="http://www.cnblogs.com/PeunZhang/p/3441110.html" target="_blank" rel="noopener">http://www.cnblogs.com/PeunZhang/p/3441110.html</a></p>
]]></content>
      <categories>
        <category>Mobile</category>
      </categories>
      <tags>
        <tag>Mobile</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中 class（类）的用法</title>
    <url>/blog/es/docs/javascript-oop.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>javascript 是一种基于对象的语言，你遇到的所有东西几乎都是对象。但是,它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有 class(类)。<br>es6 中新提出了类（Class）概念，JavaScript 中的类只是 JavaScript 中的类只是 JavaScript 现有基于原型的继承的一种语法包装（语法糖）,他能让我们用建明的语法实现继承。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>声明一个 Person “类”，它内部有一个 constructor 方法，这个就是构造方法，而 this 关键字则代表实例对象。<br>使用 new 关键子创建，是跟构造函数的用法完全一致。构造函数和普通的 JavaScript 中的构造函数是一个样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getPerson() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'名字：'</span> + <span class="keyword">this</span>.name + <span class="string">'年龄：'</span> + <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oObj = <span class="keyword">new</span> Person(<span class="string">'小明'</span>, <span class="number">20</span>);</span><br><span class="line">oObj.getPerson(); <span class="comment">// "名字：小名年龄：20"</span></span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ..and an (optional) custom class constructor. If one is</span></span><br><span class="line">  <span class="comment">// not supplied, a default constructor is used instead:</span></span><br><span class="line">  <span class="comment">// constructor() &#123; &#125;</span></span><br><span class="line">  <span class="comment">// 只能有一个 constructor 不能多次定义、如果没有声明 默认定义 constructor() &#123; &#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Polygon'</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Simple class instance methods using short-hand method</span></span><br><span class="line">  <span class="comment">// declaration</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    ChromeSamples.log(<span class="string">'Hi, I am a '</span>, <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHistory() &#123;</span><br><span class="line">    ChromeSamples.log(</span><br><span class="line">      <span class="string">'"Polygon" is derived from the Greek polus (many) '</span> + <span class="string">'and gonia (angle).'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will look at static and subclassed methods shortly</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// 这里把length传参给父类的构造方法</span></span><br><span class="line">    <span class="comment">// 作为父类Polygon的宽和高</span></span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">    <span class="comment">// 备注：在衍生类中使用this前必须先调用super()方法</span></span><br><span class="line">    <span class="comment">// 忽视这一点将会导致一个引用错误</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> area(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.area = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line">s.sayName();</span><br><span class="line">ChromeSamples.log(<span class="string">'The area of this square is '</span> + s.area);</span><br></pre></td></tr></table></figure>
<p>构造函数的 prototype(原型)属性，类的所有方法都定义在类的 prototype 属性上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.constructor === B.prototype.constructor; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="子类的使用"><a href="#子类的使用" class="headerlink" title="子类的使用"></a>子类的使用</h3><p>可以通过 extends 关键字来实现继承</p>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>一个类必须有 constructor 方法,默认添加。默认返回 this（实例对象），也可指定别的对象。<br>类必须使用 new 调用，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo();</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure>
<h3 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h3><p>类的所有实例共享一个原型对象。通过实例的<strong>proto</strong>属性为“类”添加方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oObj = <span class="keyword">new</span> Person(<span class="string">'小明'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> oObj1 = <span class="keyword">new</span> Person(<span class="string">'小明'</span>, <span class="number">20</span>);</span><br><span class="line">oObj.__proto__ === oObj1.__proto__; <span class="comment">// true</span></span><br><span class="line">oObj.__proto__.des = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'学习'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">oObj.des(); <span class="comment">// 学习</span></span><br><span class="line">oObj1.des(); <span class="comment">// 学习</span></span><br><span class="line"><span class="keyword">var</span> oObj2 = <span class="keyword">new</span> Preson(<span class="string">'小红'</span>, <span class="number">18</span>);</span><br><span class="line">oObj2.des(); <span class="comment">// 学习</span></span><br></pre></td></tr></table></figure>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>extends 关键词被用在类声明或者类表达式上，以创建一个类是另一个类的子类。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>extends 关键词用来创建一个普通类或者内建对象的子类。<br>扩展的.prototype 必须是一个 Object 或者 null。</p>
<h3 id="使用-extends"><a href="#使用-extends" class="headerlink" title="使用 extends"></a>使用 extends</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ..and an (optional) custom class constructor. If one is</span></span><br><span class="line">  <span class="comment">// not supplied, a default constructor is used instead:</span></span><br><span class="line">  <span class="comment">// constructor() &#123; &#125;</span></span><br><span class="line">  <span class="comment">// 只能有一个 constructor 不能多次定义、如果没有声明 默认定义 constructor() &#123; &#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Polygon'</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Simple class instance methods using short-hand method</span></span><br><span class="line">  <span class="comment">// declaration</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    ChromeSamples.log(<span class="string">'Hi, I am a '</span>, <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHistory() &#123;</span><br><span class="line">    ChromeSamples.log(</span><br><span class="line">      <span class="string">'"Polygon" is derived from the Greek polus (many) '</span> + <span class="string">'and gonia (angle).'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will look at static and subclassed methods shortly</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// 这里把length传参给父类的构造方法</span></span><br><span class="line">    <span class="comment">// 作为父类Polygon的宽和高</span></span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">    <span class="comment">// 备注：在衍生类中使用this前必须先调用super()方法</span></span><br><span class="line">    <span class="comment">// 忽视这一点将会导致一个引用错误</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> area(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.area = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line">s.sayName();</span><br><span class="line">ChromeSamples.log(<span class="string">'The area of this square is '</span> + s.area);</span><br></pre></td></tr></table></figure>
<h3 id="使用-extends-扩展内建对象"><a href="#使用-extends-扩展内建对象" class="headerlink" title="使用 extends 扩展内建对象"></a>使用 extends 扩展内建对象</h3><p>这个示例继承了 Date 对象。 你可以从实战演示看到这个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDate</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFormattedDate() &#123;</span><br><span class="line">    <span class="keyword">var</span> months = [</span><br><span class="line">      <span class="string">'Jan'</span>,</span><br><span class="line">      <span class="string">'Feb'</span>,</span><br><span class="line">      <span class="string">'Mar'</span>,</span><br><span class="line">      <span class="string">'Apr'</span>,</span><br><span class="line">      <span class="string">'May'</span>,</span><br><span class="line">      <span class="string">'Jun'</span>,</span><br><span class="line">      <span class="string">'Jul'</span>,</span><br><span class="line">      <span class="string">'Aug'</span>,</span><br><span class="line">      <span class="string">'Sep'</span>,</span><br><span class="line">      <span class="string">'Oct'</span>,</span><br><span class="line">      <span class="string">'Nov'</span>,</span><br><span class="line">      <span class="string">'Dec'</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="keyword">this</span>.getDate() + <span class="string">'-'</span> + months[<span class="keyword">this</span>.getMonth()] + <span class="string">'-'</span> + <span class="keyword">this</span>.getFullYear()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展-null"><a href="#扩展-null" class="headerlink" title="扩展 null"></a>扩展 null</h3><p>可以像扩展普通类一样扩展 null，但是新对象的原型将不会继承 Object.prototype.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nullExtends</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(nullExtends); <span class="comment">// Function.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(nullExtends.prototype); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="class-表达式"><a href="#class-表达式" class="headerlink" title="class 表达式"></a>class 表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> (<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class-的取值函数（getter）和存值函数（setter）"><a href="#class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="class 的取值函数（getter）和存值函数（setter）"></a>class 的取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop;</span><br><span class="line"><span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure>
<h3 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod(); <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod();</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line">Bar.classMethod(); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>
<p>如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<br>父类的静态方法，可以被子类继承。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS下的 Fixed + Input BUG现象</title>
    <url>/blog/mobile/bug/ios-bug.html</url>
    <content><![CDATA[<h2 id="iOS-下的-Fixed-Input-BUG-现象"><a href="#iOS-下的-Fixed-Input-BUG-现象" class="headerlink" title="iOS 下的 Fixed + Input BUG 现象"></a>iOS 下的 Fixed + Input BUG 现象</h2><h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>让我们先举个例子，最直观的说明一个在 ios 中 input + fixed 布局，可能使用如下布局<br>转载 <a href="http://efe.baidu.com/" target="_blank" rel="noopener">http://efe.baidu.com/</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    header,</span><br><span class="line">    footer,</span><br><span class="line">    main &#123;</span><br><span class="line">      display: block;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    header &#123;</span><br><span class="line">      position: fixed;</span><br><span class="line">      height: 50px;</span><br><span class="line">      left: 0;</span><br><span class="line">      right: 0;</span><br><span class="line">      top: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    footer &#123;</span><br><span class="line">      position: fixed;</span><br><span class="line">      height: 34px;</span><br><span class="line">      left: 0;</span><br><span class="line">      right: 0;</span><br><span class="line">      bottom: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    main &#123;</span><br><span class="line">      margin-top: 50px;</span><br><span class="line">      margin-bottom: 34px;</span><br><span class="line">      height: 2000px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"layout-fixed"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的头部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 可以滚动的区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 内容在这里... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的底部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Footer..."</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后看起来就是下面这个样子。拖动页面时 header 和 footer 已经定位在了对应的位置，目测没问题了。<br><img src="../../../images/ios_bug/fixed.png" alt="css3 3d transfrom"></p>
<!-- <img src="../../../images/ios_bug/fixed.png" alt="ios_bug" title="ios_bug"/> -->
<p>但接下来问题就来了！如果底部输入框软键盘被唤起以后，再次滑动页面，就会看到如下图所示：<br><img src="../../../images/ios_bug/fixed_bug_0.png" alt="css3 3d transfrom"> <img src="../../../images/ios_bug/fixed_bug_1.png" alt="css3 3d transfrom"><br><code>软键盘唤起后，页面的 fixed 元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。</code><br>这就是 ios 上 fixed 元素和输入框的 bug,其中不仅陷入于<code>type=&quot;text&quot;</code>的输入框，凡是软键盘（比如时间选择器、select 选择等等）被唤起，都会遇到同样的问题。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>虽然 isScroll.js 可以很好的解决 fixed 定位滚动的问题，但是不在万不得已的情况下，我们尽量尝试一下不依赖第三方库的布局方案，以简化实现方式。这里抛砖引玉作为参考。</p>
<p>即使在 ios 下由于软键盘唤出后，页面 fixed 元素会失效，导致跟随页面一起滚动，那么<code>页面不会过长出现滚动，那么即便 fixed 元素失效，也无法跟随页面滚动，也不会出现上面的问题了</code>，其实就是内部滚动</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"layout-scroll-fixed"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- fixed定位的头部 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 可以滚动的区域 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 内容在这里... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- fixed定位的底部 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Footer..."</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">footer</span>,</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="comment">/* main绝对定位，进行内部滚动 */</span></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="comment">/* 使之可以滚动 */</span></span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2000px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在原始输入法下， fixed 元素可以定位在页面的正确位置。滚动页面时，由于滚动的是 main 内部的 div，因此 footer 没有跟随页面滚动。</p>
<p>上面貌似解决了问题，但是如果在手机上实际测试一下，会发现 main 元素内的滚动非常不流畅，滑动的手指松开后，滚动立刻停止，失去了原本的流畅滚动特性。百度一下弹性滚动的问题，发现在 webkit 中，下面的属性可以恢复弹性滚动。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-overflow-scrolling</span>: <span class="selector-tag">touch</span>;</span><br></pre></td></tr></table></figure>
<p>在 main 元素上加上该属性，嗯，丝般顺滑的感觉又回来了！</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="comment">/* main绝对定位，进行内部滚动 */</span></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="comment">/* 使之可以滚动 */</span></span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  <span class="comment">/* 增加该属性，可以增加弹性 */</span></span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，这里的 header 和 footer 使用的是 fixed 定位，如果考虑到更老一些的 iOS 系统不支持 fixed 元素，完全可以把 fixed 替换成 absolute 。测试后效果是一样的。</p>
<p>至此一个不依赖第三方库的 fixed 布局就完成了。</p>
<h3 id="Android-下布局"><a href="#Android-下布局" class="headerlink" title="Android 下布局"></a>Android 下布局</h3><p>谈到了 iOS ，也来简单说一下 Android 下的布局吧。</p>
<p>在 Android2.3+ 中，因为不支持 overflow-scrolling ，因此部分浏览器内滚动会有不流畅的卡顿。但是目前发现在 body 上的滚动还是很流畅的，因此使用第一种在 iOS 出现问题的 fixed 定位的布局就可以了。</p>
<p>如果需要考虑 Android2.3 以下系统，因为不支持 fixed 元素，所以依然要需要考虑使用 isScroll.js 来实现内部滚动。</p>
<p>其实在 fixed 和输入框的问题上，基本思路就是： &gt; 由于 fixed 在软键盘唤起后会失效，导致在页面可以滚动时，会跟随页面一起滚动。因此如果页面无法滚动，那么 fixed 元素即使失效，也不会滚动，也就不会出现 bug 了。</p>
<p>所以可以在这个方面去考虑解决问题。</p>
<h3 id="其他的一些细节处理"><a href="#其他的一些细节处理" class="headerlink" title="其他的一些细节处理"></a>其他的一些细节处理</h3><p>在细节处理上，其实还有很多要注意的，挑几个实际遇到比较大的问题来说一下：</p>
<p>有时候输入框 focus 以后，会出现软键盘遮挡输入框的情况，这时候可以尝试 input 元素的 scrollIntoView 进行修复。<br>在 iOS 下使用第三方输入法时，输入法在唤起经常会盖住输入框，只有在输入了一条文字后，输入框才会浮出。目前也不知道有什么好的办法能让唤起输入框时正确显示。这暂时算是 iOS 下的一个坑吧。<br>有些第三方浏览器底部的工具栏是浮在页面之上的，因此底部 fixed 定位会被工具栏遮挡。解决办法也比较简单粗暴——适配不同的浏览器，调整 fixed 元素距离底部的距离。<br>最好将 header 和 footer 元素的 touchmove 事件禁止，以防止滚动在上面触发了部分浏览器全屏模式切换，而导致顶部地址栏和底部工具栏遮挡住 header 和 footer 元素。<br>在页面滚动到上下边缘的时候，如果继续拖拽会将整个 View 一起拖拽走，导致页面的“露底”。<br><img src="../../../images/ios_bug/fixed_pull_over.png" alt="css3 3d transfrom"><br>为了防止页面露底，可以在页面拖拽到边缘的时候，通过判断拖拽方向以及是否为边缘来阻止 touchmove 事件，防止页面继续拖拽。</p>
<p>以上面内滚动 layout-scroll-fixed 布局为例，给出一段代码作为参考：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止内容区域滚到底后引起页面整体的滚动</span></span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.querySelector(<span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">var</span> startY;</span><br><span class="line"></span><br><span class="line">content.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">content.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 高位表示向上滚动</span></span><br><span class="line">  <span class="comment">// 底位表示向下滚动</span></span><br><span class="line">  <span class="comment">// 1容许 0禁止</span></span><br><span class="line">  <span class="keyword">var</span> status = <span class="string">'11'</span>;</span><br><span class="line">  <span class="keyword">var</span> ele = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ele.scrollTop === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果内容小于容器则同时禁止上下滚动</span></span><br><span class="line">    status = ele.offsetHeight &gt;= ele.scrollHeight ? <span class="string">'00'</span> : <span class="string">'01'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.scrollTop + ele.offsetHeight &gt;= ele.scrollHeight) &#123;</span><br><span class="line">    <span class="comment">// 已经滚到底部了只能向上滚动</span></span><br><span class="line">    status = <span class="string">'10'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status != <span class="string">'11'</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前的滚动方向</span></span><br><span class="line">    <span class="keyword">var</span> direction = currentY - startY &gt; <span class="number">0</span> ? <span class="string">'10'</span> : <span class="string">'01'</span>;</span><br><span class="line">    <span class="comment">// 操作方向和当前允许状态求与运算，运算结果为0，就说明不允许该方向滚动，则禁止默认事件，阻止滚动</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">parseInt</span>(status, <span class="number">2</span>) &amp; <span class="built_in">parseInt</span>(direction, <span class="number">2</span>))) &#123;</span><br><span class="line">      stopEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mobile</category>
      </categories>
      <tags>
        <tag>Mobile</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的call、apply、bind的应用场景（二）</title>
    <url>/blog/javascript/this/js-Call-Apply-Bind.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>apply()方法吊用一个函数，其具有一种个指定的 this 值，<code>以及作为一个数组（或类似数组的对象）提供的参数</code>。call()方法的作用和 apply()方法类似，只有一个区别，就是 call()方法<code>接受的是若干个参数列表</code>，而 apply()方法接受的是一个包含<code>多个参数的数组</code><br>bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的 call 属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
<h2 id="apply-语法"><a href="#apply-语法" class="headerlink" title="apply 语法"></a>apply 语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray]);</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="thisArg"><a href="#thisArg" class="headerlink" title="thisArg"></a>thisArg</h4><p>在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是 window 对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象</p>
<h4 id="argsArray"><a href="#argsArray" class="headerlink" title="argsArray"></a>argsArray</h4><p>一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。</p>
<p>apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表（原文：a named set of parameters）。apply 可以使用数组字面量（array literal），如 fun.apply(this, [‘eat’, ‘bananas’])，或数组对象， 如 fun.apply(this, new Array(‘eat’, ‘bananas’))。</p>
<p>你也可以使用 arguments 对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用 apply 函数的时候就不需要知道被调用对象的所有参数。 你可以使用 arguments 来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。</p>
<p>从 ECMAScript 第 5 版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和[0…length) 范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {‘length’: 2, ‘0’: ‘eat’, ‘1’: ‘bananas’} 形式的对象。</p>
<p>需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">var</span> elements = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">array.push.apply(array, elements);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br></pre></td></tr></table></figure>
<h3 id="使用-apply-来链接构造器"><a href="#使用-apply-来链接构造器" class="headerlink" title="使用 apply 来链接构造器"></a>使用 apply 来链接构造器</h3><p>你可以使用 apply 来链接一个对象<code>构造器</code>，类似于 Java。在接下来的例子中我们会创建一个全局 Function 对象的 construct 方法 ，来使你能够在构造器中使用一个类数组对象而非参数列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span> (<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oNew = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</span><br><span class="line">  <span class="keyword">this</span>.apply(oNew, aArgs);</span><br><span class="line">  <span class="keyword">return</span> oNew;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意:  上面使用的 Object.create()方法相对来说比较新。另一种可选的方法，请考虑如下替代方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span> (<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oNew = &#123;&#125;;</span><br><span class="line">  oNew.__proto__ = <span class="keyword">this</span>.prototype;</span><br><span class="line">  <span class="keyword">this</span>.apply(oNew, aArgs);</span><br><span class="line">  <span class="keyword">return</span> oNew;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用闭包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span> (<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fConstructor = <span class="keyword">this</span>,</span><br><span class="line">    fNewConstr = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fConstructor.apply(<span class="keyword">this</span>, aArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">  fNewConstr.prototype = fConstructor.prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> fNewConstr();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 Function 构造器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.construct = <span class="function"><span class="keyword">function</span> (<span class="params">aArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fConstructor = <span class="keyword">this</span>,</span><br><span class="line">    fNewConstr = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fConstructor.apply(<span class="keyword">this</span>, aArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">  fNewConstr.prototype = fConstructor.prototype;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> fNewConstr();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="call-语法"><a href="#call-语法" class="headerlink" title="call 语法"></a>call 语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><h4 id="thisArg-1"><a href="#thisArg-1" class="headerlink" title="thisArg"></a>thisArg</h4><p>在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于 non-strict mode，则指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是 window 对象)，同时值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象</p>
<h4 id="arg1-arg2-…"><a href="#arg1-arg2-…" class="headerlink" title="arg1, arg2, …"></a>arg1, arg2, …</h4><p>指定的参数列表。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">参考地址</a></p>
<h2 id="bind-语法"><a href="#bind-语法" class="headerlink" title="bind 语法"></a>bind 语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">bind</span>(<span class="params">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><h4 id="thisArg-2"><a href="#thisArg-2" class="headerlink" title="thisArg"></a>thisArg</h4><p>调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。</p>
<h4 id="arg1-arg2-…-1"><a href="#arg1-arg2-…-1" class="headerlink" title="arg1, arg2, …"></a>arg1, arg2, …</h4><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">参考地址</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的this指向问题（一）</title>
    <url>/blog/javascript/this/javascript-this.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先必须要说的是，this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象,那么接下来我会深入的探讨这个问题。<br><code>function 执行默认返回 undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="在一般函数方法中使用-this-指代全局对象"><a href="#在一般函数方法中使用-this-指代全局对象" class="headerlink" title="在一般函数方法中使用 this 指代全局对象"></a>在一般函数方法中使用 this 指代全局对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ale = <span class="string">'外部'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ale = <span class="string">'内部'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.ale); <span class="comment">// 外部</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 因为在全局中执行，所以this指向window</span></span><br><span class="line"><span class="comment">// window.a(); 与上面其实是一致的</span></span><br></pre></td></tr></table></figure>
<h3 id="作为对象方法调用，this-纸袋上级对象"><a href="#作为对象方法调用，this-纸袋上级对象" class="headerlink" title="作为对象方法调用，this 纸袋上级对象"></a>作为对象方法调用，this 纸袋上级对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ale = <span class="string">'外部'</span>;</span><br><span class="line"><span class="keyword">var</span> oObeject = &#123;</span><br><span class="line">  ale: <span class="string">'内部'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.ale); <span class="comment">// 内部</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// oObeject</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">oObeject.fn();</span><br></pre></td></tr></table></figure>
<p>这里的 this 指向 oObeject,因为这个 fn 是通过 oObeject 调用的,所以指向 oObeject,this 在函数创建的时候是决定不了的,在调用的时候才能决定，<code>谁调用 this 指像谁</code></p>
<h3 id="作为构造函数调用，this-指代-new-出的对象"><a href="#作为构造函数调用，this-指代-new-出的对象" class="headerlink" title="作为构造函数调用，this 指代 new 出的对象"></a>作为构造函数调用，this 指代 new 出的对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ale = <span class="string">'外部'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.ale = <span class="string">'内部'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.ale); <span class="comment">// 内部</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Test</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 默认 return 当前this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test1 = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(test1.ale); <span class="comment">// 内部</span></span><br></pre></td></tr></table></figure>
<p>new 关键字可以改变 this 的指向,将这个 this 指向对象 test1,此时仅仅只是创建，并没有执行，而调用这个函数 Fn 的是对象 test1，那么 this 指向的自然是对象 test1</p>
<h4 id="当函数中有-return-时"><a href="#当函数中有-return-时" class="headerlink" title="当函数中有 return 时"></a>当函数中有 return 时</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.user = <span class="string">'内部'</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 因为返回的是空对象像 or return function () &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Object &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还是指向函数的实例。</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.user = <span class="string">'内部'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 因为返回的是空对象像 or return undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Object &#123;user&#125;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>还有一点就是虽然 null 也是对象，但是在这里 this 还是指向那个函数的实例，因为 null 比较特殊。</code></p>
<h3 id="apply、call、bind-改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this-指代第一个参数"><a href="#apply、call、bind-改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this-指代第一个参数" class="headerlink" title="apply、call、bind 改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this 指代第一个参数"></a>apply、call、bind 改变函数的调用对象，此方法的第一个参数为改变后调用这个函数的对象，this 指代第一个参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'外部'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  x: <span class="string">'内部'</span>,</span><br><span class="line">  m: test</span><br><span class="line">&#125;;</span><br><span class="line">o.m.apply(); <span class="comment">// 外部</span></span><br><span class="line"><span class="comment">//apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为</span></span><br><span class="line">o.m.apply(o); <span class="comment">// 内部</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>js继承实现</title>
    <url>/blog/javascript/extends/javascript-extends-one.html</url>
    <content><![CDATA[<h2 id="创建-js-样例："><a href="#创建-js-样例：" class="headerlink" title="创建 js 样例："></a>创建 js 样例：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 约定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有属性</span></span><br><span class="line">  <span class="keyword">var</span> val = <span class="number">1</span>; <span class="comment">// 私有基本属性</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>]; <span class="comment">// 私有引用属性</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 私有函数（引用属性）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>; <span class="comment">// 实例基本属性</span></span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>]; <span class="comment">// 实例引用属性</span></span><br><span class="line">  <span class="keyword">this</span>.fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 实例函数（引用属性）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型属性</span></span><br><span class="line">Fun.prototype.val = <span class="number">1</span>; <span class="comment">// 原型基本属性</span></span><br><span class="line">Fun.prototype.arr = [<span class="number">1</span>]; <span class="comment">// 原型引用属性</span></span><br><span class="line">Fun.prototype.fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 原型函数（引用属性）</span></span><br></pre></td></tr></table></figure>
<p>这样创建比较合理</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>这是实现继承最简单的方式，核心就是一句话</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super(); <span class="comment">// 核心</span></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line">sub1.val = <span class="number">2</span>;</span><br><span class="line">sub1.arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.val); <span class="comment">// 2 基本类型 不共享</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.val); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub1.arr); <span class="comment">// [1, 2] 引用 array类型 共享</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.arr); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><font color="#ff502c">拿父类实例充当子类原型对象</font>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><p>简单，易于实现</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>修改 sub1.arr 后 sub2.arr 也变了，因为来自原型对象的引用树形是所有实例共享的。<br>执行顺序：执行 sub1.arr.push(2);先对 sub1 进行属性查找，找遍了实例属性（在本例中没有实例属性），没找到，就开始顺着原型链向上找，拿到了 sub1 的原型对象，一搜身，发现有 arr 属性。于是给 arr 末尾插入了 2，所以 sub2.arr 也变了</p>
<p>创建子类实例时，无法向父类构造函数传参</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>简单原型链真够简单，可是存在 2 个致命缺点简直不能用，于是上个世纪末的 jsers 就想办法 fix 这 2 个缺陷，然后出现了借用构造函数方式</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">this</span>.fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>, val); <span class="comment">// 核心</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub(<span class="number">2</span>);</span><br><span class="line">sub1.arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.val); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.val); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub1.arr); <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.arr); <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">console</span>.log(sub1.fun === sub2.fun); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h3><p><font color="#ff502c">借父类的构造函数来增强子类实例</font>，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>解决了子类实例共享父类引用属性的问题<br>创建子类实例时，可以向父类构造函数传参</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>无法实现函数复用，每个子类实例都持有一个新的 fun 函数，太多了就会影响性能</p>
<h2 id="组合继承（常用）"><a href="#组合继承（常用）" class="headerlink" title="组合继承（常用）"></a>组合继承（常用）</h2><p>目前我们的借用构造函数方式还是有问题（无法实现函数复用），没关系，接着修复，jsers 吭哧吭哧又搞出了组合继承</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只在此处声明基本属性和引用属性</span></span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  在此处声明函数</span></span><br><span class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Super.prototype.fun2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//Super.prototype.fun3...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>); <span class="comment">// 核心</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super(); <span class="comment">// 核心</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.fun === sub2.fun); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="核心-2"><a href="#核心-2" class="headerlink" title="核心"></a>核心</h3><p>&lt;font color=”red&gt;把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过 Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过 Sub.prototype = new Super();继承父类函数，实现函数复用</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>不存在引用属性共享问题<br>可传参<br>函数可复用</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的</p>
<h2 id="寄生组合继承（最佳方式）"><a href="#寄生组合继承（最佳方式）" class="headerlink" title="寄生组合继承（最佳方式）"></a>寄生组合继承（最佳方式）</h2><p>从名字就能看出又是对组合继承的优化</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 生孩子函数 beget：龙beget龙，凤beget凤。</span></span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只在此处声明基本属性和引用属性</span></span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  在此处声明函数</span></span><br><span class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Super.prototype.fun2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//Super.prototype.fun3...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>); <span class="comment">// 核心</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> proto = beget(Super.prototype); <span class="comment">// 核心</span></span><br><span class="line"><span class="built_in">console</span>.log(proto); <span class="comment">// F &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(proto.constructor);</span><br><span class="line"><span class="comment">// function Super()&#123;</span></span><br><span class="line"><span class="comment">// 只在此处声明基本属性和引用属性</span></span><br><span class="line"><span class="comment">// this.val = 1;</span></span><br><span class="line"><span class="comment">// this.arr = [1];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">proto.constructor = Sub; <span class="comment">// 核心</span></span><br><span class="line"><span class="built_in">console</span>.log(proto.constructor);</span><br><span class="line"><span class="comment">// function Sub()&#123;</span></span><br><span class="line"><span class="comment">// Super.call(this);   // 核心</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Sub.prototype = proto; <span class="comment">// 核心</span></span><br><span class="line"><span class="built_in">console</span>.log(Sub.prototype);</span><br><span class="line"><span class="comment">// Super &#123;constructor: function&#125;</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(sub.val);</span><br><span class="line"><span class="built_in">console</span>.log(sub.arr);</span><br></pre></td></tr></table></figure>
<p>construcotr 可参考：</p>
<h3 id="核心-3"><a href="#核心-3" class="headerlink" title="核心"></a>核心</h3><p>用 beget(Super.prototype);&lt;font color=”red&gt;切掉了原型对象上多余的那份父类实例属性<br>寄生组合式继承，这名字不是很贴切，和寄生式继承关系并不是特别大</p>
<h2 id="原型式"><a href="#原型式" class="headerlink" title="原型式"></a>原型式</h2><p>其实介绍完上面的完美方案就可以结束了，但从组合继承到完美方案好像有一段不小的思维跳跃，有必要把故事说清楚</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return 一个新的 function 原型复制为参数原型</span></span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到父类对象</span></span><br><span class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="comment">// 生孩子</span></span><br><span class="line"><span class="keyword">var</span> sub = beget(sup); <span class="comment">// 核心</span></span><br><span class="line"><span class="comment">// 增强</span></span><br><span class="line">sub.attr1 = <span class="number">1</span>;</span><br><span class="line">sub.attr2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//sub.attr3...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub.val); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sub.arr); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sub.attr1); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端注意事项 (未完待续)</title>
    <url>/blog/mobile/bug/mobile-all.html</url>
    <content><![CDATA[<h2 id="一些问题阐述"><a href="#一些问题阐述" class="headerlink" title="一些问题阐述"></a>一些问题阐述</h2><ul>
<li>设备更新换代快 + 浏览器厂商不统一———— 兼容问题多</li>
<li>网络更复杂——弱网络，低端机性能差————页面打开慢</li>
<li>未知问题——坑多<a id="more"></a>
</li>
</ul>
<h2 id="meta-基础知识"><a href="#meta-基础知识" class="headerlink" title="meta 基础知识"></a>meta 基础知识</h2><ul>
<li>H5 页面窗口自动调整到设备宽度，并禁止用户缩放页面<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</code></li>
<li>忽略将页面中的数字识别为电话号码<br><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</code></li>
<li>忽略 Android 平台中对邮箱地址的识别<br><code>&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;</code></li>
<li>当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对 ios 的 safari<br><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</code><br><code>&lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt;</code></li>
<li>viewport 模板 ———— 通用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"yes"</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"black"</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"email=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"index.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    这里开始内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="移动端如何定义字体-font-family"><a href="#移动端如何定义字体-font-family" class="headerlink" title="移动端如何定义字体 font-family"></a>移动端如何定义字体 font-family</h3><p>中文字体使用系统默认即可，英文用 Helvetica<br><code>/* 移动端定义字体的代码 */</code><br><code>body{font-family:Helvetica;}</code></p>
<h3 id="移动端字体单位-font-size-选择-px-还是-rem"><a href="#移动端字体单位-font-size-选择-px-还是-rem" class="headerlink" title="移动端字体单位 font-size 选择 px 还是 rem"></a>移动端字体单位 font-size 选择 px 还是 rem</h3><p>对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用 px 即可<br>对于需要适配各种移动设备，使用 rem，例如只需要适配 iPhone 和 iPad 等分辨率差别比较挺大的设备<br>/_ 长宽占位 rem 算法, 根据 root 的 rem 来计算各元素相对 rem, 默认 html 750/10 = 75px _/<br>可以参考 &gt; <a href="http://www.cnblogs.com/well-nice/p/5509589.html" target="_blank" rel="noopener">http://www.cnblogs.com/well-nice/p/5509589.html</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updataHtml();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updataHtml</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> w = <span class="built_in">document</span>.documentElement.offsetWidth;</span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = w / <span class="number">10</span> + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  updataHtml();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="移动端-click-屏幕产生-200-300-ms-的延迟响应"><a href="#移动端-click-屏幕产生-200-300-ms-的延迟响应" class="headerlink" title="移动端 click 屏幕产生 200-300 ms 的延迟响应"></a>移动端 click 屏幕产生 200-300 ms 的延迟响应</h3><p>在 IOS safari 下，大概为 300 毫秒，IOS 自带的双击页面放大，点击完成第一次时，会等待第二次点击，页面需要过一段时间才响应，给用户慢体验感觉，对于 web 开发者来说是，页面 js 捕获 click 事件的回调函数处理，需要 300ms 后才生效，也就间接导致影响其他业务逻辑的处理</p>
<ul>
<li>fastclick 可以解决在手机上点击事件的 300ms 延迟</li>
<li>zepto 的 touch 模块，tap 事件也是为了解决在 click 的延迟问题</li>
</ul>
<h3 id="触摸事件的响应顺序"><a href="#触摸事件的响应顺序" class="headerlink" title="触摸事件的响应顺序"></a>触摸事件的响应顺序</h3><p><code>ontouchstart</code><br><code>ontouchmove</code><br><code>ontouchend</code><br><code>onclick</code><br>解决 300ms 延迟的问题，也可以通过绑定 ontouchstart 事件，加快对事件的响应</p>
<h3 id="什么是-Retina-显示屏，带来了什么问题"><a href="#什么是-Retina-显示屏，带来了什么问题" class="headerlink" title="什么是 Retina 显示屏，带来了什么问题"></a>什么是 Retina 显示屏，带来了什么问题</h3><p>retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由 1 个变为多个，如在同样带下的屏幕上，苹果设备的 retina 显示屏中，像素点 1 个变为 4 个<br>在高清显示屏中的位图被放大，图片会变得模糊，<font color="#ff502c">因此移动端的视觉稿通常会设计为传统 PC 的 2 倍</font><br>设计稿切出来的图片长宽保证为偶数，并使用 backgroud-size 把图片缩小为原来的 1/2</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//例如图片宽高为：200px*200px，那么写法如下</span><br><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它元素的取值为原来的 1/2，例如视觉稿 40px 的字体，使用样式的写法为 20px</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ios-系统中元素被触摸时产生的半透明灰色遮罩怎么去掉"><a href="#ios-系统中元素被触摸时产生的半透明灰色遮罩怎么去掉" class="headerlink" title="ios 系统中元素被触摸时产生的半透明灰色遮罩怎么去掉"></a>ios 系统中元素被触摸时产生的半透明灰色遮罩怎么去掉</h3><p>ios 用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color 的 alpha 值为 0，也就是属性值的最后一位设置为 0 就可以去除半透明灰色遮罩</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0, 0, 0, 0;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部分-android-系统中元素被点击时产生的边框怎么去掉"><a href="#部分-android-系统中元素被点击时产生的边框怎么去掉" class="headerlink" title="部分 android 系统中元素被点击时产生的边框怎么去掉"></a>部分 android 系统中元素被点击时产生的边框怎么去掉</h3><p>android 用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color 的 alpha 值为 0 去除部分机器自带的效果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0,0,0,0;)</span><br><span class="line">    -webkit-user-modify:read-write-plaintext-only;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>兼容性不是很好</p>
<h3 id="winphone-系统-a、input-标签被点击时产生的半透明灰色背景怎么去掉、"><a href="#winphone-系统-a、input-标签被点击时产生的半透明灰色背景怎么去掉、" class="headerlink" title="winphone 系统 a、input 标签被点击时产生的半透明灰色背景怎么去掉、"></a>winphone 系统 a、input 标签被点击时产生的半透明灰色背景怎么去掉、</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-tap-highlight"</span> <span class="attr">content</span>=<span class="string">"no"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="webkit-表单元素的默认外观怎么重置"><a href="#webkit-表单元素的默认外观怎么重置" class="headerlink" title="webkit 表单元素的默认外观怎么重置"></a>webkit 表单元素的默认外观怎么重置</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-apperarance</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#ff502c">把各个浏览器表单的默认样式重置</font>

<h3 id="伪元素改变-number-类型-input-框的默认样式"><a href="#伪元素改变-number-类型-input-框的默认样式" class="headerlink" title="伪元素改变 number 类型 input 框的默认样式"></a>伪元素改变 number 类型 input 框的默认样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type='number']</span><span class="selector-pseudo">::-webkit-textfield-decoration-container</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type='number']</span><span class="selector-pseudo">::-webkit-inner-spin-button</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type='number']</span><span class="selector-pseudo">::-webkit-outer-spin-button</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mobile</category>
      </categories>
      <tags>
        <tag>Mobile</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>大家好</title>
    <url>/blog/Hello.html</url>
    <content><![CDATA[<h3 id="每周两篇bolg-最后整理合并，分类，总结"><a href="#每周两篇bolg-最后整理合并，分类，总结" class="headerlink" title="每周两篇bolg,最后整理合并，分类，总结"></a>每周两篇bolg,最后整理合并，分类，总结</h3>]]></content>
  </entry>
</search>
